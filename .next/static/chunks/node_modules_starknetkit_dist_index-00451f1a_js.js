"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_starknetkit_dist_index-00451f1a_js"],{

/***/ "./node_modules/starknetkit/dist/index-00451f1a.js":
/*!*********************************************************!*\
  !*** ./node_modules/starknetkit/dist/index-00451f1a.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getStarknetWindowObject\": function() { return /* binding */ Y_; }\n/* harmony export */ });\n/* harmony import */ var _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lastConnected-b964dc30.js */ \"./node_modules/starknetkit/dist/lastConnected-b964dc30.js\");\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! starknet */ \"./node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _index_70f373da_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-70f373da.js */ \"./node_modules/starknetkit/dist/index-70f373da.js\");\n/* harmony import */ var _publicRcpNodes_be041588_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./publicRcpNodes-be041588.js */ \"./node_modules/starknetkit/dist/publicRcpNodes-be041588.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\nvar Au = Object.defineProperty;\nvar Tu = (i, e, t) => e in i ? Au(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;\nvar we = (i, e, t) => (Tu(i, typeof e != \"symbol\" ? e + \"\" : e, t), t);\n\n\n\n\nvar sn = { exports: {} }, $i = typeof Reflect == \"object\" ? Reflect : null, Bn = $i && typeof $i.apply == \"function\" ? $i.apply : function(e, t, s) {\n  return Function.prototype.apply.call(e, t, s);\n}, qs;\n$i && typeof $i.ownKeys == \"function\" ? qs = $i.ownKeys : Object.getOwnPropertySymbols ? qs = function(e) {\n  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));\n} : qs = function(e) {\n  return Object.getOwnPropertyNames(e);\n};\nfunction Lu(i) {\n  console && console.warn && console.warn(i);\n}\nvar Ya = Number.isNaN || function(e) {\n  return e !== e;\n};\nfunction Oe() {\n  Oe.init.call(this);\n}\nsn.exports = Oe;\nsn.exports.once = zu;\nOe.EventEmitter = Oe;\nOe.prototype._events = void 0;\nOe.prototype._eventsCount = 0;\nOe.prototype._maxListeners = void 0;\nvar kn = 10;\nfunction tr(i) {\n  if (typeof i != \"function\")\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof i);\n}\nObject.defineProperty(Oe, \"defaultMaxListeners\", {\n  enumerable: !0,\n  get: function() {\n    return kn;\n  },\n  set: function(i) {\n    if (typeof i != \"number\" || i < 0 || Ya(i))\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + i + \".\");\n    kn = i;\n  }\n});\nOe.init = function() {\n  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n};\nOe.prototype.setMaxListeners = function(e) {\n  if (typeof e != \"number\" || e < 0 || Ya(e))\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + e + \".\");\n  return this._maxListeners = e, this;\n};\nfunction Ja(i) {\n  return i._maxListeners === void 0 ? Oe.defaultMaxListeners : i._maxListeners;\n}\nOe.prototype.getMaxListeners = function() {\n  return Ja(this);\n};\nOe.prototype.emit = function(e) {\n  for (var t = [], s = 1; s < arguments.length; s++)\n    t.push(arguments[s]);\n  var r = e === \"error\", n = this._events;\n  if (n !== void 0)\n    r = r && n.error === void 0;\n  else if (!r)\n    return !1;\n  if (r) {\n    var o;\n    if (t.length > 0 && (o = t[0]), o instanceof Error)\n      throw o;\n    var c = new Error(\"Unhandled error.\" + (o ? \" (\" + o.message + \")\" : \"\"));\n    throw c.context = o, c;\n  }\n  var u = n[e];\n  if (u === void 0)\n    return !1;\n  if (typeof u == \"function\")\n    Bn(u, this, t);\n  else\n    for (var d = u.length, p = tc(u, d), s = 0; s < d; ++s)\n      Bn(p[s], this, t);\n  return !0;\n};\nfunction Qa(i, e, t, s) {\n  var r, n, o;\n  if (tr(t), n = i._events, n === void 0 ? (n = i._events = /* @__PURE__ */ Object.create(null), i._eventsCount = 0) : (n.newListener !== void 0 && (i.emit(\n    \"newListener\",\n    e,\n    t.listener ? t.listener : t\n  ), n = i._events), o = n[e]), o === void 0)\n    o = n[e] = t, ++i._eventsCount;\n  else if (typeof o == \"function\" ? o = n[e] = s ? [t, o] : [o, t] : s ? o.unshift(t) : o.push(t), r = Ja(i), r > 0 && o.length > r && !o.warned) {\n    o.warned = !0;\n    var c = new Error(\"Possible EventEmitter memory leak detected. \" + o.length + \" \" + String(e) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n    c.name = \"MaxListenersExceededWarning\", c.emitter = i, c.type = e, c.count = o.length, Lu(c);\n  }\n  return i;\n}\nOe.prototype.addListener = function(e, t) {\n  return Qa(this, e, t, !1);\n};\nOe.prototype.on = Oe.prototype.addListener;\nOe.prototype.prependListener = function(e, t) {\n  return Qa(this, e, t, !0);\n};\nfunction Mu() {\n  if (!this.fired)\n    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);\n}\nfunction Xa(i, e, t) {\n  var s = { fired: !1, wrapFn: void 0, target: i, type: e, listener: t }, r = Mu.bind(s);\n  return r.listener = t, s.wrapFn = r, r;\n}\nOe.prototype.once = function(e, t) {\n  return tr(t), this.on(e, Xa(this, e, t)), this;\n};\nOe.prototype.prependOnceListener = function(e, t) {\n  return tr(t), this.prependListener(e, Xa(this, e, t)), this;\n};\nOe.prototype.removeListener = function(e, t) {\n  var s, r, n, o, c;\n  if (tr(t), r = this._events, r === void 0)\n    return this;\n  if (s = r[e], s === void 0)\n    return this;\n  if (s === t || s.listener === t)\n    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[e], r.removeListener && this.emit(\"removeListener\", e, s.listener || t));\n  else if (typeof s != \"function\") {\n    for (n = -1, o = s.length - 1; o >= 0; o--)\n      if (s[o] === t || s[o].listener === t) {\n        c = s[o].listener, n = o;\n        break;\n      }\n    if (n < 0)\n      return this;\n    n === 0 ? s.shift() : qu(s, n), s.length === 1 && (r[e] = s[0]), r.removeListener !== void 0 && this.emit(\"removeListener\", e, c || t);\n  }\n  return this;\n};\nOe.prototype.off = Oe.prototype.removeListener;\nOe.prototype.removeAllListeners = function(e) {\n  var t, s, r;\n  if (s = this._events, s === void 0)\n    return this;\n  if (s.removeListener === void 0)\n    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : s[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete s[e]), this;\n  if (arguments.length === 0) {\n    var n = Object.keys(s), o;\n    for (r = 0; r < n.length; ++r)\n      o = n[r], o !== \"removeListener\" && this.removeAllListeners(o);\n    return this.removeAllListeners(\"removeListener\"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;\n  }\n  if (t = s[e], typeof t == \"function\")\n    this.removeListener(e, t);\n  else if (t !== void 0)\n    for (r = t.length - 1; r >= 0; r--)\n      this.removeListener(e, t[r]);\n  return this;\n};\nfunction Za(i, e, t) {\n  var s = i._events;\n  if (s === void 0)\n    return [];\n  var r = s[e];\n  return r === void 0 ? [] : typeof r == \"function\" ? t ? [r.listener || r] : [r] : t ? ju(r) : tc(r, r.length);\n}\nOe.prototype.listeners = function(e) {\n  return Za(this, e, !0);\n};\nOe.prototype.rawListeners = function(e) {\n  return Za(this, e, !1);\n};\nOe.listenerCount = function(i, e) {\n  return typeof i.listenerCount == \"function\" ? i.listenerCount(e) : ec.call(i, e);\n};\nOe.prototype.listenerCount = ec;\nfunction ec(i) {\n  var e = this._events;\n  if (e !== void 0) {\n    var t = e[i];\n    if (typeof t == \"function\")\n      return 1;\n    if (t !== void 0)\n      return t.length;\n  }\n  return 0;\n}\nOe.prototype.eventNames = function() {\n  return this._eventsCount > 0 ? qs(this._events) : [];\n};\nfunction tc(i, e) {\n  for (var t = new Array(e), s = 0; s < e; ++s)\n    t[s] = i[s];\n  return t;\n}\nfunction qu(i, e) {\n  for (; e + 1 < i.length; e++)\n    i[e] = i[e + 1];\n  i.pop();\n}\nfunction ju(i) {\n  for (var e = new Array(i.length), t = 0; t < e.length; ++t)\n    e[t] = i[t].listener || i[t];\n  return e;\n}\nfunction zu(i, e) {\n  return new Promise(function(t, s) {\n    function r(o) {\n      i.removeListener(e, n), s(o);\n    }\n    function n() {\n      typeof i.removeListener == \"function\" && i.removeListener(\"error\", r), t([].slice.call(arguments));\n    }\n    ic(i, e, n, { once: !0 }), e !== \"error\" && Ku(i, r, { once: !0 });\n  });\n}\nfunction Ku(i, e, t) {\n  typeof i.on == \"function\" && ic(i, \"error\", e, t);\n}\nfunction ic(i, e, t, s) {\n  if (typeof i.on == \"function\")\n    s.once ? i.once(e, t) : i.on(e, t);\n  else if (typeof i.addEventListener == \"function\")\n    i.addEventListener(e, function r(n) {\n      s.once && i.removeEventListener(e, r), t(n);\n    });\n  else\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof i);\n}\nvar We = sn.exports;\nconst ir = /* @__PURE__ */ (0,_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.e)(We);\nvar sr = {}, sc = { exports: {} };\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n(function(i) {\n  var e, t, s, r, n, o, c, u, d, p, b, x, O, _, C, F, K, I, D, y, w, f, a;\n  (function(l) {\n    var L = typeof _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c == \"object\" ? _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c : typeof self == \"object\" ? self : typeof this == \"object\" ? this : {};\n    l(v(L, v(i.exports)));\n    function v(R, $) {\n      return R !== L && (typeof Object.create == \"function\" ? Object.defineProperty(R, \"__esModule\", { value: !0 }) : R.__esModule = !0), function(q, m) {\n        return R[q] = $ ? $(q, m) : m;\n      };\n    }\n  })(function(l) {\n    var L = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, R) {\n      v.__proto__ = R;\n    } || function(v, R) {\n      for (var $ in R)\n        R.hasOwnProperty($) && (v[$] = R[$]);\n    };\n    e = function(v, R) {\n      L(v, R);\n      function $() {\n        this.constructor = v;\n      }\n      v.prototype = R === null ? Object.create(R) : ($.prototype = R.prototype, new $());\n    }, t = Object.assign || function(v) {\n      for (var R, $ = 1, q = arguments.length; $ < q; $++) {\n        R = arguments[$];\n        for (var m in R)\n          Object.prototype.hasOwnProperty.call(R, m) && (v[m] = R[m]);\n      }\n      return v;\n    }, s = function(v, R) {\n      var $ = {};\n      for (var q in v)\n        Object.prototype.hasOwnProperty.call(v, q) && R.indexOf(q) < 0 && ($[q] = v[q]);\n      if (v != null && typeof Object.getOwnPropertySymbols == \"function\")\n        for (var m = 0, q = Object.getOwnPropertySymbols(v); m < q.length; m++)\n          R.indexOf(q[m]) < 0 && Object.prototype.propertyIsEnumerable.call(v, q[m]) && ($[q[m]] = v[q[m]]);\n      return $;\n    }, r = function(v, R, $, q) {\n      var m = arguments.length, E = m < 3 ? R : q === null ? q = Object.getOwnPropertyDescriptor(R, $) : q, B;\n      if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n        E = Reflect.decorate(v, R, $, q);\n      else\n        for (var z = v.length - 1; z >= 0; z--)\n          (B = v[z]) && (E = (m < 3 ? B(E) : m > 3 ? B(R, $, E) : B(R, $)) || E);\n      return m > 3 && E && Object.defineProperty(R, $, E), E;\n    }, n = function(v, R) {\n      return function($, q) {\n        R($, q, v);\n      };\n    }, o = function(v, R) {\n      if (typeof Reflect == \"object\" && typeof Reflect.metadata == \"function\")\n        return Reflect.metadata(v, R);\n    }, c = function(v, R, $, q) {\n      function m(E) {\n        return E instanceof $ ? E : new $(function(B) {\n          B(E);\n        });\n      }\n      return new ($ || ($ = Promise))(function(E, B) {\n        function z(M) {\n          try {\n            U(q.next(M));\n          } catch (H) {\n            B(H);\n          }\n        }\n        function j(M) {\n          try {\n            U(q.throw(M));\n          } catch (H) {\n            B(H);\n          }\n        }\n        function U(M) {\n          M.done ? E(M.value) : m(M.value).then(z, j);\n        }\n        U((q = q.apply(v, R || [])).next());\n      });\n    }, u = function(v, R) {\n      var $ = { label: 0, sent: function() {\n        if (E[0] & 1)\n          throw E[1];\n        return E[1];\n      }, trys: [], ops: [] }, q, m, E, B;\n      return B = { next: z(0), throw: z(1), return: z(2) }, typeof Symbol == \"function\" && (B[Symbol.iterator] = function() {\n        return this;\n      }), B;\n      function z(U) {\n        return function(M) {\n          return j([U, M]);\n        };\n      }\n      function j(U) {\n        if (q)\n          throw new TypeError(\"Generator is already executing.\");\n        for (; $; )\n          try {\n            if (q = 1, m && (E = U[0] & 2 ? m.return : U[0] ? m.throw || ((E = m.return) && E.call(m), 0) : m.next) && !(E = E.call(m, U[1])).done)\n              return E;\n            switch (m = 0, E && (U = [U[0] & 2, E.value]), U[0]) {\n              case 0:\n              case 1:\n                E = U;\n                break;\n              case 4:\n                return $.label++, { value: U[1], done: !1 };\n              case 5:\n                $.label++, m = U[1], U = [0];\n                continue;\n              case 7:\n                U = $.ops.pop(), $.trys.pop();\n                continue;\n              default:\n                if (E = $.trys, !(E = E.length > 0 && E[E.length - 1]) && (U[0] === 6 || U[0] === 2)) {\n                  $ = 0;\n                  continue;\n                }\n                if (U[0] === 3 && (!E || U[1] > E[0] && U[1] < E[3])) {\n                  $.label = U[1];\n                  break;\n                }\n                if (U[0] === 6 && $.label < E[1]) {\n                  $.label = E[1], E = U;\n                  break;\n                }\n                if (E && $.label < E[2]) {\n                  $.label = E[2], $.ops.push(U);\n                  break;\n                }\n                E[2] && $.ops.pop(), $.trys.pop();\n                continue;\n            }\n            U = R.call(v, $);\n          } catch (M) {\n            U = [6, M], m = 0;\n          } finally {\n            q = E = 0;\n          }\n        if (U[0] & 5)\n          throw U[1];\n        return { value: U[0] ? U[1] : void 0, done: !0 };\n      }\n    }, a = function(v, R, $, q) {\n      q === void 0 && (q = $), v[q] = R[$];\n    }, d = function(v, R) {\n      for (var $ in v)\n        $ !== \"default\" && !R.hasOwnProperty($) && (R[$] = v[$]);\n    }, p = function(v) {\n      var R = typeof Symbol == \"function\" && Symbol.iterator, $ = R && v[R], q = 0;\n      if ($)\n        return $.call(v);\n      if (v && typeof v.length == \"number\")\n        return {\n          next: function() {\n            return v && q >= v.length && (v = void 0), { value: v && v[q++], done: !v };\n          }\n        };\n      throw new TypeError(R ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    }, b = function(v, R) {\n      var $ = typeof Symbol == \"function\" && v[Symbol.iterator];\n      if (!$)\n        return v;\n      var q = $.call(v), m, E = [], B;\n      try {\n        for (; (R === void 0 || R-- > 0) && !(m = q.next()).done; )\n          E.push(m.value);\n      } catch (z) {\n        B = { error: z };\n      } finally {\n        try {\n          m && !m.done && ($ = q.return) && $.call(q);\n        } finally {\n          if (B)\n            throw B.error;\n        }\n      }\n      return E;\n    }, x = function() {\n      for (var v = [], R = 0; R < arguments.length; R++)\n        v = v.concat(b(arguments[R]));\n      return v;\n    }, O = function() {\n      for (var v = 0, R = 0, $ = arguments.length; R < $; R++)\n        v += arguments[R].length;\n      for (var q = Array(v), m = 0, R = 0; R < $; R++)\n        for (var E = arguments[R], B = 0, z = E.length; B < z; B++, m++)\n          q[m] = E[B];\n      return q;\n    }, _ = function(v) {\n      return this instanceof _ ? (this.v = v, this) : new _(v);\n    }, C = function(v, R, $) {\n      if (!Symbol.asyncIterator)\n        throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n      var q = $.apply(v, R || []), m, E = [];\n      return m = {}, B(\"next\"), B(\"throw\"), B(\"return\"), m[Symbol.asyncIterator] = function() {\n        return this;\n      }, m;\n      function B(te) {\n        q[te] && (m[te] = function(G) {\n          return new Promise(function(ie, Q) {\n            E.push([te, G, ie, Q]) > 1 || z(te, G);\n          });\n        });\n      }\n      function z(te, G) {\n        try {\n          j(q[te](G));\n        } catch (ie) {\n          H(E[0][3], ie);\n        }\n      }\n      function j(te) {\n        te.value instanceof _ ? Promise.resolve(te.value.v).then(U, M) : H(E[0][2], te);\n      }\n      function U(te) {\n        z(\"next\", te);\n      }\n      function M(te) {\n        z(\"throw\", te);\n      }\n      function H(te, G) {\n        te(G), E.shift(), E.length && z(E[0][0], E[0][1]);\n      }\n    }, F = function(v) {\n      var R, $;\n      return R = {}, q(\"next\"), q(\"throw\", function(m) {\n        throw m;\n      }), q(\"return\"), R[Symbol.iterator] = function() {\n        return this;\n      }, R;\n      function q(m, E) {\n        R[m] = v[m] ? function(B) {\n          return ($ = !$) ? { value: _(v[m](B)), done: m === \"return\" } : E ? E(B) : B;\n        } : E;\n      }\n    }, K = function(v) {\n      if (!Symbol.asyncIterator)\n        throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n      var R = v[Symbol.asyncIterator], $;\n      return R ? R.call(v) : (v = typeof p == \"function\" ? p(v) : v[Symbol.iterator](), $ = {}, q(\"next\"), q(\"throw\"), q(\"return\"), $[Symbol.asyncIterator] = function() {\n        return this;\n      }, $);\n      function q(E) {\n        $[E] = v[E] && function(B) {\n          return new Promise(function(z, j) {\n            B = v[E](B), m(z, j, B.done, B.value);\n          });\n        };\n      }\n      function m(E, B, z, j) {\n        Promise.resolve(j).then(function(U) {\n          E({ value: U, done: z });\n        }, B);\n      }\n    }, I = function(v, R) {\n      return Object.defineProperty ? Object.defineProperty(v, \"raw\", { value: R }) : v.raw = R, v;\n    }, D = function(v) {\n      if (v && v.__esModule)\n        return v;\n      var R = {};\n      if (v != null)\n        for (var $ in v)\n          Object.hasOwnProperty.call(v, $) && (R[$] = v[$]);\n      return R.default = v, R;\n    }, y = function(v) {\n      return v && v.__esModule ? v : { default: v };\n    }, w = function(v, R) {\n      if (!R.has(v))\n        throw new TypeError(\"attempted to get private field on non-instance\");\n      return R.get(v);\n    }, f = function(v, R, $) {\n      if (!R.has(v))\n        throw new TypeError(\"attempted to set private field on non-instance\");\n      return R.set(v, $), $;\n    }, l(\"__extends\", e), l(\"__assign\", t), l(\"__rest\", s), l(\"__decorate\", r), l(\"__param\", n), l(\"__metadata\", o), l(\"__awaiter\", c), l(\"__generator\", u), l(\"__exportStar\", d), l(\"__createBinding\", a), l(\"__values\", p), l(\"__read\", b), l(\"__spread\", x), l(\"__spreadArrays\", O), l(\"__await\", _), l(\"__asyncGenerator\", C), l(\"__asyncDelegator\", F), l(\"__asyncValues\", K), l(\"__makeTemplateObject\", I), l(\"__importStar\", D), l(\"__importDefault\", y), l(\"__classPrivateFieldGet\", w), l(\"__classPrivateFieldSet\", f);\n  });\n})(sc);\nvar Ft = sc.exports, fs = {};\nObject.defineProperty(fs, \"__esModule\", { value: !0 });\nfunction Vu(i) {\n  if (typeof i != \"string\")\n    throw new Error(`Cannot safe json parse value of type ${typeof i}`);\n  try {\n    return JSON.parse(i);\n  } catch {\n    return i;\n  }\n}\nfs.safeJsonParse = Vu;\nfunction Bu(i) {\n  return typeof i == \"string\" ? i : JSON.stringify(i, (e, t) => typeof t > \"u\" ? null : t);\n}\nfs.safeJsonStringify = Bu;\nvar ki = { exports: {} }, Hn;\nfunction ku() {\n  return Hn || (Hn = 1, function() {\n    let i;\n    function e() {\n    }\n    i = e, i.prototype.getItem = function(t) {\n      return this.hasOwnProperty(t) ? String(this[t]) : null;\n    }, i.prototype.setItem = function(t, s) {\n      this[t] = String(s);\n    }, i.prototype.removeItem = function(t) {\n      delete this[t];\n    }, i.prototype.clear = function() {\n      const t = this;\n      Object.keys(t).forEach(function(s) {\n        t[s] = void 0, delete t[s];\n      });\n    }, i.prototype.key = function(t) {\n      return t = t || 0, Object.keys(this)[t];\n    }, i.prototype.__defineGetter__(\"length\", function() {\n      return Object.keys(this).length;\n    }), typeof _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c < \"u\" && _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c.localStorage ? ki.exports = _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c.localStorage : typeof window < \"u\" && window.localStorage ? ki.exports = window.localStorage : ki.exports = new e();\n  }()), ki.exports;\n}\nvar yr = {}, Hi = {}, Gn;\nfunction Hu() {\n  if (Gn)\n    return Hi;\n  Gn = 1, Object.defineProperty(Hi, \"__esModule\", { value: !0 }), Hi.IKeyValueStorage = void 0;\n  class i {\n  }\n  return Hi.IKeyValueStorage = i, Hi;\n}\nvar Gi = {}, Wn;\nfunction Gu() {\n  if (Wn)\n    return Gi;\n  Wn = 1, Object.defineProperty(Gi, \"__esModule\", { value: !0 }), Gi.parseEntry = void 0;\n  const i = fs;\n  function e(t) {\n    var s;\n    return [t[0], i.safeJsonParse((s = t[1]) !== null && s !== void 0 ? s : \"\")];\n  }\n  return Gi.parseEntry = e, Gi;\n}\nvar Yn;\nfunction Wu() {\n  return Yn || (Yn = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 });\n    const e = Ft;\n    e.__exportStar(Hu(), i), e.__exportStar(Gu(), i);\n  }(yr)), yr;\n}\nObject.defineProperty(sr, \"__esModule\", { value: !0 });\nsr.KeyValueStorage = void 0;\nconst Ci = Ft, Jn = fs, Yu = Ci.__importDefault(ku()), Ju = Wu();\nclass rc {\n  constructor() {\n    this.localStorage = Yu.default;\n  }\n  getKeys() {\n    return Ci.__awaiter(this, void 0, void 0, function* () {\n      return Object.keys(this.localStorage);\n    });\n  }\n  getEntries() {\n    return Ci.__awaiter(this, void 0, void 0, function* () {\n      return Object.entries(this.localStorage).map(Ju.parseEntry);\n    });\n  }\n  getItem(e) {\n    return Ci.__awaiter(this, void 0, void 0, function* () {\n      const t = this.localStorage.getItem(e);\n      if (t !== null)\n        return Jn.safeJsonParse(t);\n    });\n  }\n  setItem(e, t) {\n    return Ci.__awaiter(this, void 0, void 0, function* () {\n      this.localStorage.setItem(e, Jn.safeJsonStringify(t));\n    });\n  }\n  removeItem(e) {\n    return Ci.__awaiter(this, void 0, void 0, function* () {\n      this.localStorage.removeItem(e);\n    });\n  }\n}\nsr.KeyValueStorage = rc;\nvar nc = sr.default = rc, Wt = {}, Wi = {}, V = {}, mr = {}, Yi = {}, Qn;\nfunction Qu() {\n  if (Qn)\n    return Yi;\n  Qn = 1, Object.defineProperty(Yi, \"__esModule\", { value: !0 }), Yi.delay = void 0;\n  function i(e) {\n    return new Promise((t) => {\n      setTimeout(() => {\n        t(!0);\n      }, e);\n    });\n  }\n  return Yi.delay = i, Yi;\n}\nvar mi = {}, br = {}, bi = {}, Xn;\nfunction Xu() {\n  return Xn || (Xn = 1, Object.defineProperty(bi, \"__esModule\", { value: !0 }), bi.ONE_THOUSAND = bi.ONE_HUNDRED = void 0, bi.ONE_HUNDRED = 100, bi.ONE_THOUSAND = 1e3), bi;\n}\nvar wr = {}, Zn;\nfunction Zu() {\n  return Zn || (Zn = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 }), i.ONE_YEAR = i.FOUR_WEEKS = i.THREE_WEEKS = i.TWO_WEEKS = i.ONE_WEEK = i.THIRTY_DAYS = i.SEVEN_DAYS = i.FIVE_DAYS = i.THREE_DAYS = i.ONE_DAY = i.TWENTY_FOUR_HOURS = i.TWELVE_HOURS = i.SIX_HOURS = i.THREE_HOURS = i.ONE_HOUR = i.SIXTY_MINUTES = i.THIRTY_MINUTES = i.TEN_MINUTES = i.FIVE_MINUTES = i.ONE_MINUTE = i.SIXTY_SECONDS = i.THIRTY_SECONDS = i.TEN_SECONDS = i.FIVE_SECONDS = i.ONE_SECOND = void 0, i.ONE_SECOND = 1, i.FIVE_SECONDS = 5, i.TEN_SECONDS = 10, i.THIRTY_SECONDS = 30, i.SIXTY_SECONDS = 60, i.ONE_MINUTE = i.SIXTY_SECONDS, i.FIVE_MINUTES = i.ONE_MINUTE * 5, i.TEN_MINUTES = i.ONE_MINUTE * 10, i.THIRTY_MINUTES = i.ONE_MINUTE * 30, i.SIXTY_MINUTES = i.ONE_MINUTE * 60, i.ONE_HOUR = i.SIXTY_MINUTES, i.THREE_HOURS = i.ONE_HOUR * 3, i.SIX_HOURS = i.ONE_HOUR * 6, i.TWELVE_HOURS = i.ONE_HOUR * 12, i.TWENTY_FOUR_HOURS = i.ONE_HOUR * 24, i.ONE_DAY = i.TWENTY_FOUR_HOURS, i.THREE_DAYS = i.ONE_DAY * 3, i.FIVE_DAYS = i.ONE_DAY * 5, i.SEVEN_DAYS = i.ONE_DAY * 7, i.THIRTY_DAYS = i.ONE_DAY * 30, i.ONE_WEEK = i.SEVEN_DAYS, i.TWO_WEEKS = i.ONE_WEEK * 2, i.THREE_WEEKS = i.ONE_WEEK * 3, i.FOUR_WEEKS = i.ONE_WEEK * 4, i.ONE_YEAR = i.ONE_DAY * 365;\n  }(wr)), wr;\n}\nvar eo;\nfunction oc() {\n  return eo || (eo = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 });\n    const e = Ft;\n    e.__exportStar(Xu(), i), e.__exportStar(Zu(), i);\n  }(br)), br;\n}\nvar to;\nfunction el() {\n  if (to)\n    return mi;\n  to = 1, Object.defineProperty(mi, \"__esModule\", { value: !0 }), mi.fromMiliseconds = mi.toMiliseconds = void 0;\n  const i = oc();\n  function e(s) {\n    return s * i.ONE_THOUSAND;\n  }\n  mi.toMiliseconds = e;\n  function t(s) {\n    return Math.floor(s / i.ONE_THOUSAND);\n  }\n  return mi.fromMiliseconds = t, mi;\n}\nvar io;\nfunction tl() {\n  return io || (io = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 });\n    const e = Ft;\n    e.__exportStar(Qu(), i), e.__exportStar(el(), i);\n  }(mr)), mr;\n}\nvar Ri = {}, so;\nfunction il() {\n  if (so)\n    return Ri;\n  so = 1, Object.defineProperty(Ri, \"__esModule\", { value: !0 }), Ri.Watch = void 0;\n  class i {\n    constructor() {\n      this.timestamps = /* @__PURE__ */ new Map();\n    }\n    start(t) {\n      if (this.timestamps.has(t))\n        throw new Error(`Watch already started for label: ${t}`);\n      this.timestamps.set(t, { started: Date.now() });\n    }\n    stop(t) {\n      const s = this.get(t);\n      if (typeof s.elapsed < \"u\")\n        throw new Error(`Watch already stopped for label: ${t}`);\n      const r = Date.now() - s.started;\n      this.timestamps.set(t, { started: s.started, elapsed: r });\n    }\n    get(t) {\n      const s = this.timestamps.get(t);\n      if (typeof s > \"u\")\n        throw new Error(`No timestamp found for label: ${t}`);\n      return s;\n    }\n    elapsed(t) {\n      const s = this.get(t);\n      return s.elapsed || Date.now() - s.started;\n    }\n  }\n  return Ri.Watch = i, Ri.default = i, Ri;\n}\nvar vr = {}, Ji = {}, ro;\nfunction sl() {\n  if (ro)\n    return Ji;\n  ro = 1, Object.defineProperty(Ji, \"__esModule\", { value: !0 }), Ji.IWatch = void 0;\n  class i {\n  }\n  return Ji.IWatch = i, Ji;\n}\nvar no;\nfunction rl() {\n  return no || (no = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 }), Ft.__exportStar(sl(), i);\n  }(vr)), vr;\n}\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  const e = Ft;\n  e.__exportStar(tl(), i), e.__exportStar(il(), i), e.__exportStar(rl(), i), e.__exportStar(oc(), i);\n})(V);\nvar _r = {}, Qi = {};\nlet Nt = class {\n};\nconst nl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  IEvents: Nt\n}, Symbol.toStringTag, { value: \"Module\" })), ol = /* @__PURE__ */ (0,_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.g)(nl);\nvar oo;\nfunction al() {\n  if (oo)\n    return Qi;\n  oo = 1, Object.defineProperty(Qi, \"__esModule\", { value: !0 }), Qi.IHeartBeat = void 0;\n  const i = ol;\n  class e extends i.IEvents {\n    constructor(s) {\n      super();\n    }\n  }\n  return Qi.IHeartBeat = e, Qi;\n}\nvar ao;\nfunction ac() {\n  return ao || (ao = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 }), Ft.__exportStar(al(), i);\n  }(_r)), _r;\n}\nvar Er = {}, wi = {}, co;\nfunction cl() {\n  if (co)\n    return wi;\n  co = 1, Object.defineProperty(wi, \"__esModule\", { value: !0 }), wi.HEARTBEAT_EVENTS = wi.HEARTBEAT_INTERVAL = void 0;\n  const i = V;\n  return wi.HEARTBEAT_INTERVAL = i.FIVE_SECONDS, wi.HEARTBEAT_EVENTS = {\n    pulse: \"heartbeat_pulse\"\n  }, wi;\n}\nvar ho;\nfunction cc() {\n  return ho || (ho = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 }), Ft.__exportStar(cl(), i);\n  }(Er)), Er;\n}\nvar uo;\nfunction hl() {\n  if (uo)\n    return Wi;\n  uo = 1, Object.defineProperty(Wi, \"__esModule\", { value: !0 }), Wi.HeartBeat = void 0;\n  const i = Ft, e = We, t = V, s = ac(), r = cc();\n  class n extends s.IHeartBeat {\n    constructor(c) {\n      super(c), this.events = new e.EventEmitter(), this.interval = r.HEARTBEAT_INTERVAL, this.interval = c?.interval || r.HEARTBEAT_INTERVAL;\n    }\n    static init(c) {\n      return i.__awaiter(this, void 0, void 0, function* () {\n        const u = new n(c);\n        return yield u.init(), u;\n      });\n    }\n    init() {\n      return i.__awaiter(this, void 0, void 0, function* () {\n        yield this.initialize();\n      });\n    }\n    stop() {\n      clearInterval(this.intervalRef);\n    }\n    on(c, u) {\n      this.events.on(c, u);\n    }\n    once(c, u) {\n      this.events.once(c, u);\n    }\n    off(c, u) {\n      this.events.off(c, u);\n    }\n    removeListener(c, u) {\n      this.events.removeListener(c, u);\n    }\n    initialize() {\n      return i.__awaiter(this, void 0, void 0, function* () {\n        this.intervalRef = setInterval(() => this.pulse(), t.toMiliseconds(this.interval));\n      });\n    }\n    pulse() {\n      this.events.emit(r.HEARTBEAT_EVENTS.pulse);\n    }\n  }\n  return Wi.HeartBeat = n, Wi;\n}\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  const e = Ft;\n  e.__exportStar(hl(), i), e.__exportStar(ac(), i), e.__exportStar(cc(), i);\n})(Wt);\nvar ee = {}, Sr, lo;\nfunction ul() {\n  if (lo)\n    return Sr;\n  lo = 1;\n  function i(t) {\n    try {\n      return JSON.stringify(t);\n    } catch {\n      return '\"[Circular]\"';\n    }\n  }\n  Sr = e;\n  function e(t, s, r) {\n    var n = r && r.stringify || i, o = 1;\n    if (typeof t == \"object\" && t !== null) {\n      var c = s.length + o;\n      if (c === 1)\n        return t;\n      var u = new Array(c);\n      u[0] = n(t);\n      for (var d = 1; d < c; d++)\n        u[d] = n(s[d]);\n      return u.join(\" \");\n    }\n    if (typeof t != \"string\")\n      return t;\n    var p = s.length;\n    if (p === 0)\n      return t;\n    for (var b = \"\", x = 1 - o, O = -1, _ = t && t.length || 0, C = 0; C < _; ) {\n      if (t.charCodeAt(C) === 37 && C + 1 < _) {\n        switch (O = O > -1 ? O : 0, t.charCodeAt(C + 1)) {\n          case 100:\n          case 102:\n            if (x >= p || s[x] == null)\n              break;\n            O < C && (b += t.slice(O, C)), b += Number(s[x]), O = C + 2, C++;\n            break;\n          case 105:\n            if (x >= p || s[x] == null)\n              break;\n            O < C && (b += t.slice(O, C)), b += Math.floor(Number(s[x])), O = C + 2, C++;\n            break;\n          case 79:\n          case 111:\n          case 106:\n            if (x >= p || s[x] === void 0)\n              break;\n            O < C && (b += t.slice(O, C));\n            var F = typeof s[x];\n            if (F === \"string\") {\n              b += \"'\" + s[x] + \"'\", O = C + 2, C++;\n              break;\n            }\n            if (F === \"function\") {\n              b += s[x].name || \"<anonymous>\", O = C + 2, C++;\n              break;\n            }\n            b += n(s[x]), O = C + 2, C++;\n            break;\n          case 115:\n            if (x >= p)\n              break;\n            O < C && (b += t.slice(O, C)), b += String(s[x]), O = C + 2, C++;\n            break;\n          case 37:\n            O < C && (b += t.slice(O, C)), b += \"%\", O = C + 2, C++, x--;\n            break;\n        }\n        ++x;\n      }\n      ++C;\n    }\n    return O === -1 ? t : (O < _ && (b += t.slice(O)), b);\n  }\n  return Sr;\n}\nvar Ir, fo;\nfunction ll() {\n  if (fo)\n    return Ir;\n  fo = 1;\n  const i = ul();\n  Ir = r;\n  const e = w().console || {}, t = {\n    mapHttpRequest: _,\n    mapHttpResponse: _,\n    wrapRequestSerializer: C,\n    wrapResponseSerializer: C,\n    wrapErrorSerializer: C,\n    req: _,\n    res: _,\n    err: x\n  };\n  function s(f, a) {\n    return Array.isArray(f) ? f.filter(function(L) {\n      return L !== \"!stdSerializers.err\";\n    }) : f === !0 ? Object.keys(a) : !1;\n  }\n  function r(f) {\n    f = f || {}, f.browser = f.browser || {};\n    const a = f.browser.transmit;\n    if (a && typeof a.send != \"function\")\n      throw Error(\"pino: transmit option must have a send function\");\n    const l = f.browser.write || e;\n    f.browser.write && (f.browser.asObject = !0);\n    const L = f.serializers || {}, v = s(f.browser.serialize, L);\n    let R = f.browser.serialize;\n    Array.isArray(f.browser.serialize) && f.browser.serialize.indexOf(\"!stdSerializers.err\") > -1 && (R = !1);\n    const $ = [\"error\", \"fatal\", \"warn\", \"info\", \"debug\", \"trace\"];\n    typeof l == \"function\" && (l.error = l.fatal = l.warn = l.info = l.debug = l.trace = l), f.enabled === !1 && (f.level = \"silent\");\n    const q = f.level || \"info\", m = Object.create(l);\n    m.log || (m.log = F), Object.defineProperty(m, \"levelVal\", {\n      get: B\n    }), Object.defineProperty(m, \"level\", {\n      get: z,\n      set: j\n    });\n    const E = {\n      transmit: a,\n      serialize: v,\n      asObject: f.browser.asObject,\n      levels: $,\n      timestamp: O(f)\n    };\n    m.levels = r.levels, m.level = q, m.setMaxListeners = m.getMaxListeners = m.emit = m.addListener = m.on = m.prependListener = m.once = m.prependOnceListener = m.removeListener = m.removeAllListeners = m.listeners = m.listenerCount = m.eventNames = m.write = m.flush = F, m.serializers = L, m._serialize = v, m._stdErrSerialize = R, m.child = U, a && (m._logEvent = b());\n    function B() {\n      return this.level === \"silent\" ? 1 / 0 : this.levels.values[this.level];\n    }\n    function z() {\n      return this._level;\n    }\n    function j(M) {\n      if (M !== \"silent\" && !this.levels.values[M])\n        throw Error(\"unknown level \" + M);\n      this._level = M, n(E, m, \"error\", \"log\"), n(E, m, \"fatal\", \"error\"), n(E, m, \"warn\", \"error\"), n(E, m, \"info\", \"log\"), n(E, m, \"debug\", \"log\"), n(E, m, \"trace\", \"log\");\n    }\n    function U(M, H) {\n      if (!M)\n        throw new Error(\"missing bindings for child Pino\");\n      H = H || {}, v && M.serializers && (H.serializers = M.serializers);\n      const te = H.serializers;\n      if (v && te) {\n        var G = Object.assign({}, L, te), ie = f.browser.serialize === !0 ? Object.keys(G) : v;\n        delete M.serializers, u([M], ie, G, this._stdErrSerialize);\n      }\n      function Q(se) {\n        this._childLevel = (se._childLevel | 0) + 1, this.error = d(se, M, \"error\"), this.fatal = d(se, M, \"fatal\"), this.warn = d(se, M, \"warn\"), this.info = d(se, M, \"info\"), this.debug = d(se, M, \"debug\"), this.trace = d(se, M, \"trace\"), G && (this.serializers = G, this._serialize = ie), a && (this._logEvent = b(\n          [].concat(se._logEvent.bindings, M)\n        ));\n      }\n      return Q.prototype = this, new Q(this);\n    }\n    return m;\n  }\n  r.levels = {\n    values: {\n      fatal: 60,\n      error: 50,\n      warn: 40,\n      info: 30,\n      debug: 20,\n      trace: 10\n    },\n    labels: {\n      10: \"trace\",\n      20: \"debug\",\n      30: \"info\",\n      40: \"warn\",\n      50: \"error\",\n      60: \"fatal\"\n    }\n  }, r.stdSerializers = t, r.stdTimeFunctions = Object.assign({}, { nullTime: K, epochTime: I, unixTime: D, isoTime: y });\n  function n(f, a, l, L) {\n    const v = Object.getPrototypeOf(a);\n    a[l] = a.levelVal > a.levels.values[l] ? F : v[l] ? v[l] : e[l] || e[L] || F, o(f, a, l);\n  }\n  function o(f, a, l) {\n    !f.transmit && a[l] === F || (a[l] = function(L) {\n      return function() {\n        const R = f.timestamp(), $ = new Array(arguments.length), q = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;\n        for (var m = 0; m < $.length; m++)\n          $[m] = arguments[m];\n        if (f.serialize && !f.asObject && u($, this._serialize, this.serializers, this._stdErrSerialize), f.asObject ? L.call(q, c(this, l, $, R)) : L.apply(q, $), f.transmit) {\n          const E = f.transmit.level || a.level, B = r.levels.values[E], z = r.levels.values[l];\n          if (z < B)\n            return;\n          p(this, {\n            ts: R,\n            methodLevel: l,\n            methodValue: z,\n            transmitLevel: E,\n            transmitValue: r.levels.values[f.transmit.level || a.level],\n            send: f.transmit.send,\n            val: a.levelVal\n          }, $);\n        }\n      };\n    }(a[l]));\n  }\n  function c(f, a, l, L) {\n    f._serialize && u(l, f._serialize, f.serializers, f._stdErrSerialize);\n    const v = l.slice();\n    let R = v[0];\n    const $ = {};\n    L && ($.time = L), $.level = r.levels.values[a];\n    let q = (f._childLevel | 0) + 1;\n    if (q < 1 && (q = 1), R !== null && typeof R == \"object\") {\n      for (; q-- && typeof v[0] == \"object\"; )\n        Object.assign($, v.shift());\n      R = v.length ? i(v.shift(), v) : void 0;\n    } else\n      typeof R == \"string\" && (R = i(v.shift(), v));\n    return R !== void 0 && ($.msg = R), $;\n  }\n  function u(f, a, l, L) {\n    for (const v in f)\n      if (L && f[v] instanceof Error)\n        f[v] = r.stdSerializers.err(f[v]);\n      else if (typeof f[v] == \"object\" && !Array.isArray(f[v]))\n        for (const R in f[v])\n          a && a.indexOf(R) > -1 && R in l && (f[v][R] = l[R](f[v][R]));\n  }\n  function d(f, a, l) {\n    return function() {\n      const L = new Array(1 + arguments.length);\n      L[0] = a;\n      for (var v = 1; v < L.length; v++)\n        L[v] = arguments[v - 1];\n      return f[l].apply(this, L);\n    };\n  }\n  function p(f, a, l) {\n    const L = a.send, v = a.ts, R = a.methodLevel, $ = a.methodValue, q = a.val, m = f._logEvent.bindings;\n    u(\n      l,\n      f._serialize || Object.keys(f.serializers),\n      f.serializers,\n      f._stdErrSerialize === void 0 ? !0 : f._stdErrSerialize\n    ), f._logEvent.ts = v, f._logEvent.messages = l.filter(function(E) {\n      return m.indexOf(E) === -1;\n    }), f._logEvent.level.label = R, f._logEvent.level.value = $, L(R, f._logEvent, q), f._logEvent = b(m);\n  }\n  function b(f) {\n    return {\n      ts: 0,\n      messages: [],\n      bindings: f || [],\n      level: { label: \"\", value: 0 }\n    };\n  }\n  function x(f) {\n    const a = {\n      type: f.constructor.name,\n      msg: f.message,\n      stack: f.stack\n    };\n    for (const l in f)\n      a[l] === void 0 && (a[l] = f[l]);\n    return a;\n  }\n  function O(f) {\n    return typeof f.timestamp == \"function\" ? f.timestamp : f.timestamp === !1 ? K : I;\n  }\n  function _() {\n    return {};\n  }\n  function C(f) {\n    return f;\n  }\n  function F() {\n  }\n  function K() {\n    return !1;\n  }\n  function I() {\n    return Date.now();\n  }\n  function D() {\n    return Math.round(Date.now() / 1e3);\n  }\n  function y() {\n    return new Date(Date.now()).toISOString();\n  }\n  function w() {\n    function f(a) {\n      return typeof a < \"u\" && a;\n    }\n    try {\n      return typeof globalThis < \"u\" || Object.defineProperty(Object.prototype, \"globalThis\", {\n        get: function() {\n          return delete Object.prototype.globalThis, this.globalThis = this;\n        },\n        configurable: !0\n      }), globalThis;\n    } catch {\n      return f(self) || f(window) || f(this) || {};\n    }\n  }\n  return Ir;\n}\nvar vi = {}, po;\nfunction hc() {\n  return po || (po = 1, Object.defineProperty(vi, \"__esModule\", { value: !0 }), vi.PINO_CUSTOM_CONTEXT_KEY = vi.PINO_LOGGER_DEFAULTS = void 0, vi.PINO_LOGGER_DEFAULTS = {\n    level: \"info\"\n  }, vi.PINO_CUSTOM_CONTEXT_KEY = \"custom_context\"), vi;\n}\nvar yt = {}, go;\nfunction dl() {\n  if (go)\n    return yt;\n  go = 1, Object.defineProperty(yt, \"__esModule\", { value: !0 }), yt.generateChildLogger = yt.formatChildLoggerContext = yt.getLoggerContext = yt.setBrowserLoggerContext = yt.getBrowserLoggerContext = yt.getDefaultLoggerOptions = void 0;\n  const i = hc();\n  function e(c) {\n    return Object.assign(Object.assign({}, c), { level: c?.level || i.PINO_LOGGER_DEFAULTS.level });\n  }\n  yt.getDefaultLoggerOptions = e;\n  function t(c, u = i.PINO_CUSTOM_CONTEXT_KEY) {\n    return c[u] || \"\";\n  }\n  yt.getBrowserLoggerContext = t;\n  function s(c, u, d = i.PINO_CUSTOM_CONTEXT_KEY) {\n    return c[d] = u, c;\n  }\n  yt.setBrowserLoggerContext = s;\n  function r(c, u = i.PINO_CUSTOM_CONTEXT_KEY) {\n    let d = \"\";\n    return typeof c.bindings > \"u\" ? d = t(c, u) : d = c.bindings().context || \"\", d;\n  }\n  yt.getLoggerContext = r;\n  function n(c, u, d = i.PINO_CUSTOM_CONTEXT_KEY) {\n    const p = r(c, d);\n    return p.trim() ? `${p}/${u}` : u;\n  }\n  yt.formatChildLoggerContext = n;\n  function o(c, u, d = i.PINO_CUSTOM_CONTEXT_KEY) {\n    const p = n(c, u, d), b = c.child({ context: p });\n    return s(b, p, d);\n  }\n  return yt.generateChildLogger = o, yt;\n}\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 }), i.pino = void 0;\n  const e = Ft, t = e.__importDefault(ll());\n  Object.defineProperty(i, \"pino\", { enumerable: !0, get: function() {\n    return t.default;\n  } }), e.__exportStar(hc(), i), e.__exportStar(dl(), i);\n})(ee);\nlet fl = class extends Nt {\n  constructor(e) {\n    super(), this.opts = e, this.protocol = \"wc\", this.version = 2;\n  }\n}, pl = class extends Nt {\n  constructor(e, t) {\n    super(), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map();\n  }\n}, gl = class {\n  constructor(e, t) {\n    this.logger = e, this.core = t;\n  }\n}, yl = class extends Nt {\n  constructor(e, t) {\n    super(), this.relayer = e, this.logger = t;\n  }\n}, ml = class extends Nt {\n  constructor(e) {\n    super();\n  }\n}, bl = class {\n  constructor(e, t, s, r) {\n    this.core = e, this.logger = t, this.name = s;\n  }\n}, wl = class extends Nt {\n  constructor(e, t) {\n    super(), this.relayer = e, this.logger = t;\n  }\n}, vl = class extends Nt {\n  constructor(e, t) {\n    super(), this.core = e, this.logger = t;\n  }\n}, _l = class {\n  constructor(e, t) {\n    this.projectId = e, this.logger = t;\n  }\n}, El = class {\n  constructor(e) {\n    this.opts = e, this.protocol = \"wc\", this.version = 2;\n  }\n}, Sl = class {\n  constructor(e) {\n    this.client = e;\n  }\n};\nconst Il = (i) => JSON.stringify(i, (e, t) => typeof t == \"bigint\" ? t.toString() + \"n\" : t), Dl = (i) => {\n  const e = /([\\[:])?(\\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\\}\\]])/g, t = i.replace(e, '$1\"$2n\"$3');\n  return JSON.parse(t, (s, r) => typeof r == \"string\" && r.match(/^\\d+n$/) ? BigInt(r.substring(0, r.length - 1)) : r);\n};\nfunction rn(i) {\n  if (typeof i != \"string\")\n    throw new Error(`Cannot safe json parse value of type ${typeof i}`);\n  try {\n    return Dl(i);\n  } catch {\n    return i;\n  }\n}\nfunction rr(i) {\n  return typeof i == \"string\" ? i : Il(i) || \"\";\n}\nvar nn = {}, li = {}, nr = {}, or = {};\nObject.defineProperty(or, \"__esModule\", { value: !0 });\nor.BrowserRandomSource = void 0;\nconst yo = 65536;\nclass xl {\n  constructor() {\n    this.isAvailable = !1, this.isInstantiated = !1;\n    const e = typeof self < \"u\" ? self.crypto || self.msCrypto : null;\n    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);\n  }\n  randomBytes(e) {\n    if (!this.isAvailable || !this._crypto)\n      throw new Error(\"Browser random byte generator is not available.\");\n    const t = new Uint8Array(e);\n    for (let s = 0; s < t.length; s += yo)\n      this._crypto.getRandomValues(t.subarray(s, s + Math.min(t.length - s, yo)));\n    return t;\n  }\n}\nor.BrowserRandomSource = xl;\nfunction Ol(i) {\n  throw new Error('Could not dynamically require \"' + i + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar ar = {}, Pt = {};\nObject.defineProperty(Pt, \"__esModule\", { value: !0 });\nfunction Nl(i) {\n  for (var e = 0; e < i.length; e++)\n    i[e] = 0;\n  return i;\n}\nPt.wipe = Nl;\nconst Pl = {}, Rl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: Pl\n}, Symbol.toStringTag, { value: \"Module\" })), Cl = /* @__PURE__ */ (0,_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.g)(Rl);\nObject.defineProperty(ar, \"__esModule\", { value: !0 });\nar.NodeRandomSource = void 0;\nconst Al = Pt;\nclass Tl {\n  constructor() {\n    if (this.isAvailable = !1, this.isInstantiated = !1, typeof Ol < \"u\") {\n      const e = Cl;\n      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);\n    }\n  }\n  randomBytes(e) {\n    if (!this.isAvailable || !this._crypto)\n      throw new Error(\"Node.js random byte generator is not available.\");\n    let t = this._crypto.randomBytes(e);\n    if (t.length !== e)\n      throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n    const s = new Uint8Array(e);\n    for (let r = 0; r < s.length; r++)\n      s[r] = t[r];\n    return (0, Al.wipe)(t), s;\n  }\n}\nar.NodeRandomSource = Tl;\nObject.defineProperty(nr, \"__esModule\", { value: !0 });\nnr.SystemRandomSource = void 0;\nconst $l = or, Fl = ar;\nclass Ul {\n  constructor() {\n    if (this.isAvailable = !1, this.name = \"\", this._source = new $l.BrowserRandomSource(), this._source.isAvailable) {\n      this.isAvailable = !0, this.name = \"Browser\";\n      return;\n    }\n    if (this._source = new Fl.NodeRandomSource(), this._source.isAvailable) {\n      this.isAvailable = !0, this.name = \"Node\";\n      return;\n    }\n  }\n  randomBytes(e) {\n    if (!this.isAvailable)\n      throw new Error(\"System random byte generator is not available.\");\n    return this._source.randomBytes(e);\n  }\n}\nnr.SystemRandomSource = Ul;\nvar oe = {}, uc = {};\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  function e(c, u) {\n    var d = c >>> 16 & 65535, p = c & 65535, b = u >>> 16 & 65535, x = u & 65535;\n    return p * x + (d * x + p * b << 16 >>> 0) | 0;\n  }\n  i.mul = Math.imul || e;\n  function t(c, u) {\n    return c + u | 0;\n  }\n  i.add = t;\n  function s(c, u) {\n    return c - u | 0;\n  }\n  i.sub = s;\n  function r(c, u) {\n    return c << u | c >>> 32 - u;\n  }\n  i.rotl = r;\n  function n(c, u) {\n    return c << 32 - u | c >>> u;\n  }\n  i.rotr = n;\n  function o(c) {\n    return typeof c == \"number\" && isFinite(c) && Math.floor(c) === c;\n  }\n  i.isInteger = Number.isInteger || o, i.MAX_SAFE_INTEGER = 9007199254740991, i.isSafeInteger = function(c) {\n    return i.isInteger(c) && c >= -i.MAX_SAFE_INTEGER && c <= i.MAX_SAFE_INTEGER;\n  };\n})(uc);\nObject.defineProperty(oe, \"__esModule\", { value: !0 });\nvar lc = uc;\nfunction Ll(i, e) {\n  return e === void 0 && (e = 0), (i[e + 0] << 8 | i[e + 1]) << 16 >> 16;\n}\noe.readInt16BE = Ll;\nfunction Ml(i, e) {\n  return e === void 0 && (e = 0), (i[e + 0] << 8 | i[e + 1]) >>> 0;\n}\noe.readUint16BE = Ml;\nfunction ql(i, e) {\n  return e === void 0 && (e = 0), (i[e + 1] << 8 | i[e]) << 16 >> 16;\n}\noe.readInt16LE = ql;\nfunction jl(i, e) {\n  return e === void 0 && (e = 0), (i[e + 1] << 8 | i[e]) >>> 0;\n}\noe.readUint16LE = jl;\nfunction dc(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(2)), t === void 0 && (t = 0), e[t + 0] = i >>> 8, e[t + 1] = i >>> 0, e;\n}\noe.writeUint16BE = dc;\noe.writeInt16BE = dc;\nfunction fc(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(2)), t === void 0 && (t = 0), e[t + 0] = i >>> 0, e[t + 1] = i >>> 8, e;\n}\noe.writeUint16LE = fc;\noe.writeInt16LE = fc;\nfunction Mr(i, e) {\n  return e === void 0 && (e = 0), i[e] << 24 | i[e + 1] << 16 | i[e + 2] << 8 | i[e + 3];\n}\noe.readInt32BE = Mr;\nfunction qr(i, e) {\n  return e === void 0 && (e = 0), (i[e] << 24 | i[e + 1] << 16 | i[e + 2] << 8 | i[e + 3]) >>> 0;\n}\noe.readUint32BE = qr;\nfunction jr(i, e) {\n  return e === void 0 && (e = 0), i[e + 3] << 24 | i[e + 2] << 16 | i[e + 1] << 8 | i[e];\n}\noe.readInt32LE = jr;\nfunction zr(i, e) {\n  return e === void 0 && (e = 0), (i[e + 3] << 24 | i[e + 2] << 16 | i[e + 1] << 8 | i[e]) >>> 0;\n}\noe.readUint32LE = zr;\nfunction ks(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0), e[t + 0] = i >>> 24, e[t + 1] = i >>> 16, e[t + 2] = i >>> 8, e[t + 3] = i >>> 0, e;\n}\noe.writeUint32BE = ks;\noe.writeInt32BE = ks;\nfunction Hs(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0), e[t + 0] = i >>> 0, e[t + 1] = i >>> 8, e[t + 2] = i >>> 16, e[t + 3] = i >>> 24, e;\n}\noe.writeUint32LE = Hs;\noe.writeInt32LE = Hs;\nfunction zl(i, e) {\n  e === void 0 && (e = 0);\n  var t = Mr(i, e), s = Mr(i, e + 4);\n  return t * 4294967296 + s - (s >> 31) * 4294967296;\n}\noe.readInt64BE = zl;\nfunction Kl(i, e) {\n  e === void 0 && (e = 0);\n  var t = qr(i, e), s = qr(i, e + 4);\n  return t * 4294967296 + s;\n}\noe.readUint64BE = Kl;\nfunction Vl(i, e) {\n  e === void 0 && (e = 0);\n  var t = jr(i, e), s = jr(i, e + 4);\n  return s * 4294967296 + t - (t >> 31) * 4294967296;\n}\noe.readInt64LE = Vl;\nfunction Bl(i, e) {\n  e === void 0 && (e = 0);\n  var t = zr(i, e), s = zr(i, e + 4);\n  return s * 4294967296 + t;\n}\noe.readUint64LE = Bl;\nfunction pc(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0), ks(i / 4294967296 >>> 0, e, t), ks(i >>> 0, e, t + 4), e;\n}\noe.writeUint64BE = pc;\noe.writeInt64BE = pc;\nfunction gc(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0), Hs(i >>> 0, e, t), Hs(i / 4294967296 >>> 0, e, t + 4), e;\n}\noe.writeUint64LE = gc;\noe.writeInt64LE = gc;\nfunction kl(i, e, t) {\n  if (t === void 0 && (t = 0), i % 8 !== 0)\n    throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n  if (i / 8 > e.length - t)\n    throw new Error(\"readUintBE: array is too short for the given bitLength\");\n  for (var s = 0, r = 1, n = i / 8 + t - 1; n >= t; n--)\n    s += e[n] * r, r *= 256;\n  return s;\n}\noe.readUintBE = kl;\nfunction Hl(i, e, t) {\n  if (t === void 0 && (t = 0), i % 8 !== 0)\n    throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n  if (i / 8 > e.length - t)\n    throw new Error(\"readUintLE: array is too short for the given bitLength\");\n  for (var s = 0, r = 1, n = t; n < t + i / 8; n++)\n    s += e[n] * r, r *= 256;\n  return s;\n}\noe.readUintLE = Hl;\nfunction Gl(i, e, t, s) {\n  if (t === void 0 && (t = new Uint8Array(i / 8)), s === void 0 && (s = 0), i % 8 !== 0)\n    throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n  if (!lc.isSafeInteger(e))\n    throw new Error(\"writeUintBE value must be an integer\");\n  for (var r = 1, n = i / 8 + s - 1; n >= s; n--)\n    t[n] = e / r & 255, r *= 256;\n  return t;\n}\noe.writeUintBE = Gl;\nfunction Wl(i, e, t, s) {\n  if (t === void 0 && (t = new Uint8Array(i / 8)), s === void 0 && (s = 0), i % 8 !== 0)\n    throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n  if (!lc.isSafeInteger(e))\n    throw new Error(\"writeUintLE value must be an integer\");\n  for (var r = 1, n = s; n < s + i / 8; n++)\n    t[n] = e / r & 255, r *= 256;\n  return t;\n}\noe.writeUintLE = Wl;\nfunction Yl(i, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(i.buffer, i.byteOffset, i.byteLength);\n  return t.getFloat32(e);\n}\noe.readFloat32BE = Yl;\nfunction Jl(i, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(i.buffer, i.byteOffset, i.byteLength);\n  return t.getFloat32(e, !0);\n}\noe.readFloat32LE = Jl;\nfunction Ql(i, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(i.buffer, i.byteOffset, i.byteLength);\n  return t.getFloat64(e);\n}\noe.readFloat64BE = Ql;\nfunction Xl(i, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(i.buffer, i.byteOffset, i.byteLength);\n  return t.getFloat64(e, !0);\n}\noe.readFloat64LE = Xl;\nfunction Zl(i, e, t) {\n  e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0);\n  var s = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return s.setFloat32(t, i), e;\n}\noe.writeFloat32BE = Zl;\nfunction ed(i, e, t) {\n  e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0);\n  var s = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return s.setFloat32(t, i, !0), e;\n}\noe.writeFloat32LE = ed;\nfunction td(i, e, t) {\n  e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0);\n  var s = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return s.setFloat64(t, i), e;\n}\noe.writeFloat64BE = td;\nfunction id(i, e, t) {\n  e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0);\n  var s = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return s.setFloat64(t, i, !0), e;\n}\noe.writeFloat64LE = id;\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 }), i.randomStringForEntropy = i.randomString = i.randomUint32 = i.randomBytes = i.defaultRandomSource = void 0;\n  const e = nr, t = oe, s = Pt;\n  i.defaultRandomSource = new e.SystemRandomSource();\n  function r(d, p = i.defaultRandomSource) {\n    return p.randomBytes(d);\n  }\n  i.randomBytes = r;\n  function n(d = i.defaultRandomSource) {\n    const p = r(4, d), b = (0, t.readUint32LE)(p);\n    return (0, s.wipe)(p), b;\n  }\n  i.randomUint32 = n;\n  const o = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  function c(d, p = o, b = i.defaultRandomSource) {\n    if (p.length < 2)\n      throw new Error(\"randomString charset is too short\");\n    if (p.length > 256)\n      throw new Error(\"randomString charset is too long\");\n    let x = \"\";\n    const O = p.length, _ = 256 - 256 % O;\n    for (; d > 0; ) {\n      const C = r(Math.ceil(d * 256 / _), b);\n      for (let F = 0; F < C.length && d > 0; F++) {\n        const K = C[F];\n        K < _ && (x += p.charAt(K % O), d--);\n      }\n      (0, s.wipe)(C);\n    }\n    return x;\n  }\n  i.randomString = c;\n  function u(d, p = o, b = i.defaultRandomSource) {\n    const x = Math.ceil(d / (Math.log(p.length) / Math.LN2));\n    return c(x, p, b);\n  }\n  i.randomStringForEntropy = u;\n})(li);\nvar yc = {};\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  var e = oe, t = Pt;\n  i.DIGEST_LENGTH = 64, i.BLOCK_SIZE = 128;\n  var s = (\n    /** @class */\n    function() {\n      function c() {\n        this.digestLength = i.DIGEST_LENGTH, this.blockSize = i.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();\n      }\n      return c.prototype._initState = function() {\n        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;\n      }, c.prototype.reset = function() {\n        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;\n      }, c.prototype.clean = function() {\n        t.wipe(this._buffer), t.wipe(this._tempHi), t.wipe(this._tempLo), this.reset();\n      }, c.prototype.update = function(u, d) {\n        if (d === void 0 && (d = u.length), this._finished)\n          throw new Error(\"SHA512: can't update because hash was finished.\");\n        var p = 0;\n        if (this._bytesHashed += d, this._bufferLength > 0) {\n          for (; this._bufferLength < i.BLOCK_SIZE && d > 0; )\n            this._buffer[this._bufferLength++] = u[p++], d--;\n          this._bufferLength === this.blockSize && (n(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);\n        }\n        for (d >= this.blockSize && (p = n(this._tempHi, this._tempLo, this._stateHi, this._stateLo, u, p, d), d %= this.blockSize); d > 0; )\n          this._buffer[this._bufferLength++] = u[p++], d--;\n        return this;\n      }, c.prototype.finish = function(u) {\n        if (!this._finished) {\n          var d = this._bytesHashed, p = this._bufferLength, b = d / 536870912 | 0, x = d << 3, O = d % 128 < 112 ? 128 : 256;\n          this._buffer[p] = 128;\n          for (var _ = p + 1; _ < O - 8; _++)\n            this._buffer[_] = 0;\n          e.writeUint32BE(b, this._buffer, O - 8), e.writeUint32BE(x, this._buffer, O - 4), n(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, O), this._finished = !0;\n        }\n        for (var _ = 0; _ < this.digestLength / 8; _++)\n          e.writeUint32BE(this._stateHi[_], u, _ * 8), e.writeUint32BE(this._stateLo[_], u, _ * 8 + 4);\n        return this;\n      }, c.prototype.digest = function() {\n        var u = new Uint8Array(this.digestLength);\n        return this.finish(u), u;\n      }, c.prototype.saveState = function() {\n        if (this._finished)\n          throw new Error(\"SHA256: cannot save finished state\");\n        return {\n          stateHi: new Int32Array(this._stateHi),\n          stateLo: new Int32Array(this._stateLo),\n          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,\n          bufferLength: this._bufferLength,\n          bytesHashed: this._bytesHashed\n        };\n      }, c.prototype.restoreState = function(u) {\n        return this._stateHi.set(u.stateHi), this._stateLo.set(u.stateLo), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;\n      }, c.prototype.cleanSavedState = function(u) {\n        t.wipe(u.stateHi), t.wipe(u.stateLo), u.buffer && t.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;\n      }, c;\n    }()\n  );\n  i.SHA512 = s;\n  var r = new Int32Array([\n    1116352408,\n    3609767458,\n    1899447441,\n    602891725,\n    3049323471,\n    3964484399,\n    3921009573,\n    2173295548,\n    961987163,\n    4081628472,\n    1508970993,\n    3053834265,\n    2453635748,\n    2937671579,\n    2870763221,\n    3664609560,\n    3624381080,\n    2734883394,\n    310598401,\n    1164996542,\n    607225278,\n    1323610764,\n    1426881987,\n    3590304994,\n    1925078388,\n    4068182383,\n    2162078206,\n    991336113,\n    2614888103,\n    633803317,\n    3248222580,\n    3479774868,\n    3835390401,\n    2666613458,\n    4022224774,\n    944711139,\n    264347078,\n    2341262773,\n    604807628,\n    2007800933,\n    770255983,\n    1495990901,\n    1249150122,\n    1856431235,\n    1555081692,\n    3175218132,\n    1996064986,\n    2198950837,\n    2554220882,\n    3999719339,\n    2821834349,\n    766784016,\n    2952996808,\n    2566594879,\n    3210313671,\n    3203337956,\n    3336571891,\n    1034457026,\n    3584528711,\n    2466948901,\n    113926993,\n    3758326383,\n    338241895,\n    168717936,\n    666307205,\n    1188179964,\n    773529912,\n    1546045734,\n    1294757372,\n    1522805485,\n    1396182291,\n    2643833823,\n    1695183700,\n    2343527390,\n    1986661051,\n    1014477480,\n    2177026350,\n    1206759142,\n    2456956037,\n    344077627,\n    2730485921,\n    1290863460,\n    2820302411,\n    3158454273,\n    3259730800,\n    3505952657,\n    3345764771,\n    106217008,\n    3516065817,\n    3606008344,\n    3600352804,\n    1432725776,\n    4094571909,\n    1467031594,\n    275423344,\n    851169720,\n    430227734,\n    3100823752,\n    506948616,\n    1363258195,\n    659060556,\n    3750685593,\n    883997877,\n    3785050280,\n    958139571,\n    3318307427,\n    1322822218,\n    3812723403,\n    1537002063,\n    2003034995,\n    1747873779,\n    3602036899,\n    1955562222,\n    1575990012,\n    2024104815,\n    1125592928,\n    2227730452,\n    2716904306,\n    2361852424,\n    442776044,\n    2428436474,\n    593698344,\n    2756734187,\n    3733110249,\n    3204031479,\n    2999351573,\n    3329325298,\n    3815920427,\n    3391569614,\n    3928383900,\n    3515267271,\n    566280711,\n    3940187606,\n    3454069534,\n    4118630271,\n    4000239992,\n    116418474,\n    1914138554,\n    174292421,\n    2731055270,\n    289380356,\n    3203993006,\n    460393269,\n    320620315,\n    685471733,\n    587496836,\n    852142971,\n    1086792851,\n    1017036298,\n    365543100,\n    1126000580,\n    2618297676,\n    1288033470,\n    3409855158,\n    1501505948,\n    4234509866,\n    1607167915,\n    987167468,\n    1816402316,\n    1246189591\n  ]);\n  function n(c, u, d, p, b, x, O) {\n    for (var _ = d[0], C = d[1], F = d[2], K = d[3], I = d[4], D = d[5], y = d[6], w = d[7], f = p[0], a = p[1], l = p[2], L = p[3], v = p[4], R = p[5], $ = p[6], q = p[7], m, E, B, z, j, U, M, H; O >= 128; ) {\n      for (var te = 0; te < 16; te++) {\n        var G = 8 * te + x;\n        c[te] = e.readUint32BE(b, G), u[te] = e.readUint32BE(b, G + 4);\n      }\n      for (var te = 0; te < 80; te++) {\n        var ie = _, Q = C, se = F, T = K, A = I, N = D, h = y, S = w, W = f, X = a, fe = l, ve = L, ge = v, Se = R, Me = $, $e = q;\n        if (m = w, E = q, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = (I >>> 14 | v << 32 - 14) ^ (I >>> 18 | v << 32 - 18) ^ (v >>> 41 - 32 | I << 32 - (41 - 32)), E = (v >>> 14 | I << 32 - 14) ^ (v >>> 18 | I << 32 - 18) ^ (I >>> 41 - 32 | v << 32 - (41 - 32)), j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, m = I & D ^ ~I & y, E = v & R ^ ~v & $, j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, m = r[te * 2], E = r[te * 2 + 1], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, m = c[te % 16], E = u[te % 16], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, B = M & 65535 | H << 16, z = j & 65535 | U << 16, m = B, E = z, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = (_ >>> 28 | f << 32 - 28) ^ (f >>> 34 - 32 | _ << 32 - (34 - 32)) ^ (f >>> 39 - 32 | _ << 32 - (39 - 32)), E = (f >>> 28 | _ << 32 - 28) ^ (_ >>> 34 - 32 | f << 32 - (34 - 32)) ^ (_ >>> 39 - 32 | f << 32 - (39 - 32)), j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, m = _ & C ^ _ & F ^ C & F, E = f & a ^ f & l ^ a & l, j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, S = M & 65535 | H << 16, $e = j & 65535 | U << 16, m = T, E = ve, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = B, E = z, j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, T = M & 65535 | H << 16, ve = j & 65535 | U << 16, C = ie, F = Q, K = se, I = T, D = A, y = N, w = h, _ = S, a = W, l = X, L = fe, v = ve, R = ge, $ = Se, q = Me, f = $e, te % 16 === 15)\n          for (var G = 0; G < 16; G++)\n            m = c[G], E = u[G], j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = c[(G + 9) % 16], E = u[(G + 9) % 16], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, B = c[(G + 1) % 16], z = u[(G + 1) % 16], m = (B >>> 1 | z << 32 - 1) ^ (B >>> 8 | z << 32 - 8) ^ B >>> 7, E = (z >>> 1 | B << 32 - 1) ^ (z >>> 8 | B << 32 - 8) ^ (z >>> 7 | B << 32 - 7), j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, B = c[(G + 14) % 16], z = u[(G + 14) % 16], m = (B >>> 19 | z << 32 - 19) ^ (z >>> 61 - 32 | B << 32 - (61 - 32)) ^ B >>> 6, E = (z >>> 19 | B << 32 - 19) ^ (B >>> 61 - 32 | z << 32 - (61 - 32)) ^ (z >>> 6 | B << 32 - 6), j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, c[G] = M & 65535 | H << 16, u[G] = j & 65535 | U << 16;\n      }\n      m = _, E = f, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[0], E = p[0], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[0] = _ = M & 65535 | H << 16, p[0] = f = j & 65535 | U << 16, m = C, E = a, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[1], E = p[1], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[1] = C = M & 65535 | H << 16, p[1] = a = j & 65535 | U << 16, m = F, E = l, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[2], E = p[2], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[2] = F = M & 65535 | H << 16, p[2] = l = j & 65535 | U << 16, m = K, E = L, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[3], E = p[3], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[3] = K = M & 65535 | H << 16, p[3] = L = j & 65535 | U << 16, m = I, E = v, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[4], E = p[4], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[4] = I = M & 65535 | H << 16, p[4] = v = j & 65535 | U << 16, m = D, E = R, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[5], E = p[5], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[5] = D = M & 65535 | H << 16, p[5] = R = j & 65535 | U << 16, m = y, E = $, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[6], E = p[6], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[6] = y = M & 65535 | H << 16, p[6] = $ = j & 65535 | U << 16, m = w, E = q, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[7], E = p[7], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[7] = w = M & 65535 | H << 16, p[7] = q = j & 65535 | U << 16, x += 128, O -= 128;\n    }\n    return x;\n  }\n  function o(c) {\n    var u = new s();\n    u.update(c);\n    var d = u.digest();\n    return u.clean(), d;\n  }\n  i.hash = o;\n})(yc);\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 }), i.convertSecretKeyToX25519 = i.convertPublicKeyToX25519 = i.verify = i.sign = i.extractPublicKeyFromSecretKey = i.generateKeyPair = i.generateKeyPairFromSeed = i.SEED_LENGTH = i.SECRET_KEY_LENGTH = i.PUBLIC_KEY_LENGTH = i.SIGNATURE_LENGTH = void 0;\n  const e = li, t = yc, s = Pt;\n  i.SIGNATURE_LENGTH = 64, i.PUBLIC_KEY_LENGTH = 32, i.SECRET_KEY_LENGTH = 64, i.SEED_LENGTH = 32;\n  function r(T) {\n    const A = new Float64Array(16);\n    if (T)\n      for (let N = 0; N < T.length; N++)\n        A[N] = T[N];\n    return A;\n  }\n  const n = new Uint8Array(32);\n  n[0] = 9;\n  const o = r(), c = r([1]), u = r([\n    30883,\n    4953,\n    19914,\n    30187,\n    55467,\n    16705,\n    2637,\n    112,\n    59544,\n    30585,\n    16505,\n    36039,\n    65139,\n    11119,\n    27886,\n    20995\n  ]), d = r([\n    61785,\n    9906,\n    39828,\n    60374,\n    45398,\n    33411,\n    5274,\n    224,\n    53552,\n    61171,\n    33010,\n    6542,\n    64743,\n    22239,\n    55772,\n    9222\n  ]), p = r([\n    54554,\n    36645,\n    11616,\n    51542,\n    42930,\n    38181,\n    51040,\n    26924,\n    56412,\n    64982,\n    57905,\n    49316,\n    21502,\n    52590,\n    14035,\n    8553\n  ]), b = r([\n    26200,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214\n  ]), x = r([\n    41136,\n    18958,\n    6951,\n    50414,\n    58488,\n    44335,\n    6150,\n    12099,\n    55207,\n    15867,\n    153,\n    11085,\n    57099,\n    20417,\n    9344,\n    11139\n  ]);\n  function O(T, A) {\n    for (let N = 0; N < 16; N++)\n      T[N] = A[N] | 0;\n  }\n  function _(T) {\n    let A = 1;\n    for (let N = 0; N < 16; N++) {\n      let h = T[N] + A + 65535;\n      A = Math.floor(h / 65536), T[N] = h - A * 65536;\n    }\n    T[0] += A - 1 + 37 * (A - 1);\n  }\n  function C(T, A, N) {\n    const h = ~(N - 1);\n    for (let S = 0; S < 16; S++) {\n      const W = h & (T[S] ^ A[S]);\n      T[S] ^= W, A[S] ^= W;\n    }\n  }\n  function F(T, A) {\n    const N = r(), h = r();\n    for (let S = 0; S < 16; S++)\n      h[S] = A[S];\n    _(h), _(h), _(h);\n    for (let S = 0; S < 2; S++) {\n      N[0] = h[0] - 65517;\n      for (let X = 1; X < 15; X++)\n        N[X] = h[X] - 65535 - (N[X - 1] >> 16 & 1), N[X - 1] &= 65535;\n      N[15] = h[15] - 32767 - (N[14] >> 16 & 1);\n      const W = N[15] >> 16 & 1;\n      N[14] &= 65535, C(h, N, 1 - W);\n    }\n    for (let S = 0; S < 16; S++)\n      T[2 * S] = h[S] & 255, T[2 * S + 1] = h[S] >> 8;\n  }\n  function K(T, A) {\n    let N = 0;\n    for (let h = 0; h < 32; h++)\n      N |= T[h] ^ A[h];\n    return (1 & N - 1 >>> 8) - 1;\n  }\n  function I(T, A) {\n    const N = new Uint8Array(32), h = new Uint8Array(32);\n    return F(N, T), F(h, A), K(N, h);\n  }\n  function D(T) {\n    const A = new Uint8Array(32);\n    return F(A, T), A[0] & 1;\n  }\n  function y(T, A) {\n    for (let N = 0; N < 16; N++)\n      T[N] = A[2 * N] + (A[2 * N + 1] << 8);\n    T[15] &= 32767;\n  }\n  function w(T, A, N) {\n    for (let h = 0; h < 16; h++)\n      T[h] = A[h] + N[h];\n  }\n  function f(T, A, N) {\n    for (let h = 0; h < 16; h++)\n      T[h] = A[h] - N[h];\n  }\n  function a(T, A, N) {\n    let h, S, W = 0, X = 0, fe = 0, ve = 0, ge = 0, Se = 0, Me = 0, $e = 0, be = 0, ye = 0, pe = 0, le = 0, ue = 0, he = 0, ce = 0, re = 0, de = 0, me = 0, ne = 0, _e = 0, Ee = 0, De = 0, xe = 0, Ie = 0, Ut = 0, qt = 0, si = 0, Dt = 0, fi = 0, Ki = 0, Os = 0, qe = N[0], Fe = N[1], je = N[2], ze = N[3], Ke = N[4], Ue = N[5], Qe = N[6], Xe = N[7], Ze = N[8], et = N[9], tt = N[10], Ye = N[11], Ve = N[12], Ae = N[13], it = N[14], st = N[15];\n    h = A[0], W += h * qe, X += h * Fe, fe += h * je, ve += h * ze, ge += h * Ke, Se += h * Ue, Me += h * Qe, $e += h * Xe, be += h * Ze, ye += h * et, pe += h * tt, le += h * Ye, ue += h * Ve, he += h * Ae, ce += h * it, re += h * st, h = A[1], X += h * qe, fe += h * Fe, ve += h * je, ge += h * ze, Se += h * Ke, Me += h * Ue, $e += h * Qe, be += h * Xe, ye += h * Ze, pe += h * et, le += h * tt, ue += h * Ye, he += h * Ve, ce += h * Ae, re += h * it, de += h * st, h = A[2], fe += h * qe, ve += h * Fe, ge += h * je, Se += h * ze, Me += h * Ke, $e += h * Ue, be += h * Qe, ye += h * Xe, pe += h * Ze, le += h * et, ue += h * tt, he += h * Ye, ce += h * Ve, re += h * Ae, de += h * it, me += h * st, h = A[3], ve += h * qe, ge += h * Fe, Se += h * je, Me += h * ze, $e += h * Ke, be += h * Ue, ye += h * Qe, pe += h * Xe, le += h * Ze, ue += h * et, he += h * tt, ce += h * Ye, re += h * Ve, de += h * Ae, me += h * it, ne += h * st, h = A[4], ge += h * qe, Se += h * Fe, Me += h * je, $e += h * ze, be += h * Ke, ye += h * Ue, pe += h * Qe, le += h * Xe, ue += h * Ze, he += h * et, ce += h * tt, re += h * Ye, de += h * Ve, me += h * Ae, ne += h * it, _e += h * st, h = A[5], Se += h * qe, Me += h * Fe, $e += h * je, be += h * ze, ye += h * Ke, pe += h * Ue, le += h * Qe, ue += h * Xe, he += h * Ze, ce += h * et, re += h * tt, de += h * Ye, me += h * Ve, ne += h * Ae, _e += h * it, Ee += h * st, h = A[6], Me += h * qe, $e += h * Fe, be += h * je, ye += h * ze, pe += h * Ke, le += h * Ue, ue += h * Qe, he += h * Xe, ce += h * Ze, re += h * et, de += h * tt, me += h * Ye, ne += h * Ve, _e += h * Ae, Ee += h * it, De += h * st, h = A[7], $e += h * qe, be += h * Fe, ye += h * je, pe += h * ze, le += h * Ke, ue += h * Ue, he += h * Qe, ce += h * Xe, re += h * Ze, de += h * et, me += h * tt, ne += h * Ye, _e += h * Ve, Ee += h * Ae, De += h * it, xe += h * st, h = A[8], be += h * qe, ye += h * Fe, pe += h * je, le += h * ze, ue += h * Ke, he += h * Ue, ce += h * Qe, re += h * Xe, de += h * Ze, me += h * et, ne += h * tt, _e += h * Ye, Ee += h * Ve, De += h * Ae, xe += h * it, Ie += h * st, h = A[9], ye += h * qe, pe += h * Fe, le += h * je, ue += h * ze, he += h * Ke, ce += h * Ue, re += h * Qe, de += h * Xe, me += h * Ze, ne += h * et, _e += h * tt, Ee += h * Ye, De += h * Ve, xe += h * Ae, Ie += h * it, Ut += h * st, h = A[10], pe += h * qe, le += h * Fe, ue += h * je, he += h * ze, ce += h * Ke, re += h * Ue, de += h * Qe, me += h * Xe, ne += h * Ze, _e += h * et, Ee += h * tt, De += h * Ye, xe += h * Ve, Ie += h * Ae, Ut += h * it, qt += h * st, h = A[11], le += h * qe, ue += h * Fe, he += h * je, ce += h * ze, re += h * Ke, de += h * Ue, me += h * Qe, ne += h * Xe, _e += h * Ze, Ee += h * et, De += h * tt, xe += h * Ye, Ie += h * Ve, Ut += h * Ae, qt += h * it, si += h * st, h = A[12], ue += h * qe, he += h * Fe, ce += h * je, re += h * ze, de += h * Ke, me += h * Ue, ne += h * Qe, _e += h * Xe, Ee += h * Ze, De += h * et, xe += h * tt, Ie += h * Ye, Ut += h * Ve, qt += h * Ae, si += h * it, Dt += h * st, h = A[13], he += h * qe, ce += h * Fe, re += h * je, de += h * ze, me += h * Ke, ne += h * Ue, _e += h * Qe, Ee += h * Xe, De += h * Ze, xe += h * et, Ie += h * tt, Ut += h * Ye, qt += h * Ve, si += h * Ae, Dt += h * it, fi += h * st, h = A[14], ce += h * qe, re += h * Fe, de += h * je, me += h * ze, ne += h * Ke, _e += h * Ue, Ee += h * Qe, De += h * Xe, xe += h * Ze, Ie += h * et, Ut += h * tt, qt += h * Ye, si += h * Ve, Dt += h * Ae, fi += h * it, Ki += h * st, h = A[15], re += h * qe, de += h * Fe, me += h * je, ne += h * ze, _e += h * Ke, Ee += h * Ue, De += h * Qe, xe += h * Xe, Ie += h * Ze, Ut += h * et, qt += h * tt, si += h * Ye, Dt += h * Ve, fi += h * Ae, Ki += h * it, Os += h * st, W += 38 * de, X += 38 * me, fe += 38 * ne, ve += 38 * _e, ge += 38 * Ee, Se += 38 * De, Me += 38 * xe, $e += 38 * Ie, be += 38 * Ut, ye += 38 * qt, pe += 38 * si, le += 38 * Dt, ue += 38 * fi, he += 38 * Ki, ce += 38 * Os, S = 1, h = W + S + 65535, S = Math.floor(h / 65536), W = h - S * 65536, h = X + S + 65535, S = Math.floor(h / 65536), X = h - S * 65536, h = fe + S + 65535, S = Math.floor(h / 65536), fe = h - S * 65536, h = ve + S + 65535, S = Math.floor(h / 65536), ve = h - S * 65536, h = ge + S + 65535, S = Math.floor(h / 65536), ge = h - S * 65536, h = Se + S + 65535, S = Math.floor(h / 65536), Se = h - S * 65536, h = Me + S + 65535, S = Math.floor(h / 65536), Me = h - S * 65536, h = $e + S + 65535, S = Math.floor(h / 65536), $e = h - S * 65536, h = be + S + 65535, S = Math.floor(h / 65536), be = h - S * 65536, h = ye + S + 65535, S = Math.floor(h / 65536), ye = h - S * 65536, h = pe + S + 65535, S = Math.floor(h / 65536), pe = h - S * 65536, h = le + S + 65535, S = Math.floor(h / 65536), le = h - S * 65536, h = ue + S + 65535, S = Math.floor(h / 65536), ue = h - S * 65536, h = he + S + 65535, S = Math.floor(h / 65536), he = h - S * 65536, h = ce + S + 65535, S = Math.floor(h / 65536), ce = h - S * 65536, h = re + S + 65535, S = Math.floor(h / 65536), re = h - S * 65536, W += S - 1 + 37 * (S - 1), S = 1, h = W + S + 65535, S = Math.floor(h / 65536), W = h - S * 65536, h = X + S + 65535, S = Math.floor(h / 65536), X = h - S * 65536, h = fe + S + 65535, S = Math.floor(h / 65536), fe = h - S * 65536, h = ve + S + 65535, S = Math.floor(h / 65536), ve = h - S * 65536, h = ge + S + 65535, S = Math.floor(h / 65536), ge = h - S * 65536, h = Se + S + 65535, S = Math.floor(h / 65536), Se = h - S * 65536, h = Me + S + 65535, S = Math.floor(h / 65536), Me = h - S * 65536, h = $e + S + 65535, S = Math.floor(h / 65536), $e = h - S * 65536, h = be + S + 65535, S = Math.floor(h / 65536), be = h - S * 65536, h = ye + S + 65535, S = Math.floor(h / 65536), ye = h - S * 65536, h = pe + S + 65535, S = Math.floor(h / 65536), pe = h - S * 65536, h = le + S + 65535, S = Math.floor(h / 65536), le = h - S * 65536, h = ue + S + 65535, S = Math.floor(h / 65536), ue = h - S * 65536, h = he + S + 65535, S = Math.floor(h / 65536), he = h - S * 65536, h = ce + S + 65535, S = Math.floor(h / 65536), ce = h - S * 65536, h = re + S + 65535, S = Math.floor(h / 65536), re = h - S * 65536, W += S - 1 + 37 * (S - 1), T[0] = W, T[1] = X, T[2] = fe, T[3] = ve, T[4] = ge, T[5] = Se, T[6] = Me, T[7] = $e, T[8] = be, T[9] = ye, T[10] = pe, T[11] = le, T[12] = ue, T[13] = he, T[14] = ce, T[15] = re;\n  }\n  function l(T, A) {\n    a(T, A, A);\n  }\n  function L(T, A) {\n    const N = r();\n    let h;\n    for (h = 0; h < 16; h++)\n      N[h] = A[h];\n    for (h = 253; h >= 0; h--)\n      l(N, N), h !== 2 && h !== 4 && a(N, N, A);\n    for (h = 0; h < 16; h++)\n      T[h] = N[h];\n  }\n  function v(T, A) {\n    const N = r();\n    let h;\n    for (h = 0; h < 16; h++)\n      N[h] = A[h];\n    for (h = 250; h >= 0; h--)\n      l(N, N), h !== 1 && a(N, N, A);\n    for (h = 0; h < 16; h++)\n      T[h] = N[h];\n  }\n  function R(T, A) {\n    const N = r(), h = r(), S = r(), W = r(), X = r(), fe = r(), ve = r(), ge = r(), Se = r();\n    f(N, T[1], T[0]), f(Se, A[1], A[0]), a(N, N, Se), w(h, T[0], T[1]), w(Se, A[0], A[1]), a(h, h, Se), a(S, T[3], A[3]), a(S, S, d), a(W, T[2], A[2]), w(W, W, W), f(X, h, N), f(fe, W, S), w(ve, W, S), w(ge, h, N), a(T[0], X, fe), a(T[1], ge, ve), a(T[2], ve, fe), a(T[3], X, ge);\n  }\n  function $(T, A, N) {\n    for (let h = 0; h < 4; h++)\n      C(T[h], A[h], N);\n  }\n  function q(T, A) {\n    const N = r(), h = r(), S = r();\n    L(S, A[2]), a(N, A[0], S), a(h, A[1], S), F(T, h), T[31] ^= D(N) << 7;\n  }\n  function m(T, A, N) {\n    O(T[0], o), O(T[1], c), O(T[2], c), O(T[3], o);\n    for (let h = 255; h >= 0; --h) {\n      const S = N[h / 8 | 0] >> (h & 7) & 1;\n      $(T, A, S), R(A, T), R(T, T), $(T, A, S);\n    }\n  }\n  function E(T, A) {\n    const N = [r(), r(), r(), r()];\n    O(N[0], p), O(N[1], b), O(N[2], c), a(N[3], p, b), m(T, N, A);\n  }\n  function B(T) {\n    if (T.length !== i.SEED_LENGTH)\n      throw new Error(`ed25519: seed must be ${i.SEED_LENGTH} bytes`);\n    const A = (0, t.hash)(T);\n    A[0] &= 248, A[31] &= 127, A[31] |= 64;\n    const N = new Uint8Array(32), h = [r(), r(), r(), r()];\n    E(h, A), q(N, h);\n    const S = new Uint8Array(64);\n    return S.set(T), S.set(N, 32), {\n      publicKey: N,\n      secretKey: S\n    };\n  }\n  i.generateKeyPairFromSeed = B;\n  function z(T) {\n    const A = (0, e.randomBytes)(32, T), N = B(A);\n    return (0, s.wipe)(A), N;\n  }\n  i.generateKeyPair = z;\n  function j(T) {\n    if (T.length !== i.SECRET_KEY_LENGTH)\n      throw new Error(`ed25519: secret key must be ${i.SECRET_KEY_LENGTH} bytes`);\n    return new Uint8Array(T.subarray(32));\n  }\n  i.extractPublicKeyFromSecretKey = j;\n  const U = new Float64Array([\n    237,\n    211,\n    245,\n    92,\n    26,\n    99,\n    18,\n    88,\n    214,\n    156,\n    247,\n    162,\n    222,\n    249,\n    222,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    16\n  ]);\n  function M(T, A) {\n    let N, h, S, W;\n    for (h = 63; h >= 32; --h) {\n      for (N = 0, S = h - 32, W = h - 12; S < W; ++S)\n        A[S] += N - 16 * A[h] * U[S - (h - 32)], N = Math.floor((A[S] + 128) / 256), A[S] -= N * 256;\n      A[S] += N, A[h] = 0;\n    }\n    for (N = 0, S = 0; S < 32; S++)\n      A[S] += N - (A[31] >> 4) * U[S], N = A[S] >> 8, A[S] &= 255;\n    for (S = 0; S < 32; S++)\n      A[S] -= N * U[S];\n    for (h = 0; h < 32; h++)\n      A[h + 1] += A[h] >> 8, T[h] = A[h] & 255;\n  }\n  function H(T) {\n    const A = new Float64Array(64);\n    for (let N = 0; N < 64; N++)\n      A[N] = T[N];\n    for (let N = 0; N < 64; N++)\n      T[N] = 0;\n    M(T, A);\n  }\n  function te(T, A) {\n    const N = new Float64Array(64), h = [r(), r(), r(), r()], S = (0, t.hash)(T.subarray(0, 32));\n    S[0] &= 248, S[31] &= 127, S[31] |= 64;\n    const W = new Uint8Array(64);\n    W.set(S.subarray(32), 32);\n    const X = new t.SHA512();\n    X.update(W.subarray(32)), X.update(A);\n    const fe = X.digest();\n    X.clean(), H(fe), E(h, fe), q(W, h), X.reset(), X.update(W.subarray(0, 32)), X.update(T.subarray(32)), X.update(A);\n    const ve = X.digest();\n    H(ve);\n    for (let ge = 0; ge < 32; ge++)\n      N[ge] = fe[ge];\n    for (let ge = 0; ge < 32; ge++)\n      for (let Se = 0; Se < 32; Se++)\n        N[ge + Se] += ve[ge] * S[Se];\n    return M(W.subarray(32), N), W;\n  }\n  i.sign = te;\n  function G(T, A) {\n    const N = r(), h = r(), S = r(), W = r(), X = r(), fe = r(), ve = r();\n    return O(T[2], c), y(T[1], A), l(S, T[1]), a(W, S, u), f(S, S, T[2]), w(W, T[2], W), l(X, W), l(fe, X), a(ve, fe, X), a(N, ve, S), a(N, N, W), v(N, N), a(N, N, S), a(N, N, W), a(N, N, W), a(T[0], N, W), l(h, T[0]), a(h, h, W), I(h, S) && a(T[0], T[0], x), l(h, T[0]), a(h, h, W), I(h, S) ? -1 : (D(T[0]) === A[31] >> 7 && f(T[0], o, T[0]), a(T[3], T[0], T[1]), 0);\n  }\n  function ie(T, A, N) {\n    const h = new Uint8Array(32), S = [r(), r(), r(), r()], W = [r(), r(), r(), r()];\n    if (N.length !== i.SIGNATURE_LENGTH)\n      throw new Error(`ed25519: signature must be ${i.SIGNATURE_LENGTH} bytes`);\n    if (G(W, T))\n      return !1;\n    const X = new t.SHA512();\n    X.update(N.subarray(0, 32)), X.update(T), X.update(A);\n    const fe = X.digest();\n    return H(fe), m(S, W, fe), E(W, N.subarray(32)), R(S, W), q(h, S), !K(N, h);\n  }\n  i.verify = ie;\n  function Q(T) {\n    let A = [r(), r(), r(), r()];\n    if (G(A, T))\n      throw new Error(\"Ed25519: invalid public key\");\n    let N = r(), h = r(), S = A[1];\n    w(N, c, S), f(h, c, S), L(h, h), a(N, N, h);\n    let W = new Uint8Array(32);\n    return F(W, N), W;\n  }\n  i.convertPublicKeyToX25519 = Q;\n  function se(T) {\n    const A = (0, t.hash)(T.subarray(0, 32));\n    A[0] &= 248, A[31] &= 127, A[31] |= 64;\n    const N = new Uint8Array(A.subarray(0, 32));\n    return (0, s.wipe)(A), N;\n  }\n  i.convertSecretKeyToX25519 = se;\n})(nn);\nconst sd = \"EdDSA\", rd = \"JWT\", mc = \".\", bc = \"base64url\", nd = \"utf8\", od = \"utf8\", ad = \":\", cd = \"did\", hd = \"key\", mo = \"base58btc\", ud = \"z\", ld = \"K36\", dd = 32;\nfunction on(i) {\n  return globalThis.Buffer != null ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : i;\n}\nfunction wc(i = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? on(globalThis.Buffer.allocUnsafe(i)) : new Uint8Array(i);\n}\nfunction ls(i, e) {\n  e || (e = i.reduce((r, n) => r + n.length, 0));\n  const t = wc(e);\n  let s = 0;\n  for (const r of i)\n    t.set(r, s), s += r.length;\n  return on(t);\n}\nfunction fd(i, e) {\n  if (i.length >= 255)\n    throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), s = 0; s < t.length; s++)\n    t[s] = 255;\n  for (var r = 0; r < i.length; r++) {\n    var n = i.charAt(r), o = n.charCodeAt(0);\n    if (t[o] !== 255)\n      throw new TypeError(n + \" is ambiguous\");\n    t[o] = r;\n  }\n  var c = i.length, u = i.charAt(0), d = Math.log(c) / Math.log(256), p = Math.log(256) / Math.log(c);\n  function b(_) {\n    if (_ instanceof Uint8Array || (ArrayBuffer.isView(_) ? _ = new Uint8Array(_.buffer, _.byteOffset, _.byteLength) : Array.isArray(_) && (_ = Uint8Array.from(_))), !(_ instanceof Uint8Array))\n      throw new TypeError(\"Expected Uint8Array\");\n    if (_.length === 0)\n      return \"\";\n    for (var C = 0, F = 0, K = 0, I = _.length; K !== I && _[K] === 0; )\n      K++, C++;\n    for (var D = (I - K) * p + 1 >>> 0, y = new Uint8Array(D); K !== I; ) {\n      for (var w = _[K], f = 0, a = D - 1; (w !== 0 || f < F) && a !== -1; a--, f++)\n        w += 256 * y[a] >>> 0, y[a] = w % c >>> 0, w = w / c >>> 0;\n      if (w !== 0)\n        throw new Error(\"Non-zero carry\");\n      F = f, K++;\n    }\n    for (var l = D - F; l !== D && y[l] === 0; )\n      l++;\n    for (var L = u.repeat(C); l < D; ++l)\n      L += i.charAt(y[l]);\n    return L;\n  }\n  function x(_) {\n    if (typeof _ != \"string\")\n      throw new TypeError(\"Expected String\");\n    if (_.length === 0)\n      return new Uint8Array();\n    var C = 0;\n    if (_[C] !== \" \") {\n      for (var F = 0, K = 0; _[C] === u; )\n        F++, C++;\n      for (var I = (_.length - C) * d + 1 >>> 0, D = new Uint8Array(I); _[C]; ) {\n        var y = t[_.charCodeAt(C)];\n        if (y === 255)\n          return;\n        for (var w = 0, f = I - 1; (y !== 0 || w < K) && f !== -1; f--, w++)\n          y += c * D[f] >>> 0, D[f] = y % 256 >>> 0, y = y / 256 >>> 0;\n        if (y !== 0)\n          throw new Error(\"Non-zero carry\");\n        K = w, C++;\n      }\n      if (_[C] !== \" \") {\n        for (var a = I - K; a !== I && D[a] === 0; )\n          a++;\n        for (var l = new Uint8Array(F + (I - a)), L = F; a !== I; )\n          l[L++] = D[a++];\n        return l;\n      }\n    }\n  }\n  function O(_) {\n    var C = x(_);\n    if (C)\n      return C;\n    throw new Error(`Non-${e} character`);\n  }\n  return {\n    encode: b,\n    decodeUnsafe: x,\n    decode: O\n  };\n}\nvar pd = fd, gd = pd;\nconst yd = (i) => {\n  if (i instanceof Uint8Array && i.constructor.name === \"Uint8Array\")\n    return i;\n  if (i instanceof ArrayBuffer)\n    return new Uint8Array(i);\n  if (ArrayBuffer.isView(i))\n    return new Uint8Array(i.buffer, i.byteOffset, i.byteLength);\n  throw new Error(\"Unknown type, must be binary type\");\n}, md = (i) => new TextEncoder().encode(i), bd = (i) => new TextDecoder().decode(i);\nclass wd {\n  constructor(e, t, s) {\n    this.name = e, this.prefix = t, this.baseEncode = s;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array)\n      return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass vd {\n  constructor(e, t, s) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)\n      throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint)\n        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else\n      throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return vc(this, e);\n  }\n}\nclass _d {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return vc(this, e);\n  }\n  decode(e) {\n    const t = e[0], s = this.decoders[t];\n    if (s)\n      return s.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst vc = (i, e) => new _d({\n  ...i.decoders || { [i.prefix]: i },\n  ...e.decoders || { [e.prefix]: e }\n});\nclass Ed {\n  constructor(e, t, s, r) {\n    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = r, this.encoder = new wd(e, t, s), this.decoder = new vd(e, t, r);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst cr = ({ name: i, prefix: e, encode: t, decode: s }) => new Ed(i, e, t, s), ps = ({ prefix: i, name: e, alphabet: t }) => {\n  const { encode: s, decode: r } = gd(t, e);\n  return cr({\n    prefix: i,\n    name: e,\n    encode: s,\n    decode: (n) => yd(r(n))\n  });\n}, Sd = (i, e, t, s) => {\n  const r = {};\n  for (let p = 0; p < e.length; ++p)\n    r[e[p]] = p;\n  let n = i.length;\n  for (; i[n - 1] === \"=\"; )\n    --n;\n  const o = new Uint8Array(n * t / 8 | 0);\n  let c = 0, u = 0, d = 0;\n  for (let p = 0; p < n; ++p) {\n    const b = r[i[p]];\n    if (b === void 0)\n      throw new SyntaxError(`Non-${s} character`);\n    u = u << t | b, c += t, c >= 8 && (c -= 8, o[d++] = 255 & u >> c);\n  }\n  if (c >= t || 255 & u << 8 - c)\n    throw new SyntaxError(\"Unexpected end of data\");\n  return o;\n}, Id = (i, e, t) => {\n  const s = e[e.length - 1] === \"=\", r = (1 << t) - 1;\n  let n = \"\", o = 0, c = 0;\n  for (let u = 0; u < i.length; ++u)\n    for (c = c << 8 | i[u], o += 8; o > t; )\n      o -= t, n += e[r & c >> o];\n  if (o && (n += e[r & c << t - o]), s)\n    for (; n.length * t & 7; )\n      n += \"=\";\n  return n;\n}, ut = ({ name: i, prefix: e, bitsPerChar: t, alphabet: s }) => cr({\n  prefix: e,\n  name: i,\n  encode(r) {\n    return Id(r, s, t);\n  },\n  decode(r) {\n    return Sd(r, s, t, i);\n  }\n}), Dd = cr({\n  prefix: \"\\0\",\n  name: \"identity\",\n  encode: (i) => bd(i),\n  decode: (i) => md(i)\n}), xd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  identity: Dd\n}, Symbol.toStringTag, { value: \"Module\" })), Od = ut({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n}), Nd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base2: Od\n}, Symbol.toStringTag, { value: \"Module\" })), Pd = ut({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n}), Rd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base8: Pd\n}, Symbol.toStringTag, { value: \"Module\" })), Cd = ps({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n}), Ad = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base10: Cd\n}, Symbol.toStringTag, { value: \"Module\" })), Td = ut({\n  prefix: \"f\",\n  name: \"base16\",\n  alphabet: \"0123456789abcdef\",\n  bitsPerChar: 4\n}), $d = ut({\n  prefix: \"F\",\n  name: \"base16upper\",\n  alphabet: \"0123456789ABCDEF\",\n  bitsPerChar: 4\n}), Fd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base16: Td,\n  base16upper: $d\n}, Symbol.toStringTag, { value: \"Module\" })), Ud = ut({\n  prefix: \"b\",\n  name: \"base32\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n  bitsPerChar: 5\n}), Ld = ut({\n  prefix: \"B\",\n  name: \"base32upper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  bitsPerChar: 5\n}), Md = ut({\n  prefix: \"c\",\n  name: \"base32pad\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n  bitsPerChar: 5\n}), qd = ut({\n  prefix: \"C\",\n  name: \"base32padupper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n  bitsPerChar: 5\n}), jd = ut({\n  prefix: \"v\",\n  name: \"base32hex\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n  bitsPerChar: 5\n}), zd = ut({\n  prefix: \"V\",\n  name: \"base32hexupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  bitsPerChar: 5\n}), Kd = ut({\n  prefix: \"t\",\n  name: \"base32hexpad\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n  bitsPerChar: 5\n}), Vd = ut({\n  prefix: \"T\",\n  name: \"base32hexpadupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n  bitsPerChar: 5\n}), Bd = ut({\n  prefix: \"h\",\n  name: \"base32z\",\n  alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n  bitsPerChar: 5\n}), kd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base32: Ud,\n  base32hex: jd,\n  base32hexpad: Kd,\n  base32hexpadupper: Vd,\n  base32hexupper: zd,\n  base32pad: Md,\n  base32padupper: qd,\n  base32upper: Ld,\n  base32z: Bd\n}, Symbol.toStringTag, { value: \"Module\" })), Hd = ps({\n  prefix: \"k\",\n  name: \"base36\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n}), Gd = ps({\n  prefix: \"K\",\n  name: \"base36upper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n}), Wd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base36: Hd,\n  base36upper: Gd\n}, Symbol.toStringTag, { value: \"Module\" })), Yd = ps({\n  name: \"base58btc\",\n  prefix: \"z\",\n  alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n}), Jd = ps({\n  name: \"base58flickr\",\n  prefix: \"Z\",\n  alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n}), Qd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base58btc: Yd,\n  base58flickr: Jd\n}, Symbol.toStringTag, { value: \"Module\" })), Xd = ut({\n  prefix: \"m\",\n  name: \"base64\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  bitsPerChar: 6\n}), Zd = ut({\n  prefix: \"M\",\n  name: \"base64pad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n  bitsPerChar: 6\n}), ef = ut({\n  prefix: \"u\",\n  name: \"base64url\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n  bitsPerChar: 6\n}), tf = ut({\n  prefix: \"U\",\n  name: \"base64urlpad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n  bitsPerChar: 6\n}), sf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base64: Xd,\n  base64pad: Zd,\n  base64url: ef,\n  base64urlpad: tf\n}, Symbol.toStringTag, { value: \"Module\" })), _c = Array.from(\"🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂\"), rf = _c.reduce((i, e, t) => (i[t] = e, i), []), nf = _c.reduce((i, e, t) => (i[e.codePointAt(0)] = t, i), []);\nfunction of(i) {\n  return i.reduce((e, t) => (e += rf[t], e), \"\");\n}\nfunction af(i) {\n  const e = [];\n  for (const t of i) {\n    const s = nf[t.codePointAt(0)];\n    if (s === void 0)\n      throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(s);\n  }\n  return new Uint8Array(e);\n}\nconst cf = cr({\n  prefix: \"🚀\",\n  name: \"base256emoji\",\n  encode: of,\n  decode: af\n}), hf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base256emoji: cf\n}, Symbol.toStringTag, { value: \"Module\" }));\nnew TextEncoder();\nnew TextDecoder();\nconst bo = {\n  ...xd,\n  ...Nd,\n  ...Rd,\n  ...Ad,\n  ...Fd,\n  ...kd,\n  ...Wd,\n  ...Qd,\n  ...sf,\n  ...hf\n};\nfunction Ec(i, e, t, s) {\n  return {\n    name: i,\n    prefix: e,\n    encoder: {\n      name: i,\n      prefix: e,\n      encode: t\n    },\n    decoder: { decode: s }\n  };\n}\nconst wo = Ec(\"utf8\", \"u\", (i) => \"u\" + new TextDecoder(\"utf8\").decode(i), (i) => new TextEncoder().encode(i.substring(1))), Dr = Ec(\"ascii\", \"a\", (i) => {\n  let e = \"a\";\n  for (let t = 0; t < i.length; t++)\n    e += String.fromCharCode(i[t]);\n  return e;\n}, (i) => {\n  i = i.substring(1);\n  const e = wc(i.length);\n  for (let t = 0; t < i.length; t++)\n    e[t] = i.charCodeAt(t);\n  return e;\n}), Sc = {\n  utf8: wo,\n  \"utf-8\": wo,\n  hex: bo.base16,\n  latin1: Dr,\n  ascii: Dr,\n  binary: Dr,\n  ...bo\n};\nfunction Ne(i, e = \"utf8\") {\n  const t = Sc[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(i.buffer, i.byteOffset, i.byteLength).toString(\"utf8\") : t.encoder.encode(i).substring(1);\n}\nfunction Ce(i, e = \"utf8\") {\n  const t = Sc[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? on(globalThis.Buffer.from(i, \"utf-8\")) : t.decoder.decode(`${t.prefix}${i}`);\n}\nfunction Gs(i) {\n  return Ne(Ce(rr(i), nd), bc);\n}\nfunction an(i) {\n  const e = Ce(ld, mo), t = ud + Ne(ls([e, i]), mo);\n  return [cd, hd, t].join(ad);\n}\nfunction uf(i) {\n  return Ne(i, bc);\n}\nfunction lf(i) {\n  return Ce([Gs(i.header), Gs(i.payload)].join(mc), od);\n}\nfunction df(i) {\n  return [\n    Gs(i.header),\n    Gs(i.payload),\n    uf(i.signature)\n  ].join(mc);\n}\nfunction Ws(i = li.randomBytes(dd)) {\n  return nn.generateKeyPairFromSeed(i);\n}\nasync function Ic(i, e, t, s, r = V.fromMiliseconds(Date.now())) {\n  const n = { alg: sd, typ: rd }, o = an(s.publicKey), c = r + t, u = { iss: o, sub: i, aud: e, iat: r, exp: c }, d = lf({ header: n, payload: u }), p = nn.sign(s.secretKey, d);\n  return df({ header: n, payload: u, signature: p });\n}\nvar gs = {}, hr = {};\nObject.defineProperty(hr, \"__esModule\", { value: !0 });\nvar pt = oe, Kr = Pt, ff = 20;\nfunction pf(i, e, t) {\n  for (var s = 1634760805, r = 857760878, n = 2036477234, o = 1797285236, c = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], u = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], d = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], p = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], b = t[19] << 24 | t[18] << 16 | t[17] << 8 | t[16], x = t[23] << 24 | t[22] << 16 | t[21] << 8 | t[20], O = t[27] << 24 | t[26] << 16 | t[25] << 8 | t[24], _ = t[31] << 24 | t[30] << 16 | t[29] << 8 | t[28], C = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], F = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], K = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], I = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], D = s, y = r, w = n, f = o, a = c, l = u, L = d, v = p, R = b, $ = x, q = O, m = _, E = C, B = F, z = K, j = I, U = 0; U < ff; U += 2)\n    D = D + a | 0, E ^= D, E = E >>> 32 - 16 | E << 16, R = R + E | 0, a ^= R, a = a >>> 32 - 12 | a << 12, y = y + l | 0, B ^= y, B = B >>> 32 - 16 | B << 16, $ = $ + B | 0, l ^= $, l = l >>> 32 - 12 | l << 12, w = w + L | 0, z ^= w, z = z >>> 32 - 16 | z << 16, q = q + z | 0, L ^= q, L = L >>> 32 - 12 | L << 12, f = f + v | 0, j ^= f, j = j >>> 32 - 16 | j << 16, m = m + j | 0, v ^= m, v = v >>> 32 - 12 | v << 12, w = w + L | 0, z ^= w, z = z >>> 32 - 8 | z << 8, q = q + z | 0, L ^= q, L = L >>> 32 - 7 | L << 7, f = f + v | 0, j ^= f, j = j >>> 32 - 8 | j << 8, m = m + j | 0, v ^= m, v = v >>> 32 - 7 | v << 7, y = y + l | 0, B ^= y, B = B >>> 32 - 8 | B << 8, $ = $ + B | 0, l ^= $, l = l >>> 32 - 7 | l << 7, D = D + a | 0, E ^= D, E = E >>> 32 - 8 | E << 8, R = R + E | 0, a ^= R, a = a >>> 32 - 7 | a << 7, D = D + l | 0, j ^= D, j = j >>> 32 - 16 | j << 16, q = q + j | 0, l ^= q, l = l >>> 32 - 12 | l << 12, y = y + L | 0, E ^= y, E = E >>> 32 - 16 | E << 16, m = m + E | 0, L ^= m, L = L >>> 32 - 12 | L << 12, w = w + v | 0, B ^= w, B = B >>> 32 - 16 | B << 16, R = R + B | 0, v ^= R, v = v >>> 32 - 12 | v << 12, f = f + a | 0, z ^= f, z = z >>> 32 - 16 | z << 16, $ = $ + z | 0, a ^= $, a = a >>> 32 - 12 | a << 12, w = w + v | 0, B ^= w, B = B >>> 32 - 8 | B << 8, R = R + B | 0, v ^= R, v = v >>> 32 - 7 | v << 7, f = f + a | 0, z ^= f, z = z >>> 32 - 8 | z << 8, $ = $ + z | 0, a ^= $, a = a >>> 32 - 7 | a << 7, y = y + L | 0, E ^= y, E = E >>> 32 - 8 | E << 8, m = m + E | 0, L ^= m, L = L >>> 32 - 7 | L << 7, D = D + l | 0, j ^= D, j = j >>> 32 - 8 | j << 8, q = q + j | 0, l ^= q, l = l >>> 32 - 7 | l << 7;\n  pt.writeUint32LE(D + s | 0, i, 0), pt.writeUint32LE(y + r | 0, i, 4), pt.writeUint32LE(w + n | 0, i, 8), pt.writeUint32LE(f + o | 0, i, 12), pt.writeUint32LE(a + c | 0, i, 16), pt.writeUint32LE(l + u | 0, i, 20), pt.writeUint32LE(L + d | 0, i, 24), pt.writeUint32LE(v + p | 0, i, 28), pt.writeUint32LE(R + b | 0, i, 32), pt.writeUint32LE($ + x | 0, i, 36), pt.writeUint32LE(q + O | 0, i, 40), pt.writeUint32LE(m + _ | 0, i, 44), pt.writeUint32LE(E + C | 0, i, 48), pt.writeUint32LE(B + F | 0, i, 52), pt.writeUint32LE(z + K | 0, i, 56), pt.writeUint32LE(j + I | 0, i, 60);\n}\nfunction Dc(i, e, t, s, r) {\n  if (r === void 0 && (r = 0), i.length !== 32)\n    throw new Error(\"ChaCha: key size must be 32 bytes\");\n  if (s.length < t.length)\n    throw new Error(\"ChaCha: destination is shorter than source\");\n  var n, o;\n  if (r === 0) {\n    if (e.length !== 8 && e.length !== 12)\n      throw new Error(\"ChaCha nonce must be 8 or 12 bytes\");\n    n = new Uint8Array(16), o = n.length - e.length, n.set(e, o);\n  } else {\n    if (e.length !== 16)\n      throw new Error(\"ChaCha nonce with counter must be 16 bytes\");\n    n = e, o = r;\n  }\n  for (var c = new Uint8Array(64), u = 0; u < t.length; u += 64) {\n    pf(c, n, i);\n    for (var d = u; d < u + 64 && d < t.length; d++)\n      s[d] = t[d] ^ c[d - u];\n    yf(n, 0, o);\n  }\n  return Kr.wipe(c), r === 0 && Kr.wipe(n), s;\n}\nhr.streamXOR = Dc;\nfunction gf(i, e, t, s) {\n  return s === void 0 && (s = 0), Kr.wipe(t), Dc(i, e, t, t, s);\n}\nhr.stream = gf;\nfunction yf(i, e, t) {\n  for (var s = 1; t--; )\n    s = s + (i[e] & 255) | 0, i[e] = s & 255, s >>>= 8, e++;\n  if (s > 0)\n    throw new Error(\"ChaCha: counter overflow\");\n}\nvar xc = {}, di = {};\nObject.defineProperty(di, \"__esModule\", { value: !0 });\nfunction mf(i, e, t) {\n  return ~(i - 1) & e | i - 1 & t;\n}\ndi.select = mf;\nfunction bf(i, e) {\n  return (i | 0) - (e | 0) - 1 >>> 31 & 1;\n}\ndi.lessOrEqual = bf;\nfunction Oc(i, e) {\n  if (i.length !== e.length)\n    return 0;\n  for (var t = 0, s = 0; s < i.length; s++)\n    t |= i[s] ^ e[s];\n  return 1 & t - 1 >>> 8;\n}\ndi.compare = Oc;\nfunction wf(i, e) {\n  return i.length === 0 || e.length === 0 ? !1 : Oc(i, e) !== 0;\n}\ndi.equal = wf;\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  var e = di, t = Pt;\n  i.DIGEST_LENGTH = 16;\n  var s = (\n    /** @class */\n    function() {\n      function o(c) {\n        this.digestLength = i.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;\n        var u = c[0] | c[1] << 8;\n        this._r[0] = u & 8191;\n        var d = c[2] | c[3] << 8;\n        this._r[1] = (u >>> 13 | d << 3) & 8191;\n        var p = c[4] | c[5] << 8;\n        this._r[2] = (d >>> 10 | p << 6) & 7939;\n        var b = c[6] | c[7] << 8;\n        this._r[3] = (p >>> 7 | b << 9) & 8191;\n        var x = c[8] | c[9] << 8;\n        this._r[4] = (b >>> 4 | x << 12) & 255, this._r[5] = x >>> 1 & 8190;\n        var O = c[10] | c[11] << 8;\n        this._r[6] = (x >>> 14 | O << 2) & 8191;\n        var _ = c[12] | c[13] << 8;\n        this._r[7] = (O >>> 11 | _ << 5) & 8065;\n        var C = c[14] | c[15] << 8;\n        this._r[8] = (_ >>> 8 | C << 8) & 8191, this._r[9] = C >>> 5 & 127, this._pad[0] = c[16] | c[17] << 8, this._pad[1] = c[18] | c[19] << 8, this._pad[2] = c[20] | c[21] << 8, this._pad[3] = c[22] | c[23] << 8, this._pad[4] = c[24] | c[25] << 8, this._pad[5] = c[26] | c[27] << 8, this._pad[6] = c[28] | c[29] << 8, this._pad[7] = c[30] | c[31] << 8;\n      }\n      return o.prototype._blocks = function(c, u, d) {\n        for (var p = this._fin ? 0 : 2048, b = this._h[0], x = this._h[1], O = this._h[2], _ = this._h[3], C = this._h[4], F = this._h[5], K = this._h[6], I = this._h[7], D = this._h[8], y = this._h[9], w = this._r[0], f = this._r[1], a = this._r[2], l = this._r[3], L = this._r[4], v = this._r[5], R = this._r[6], $ = this._r[7], q = this._r[8], m = this._r[9]; d >= 16; ) {\n          var E = c[u + 0] | c[u + 1] << 8;\n          b += E & 8191;\n          var B = c[u + 2] | c[u + 3] << 8;\n          x += (E >>> 13 | B << 3) & 8191;\n          var z = c[u + 4] | c[u + 5] << 8;\n          O += (B >>> 10 | z << 6) & 8191;\n          var j = c[u + 6] | c[u + 7] << 8;\n          _ += (z >>> 7 | j << 9) & 8191;\n          var U = c[u + 8] | c[u + 9] << 8;\n          C += (j >>> 4 | U << 12) & 8191, F += U >>> 1 & 8191;\n          var M = c[u + 10] | c[u + 11] << 8;\n          K += (U >>> 14 | M << 2) & 8191;\n          var H = c[u + 12] | c[u + 13] << 8;\n          I += (M >>> 11 | H << 5) & 8191;\n          var te = c[u + 14] | c[u + 15] << 8;\n          D += (H >>> 8 | te << 8) & 8191, y += te >>> 5 | p;\n          var G = 0, ie = G;\n          ie += b * w, ie += x * (5 * m), ie += O * (5 * q), ie += _ * (5 * $), ie += C * (5 * R), G = ie >>> 13, ie &= 8191, ie += F * (5 * v), ie += K * (5 * L), ie += I * (5 * l), ie += D * (5 * a), ie += y * (5 * f), G += ie >>> 13, ie &= 8191;\n          var Q = G;\n          Q += b * f, Q += x * w, Q += O * (5 * m), Q += _ * (5 * q), Q += C * (5 * $), G = Q >>> 13, Q &= 8191, Q += F * (5 * R), Q += K * (5 * v), Q += I * (5 * L), Q += D * (5 * l), Q += y * (5 * a), G += Q >>> 13, Q &= 8191;\n          var se = G;\n          se += b * a, se += x * f, se += O * w, se += _ * (5 * m), se += C * (5 * q), G = se >>> 13, se &= 8191, se += F * (5 * $), se += K * (5 * R), se += I * (5 * v), se += D * (5 * L), se += y * (5 * l), G += se >>> 13, se &= 8191;\n          var T = G;\n          T += b * l, T += x * a, T += O * f, T += _ * w, T += C * (5 * m), G = T >>> 13, T &= 8191, T += F * (5 * q), T += K * (5 * $), T += I * (5 * R), T += D * (5 * v), T += y * (5 * L), G += T >>> 13, T &= 8191;\n          var A = G;\n          A += b * L, A += x * l, A += O * a, A += _ * f, A += C * w, G = A >>> 13, A &= 8191, A += F * (5 * m), A += K * (5 * q), A += I * (5 * $), A += D * (5 * R), A += y * (5 * v), G += A >>> 13, A &= 8191;\n          var N = G;\n          N += b * v, N += x * L, N += O * l, N += _ * a, N += C * f, G = N >>> 13, N &= 8191, N += F * w, N += K * (5 * m), N += I * (5 * q), N += D * (5 * $), N += y * (5 * R), G += N >>> 13, N &= 8191;\n          var h = G;\n          h += b * R, h += x * v, h += O * L, h += _ * l, h += C * a, G = h >>> 13, h &= 8191, h += F * f, h += K * w, h += I * (5 * m), h += D * (5 * q), h += y * (5 * $), G += h >>> 13, h &= 8191;\n          var S = G;\n          S += b * $, S += x * R, S += O * v, S += _ * L, S += C * l, G = S >>> 13, S &= 8191, S += F * a, S += K * f, S += I * w, S += D * (5 * m), S += y * (5 * q), G += S >>> 13, S &= 8191;\n          var W = G;\n          W += b * q, W += x * $, W += O * R, W += _ * v, W += C * L, G = W >>> 13, W &= 8191, W += F * l, W += K * a, W += I * f, W += D * w, W += y * (5 * m), G += W >>> 13, W &= 8191;\n          var X = G;\n          X += b * m, X += x * q, X += O * $, X += _ * R, X += C * v, G = X >>> 13, X &= 8191, X += F * L, X += K * l, X += I * a, X += D * f, X += y * w, G += X >>> 13, X &= 8191, G = (G << 2) + G | 0, G = G + ie | 0, ie = G & 8191, G = G >>> 13, Q += G, b = ie, x = Q, O = se, _ = T, C = A, F = N, K = h, I = S, D = W, y = X, u += 16, d -= 16;\n        }\n        this._h[0] = b, this._h[1] = x, this._h[2] = O, this._h[3] = _, this._h[4] = C, this._h[5] = F, this._h[6] = K, this._h[7] = I, this._h[8] = D, this._h[9] = y;\n      }, o.prototype.finish = function(c, u) {\n        u === void 0 && (u = 0);\n        var d = new Uint16Array(10), p, b, x, O;\n        if (this._leftover) {\n          for (O = this._leftover, this._buffer[O++] = 1; O < 16; O++)\n            this._buffer[O] = 0;\n          this._fin = 1, this._blocks(this._buffer, 0, 16);\n        }\n        for (p = this._h[1] >>> 13, this._h[1] &= 8191, O = 2; O < 10; O++)\n          this._h[O] += p, p = this._h[O] >>> 13, this._h[O] &= 8191;\n        for (this._h[0] += p * 5, p = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += p, p = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += p, d[0] = this._h[0] + 5, p = d[0] >>> 13, d[0] &= 8191, O = 1; O < 10; O++)\n          d[O] = this._h[O] + p, p = d[O] >>> 13, d[O] &= 8191;\n        for (d[9] -= 8192, b = (p ^ 1) - 1, O = 0; O < 10; O++)\n          d[O] &= b;\n        for (b = ~b, O = 0; O < 10; O++)\n          this._h[O] = this._h[O] & b | d[O];\n        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, x = this._h[0] + this._pad[0], this._h[0] = x & 65535, O = 1; O < 8; O++)\n          x = (this._h[O] + this._pad[O] | 0) + (x >>> 16) | 0, this._h[O] = x & 65535;\n        return c[u + 0] = this._h[0] >>> 0, c[u + 1] = this._h[0] >>> 8, c[u + 2] = this._h[1] >>> 0, c[u + 3] = this._h[1] >>> 8, c[u + 4] = this._h[2] >>> 0, c[u + 5] = this._h[2] >>> 8, c[u + 6] = this._h[3] >>> 0, c[u + 7] = this._h[3] >>> 8, c[u + 8] = this._h[4] >>> 0, c[u + 9] = this._h[4] >>> 8, c[u + 10] = this._h[5] >>> 0, c[u + 11] = this._h[5] >>> 8, c[u + 12] = this._h[6] >>> 0, c[u + 13] = this._h[6] >>> 8, c[u + 14] = this._h[7] >>> 0, c[u + 15] = this._h[7] >>> 8, this._finished = !0, this;\n      }, o.prototype.update = function(c) {\n        var u = 0, d = c.length, p;\n        if (this._leftover) {\n          p = 16 - this._leftover, p > d && (p = d);\n          for (var b = 0; b < p; b++)\n            this._buffer[this._leftover + b] = c[u + b];\n          if (d -= p, u += p, this._leftover += p, this._leftover < 16)\n            return this;\n          this._blocks(this._buffer, 0, 16), this._leftover = 0;\n        }\n        if (d >= 16 && (p = d - d % 16, this._blocks(c, u, p), u += p, d -= p), d) {\n          for (var b = 0; b < d; b++)\n            this._buffer[this._leftover + b] = c[u + b];\n          this._leftover += d;\n        }\n        return this;\n      }, o.prototype.digest = function() {\n        if (this._finished)\n          throw new Error(\"Poly1305 was finished\");\n        var c = new Uint8Array(16);\n        return this.finish(c), c;\n      }, o.prototype.clean = function() {\n        return t.wipe(this._buffer), t.wipe(this._r), t.wipe(this._h), t.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;\n      }, o;\n    }()\n  );\n  i.Poly1305 = s;\n  function r(o, c) {\n    var u = new s(o);\n    u.update(c);\n    var d = u.digest();\n    return u.clean(), d;\n  }\n  i.oneTimeAuth = r;\n  function n(o, c) {\n    return o.length !== i.DIGEST_LENGTH || c.length !== i.DIGEST_LENGTH ? !1 : e.equal(o, c);\n  }\n  i.equal = n;\n})(xc);\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  var e = hr, t = xc, s = Pt, r = oe, n = di;\n  i.KEY_LENGTH = 32, i.NONCE_LENGTH = 12, i.TAG_LENGTH = 16;\n  var o = new Uint8Array(16), c = (\n    /** @class */\n    function() {\n      function u(d) {\n        if (this.nonceLength = i.NONCE_LENGTH, this.tagLength = i.TAG_LENGTH, d.length !== i.KEY_LENGTH)\n          throw new Error(\"ChaCha20Poly1305 needs 32-byte key\");\n        this._key = new Uint8Array(d);\n      }\n      return u.prototype.seal = function(d, p, b, x) {\n        if (d.length > 16)\n          throw new Error(\"ChaCha20Poly1305: incorrect nonce length\");\n        var O = new Uint8Array(16);\n        O.set(d, O.length - d.length);\n        var _ = new Uint8Array(32);\n        e.stream(this._key, O, _, 4);\n        var C = p.length + this.tagLength, F;\n        if (x) {\n          if (x.length !== C)\n            throw new Error(\"ChaCha20Poly1305: incorrect destination length\");\n          F = x;\n        } else\n          F = new Uint8Array(C);\n        return e.streamXOR(this._key, O, p, F, 4), this._authenticate(F.subarray(F.length - this.tagLength, F.length), _, F.subarray(0, F.length - this.tagLength), b), s.wipe(O), F;\n      }, u.prototype.open = function(d, p, b, x) {\n        if (d.length > 16)\n          throw new Error(\"ChaCha20Poly1305: incorrect nonce length\");\n        if (p.length < this.tagLength)\n          return null;\n        var O = new Uint8Array(16);\n        O.set(d, O.length - d.length);\n        var _ = new Uint8Array(32);\n        e.stream(this._key, O, _, 4);\n        var C = new Uint8Array(this.tagLength);\n        if (this._authenticate(C, _, p.subarray(0, p.length - this.tagLength), b), !n.equal(C, p.subarray(p.length - this.tagLength, p.length)))\n          return null;\n        var F = p.length - this.tagLength, K;\n        if (x) {\n          if (x.length !== F)\n            throw new Error(\"ChaCha20Poly1305: incorrect destination length\");\n          K = x;\n        } else\n          K = new Uint8Array(F);\n        return e.streamXOR(this._key, O, p.subarray(0, p.length - this.tagLength), K, 4), s.wipe(O), K;\n      }, u.prototype.clean = function() {\n        return s.wipe(this._key), this;\n      }, u.prototype._authenticate = function(d, p, b, x) {\n        var O = new t.Poly1305(p);\n        x && (O.update(x), x.length % 16 > 0 && O.update(o.subarray(x.length % 16))), O.update(b), b.length % 16 > 0 && O.update(o.subarray(b.length % 16));\n        var _ = new Uint8Array(8);\n        x && r.writeUint64LE(x.length, _), O.update(_), r.writeUint64LE(b.length, _), O.update(_);\n        for (var C = O.digest(), F = 0; F < C.length; F++)\n          d[F] = C[F];\n        O.clean(), s.wipe(C), s.wipe(_);\n      }, u;\n    }()\n  );\n  i.ChaCha20Poly1305 = c;\n})(gs);\nvar Nc = {}, ys = {}, cn = {};\nObject.defineProperty(cn, \"__esModule\", { value: !0 });\nfunction vf(i) {\n  return typeof i.saveState < \"u\" && typeof i.restoreState < \"u\" && typeof i.cleanSavedState < \"u\";\n}\ncn.isSerializableHash = vf;\nObject.defineProperty(ys, \"__esModule\", { value: !0 });\nvar jt = cn, _f = di, Ef = Pt, Pc = (\n  /** @class */\n  function() {\n    function i(e, t) {\n      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;\n      var s = new Uint8Array(this.blockSize);\n      t.length > this.blockSize ? this._inner.update(t).finish(s).clean() : s.set(t);\n      for (var r = 0; r < s.length; r++)\n        s[r] ^= 54;\n      this._inner.update(s);\n      for (var r = 0; r < s.length; r++)\n        s[r] ^= 106;\n      this._outer.update(s), jt.isSerializableHash(this._inner) && jt.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), Ef.wipe(s);\n    }\n    return i.prototype.reset = function() {\n      if (!jt.isSerializableHash(this._inner) || !jt.isSerializableHash(this._outer))\n        throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;\n    }, i.prototype.clean = function() {\n      jt.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), jt.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();\n    }, i.prototype.update = function(e) {\n      return this._inner.update(e), this;\n    }, i.prototype.finish = function(e) {\n      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);\n    }, i.prototype.digest = function() {\n      var e = new Uint8Array(this.digestLength);\n      return this.finish(e), e;\n    }, i.prototype.saveState = function() {\n      if (!jt.isSerializableHash(this._inner))\n        throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n      return this._inner.saveState();\n    }, i.prototype.restoreState = function(e) {\n      if (!jt.isSerializableHash(this._inner) || !jt.isSerializableHash(this._outer))\n        throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;\n    }, i.prototype.cleanSavedState = function(e) {\n      if (!jt.isSerializableHash(this._inner))\n        throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n      this._inner.cleanSavedState(e);\n    }, i;\n  }()\n);\nys.HMAC = Pc;\nfunction Sf(i, e, t) {\n  var s = new Pc(i, e);\n  s.update(t);\n  var r = s.digest();\n  return s.clean(), r;\n}\nys.hmac = Sf;\nys.equal = _f.equal;\nObject.defineProperty(Nc, \"__esModule\", { value: !0 });\nvar vo = ys, _o = Pt, If = (\n  /** @class */\n  function() {\n    function i(e, t, s, r) {\n      s === void 0 && (s = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = r;\n      var n = vo.hmac(this._hash, s, t);\n      this._hmac = new vo.HMAC(e, n), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;\n    }\n    return i.prototype._fillBuffer = function() {\n      this._counter[0]++;\n      var e = this._counter[0];\n      if (e === 0)\n        throw new Error(\"hkdf: cannot expand more\");\n      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;\n    }, i.prototype.expand = function(e) {\n      for (var t = new Uint8Array(e), s = 0; s < t.length; s++)\n        this._bufpos === this._buffer.length && this._fillBuffer(), t[s] = this._buffer[this._bufpos++];\n      return t;\n    }, i.prototype.clean = function() {\n      this._hmac.clean(), _o.wipe(this._buffer), _o.wipe(this._counter), this._bufpos = 0;\n    }, i;\n  }()\n), Rc = Nc.HKDF = If, Si = {};\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  var e = oe, t = Pt;\n  i.DIGEST_LENGTH = 32, i.BLOCK_SIZE = 64;\n  var s = (\n    /** @class */\n    function() {\n      function c() {\n        this.digestLength = i.DIGEST_LENGTH, this.blockSize = i.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();\n      }\n      return c.prototype._initState = function() {\n        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;\n      }, c.prototype.reset = function() {\n        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;\n      }, c.prototype.clean = function() {\n        t.wipe(this._buffer), t.wipe(this._temp), this.reset();\n      }, c.prototype.update = function(u, d) {\n        if (d === void 0 && (d = u.length), this._finished)\n          throw new Error(\"SHA256: can't update because hash was finished.\");\n        var p = 0;\n        if (this._bytesHashed += d, this._bufferLength > 0) {\n          for (; this._bufferLength < this.blockSize && d > 0; )\n            this._buffer[this._bufferLength++] = u[p++], d--;\n          this._bufferLength === this.blockSize && (n(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);\n        }\n        for (d >= this.blockSize && (p = n(this._temp, this._state, u, p, d), d %= this.blockSize); d > 0; )\n          this._buffer[this._bufferLength++] = u[p++], d--;\n        return this;\n      }, c.prototype.finish = function(u) {\n        if (!this._finished) {\n          var d = this._bytesHashed, p = this._bufferLength, b = d / 536870912 | 0, x = d << 3, O = d % 64 < 56 ? 64 : 128;\n          this._buffer[p] = 128;\n          for (var _ = p + 1; _ < O - 8; _++)\n            this._buffer[_] = 0;\n          e.writeUint32BE(b, this._buffer, O - 8), e.writeUint32BE(x, this._buffer, O - 4), n(this._temp, this._state, this._buffer, 0, O), this._finished = !0;\n        }\n        for (var _ = 0; _ < this.digestLength / 4; _++)\n          e.writeUint32BE(this._state[_], u, _ * 4);\n        return this;\n      }, c.prototype.digest = function() {\n        var u = new Uint8Array(this.digestLength);\n        return this.finish(u), u;\n      }, c.prototype.saveState = function() {\n        if (this._finished)\n          throw new Error(\"SHA256: cannot save finished state\");\n        return {\n          state: new Int32Array(this._state),\n          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,\n          bufferLength: this._bufferLength,\n          bytesHashed: this._bytesHashed\n        };\n      }, c.prototype.restoreState = function(u) {\n        return this._state.set(u.state), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;\n      }, c.prototype.cleanSavedState = function(u) {\n        t.wipe(u.state), u.buffer && t.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;\n      }, c;\n    }()\n  );\n  i.SHA256 = s;\n  var r = new Int32Array([\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n  ]);\n  function n(c, u, d, p, b) {\n    for (; b >= 64; ) {\n      for (var x = u[0], O = u[1], _ = u[2], C = u[3], F = u[4], K = u[5], I = u[6], D = u[7], y = 0; y < 16; y++) {\n        var w = p + y * 4;\n        c[y] = e.readUint32BE(d, w);\n      }\n      for (var y = 16; y < 64; y++) {\n        var f = c[y - 2], a = (f >>> 17 | f << 32 - 17) ^ (f >>> 19 | f << 32 - 19) ^ f >>> 10;\n        f = c[y - 15];\n        var l = (f >>> 7 | f << 32 - 7) ^ (f >>> 18 | f << 32 - 18) ^ f >>> 3;\n        c[y] = (a + c[y - 7] | 0) + (l + c[y - 16] | 0);\n      }\n      for (var y = 0; y < 64; y++) {\n        var a = (((F >>> 6 | F << 26) ^ (F >>> 11 | F << 21) ^ (F >>> 25 | F << 7)) + (F & K ^ ~F & I) | 0) + (D + (r[y] + c[y] | 0) | 0) | 0, l = ((x >>> 2 | x << 32 - 2) ^ (x >>> 13 | x << 32 - 13) ^ (x >>> 22 | x << 32 - 22)) + (x & O ^ x & _ ^ O & _) | 0;\n        D = I, I = K, K = F, F = C + a | 0, C = _, _ = O, O = x, x = a + l | 0;\n      }\n      u[0] += x, u[1] += O, u[2] += _, u[3] += C, u[4] += F, u[5] += K, u[6] += I, u[7] += D, p += 64, b -= 64;\n    }\n    return p;\n  }\n  function o(c) {\n    var u = new s();\n    u.update(c);\n    var d = u.digest();\n    return u.clean(), d;\n  }\n  i.hash = o;\n})(Si);\nvar ms = {};\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 }), i.sharedKey = i.generateKeyPair = i.generateKeyPairFromSeed = i.scalarMultBase = i.scalarMult = i.SHARED_KEY_LENGTH = i.SECRET_KEY_LENGTH = i.PUBLIC_KEY_LENGTH = void 0;\n  const e = li, t = Pt;\n  i.PUBLIC_KEY_LENGTH = 32, i.SECRET_KEY_LENGTH = 32, i.SHARED_KEY_LENGTH = 32;\n  function s(y) {\n    const w = new Float64Array(16);\n    if (y)\n      for (let f = 0; f < y.length; f++)\n        w[f] = y[f];\n    return w;\n  }\n  const r = new Uint8Array(32);\n  r[0] = 9;\n  const n = s([56129, 1]);\n  function o(y) {\n    let w = 1;\n    for (let f = 0; f < 16; f++) {\n      let a = y[f] + w + 65535;\n      w = Math.floor(a / 65536), y[f] = a - w * 65536;\n    }\n    y[0] += w - 1 + 37 * (w - 1);\n  }\n  function c(y, w, f) {\n    const a = ~(f - 1);\n    for (let l = 0; l < 16; l++) {\n      const L = a & (y[l] ^ w[l]);\n      y[l] ^= L, w[l] ^= L;\n    }\n  }\n  function u(y, w) {\n    const f = s(), a = s();\n    for (let l = 0; l < 16; l++)\n      a[l] = w[l];\n    o(a), o(a), o(a);\n    for (let l = 0; l < 2; l++) {\n      f[0] = a[0] - 65517;\n      for (let v = 1; v < 15; v++)\n        f[v] = a[v] - 65535 - (f[v - 1] >> 16 & 1), f[v - 1] &= 65535;\n      f[15] = a[15] - 32767 - (f[14] >> 16 & 1);\n      const L = f[15] >> 16 & 1;\n      f[14] &= 65535, c(a, f, 1 - L);\n    }\n    for (let l = 0; l < 16; l++)\n      y[2 * l] = a[l] & 255, y[2 * l + 1] = a[l] >> 8;\n  }\n  function d(y, w) {\n    for (let f = 0; f < 16; f++)\n      y[f] = w[2 * f] + (w[2 * f + 1] << 8);\n    y[15] &= 32767;\n  }\n  function p(y, w, f) {\n    for (let a = 0; a < 16; a++)\n      y[a] = w[a] + f[a];\n  }\n  function b(y, w, f) {\n    for (let a = 0; a < 16; a++)\n      y[a] = w[a] - f[a];\n  }\n  function x(y, w, f) {\n    let a, l, L = 0, v = 0, R = 0, $ = 0, q = 0, m = 0, E = 0, B = 0, z = 0, j = 0, U = 0, M = 0, H = 0, te = 0, G = 0, ie = 0, Q = 0, se = 0, T = 0, A = 0, N = 0, h = 0, S = 0, W = 0, X = 0, fe = 0, ve = 0, ge = 0, Se = 0, Me = 0, $e = 0, be = f[0], ye = f[1], pe = f[2], le = f[3], ue = f[4], he = f[5], ce = f[6], re = f[7], de = f[8], me = f[9], ne = f[10], _e = f[11], Ee = f[12], De = f[13], xe = f[14], Ie = f[15];\n    a = w[0], L += a * be, v += a * ye, R += a * pe, $ += a * le, q += a * ue, m += a * he, E += a * ce, B += a * re, z += a * de, j += a * me, U += a * ne, M += a * _e, H += a * Ee, te += a * De, G += a * xe, ie += a * Ie, a = w[1], v += a * be, R += a * ye, $ += a * pe, q += a * le, m += a * ue, E += a * he, B += a * ce, z += a * re, j += a * de, U += a * me, M += a * ne, H += a * _e, te += a * Ee, G += a * De, ie += a * xe, Q += a * Ie, a = w[2], R += a * be, $ += a * ye, q += a * pe, m += a * le, E += a * ue, B += a * he, z += a * ce, j += a * re, U += a * de, M += a * me, H += a * ne, te += a * _e, G += a * Ee, ie += a * De, Q += a * xe, se += a * Ie, a = w[3], $ += a * be, q += a * ye, m += a * pe, E += a * le, B += a * ue, z += a * he, j += a * ce, U += a * re, M += a * de, H += a * me, te += a * ne, G += a * _e, ie += a * Ee, Q += a * De, se += a * xe, T += a * Ie, a = w[4], q += a * be, m += a * ye, E += a * pe, B += a * le, z += a * ue, j += a * he, U += a * ce, M += a * re, H += a * de, te += a * me, G += a * ne, ie += a * _e, Q += a * Ee, se += a * De, T += a * xe, A += a * Ie, a = w[5], m += a * be, E += a * ye, B += a * pe, z += a * le, j += a * ue, U += a * he, M += a * ce, H += a * re, te += a * de, G += a * me, ie += a * ne, Q += a * _e, se += a * Ee, T += a * De, A += a * xe, N += a * Ie, a = w[6], E += a * be, B += a * ye, z += a * pe, j += a * le, U += a * ue, M += a * he, H += a * ce, te += a * re, G += a * de, ie += a * me, Q += a * ne, se += a * _e, T += a * Ee, A += a * De, N += a * xe, h += a * Ie, a = w[7], B += a * be, z += a * ye, j += a * pe, U += a * le, M += a * ue, H += a * he, te += a * ce, G += a * re, ie += a * de, Q += a * me, se += a * ne, T += a * _e, A += a * Ee, N += a * De, h += a * xe, S += a * Ie, a = w[8], z += a * be, j += a * ye, U += a * pe, M += a * le, H += a * ue, te += a * he, G += a * ce, ie += a * re, Q += a * de, se += a * me, T += a * ne, A += a * _e, N += a * Ee, h += a * De, S += a * xe, W += a * Ie, a = w[9], j += a * be, U += a * ye, M += a * pe, H += a * le, te += a * ue, G += a * he, ie += a * ce, Q += a * re, se += a * de, T += a * me, A += a * ne, N += a * _e, h += a * Ee, S += a * De, W += a * xe, X += a * Ie, a = w[10], U += a * be, M += a * ye, H += a * pe, te += a * le, G += a * ue, ie += a * he, Q += a * ce, se += a * re, T += a * de, A += a * me, N += a * ne, h += a * _e, S += a * Ee, W += a * De, X += a * xe, fe += a * Ie, a = w[11], M += a * be, H += a * ye, te += a * pe, G += a * le, ie += a * ue, Q += a * he, se += a * ce, T += a * re, A += a * de, N += a * me, h += a * ne, S += a * _e, W += a * Ee, X += a * De, fe += a * xe, ve += a * Ie, a = w[12], H += a * be, te += a * ye, G += a * pe, ie += a * le, Q += a * ue, se += a * he, T += a * ce, A += a * re, N += a * de, h += a * me, S += a * ne, W += a * _e, X += a * Ee, fe += a * De, ve += a * xe, ge += a * Ie, a = w[13], te += a * be, G += a * ye, ie += a * pe, Q += a * le, se += a * ue, T += a * he, A += a * ce, N += a * re, h += a * de, S += a * me, W += a * ne, X += a * _e, fe += a * Ee, ve += a * De, ge += a * xe, Se += a * Ie, a = w[14], G += a * be, ie += a * ye, Q += a * pe, se += a * le, T += a * ue, A += a * he, N += a * ce, h += a * re, S += a * de, W += a * me, X += a * ne, fe += a * _e, ve += a * Ee, ge += a * De, Se += a * xe, Me += a * Ie, a = w[15], ie += a * be, Q += a * ye, se += a * pe, T += a * le, A += a * ue, N += a * he, h += a * ce, S += a * re, W += a * de, X += a * me, fe += a * ne, ve += a * _e, ge += a * Ee, Se += a * De, Me += a * xe, $e += a * Ie, L += 38 * Q, v += 38 * se, R += 38 * T, $ += 38 * A, q += 38 * N, m += 38 * h, E += 38 * S, B += 38 * W, z += 38 * X, j += 38 * fe, U += 38 * ve, M += 38 * ge, H += 38 * Se, te += 38 * Me, G += 38 * $e, l = 1, a = L + l + 65535, l = Math.floor(a / 65536), L = a - l * 65536, a = v + l + 65535, l = Math.floor(a / 65536), v = a - l * 65536, a = R + l + 65535, l = Math.floor(a / 65536), R = a - l * 65536, a = $ + l + 65535, l = Math.floor(a / 65536), $ = a - l * 65536, a = q + l + 65535, l = Math.floor(a / 65536), q = a - l * 65536, a = m + l + 65535, l = Math.floor(a / 65536), m = a - l * 65536, a = E + l + 65535, l = Math.floor(a / 65536), E = a - l * 65536, a = B + l + 65535, l = Math.floor(a / 65536), B = a - l * 65536, a = z + l + 65535, l = Math.floor(a / 65536), z = a - l * 65536, a = j + l + 65535, l = Math.floor(a / 65536), j = a - l * 65536, a = U + l + 65535, l = Math.floor(a / 65536), U = a - l * 65536, a = M + l + 65535, l = Math.floor(a / 65536), M = a - l * 65536, a = H + l + 65535, l = Math.floor(a / 65536), H = a - l * 65536, a = te + l + 65535, l = Math.floor(a / 65536), te = a - l * 65536, a = G + l + 65535, l = Math.floor(a / 65536), G = a - l * 65536, a = ie + l + 65535, l = Math.floor(a / 65536), ie = a - l * 65536, L += l - 1 + 37 * (l - 1), l = 1, a = L + l + 65535, l = Math.floor(a / 65536), L = a - l * 65536, a = v + l + 65535, l = Math.floor(a / 65536), v = a - l * 65536, a = R + l + 65535, l = Math.floor(a / 65536), R = a - l * 65536, a = $ + l + 65535, l = Math.floor(a / 65536), $ = a - l * 65536, a = q + l + 65535, l = Math.floor(a / 65536), q = a - l * 65536, a = m + l + 65535, l = Math.floor(a / 65536), m = a - l * 65536, a = E + l + 65535, l = Math.floor(a / 65536), E = a - l * 65536, a = B + l + 65535, l = Math.floor(a / 65536), B = a - l * 65536, a = z + l + 65535, l = Math.floor(a / 65536), z = a - l * 65536, a = j + l + 65535, l = Math.floor(a / 65536), j = a - l * 65536, a = U + l + 65535, l = Math.floor(a / 65536), U = a - l * 65536, a = M + l + 65535, l = Math.floor(a / 65536), M = a - l * 65536, a = H + l + 65535, l = Math.floor(a / 65536), H = a - l * 65536, a = te + l + 65535, l = Math.floor(a / 65536), te = a - l * 65536, a = G + l + 65535, l = Math.floor(a / 65536), G = a - l * 65536, a = ie + l + 65535, l = Math.floor(a / 65536), ie = a - l * 65536, L += l - 1 + 37 * (l - 1), y[0] = L, y[1] = v, y[2] = R, y[3] = $, y[4] = q, y[5] = m, y[6] = E, y[7] = B, y[8] = z, y[9] = j, y[10] = U, y[11] = M, y[12] = H, y[13] = te, y[14] = G, y[15] = ie;\n  }\n  function O(y, w) {\n    x(y, w, w);\n  }\n  function _(y, w) {\n    const f = s();\n    for (let a = 0; a < 16; a++)\n      f[a] = w[a];\n    for (let a = 253; a >= 0; a--)\n      O(f, f), a !== 2 && a !== 4 && x(f, f, w);\n    for (let a = 0; a < 16; a++)\n      y[a] = f[a];\n  }\n  function C(y, w) {\n    const f = new Uint8Array(32), a = new Float64Array(80), l = s(), L = s(), v = s(), R = s(), $ = s(), q = s();\n    for (let z = 0; z < 31; z++)\n      f[z] = y[z];\n    f[31] = y[31] & 127 | 64, f[0] &= 248, d(a, w);\n    for (let z = 0; z < 16; z++)\n      L[z] = a[z];\n    l[0] = R[0] = 1;\n    for (let z = 254; z >= 0; --z) {\n      const j = f[z >>> 3] >>> (z & 7) & 1;\n      c(l, L, j), c(v, R, j), p($, l, v), b(l, l, v), p(v, L, R), b(L, L, R), O(R, $), O(q, l), x(l, v, l), x(v, L, $), p($, l, v), b(l, l, v), O(L, l), b(v, R, q), x(l, v, n), p(l, l, R), x(v, v, l), x(l, R, q), x(R, L, a), O(L, $), c(l, L, j), c(v, R, j);\n    }\n    for (let z = 0; z < 16; z++)\n      a[z + 16] = l[z], a[z + 32] = v[z], a[z + 48] = L[z], a[z + 64] = R[z];\n    const m = a.subarray(32), E = a.subarray(16);\n    _(m, m), x(E, E, m);\n    const B = new Uint8Array(32);\n    return u(B, E), B;\n  }\n  i.scalarMult = C;\n  function F(y) {\n    return C(y, r);\n  }\n  i.scalarMultBase = F;\n  function K(y) {\n    if (y.length !== i.SECRET_KEY_LENGTH)\n      throw new Error(`x25519: seed must be ${i.SECRET_KEY_LENGTH} bytes`);\n    const w = new Uint8Array(y);\n    return {\n      publicKey: F(w),\n      secretKey: w\n    };\n  }\n  i.generateKeyPairFromSeed = K;\n  function I(y) {\n    const w = (0, e.randomBytes)(32, y), f = K(w);\n    return (0, t.wipe)(w), f;\n  }\n  i.generateKeyPair = I;\n  function D(y, w, f = !1) {\n    if (y.length !== i.PUBLIC_KEY_LENGTH)\n      throw new Error(\"X25519: incorrect secret key length\");\n    if (w.length !== i.PUBLIC_KEY_LENGTH)\n      throw new Error(\"X25519: incorrect public key length\");\n    const a = C(y, w);\n    if (f) {\n      let l = 0;\n      for (let L = 0; L < a.length; L++)\n        l |= a[L];\n      if (l === 0)\n        throw new Error(\"X25519: invalid shared key\");\n    }\n    return a;\n  }\n  i.sharedKey = D;\n})(ms);\nvar Eo = globalThis && globalThis.__spreadArray || function(i, e, t) {\n  if (t || arguments.length === 2)\n    for (var s = 0, r = e.length, n; s < r; s++)\n      (n || !(s in e)) && (n || (n = Array.prototype.slice.call(e, 0, s)), n[s] = e[s]);\n  return i.concat(n || Array.prototype.slice.call(e));\n}, Df = (\n  /** @class */\n  function() {\n    function i(e, t, s) {\n      this.name = e, this.version = t, this.os = s, this.type = \"browser\";\n    }\n    return i;\n  }()\n), xf = (\n  /** @class */\n  function() {\n    function i(e) {\n      this.version = e, this.type = \"node\", this.name = \"node\", this.os = process.platform;\n    }\n    return i;\n  }()\n), Of = (\n  /** @class */\n  function() {\n    function i(e, t, s, r) {\n      this.name = e, this.version = t, this.os = s, this.bot = r, this.type = \"bot-device\";\n    }\n    return i;\n  }()\n), Nf = (\n  /** @class */\n  function() {\n    function i() {\n      this.type = \"bot\", this.bot = !0, this.name = \"bot\", this.version = null, this.os = null;\n    }\n    return i;\n  }()\n), Pf = (\n  /** @class */\n  function() {\n    function i() {\n      this.type = \"react-native\", this.name = \"react-native\", this.version = null, this.os = null;\n    }\n    return i;\n  }()\n), Rf = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, Cf = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\\ Jeeves\\/Teoma|ia_archiver)/, So = 3, Af = [\n  [\"aol\", /AOLShield\\/([0-9\\._]+)/],\n  [\"edge\", /Edge\\/([0-9\\._]+)/],\n  [\"edge-ios\", /EdgiOS\\/([0-9\\._]+)/],\n  [\"yandexbrowser\", /YaBrowser\\/([0-9\\._]+)/],\n  [\"kakaotalk\", /KAKAOTALK\\s([0-9\\.]+)/],\n  [\"samsung\", /SamsungBrowser\\/([0-9\\.]+)/],\n  [\"silk\", /\\bSilk\\/([0-9._-]+)\\b/],\n  [\"miui\", /MiuiBrowser\\/([0-9\\.]+)$/],\n  [\"beaker\", /BeakerBrowser\\/([0-9\\.]+)/],\n  [\"edge-chromium\", /EdgA?\\/([0-9\\.]+)/],\n  [\n    \"chromium-webview\",\n    /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/\n  ],\n  [\"chrome\", /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"phantomjs\", /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"crios\", /CriOS\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"firefox\", /Firefox\\/([0-9\\.]+)(?:\\s|$)/],\n  [\"fxios\", /FxiOS\\/([0-9\\.]+)/],\n  [\"opera-mini\", /Opera Mini.*Version\\/([0-9\\.]+)/],\n  [\"opera\", /Opera\\/([0-9\\.]+)(?:\\s|$)/],\n  [\"opera\", /OPR\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"pie\", /^Microsoft Pocket Internet Explorer\\/(\\d+\\.\\d+)$/],\n  [\"pie\", /^Mozilla\\/\\d\\.\\d+\\s\\(compatible;\\s(?:MSP?IE|MSInternet Explorer) (\\d+\\.\\d+);.*Windows CE.*\\)$/],\n  [\"netfront\", /^Mozilla\\/\\d\\.\\d+.*NetFront\\/(\\d.\\d)/],\n  [\"ie\", /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/],\n  [\"ie\", /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/],\n  [\"ie\", /MSIE\\s(7\\.0)/],\n  [\"bb10\", /BB10;\\sTouch.*Version\\/([0-9\\.]+)/],\n  [\"android\", /Android\\s([0-9\\.]+)/],\n  [\"ios\", /Version\\/([0-9\\._]+).*Mobile.*Safari.*/],\n  [\"safari\", /Version\\/([0-9\\._]+).*Safari/],\n  [\"facebook\", /FB[AS]V\\/([0-9\\.]+)/],\n  [\"instagram\", /Instagram\\s([0-9\\.]+)/],\n  [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Mobile/],\n  [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/],\n  [\"curl\", /^curl\\/([0-9\\.]+)$/],\n  [\"searchbot\", Rf]\n], Io = [\n  [\"iOS\", /iP(hone|od|ad)/],\n  [\"Android OS\", /Android/],\n  [\"BlackBerry OS\", /BlackBerry|BB10/],\n  [\"Windows Mobile\", /IEMobile/],\n  [\"Amazon OS\", /Kindle/],\n  [\"Windows 3.11\", /Win16/],\n  [\"Windows 95\", /(Windows 95)|(Win95)|(Windows_95)/],\n  [\"Windows 98\", /(Windows 98)|(Win98)/],\n  [\"Windows 2000\", /(Windows NT 5.0)|(Windows 2000)/],\n  [\"Windows XP\", /(Windows NT 5.1)|(Windows XP)/],\n  [\"Windows Server 2003\", /(Windows NT 5.2)/],\n  [\"Windows Vista\", /(Windows NT 6.0)/],\n  [\"Windows 7\", /(Windows NT 6.1)/],\n  [\"Windows 8\", /(Windows NT 6.2)/],\n  [\"Windows 8.1\", /(Windows NT 6.3)/],\n  [\"Windows 10\", /(Windows NT 10.0)/],\n  [\"Windows ME\", /Windows ME/],\n  [\"Windows CE\", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],\n  [\"Open BSD\", /OpenBSD/],\n  [\"Sun OS\", /SunOS/],\n  [\"Chrome OS\", /CrOS/],\n  [\"Linux\", /(Linux)|(X11)/],\n  [\"Mac OS\", /(Mac_PowerPC)|(Macintosh)/],\n  [\"QNX\", /QNX/],\n  [\"BeOS\", /BeOS/],\n  [\"OS/2\", /OS\\/2/]\n];\nfunction hn(i) {\n  return i ? Do(i) : typeof document > \"u\" && typeof navigator < \"u\" && navigator.product === \"ReactNative\" ? new Pf() : typeof navigator < \"u\" ? Do(navigator.userAgent) : Ff();\n}\nfunction Tf(i) {\n  return i !== \"\" && Af.reduce(function(e, t) {\n    var s = t[0], r = t[1];\n    if (e)\n      return e;\n    var n = r.exec(i);\n    return !!n && [s, n];\n  }, !1);\n}\nfunction Do(i) {\n  var e = Tf(i);\n  if (!e)\n    return null;\n  var t = e[0], s = e[1];\n  if (t === \"searchbot\")\n    return new Nf();\n  var r = s[1] && s[1].split(\".\").join(\"_\").split(\"_\").slice(0, 3);\n  r ? r.length < So && (r = Eo(Eo([], r, !0), Uf(So - r.length), !0)) : r = [];\n  var n = r.join(\".\"), o = $f(i), c = Cf.exec(i);\n  return c && c[1] ? new Of(t, n, o, c[1]) : new Df(t, n, o);\n}\nfunction $f(i) {\n  for (var e = 0, t = Io.length; e < t; e++) {\n    var s = Io[e], r = s[0], n = s[1], o = n.exec(i);\n    if (o)\n      return r;\n  }\n  return null;\n}\nfunction Ff() {\n  var i = typeof process < \"u\" && process.version;\n  return i ? new xf(process.version.slice(1)) : null;\n}\nfunction Uf(i) {\n  for (var e = [], t = 0; t < i; t++)\n    e.push(\"0\");\n  return e;\n}\nvar Pe = {};\nObject.defineProperty(Pe, \"__esModule\", { value: !0 });\nPe.getLocalStorage = Pe.getLocalStorageOrThrow = Pe.getCrypto = Pe.getCryptoOrThrow = ln = Pe.getLocation = Pe.getLocationOrThrow = bs = Pe.getNavigator = Pe.getNavigatorOrThrow = un = Pe.getDocument = Pe.getDocumentOrThrow = Pe.getFromWindowOrThrow = Pe.getFromWindow = void 0;\nfunction Ii(i) {\n  let e;\n  return typeof window < \"u\" && typeof window[i] < \"u\" && (e = window[i]), e;\n}\nPe.getFromWindow = Ii;\nfunction Li(i) {\n  const e = Ii(i);\n  if (!e)\n    throw new Error(`${i} is not defined in Window`);\n  return e;\n}\nPe.getFromWindowOrThrow = Li;\nfunction Lf() {\n  return Li(\"document\");\n}\nPe.getDocumentOrThrow = Lf;\nfunction Mf() {\n  return Ii(\"document\");\n}\nvar un = Pe.getDocument = Mf;\nfunction qf() {\n  return Li(\"navigator\");\n}\nPe.getNavigatorOrThrow = qf;\nfunction jf() {\n  return Ii(\"navigator\");\n}\nvar bs = Pe.getNavigator = jf;\nfunction zf() {\n  return Li(\"location\");\n}\nPe.getLocationOrThrow = zf;\nfunction Kf() {\n  return Ii(\"location\");\n}\nvar ln = Pe.getLocation = Kf;\nfunction Vf() {\n  return Li(\"crypto\");\n}\nPe.getCryptoOrThrow = Vf;\nfunction Bf() {\n  return Ii(\"crypto\");\n}\nPe.getCrypto = Bf;\nfunction kf() {\n  return Li(\"localStorage\");\n}\nPe.getLocalStorageOrThrow = kf;\nfunction Hf() {\n  return Ii(\"localStorage\");\n}\nPe.getLocalStorage = Hf;\nvar dn = {};\nObject.defineProperty(dn, \"__esModule\", { value: !0 });\nvar fn = dn.getWindowMetadata = void 0;\nconst xo = Pe;\nfunction Gf() {\n  let i, e;\n  try {\n    i = xo.getDocumentOrThrow(), e = xo.getLocationOrThrow();\n  } catch {\n    return null;\n  }\n  function t() {\n    const b = i.getElementsByTagName(\"link\"), x = [];\n    for (let O = 0; O < b.length; O++) {\n      const _ = b[O], C = _.getAttribute(\"rel\");\n      if (C && C.toLowerCase().indexOf(\"icon\") > -1) {\n        const F = _.getAttribute(\"href\");\n        if (F)\n          if (F.toLowerCase().indexOf(\"https:\") === -1 && F.toLowerCase().indexOf(\"http:\") === -1 && F.indexOf(\"//\") !== 0) {\n            let K = e.protocol + \"//\" + e.host;\n            if (F.indexOf(\"/\") === 0)\n              K += F;\n            else {\n              const I = e.pathname.split(\"/\");\n              I.pop();\n              const D = I.join(\"/\");\n              K += D + \"/\" + F;\n            }\n            x.push(K);\n          } else if (F.indexOf(\"//\") === 0) {\n            const K = e.protocol + F;\n            x.push(K);\n          } else\n            x.push(F);\n      }\n    }\n    return x;\n  }\n  function s(...b) {\n    const x = i.getElementsByTagName(\"meta\");\n    for (let O = 0; O < x.length; O++) {\n      const _ = x[O], C = [\"itemprop\", \"property\", \"name\"].map((F) => _.getAttribute(F)).filter((F) => F ? b.includes(F) : !1);\n      if (C.length && C) {\n        const F = _.getAttribute(\"content\");\n        if (F)\n          return F;\n      }\n    }\n    return \"\";\n  }\n  function r() {\n    let b = s(\"name\", \"og:site_name\", \"og:title\", \"twitter:title\");\n    return b || (b = i.title), b;\n  }\n  function n() {\n    return s(\"description\", \"og:description\", \"twitter:description\", \"keywords\");\n  }\n  const o = r(), c = n(), u = e.origin, d = t();\n  return {\n    description: c,\n    url: u,\n    icons: d,\n    name: o\n  };\n}\nfn = dn.getWindowMetadata = Gf;\nvar ii = {}, Wf = (i) => encodeURIComponent(i).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), Cc = \"%[a-f0-9]{2}\", Oo = new RegExp(\"(\" + Cc + \")|([^%]+?)\", \"gi\"), No = new RegExp(\"(\" + Cc + \")+\", \"gi\");\nfunction Vr(i, e) {\n  try {\n    return [decodeURIComponent(i.join(\"\"))];\n  } catch {\n  }\n  if (i.length === 1)\n    return i;\n  e = e || 1;\n  var t = i.slice(0, e), s = i.slice(e);\n  return Array.prototype.concat.call([], Vr(t), Vr(s));\n}\nfunction Yf(i) {\n  try {\n    return decodeURIComponent(i);\n  } catch {\n    for (var e = i.match(Oo) || [], t = 1; t < e.length; t++)\n      i = Vr(e, t).join(\"\"), e = i.match(Oo) || [];\n    return i;\n  }\n}\nfunction Jf(i) {\n  for (var e = {\n    \"%FE%FF\": \"��\",\n    \"%FF%FE\": \"��\"\n  }, t = No.exec(i); t; ) {\n    try {\n      e[t[0]] = decodeURIComponent(t[0]);\n    } catch {\n      var s = Yf(t[0]);\n      s !== t[0] && (e[t[0]] = s);\n    }\n    t = No.exec(i);\n  }\n  e[\"%C2\"] = \"�\";\n  for (var r = Object.keys(e), n = 0; n < r.length; n++) {\n    var o = r[n];\n    i = i.replace(new RegExp(o, \"g\"), e[o]);\n  }\n  return i;\n}\nvar Qf = function(i) {\n  if (typeof i != \"string\")\n    throw new TypeError(\"Expected `encodedURI` to be of type `string`, got `\" + typeof i + \"`\");\n  try {\n    return i = i.replace(/\\+/g, \" \"), decodeURIComponent(i);\n  } catch {\n    return Jf(i);\n  }\n}, Xf = (i, e) => {\n  if (!(typeof i == \"string\" && typeof e == \"string\"))\n    throw new TypeError(\"Expected the arguments to be of type `string`\");\n  if (e === \"\")\n    return [i];\n  const t = i.indexOf(e);\n  return t === -1 ? [i] : [\n    i.slice(0, t),\n    i.slice(t + e.length)\n  ];\n}, Zf = function(i, e) {\n  for (var t = {}, s = Object.keys(i), r = Array.isArray(e), n = 0; n < s.length; n++) {\n    var o = s[n], c = i[o];\n    (r ? e.indexOf(o) !== -1 : e(o, c, i)) && (t[o] = c);\n  }\n  return t;\n};\n(function(i) {\n  const e = Wf, t = Qf, s = Xf, r = Zf, n = (I) => I == null, o = Symbol(\"encodeFragmentIdentifier\");\n  function c(I) {\n    switch (I.arrayFormat) {\n      case \"index\":\n        return (D) => (y, w) => {\n          const f = y.length;\n          return w === void 0 || I.skipNull && w === null || I.skipEmptyString && w === \"\" ? y : w === null ? [...y, [p(D, I), \"[\", f, \"]\"].join(\"\")] : [\n            ...y,\n            [p(D, I), \"[\", p(f, I), \"]=\", p(w, I)].join(\"\")\n          ];\n        };\n      case \"bracket\":\n        return (D) => (y, w) => w === void 0 || I.skipNull && w === null || I.skipEmptyString && w === \"\" ? y : w === null ? [...y, [p(D, I), \"[]\"].join(\"\")] : [...y, [p(D, I), \"[]=\", p(w, I)].join(\"\")];\n      case \"colon-list-separator\":\n        return (D) => (y, w) => w === void 0 || I.skipNull && w === null || I.skipEmptyString && w === \"\" ? y : w === null ? [...y, [p(D, I), \":list=\"].join(\"\")] : [...y, [p(D, I), \":list=\", p(w, I)].join(\"\")];\n      case \"comma\":\n      case \"separator\":\n      case \"bracket-separator\": {\n        const D = I.arrayFormat === \"bracket-separator\" ? \"[]=\" : \"=\";\n        return (y) => (w, f) => f === void 0 || I.skipNull && f === null || I.skipEmptyString && f === \"\" ? w : (f = f === null ? \"\" : f, w.length === 0 ? [[p(y, I), D, p(f, I)].join(\"\")] : [[w, p(f, I)].join(I.arrayFormatSeparator)]);\n      }\n      default:\n        return (D) => (y, w) => w === void 0 || I.skipNull && w === null || I.skipEmptyString && w === \"\" ? y : w === null ? [...y, p(D, I)] : [...y, [p(D, I), \"=\", p(w, I)].join(\"\")];\n    }\n  }\n  function u(I) {\n    let D;\n    switch (I.arrayFormat) {\n      case \"index\":\n        return (y, w, f) => {\n          if (D = /\\[(\\d*)\\]$/.exec(y), y = y.replace(/\\[\\d*\\]$/, \"\"), !D) {\n            f[y] = w;\n            return;\n          }\n          f[y] === void 0 && (f[y] = {}), f[y][D[1]] = w;\n        };\n      case \"bracket\":\n        return (y, w, f) => {\n          if (D = /(\\[\\])$/.exec(y), y = y.replace(/\\[\\]$/, \"\"), !D) {\n            f[y] = w;\n            return;\n          }\n          if (f[y] === void 0) {\n            f[y] = [w];\n            return;\n          }\n          f[y] = [].concat(f[y], w);\n        };\n      case \"colon-list-separator\":\n        return (y, w, f) => {\n          if (D = /(:list)$/.exec(y), y = y.replace(/:list$/, \"\"), !D) {\n            f[y] = w;\n            return;\n          }\n          if (f[y] === void 0) {\n            f[y] = [w];\n            return;\n          }\n          f[y] = [].concat(f[y], w);\n        };\n      case \"comma\":\n      case \"separator\":\n        return (y, w, f) => {\n          const a = typeof w == \"string\" && w.includes(I.arrayFormatSeparator), l = typeof w == \"string\" && !a && b(w, I).includes(I.arrayFormatSeparator);\n          w = l ? b(w, I) : w;\n          const L = a || l ? w.split(I.arrayFormatSeparator).map((v) => b(v, I)) : w === null ? w : b(w, I);\n          f[y] = L;\n        };\n      case \"bracket-separator\":\n        return (y, w, f) => {\n          const a = /(\\[\\])$/.test(y);\n          if (y = y.replace(/\\[\\]$/, \"\"), !a) {\n            f[y] = w && b(w, I);\n            return;\n          }\n          const l = w === null ? [] : w.split(I.arrayFormatSeparator).map((L) => b(L, I));\n          if (f[y] === void 0) {\n            f[y] = l;\n            return;\n          }\n          f[y] = [].concat(f[y], l);\n        };\n      default:\n        return (y, w, f) => {\n          if (f[y] === void 0) {\n            f[y] = w;\n            return;\n          }\n          f[y] = [].concat(f[y], w);\n        };\n    }\n  }\n  function d(I) {\n    if (typeof I != \"string\" || I.length !== 1)\n      throw new TypeError(\"arrayFormatSeparator must be single character string\");\n  }\n  function p(I, D) {\n    return D.encode ? D.strict ? e(I) : encodeURIComponent(I) : I;\n  }\n  function b(I, D) {\n    return D.decode ? t(I) : I;\n  }\n  function x(I) {\n    return Array.isArray(I) ? I.sort() : typeof I == \"object\" ? x(Object.keys(I)).sort((D, y) => Number(D) - Number(y)).map((D) => I[D]) : I;\n  }\n  function O(I) {\n    const D = I.indexOf(\"#\");\n    return D !== -1 && (I = I.slice(0, D)), I;\n  }\n  function _(I) {\n    let D = \"\";\n    const y = I.indexOf(\"#\");\n    return y !== -1 && (D = I.slice(y)), D;\n  }\n  function C(I) {\n    I = O(I);\n    const D = I.indexOf(\"?\");\n    return D === -1 ? \"\" : I.slice(D + 1);\n  }\n  function F(I, D) {\n    return D.parseNumbers && !Number.isNaN(Number(I)) && typeof I == \"string\" && I.trim() !== \"\" ? I = Number(I) : D.parseBooleans && I !== null && (I.toLowerCase() === \"true\" || I.toLowerCase() === \"false\") && (I = I.toLowerCase() === \"true\"), I;\n  }\n  function K(I, D) {\n    D = Object.assign({\n      decode: !0,\n      sort: !0,\n      arrayFormat: \"none\",\n      arrayFormatSeparator: \",\",\n      parseNumbers: !1,\n      parseBooleans: !1\n    }, D), d(D.arrayFormatSeparator);\n    const y = u(D), w = /* @__PURE__ */ Object.create(null);\n    if (typeof I != \"string\" || (I = I.trim().replace(/^[?#&]/, \"\"), !I))\n      return w;\n    for (const f of I.split(\"&\")) {\n      if (f === \"\")\n        continue;\n      let [a, l] = s(D.decode ? f.replace(/\\+/g, \" \") : f, \"=\");\n      l = l === void 0 ? null : [\"comma\", \"separator\", \"bracket-separator\"].includes(D.arrayFormat) ? l : b(l, D), y(b(a, D), l, w);\n    }\n    for (const f of Object.keys(w)) {\n      const a = w[f];\n      if (typeof a == \"object\" && a !== null)\n        for (const l of Object.keys(a))\n          a[l] = F(a[l], D);\n      else\n        w[f] = F(a, D);\n    }\n    return D.sort === !1 ? w : (D.sort === !0 ? Object.keys(w).sort() : Object.keys(w).sort(D.sort)).reduce((f, a) => {\n      const l = w[a];\n      return l && typeof l == \"object\" && !Array.isArray(l) ? f[a] = x(l) : f[a] = l, f;\n    }, /* @__PURE__ */ Object.create(null));\n  }\n  i.extract = C, i.parse = K, i.stringify = (I, D) => {\n    if (!I)\n      return \"\";\n    D = Object.assign({\n      encode: !0,\n      strict: !0,\n      arrayFormat: \"none\",\n      arrayFormatSeparator: \",\"\n    }, D), d(D.arrayFormatSeparator);\n    const y = (l) => D.skipNull && n(I[l]) || D.skipEmptyString && I[l] === \"\", w = c(D), f = {};\n    for (const l of Object.keys(I))\n      y(l) || (f[l] = I[l]);\n    const a = Object.keys(f);\n    return D.sort !== !1 && a.sort(D.sort), a.map((l) => {\n      const L = I[l];\n      return L === void 0 ? \"\" : L === null ? p(l, D) : Array.isArray(L) ? L.length === 0 && D.arrayFormat === \"bracket-separator\" ? p(l, D) + \"[]\" : L.reduce(w(l), []).join(\"&\") : p(l, D) + \"=\" + p(L, D);\n    }).filter((l) => l.length > 0).join(\"&\");\n  }, i.parseUrl = (I, D) => {\n    D = Object.assign({\n      decode: !0\n    }, D);\n    const [y, w] = s(I, \"#\");\n    return Object.assign(\n      {\n        url: y.split(\"?\")[0] || \"\",\n        query: K(C(I), D)\n      },\n      D && D.parseFragmentIdentifier && w ? { fragmentIdentifier: b(w, D) } : {}\n    );\n  }, i.stringifyUrl = (I, D) => {\n    D = Object.assign({\n      encode: !0,\n      strict: !0,\n      [o]: !0\n    }, D);\n    const y = O(I.url).split(\"?\")[0] || \"\", w = i.extract(I.url), f = i.parse(w, { sort: !1 }), a = Object.assign(f, I.query);\n    let l = i.stringify(a, D);\n    l && (l = `?${l}`);\n    let L = _(I.url);\n    return I.fragmentIdentifier && (L = `#${D[o] ? p(I.fragmentIdentifier, D) : I.fragmentIdentifier}`), `${y}${l}${L}`;\n  }, i.pick = (I, D, y) => {\n    y = Object.assign({\n      parseFragmentIdentifier: !0,\n      [o]: !1\n    }, y);\n    const { url: w, query: f, fragmentIdentifier: a } = i.parseUrl(I, y);\n    return i.stringifyUrl({\n      url: w,\n      query: r(f, D),\n      fragmentIdentifier: a\n    }, y);\n  }, i.exclude = (I, D, y) => {\n    const w = Array.isArray(D) ? (f) => !D.includes(f) : (f, a) => !D(f, a);\n    return i.pick(I, w, y);\n  };\n})(ii);\nconst Ac = {\n  waku: {\n    publish: \"waku_publish\",\n    batchPublish: \"waku_batchPublish\",\n    subscribe: \"waku_subscribe\",\n    batchSubscribe: \"waku_batchSubscribe\",\n    subscription: \"waku_subscription\",\n    unsubscribe: \"waku_unsubscribe\",\n    batchUnsubscribe: \"waku_batchUnsubscribe\"\n  },\n  irn: {\n    publish: \"irn_publish\",\n    batchPublish: \"irn_batchPublish\",\n    subscribe: \"irn_subscribe\",\n    batchSubscribe: \"irn_batchSubscribe\",\n    subscription: \"irn_subscription\",\n    unsubscribe: \"irn_unsubscribe\",\n    batchUnsubscribe: \"irn_batchUnsubscribe\"\n  },\n  iridium: {\n    publish: \"iridium_publish\",\n    batchPublish: \"iridium_batchPublish\",\n    subscribe: \"iridium_subscribe\",\n    batchSubscribe: \"iridium_batchSubscribe\",\n    subscription: \"iridium_subscription\",\n    unsubscribe: \"iridium_unsubscribe\",\n    batchUnsubscribe: \"iridium_batchUnsubscribe\"\n  }\n};\nfunction Tc(i, e) {\n  return i.includes(\":\") ? [i] : e.chains || [];\n}\nconst $c = \"base10\", vt = \"base16\", Br = \"base64pad\", pn = \"utf8\", Fc = 0, Di = 1, ep = 0, Po = 1, kr = 12, gn = 32;\nfunction tp() {\n  const i = ms.generateKeyPair();\n  return { privateKey: Ne(i.secretKey, vt), publicKey: Ne(i.publicKey, vt) };\n}\nfunction Hr() {\n  const i = li.randomBytes(gn);\n  return Ne(i, vt);\n}\nfunction ip(i, e) {\n  const t = ms.sharedKey(Ce(i, vt), Ce(e, vt), !0), s = new Rc(Si.SHA256, t).expand(gn);\n  return Ne(s, vt);\n}\nfunction sp(i) {\n  const e = Si.hash(Ce(i, vt));\n  return Ne(e, vt);\n}\nfunction Fi(i) {\n  const e = Si.hash(Ce(i, pn));\n  return Ne(e, vt);\n}\nfunction rp(i) {\n  return Ce(`${i}`, $c);\n}\nfunction ws(i) {\n  return Number(Ne(i, $c));\n}\nfunction np(i) {\n  const e = rp(typeof i.type < \"u\" ? i.type : Fc);\n  if (ws(e) === Di && typeof i.senderPublicKey > \"u\")\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof i.senderPublicKey < \"u\" ? Ce(i.senderPublicKey, vt) : void 0, s = typeof i.iv < \"u\" ? Ce(i.iv, vt) : li.randomBytes(kr), r = new gs.ChaCha20Poly1305(Ce(i.symKey, vt)).seal(s, Ce(i.message, pn));\n  return ap({ type: e, sealed: r, iv: s, senderPublicKey: t });\n}\nfunction op(i) {\n  const e = new gs.ChaCha20Poly1305(Ce(i.symKey, vt)), { sealed: t, iv: s } = Ys(i.encoded), r = e.open(s, t);\n  if (r === null)\n    throw new Error(\"Failed to decrypt\");\n  return Ne(r, pn);\n}\nfunction ap(i) {\n  if (ws(i.type) === Di) {\n    if (typeof i.senderPublicKey > \"u\")\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    return Ne(ls([i.type, i.senderPublicKey, i.iv, i.sealed]), Br);\n  }\n  return Ne(ls([i.type, i.iv, i.sealed]), Br);\n}\nfunction Ys(i) {\n  const e = Ce(i, Br), t = e.slice(ep, Po), s = Po;\n  if (ws(t) === Di) {\n    const c = s + gn, u = c + kr, d = e.slice(s, c), p = e.slice(c, u), b = e.slice(u);\n    return { type: t, sealed: b, iv: p, senderPublicKey: d };\n  }\n  const r = s + kr, n = e.slice(s, r), o = e.slice(r);\n  return { type: t, sealed: o, iv: n };\n}\nfunction cp(i, e) {\n  const t = Ys(i);\n  return Uc({ type: ws(t.type), senderPublicKey: typeof t.senderPublicKey < \"u\" ? Ne(t.senderPublicKey, vt) : void 0, receiverPublicKey: e?.receiverPublicKey });\n}\nfunction Uc(i) {\n  const e = i?.type || Fc;\n  if (e === Di) {\n    if (typeof i?.senderPublicKey > \"u\")\n      throw new Error(\"missing sender public key\");\n    if (typeof i?.receiverPublicKey > \"u\")\n      throw new Error(\"missing receiver public key\");\n  }\n  return { type: e, senderPublicKey: i?.senderPublicKey, receiverPublicKey: i?.receiverPublicKey };\n}\nfunction Ro(i) {\n  return i.type === Di && typeof i.senderPublicKey == \"string\" && typeof i.receiverPublicKey == \"string\";\n}\nvar hp = Object.defineProperty, Co = Object.getOwnPropertySymbols, up = Object.prototype.hasOwnProperty, lp = Object.prototype.propertyIsEnumerable, Ao = (i, e, t) => e in i ? hp(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, To = (i, e) => {\n  for (var t in e || (e = {}))\n    up.call(e, t) && Ao(i, t, e[t]);\n  if (Co)\n    for (var t of Co(e))\n      lp.call(e, t) && Ao(i, t, e[t]);\n  return i;\n};\nconst dp = \"ReactNative\", Ot = { reactNative: \"react-native\", node: \"node\", browser: \"browser\", unknown: \"unknown\" }, fp = \"js\";\nfunction yn() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction ur() {\n  return !un() && !!bs() && navigator.product === dp;\n}\nfunction vs() {\n  return !yn() && !!bs();\n}\nfunction _s() {\n  return ur() ? Ot.reactNative : yn() ? Ot.node : vs() ? Ot.browser : Ot.unknown;\n}\nfunction pp(i, e) {\n  let t = ii.parse(i);\n  return t = To(To({}, t), e), i = ii.stringify(t), i;\n}\nfunction gp() {\n  return fn() || { name: \"\", description: \"\", url: \"\", icons: [\"\"] };\n}\nfunction yp() {\n  if (_s() === Ot.reactNative && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\") {\n    const { OS: t, Version: s } = global.Platform;\n    return [t, s].join(\"-\");\n  }\n  const i = hn();\n  if (i === null)\n    return \"unknown\";\n  const e = i.os ? i.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return i.type === \"browser\" ? [e, i.name, i.version].join(\"-\") : [e, i.version].join(\"-\");\n}\nfunction mp() {\n  var i;\n  const e = _s();\n  return e === Ot.browser ? [e, ((i = ln()) == null ? void 0 : i.host) || \"unknown\"].join(\":\") : e;\n}\nfunction bp(i, e, t) {\n  const s = yp(), r = mp();\n  return [[i, e].join(\"-\"), [fp, t].join(\"-\"), s, r].join(\"/\");\n}\nfunction wp({ protocol: i, version: e, relayUrl: t, sdkVersion: s, auth: r, projectId: n, useOnCloseEvent: o }) {\n  const c = t.split(\"?\"), u = bp(i, e, s), d = { auth: r, ua: u, projectId: n, useOnCloseEvent: o || void 0 }, p = pp(c[1] || \"\", d);\n  return c[0] + \"?\" + p;\n}\nfunction _i(i, e) {\n  return i.filter((t) => e.includes(t)).length === i.length;\n}\nfunction Lc(i) {\n  return Object.fromEntries(i.entries());\n}\nfunction Mc(i) {\n  return new Map(Object.entries(i));\n}\nfunction Ai(i = V.FIVE_MINUTES, e) {\n  const t = V.toMiliseconds(i || V.FIVE_MINUTES);\n  let s, r, n;\n  return { resolve: (o) => {\n    n && s && (clearTimeout(n), s(o));\n  }, reject: (o) => {\n    n && r && (clearTimeout(n), r(o));\n  }, done: () => new Promise((o, c) => {\n    n = setTimeout(() => {\n      c(new Error(e));\n    }, t), s = o, r = c;\n  }) };\n}\nfunction ds(i, e, t) {\n  return new Promise(async (s, r) => {\n    const n = setTimeout(() => r(new Error(t)), e);\n    try {\n      const o = await i;\n      s(o);\n    } catch (o) {\n      r(o);\n    }\n    clearTimeout(n);\n  });\n}\nfunction qc(i, e) {\n  if (typeof e == \"string\" && e.startsWith(`${i}:`))\n    return e;\n  if (i.toLowerCase() === \"topic\") {\n    if (typeof e != \"string\")\n      throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${e}`;\n  } else if (i.toLowerCase() === \"id\") {\n    if (typeof e != \"number\")\n      throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${e}`;\n  }\n  throw new Error(`Unknown expirer target type: ${i}`);\n}\nfunction vp(i) {\n  return qc(\"topic\", i);\n}\nfunction _p(i) {\n  return qc(\"id\", i);\n}\nfunction jc(i) {\n  const [e, t] = i.split(\":\"), s = { id: void 0, topic: void 0 };\n  if (e === \"topic\" && typeof t == \"string\")\n    s.topic = t;\n  else if (e === \"id\" && Number.isInteger(Number(t)))\n    s.id = Number(t);\n  else\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);\n  return s;\n}\nfunction Mt(i, e) {\n  return V.fromMiliseconds((e || Date.now()) + V.toMiliseconds(i));\n}\nfunction ai(i) {\n  return Date.now() >= V.toMiliseconds(i);\n}\nfunction Be(i, e) {\n  return `${i}${e ? `:${e}` : \"\"}`;\n}\nasync function Ep({ id: i, topic: e, wcDeepLink: t }) {\n  try {\n    if (!t)\n      return;\n    let r = (typeof t == \"string\" ? JSON.parse(t) : t)?.href;\n    if (typeof r != \"string\")\n      return;\n    r.endsWith(\"/\") && (r = r.slice(0, -1));\n    const n = `${r}/wc?requestId=${i}&sessionTopic=${e}`, o = _s();\n    o === Ot.browser ? n.startsWith(\"https://\") ? window.open(n, \"_blank\", \"noreferrer noopener\") : window.open(n, \"_self\", \"noreferrer noopener\") : o === Ot.reactNative && typeof (global == null ? void 0 : global.Linking) < \"u\" && await global.Linking.openURL(n);\n  } catch (s) {\n    console.error(s);\n  }\n}\nconst Sp = \"irn\";\nfunction Gr(i) {\n  return i?.relay || { protocol: Sp };\n}\nfunction js(i) {\n  const e = Ac[i];\n  if (typeof e > \"u\")\n    throw new Error(`Relay Protocol not supported: ${i}`);\n  return e;\n}\nvar Ip = Object.defineProperty, $o = Object.getOwnPropertySymbols, Dp = Object.prototype.hasOwnProperty, xp = Object.prototype.propertyIsEnumerable, Fo = (i, e, t) => e in i ? Ip(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Op = (i, e) => {\n  for (var t in e || (e = {}))\n    Dp.call(e, t) && Fo(i, t, e[t]);\n  if ($o)\n    for (var t of $o(e))\n      xp.call(e, t) && Fo(i, t, e[t]);\n  return i;\n};\nfunction Np(i, e = \"-\") {\n  const t = {}, s = \"relay\" + e;\n  return Object.keys(i).forEach((r) => {\n    if (r.startsWith(s)) {\n      const n = r.replace(s, \"\"), o = i[r];\n      t[n] = o;\n    }\n  }), t;\n}\nfunction Pp(i) {\n  const e = i.indexOf(\":\"), t = i.indexOf(\"?\") !== -1 ? i.indexOf(\"?\") : void 0, s = i.substring(0, e), r = i.substring(e + 1, t).split(\"@\"), n = typeof t < \"u\" ? i.substring(t) : \"\", o = ii.parse(n);\n  return { protocol: s, topic: Rp(r[0]), version: parseInt(r[1], 10), symKey: o.symKey, relay: Np(o) };\n}\nfunction Rp(i) {\n  return i.startsWith(\"//\") ? i.substring(2) : i;\n}\nfunction Cp(i, e = \"-\") {\n  const t = \"relay\", s = {};\n  return Object.keys(i).forEach((r) => {\n    const n = t + e + r;\n    i[r] && (s[n] = i[r]);\n  }), s;\n}\nfunction Ap(i) {\n  return `${i.protocol}:${i.topic}@${i.version}?` + ii.stringify(Op({ symKey: i.symKey }, Cp(i.relay)));\n}\nfunction Mi(i) {\n  const e = [];\n  return i.forEach((t) => {\n    const [s, r] = t.split(\":\");\n    e.push(`${s}:${r}`);\n  }), e;\n}\nfunction Tp(i) {\n  const e = [];\n  return Object.values(i).forEach((t) => {\n    e.push(...Mi(t.accounts));\n  }), e;\n}\nfunction $p(i, e) {\n  const t = [];\n  return Object.values(i).forEach((s) => {\n    Mi(s.accounts).includes(e) && t.push(...s.methods);\n  }), t;\n}\nfunction Fp(i, e) {\n  const t = [];\n  return Object.values(i).forEach((s) => {\n    Mi(s.accounts).includes(e) && t.push(...s.events);\n  }), t;\n}\nfunction Up(i, e) {\n  const t = zs(i, e);\n  if (t)\n    throw new Error(t.message);\n  const s = {};\n  for (const [r, n] of Object.entries(i))\n    s[r] = { methods: n.methods, events: n.events, chains: n.accounts.map((o) => `${o.split(\":\")[0]}:${o.split(\":\")[1]}`) };\n  return s;\n}\nconst Lp = { INVALID_METHOD: { message: \"Invalid method.\", code: 1001 }, INVALID_EVENT: { message: \"Invalid event.\", code: 1002 }, INVALID_UPDATE_REQUEST: { message: \"Invalid update request.\", code: 1003 }, INVALID_EXTEND_REQUEST: { message: \"Invalid extend request.\", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: \"Invalid session settle request.\", code: 1005 }, UNAUTHORIZED_METHOD: { message: \"Unauthorized method.\", code: 3001 }, UNAUTHORIZED_EVENT: { message: \"Unauthorized event.\", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: \"Unauthorized update request.\", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: \"Unauthorized extend request.\", code: 3004 }, USER_REJECTED: { message: \"User rejected.\", code: 5e3 }, USER_REJECTED_CHAINS: { message: \"User rejected chains.\", code: 5001 }, USER_REJECTED_METHODS: { message: \"User rejected methods.\", code: 5002 }, USER_REJECTED_EVENTS: { message: \"User rejected events.\", code: 5003 }, UNSUPPORTED_CHAINS: { message: \"Unsupported chains.\", code: 5100 }, UNSUPPORTED_METHODS: { message: \"Unsupported methods.\", code: 5101 }, UNSUPPORTED_EVENTS: { message: \"Unsupported events.\", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: \"Unsupported accounts.\", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: \"Unsupported namespace key.\", code: 5104 }, USER_DISCONNECTED: { message: \"User disconnected.\", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: \"Session settlement failed.\", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: \"Unsupported wc_ method.\", code: 10001 } }, Mp = { NOT_INITIALIZED: { message: \"Not initialized.\", code: 1 }, NO_MATCHING_KEY: { message: \"No matching key.\", code: 2 }, RESTORE_WILL_OVERRIDE: { message: \"Restore will override.\", code: 3 }, RESUBSCRIBED: { message: \"Resubscribed.\", code: 4 }, MISSING_OR_INVALID: { message: \"Missing or invalid.\", code: 5 }, EXPIRED: { message: \"Expired.\", code: 6 }, UNKNOWN_TYPE: { message: \"Unknown type.\", code: 7 }, MISMATCHED_TOPIC: { message: \"Mismatched topic.\", code: 8 }, NON_CONFORMING_NAMESPACES: { message: \"Non conforming namespaces.\", code: 9 } };\nfunction Y(i, e) {\n  const { message: t, code: s } = Mp[i];\n  return { message: e ? `${t} ${e}` : t, code: s };\n}\nfunction nt(i, e) {\n  const { message: t, code: s } = Lp[i];\n  return { message: e ? `${t} ${e}` : t, code: s };\n}\nfunction Es(i, e) {\n  return Array.isArray(i) ? typeof e < \"u\" && i.length ? i.every(e) : !0 : !1;\n}\nfunction cs(i) {\n  return Object.getPrototypeOf(i) === Object.prototype && Object.keys(i).length;\n}\nfunction bt(i) {\n  return typeof i > \"u\";\n}\nfunction ot(i, e) {\n  return e && bt(i) ? !0 : typeof i == \"string\" && !!i.trim().length;\n}\nfunction mn(i, e) {\n  return e && bt(i) ? !0 : typeof i == \"number\" && !isNaN(i);\n}\nfunction qp(i, e) {\n  const { requiredNamespaces: t } = e, s = Object.keys(i.namespaces), r = Object.keys(t);\n  let n = !0;\n  return _i(r, s) ? (s.forEach((o) => {\n    const { accounts: c, methods: u, events: d } = i.namespaces[o], p = Mi(c), b = t[o];\n    (!_i(Tc(o, b), p) || !_i(b.methods, u) || !_i(b.events, d)) && (n = !1);\n  }), n) : !1;\n}\nfunction Js(i) {\n  return ot(i, !1) && i.includes(\":\") ? i.split(\":\").length === 2 : !1;\n}\nfunction jp(i) {\n  if (ot(i, !1) && i.includes(\":\")) {\n    const e = i.split(\":\");\n    if (e.length === 3) {\n      const t = e[0] + \":\" + e[1];\n      return !!e[2] && Js(t);\n    }\n  }\n  return !1;\n}\nfunction zp(i) {\n  if (ot(i, !1))\n    try {\n      return typeof new URL(i) < \"u\";\n    } catch {\n      return !1;\n    }\n  return !1;\n}\nfunction Kp(i) {\n  var e;\n  return (e = i?.proposer) == null ? void 0 : e.publicKey;\n}\nfunction Vp(i) {\n  return i?.topic;\n}\nfunction Bp(i, e) {\n  let t = null;\n  return ot(i?.publicKey, !1) || (t = Y(\"MISSING_OR_INVALID\", `${e} controller public key should be a string`)), t;\n}\nfunction Uo(i) {\n  let e = !0;\n  return Es(i) ? i.length && (e = i.every((t) => ot(t, !1))) : e = !1, e;\n}\nfunction kp(i, e, t) {\n  let s = null;\n  return Es(e) && e.length ? e.forEach((r) => {\n    s || Js(r) || (s = nt(\"UNSUPPORTED_CHAINS\", `${t}, chain ${r} should be a string and conform to \"namespace:chainId\" format`));\n  }) : Js(i) || (s = nt(\"UNSUPPORTED_CHAINS\", `${t}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`)), s;\n}\nfunction Hp(i, e, t) {\n  let s = null;\n  return Object.entries(i).forEach(([r, n]) => {\n    if (s)\n      return;\n    const o = kp(r, Tc(r, n), `${e} ${t}`);\n    o && (s = o);\n  }), s;\n}\nfunction Gp(i, e) {\n  let t = null;\n  return Es(i) ? i.forEach((s) => {\n    t || jp(s) || (t = nt(\"UNSUPPORTED_ACCOUNTS\", `${e}, account ${s} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = nt(\"UNSUPPORTED_ACCOUNTS\", `${e}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction Wp(i, e) {\n  let t = null;\n  return Object.values(i).forEach((s) => {\n    if (t)\n      return;\n    const r = Gp(s?.accounts, `${e} namespace`);\n    r && (t = r);\n  }), t;\n}\nfunction Yp(i, e) {\n  let t = null;\n  return Uo(i?.methods) ? Uo(i?.events) || (t = nt(\"UNSUPPORTED_EVENTS\", `${e}, events should be an array of strings or empty array for no events`)) : t = nt(\"UNSUPPORTED_METHODS\", `${e}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction zc(i, e) {\n  let t = null;\n  return Object.values(i).forEach((s) => {\n    if (t)\n      return;\n    const r = Yp(s, `${e}, namespace`);\n    r && (t = r);\n  }), t;\n}\nfunction Jp(i, e, t) {\n  let s = null;\n  if (i && cs(i)) {\n    const r = zc(i, e);\n    r && (s = r);\n    const n = Hp(i, e, t);\n    n && (s = n);\n  } else\n    s = Y(\"MISSING_OR_INVALID\", `${e}, ${t} should be an object with data`);\n  return s;\n}\nfunction zs(i, e) {\n  let t = null;\n  if (i && cs(i)) {\n    const s = zc(i, e);\n    s && (t = s);\n    const r = Wp(i, e);\n    r && (t = r);\n  } else\n    t = Y(\"MISSING_OR_INVALID\", `${e}, namespaces should be an object with data`);\n  return t;\n}\nfunction Kc(i) {\n  return ot(i.protocol, !0);\n}\nfunction Qp(i, e) {\n  let t = !1;\n  return e && !i ? t = !0 : i && Es(i) && i.length && i.forEach((s) => {\n    t = Kc(s);\n  }), t;\n}\nfunction Xp(i) {\n  return typeof i == \"number\";\n}\nfunction St(i) {\n  return typeof i < \"u\" && typeof i !== null;\n}\nfunction Zp(i) {\n  return !(!i || typeof i != \"object\" || !i.code || !mn(i.code, !1) || !i.message || !ot(i.message, !1));\n}\nfunction eg(i) {\n  return !(bt(i) || !ot(i.method, !1));\n}\nfunction tg(i) {\n  return !(bt(i) || bt(i.result) && bt(i.error) || !mn(i.id, !1) || !ot(i.jsonrpc, !1));\n}\nfunction ig(i) {\n  return !(bt(i) || !ot(i.name, !1));\n}\nfunction Lo(i, e) {\n  return !(!Js(e) || !Tp(i).includes(e));\n}\nfunction sg(i, e, t) {\n  return ot(t, !1) ? $p(i, e).includes(t) : !1;\n}\nfunction rg(i, e, t) {\n  return ot(t, !1) ? Fp(i, e).includes(t) : !1;\n}\nfunction Mo(i, e, t) {\n  let s = null;\n  const r = ng(i), n = og(e), o = Object.keys(r), c = Object.keys(n), u = qo(Object.keys(i)), d = qo(Object.keys(e)), p = u.filter((b) => !d.includes(b));\n  return p.length && (s = Y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${p.toString()}\n      Received: ${Object.keys(e).toString()}`)), _i(o, c) || (s = Y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${o.toString()}\n      Approved: ${c.toString()}`)), Object.keys(e).forEach((b) => {\n    if (!b.includes(\":\") || s)\n      return;\n    const x = Mi(e[b].accounts);\n    x.includes(b) || (s = Y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${b}\n        Required: ${b}\n        Approved: ${x.toString()}`));\n  }), o.forEach((b) => {\n    s || (_i(r[b].methods, n[b].methods) ? _i(r[b].events, n[b].events) || (s = Y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${b}`)) : s = Y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${b}`));\n  }), s;\n}\nfunction ng(i) {\n  const e = {};\n  return Object.keys(i).forEach((t) => {\n    var s;\n    t.includes(\":\") ? e[t] = i[t] : (s = i[t].chains) == null || s.forEach((r) => {\n      e[r] = { methods: i[t].methods, events: i[t].events };\n    });\n  }), e;\n}\nfunction qo(i) {\n  return [...new Set(i.map((e) => e.includes(\":\") ? e.split(\":\")[0] : e))];\n}\nfunction og(i) {\n  const e = {};\n  return Object.keys(i).forEach((t) => {\n    t.includes(\":\") ? e[t] = i[t] : Mi(i[t].accounts)?.forEach((r) => {\n      e[r] = { accounts: i[t].accounts.filter((n) => n.includes(`${r}:`)), methods: i[t].methods, events: i[t].events };\n    });\n  }), e;\n}\nfunction ag(i, e) {\n  return mn(i, !1) && i <= e.max && i >= e.min;\n}\nfunction jo() {\n  const i = _s();\n  return new Promise((e) => {\n    switch (i) {\n      case Ot.browser:\n        e(cg());\n        break;\n      case Ot.reactNative:\n        e(hg());\n        break;\n      case Ot.node:\n        e(ug());\n        break;\n      default:\n        e(!0);\n    }\n  });\n}\nfunction cg() {\n  return vs() && navigator?.onLine;\n}\nasync function hg() {\n  return ur() && typeof global < \"u\" && global != null && global.NetInfo ? (await (global == null ? void 0 : global.NetInfo.fetch()))?.isConnected : !0;\n}\nfunction ug() {\n  return !0;\n}\nfunction lg(i) {\n  switch (_s()) {\n    case Ot.browser:\n      dg(i);\n      break;\n    case Ot.reactNative:\n      fg(i);\n      break;\n  }\n}\nfunction dg(i) {\n  vs() && (window.addEventListener(\"online\", () => i(!0)), window.addEventListener(\"offline\", () => i(!1)));\n}\nfunction fg(i) {\n  ur() && typeof global < \"u\" && global != null && global.NetInfo && global?.NetInfo.addEventListener((e) => i(e?.isConnected));\n}\nconst xr = {};\nlet $s = class {\n  static get(e) {\n    return xr[e];\n  }\n  static set(e, t) {\n    xr[e] = t;\n  }\n  static delete(e) {\n    delete xr[e];\n  }\n};\nconst pg = \"PARSE_ERROR\", gg = \"INVALID_REQUEST\", yg = \"METHOD_NOT_FOUND\", mg = \"INVALID_PARAMS\", Vc = \"INTERNAL_ERROR\", bn = \"SERVER_ERROR\", bg = [-32700, -32600, -32601, -32602, -32603], hs = {\n  [pg]: { code: -32700, message: \"Parse error\" },\n  [gg]: { code: -32600, message: \"Invalid Request\" },\n  [yg]: { code: -32601, message: \"Method not found\" },\n  [mg]: { code: -32602, message: \"Invalid params\" },\n  [Vc]: { code: -32603, message: \"Internal error\" },\n  [bn]: { code: -32e3, message: \"Server error\" }\n}, Bc = bn;\nfunction wg(i) {\n  return bg.includes(i);\n}\nfunction zo(i) {\n  return Object.keys(hs).includes(i) ? hs[i] : hs[Bc];\n}\nfunction vg(i) {\n  const e = Object.values(hs).find((t) => t.code === i);\n  return e || hs[Bc];\n}\nfunction _g(i, e, t) {\n  return i.message.includes(\"getaddrinfo ENOTFOUND\") || i.message.includes(\"connect ECONNREFUSED\") ? new Error(`Unavailable ${t} RPC url at ${e}`) : i;\n}\nvar kc = {}, Qt = {}, Ko;\nfunction Eg() {\n  if (Ko)\n    return Qt;\n  Ko = 1, Object.defineProperty(Qt, \"__esModule\", { value: !0 }), Qt.isBrowserCryptoAvailable = Qt.getSubtleCrypto = Qt.getBrowerCrypto = void 0;\n  function i() {\n    return (_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c === null || _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c === void 0 ? void 0 : _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c.crypto) || (_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c === null || _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c === void 0 ? void 0 : _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c.msCrypto) || {};\n  }\n  Qt.getBrowerCrypto = i;\n  function e() {\n    const s = i();\n    return s.subtle || s.webkitSubtle;\n  }\n  Qt.getSubtleCrypto = e;\n  function t() {\n    return !!i() && !!e();\n  }\n  return Qt.isBrowserCryptoAvailable = t, Qt;\n}\nvar Xt = {}, Vo;\nfunction Sg() {\n  if (Vo)\n    return Xt;\n  Vo = 1, Object.defineProperty(Xt, \"__esModule\", { value: !0 }), Xt.isBrowser = Xt.isNode = Xt.isReactNative = void 0;\n  function i() {\n    return typeof document > \"u\" && typeof navigator < \"u\" && navigator.product === \"ReactNative\";\n  }\n  Xt.isReactNative = i;\n  function e() {\n    return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n  }\n  Xt.isNode = e;\n  function t() {\n    return !i() && !e();\n  }\n  return Xt.isBrowser = t, Xt;\n}\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  const e = Ft;\n  e.__exportStar(Eg(), i), e.__exportStar(Sg(), i);\n})(kc);\nfunction wn(i = 3) {\n  const e = Date.now() * Math.pow(10, i), t = Math.floor(Math.random() * Math.pow(10, i));\n  return e + t;\n}\nfunction vn(i = 6) {\n  return BigInt(wn(i));\n}\nfunction ti(i, e, t) {\n  return {\n    id: t || wn(),\n    jsonrpc: \"2.0\",\n    method: i,\n    params: e\n  };\n}\nfunction xi(i, e) {\n  return {\n    id: i,\n    jsonrpc: \"2.0\",\n    result: e\n  };\n}\nfunction qi(i, e, t) {\n  return {\n    id: i,\n    jsonrpc: \"2.0\",\n    error: Ig(e, t)\n  };\n}\nfunction Ig(i, e) {\n  return typeof i > \"u\" ? zo(Vc) : (typeof i == \"string\" && (i = Object.assign(Object.assign({}, zo(bn)), { message: i })), typeof e < \"u\" && (i.data = e), wg(i.code) && (i = vg(i.code)), i);\n}\nclass Hc {\n}\nclass Dg extends Hc {\n  constructor(e) {\n    super();\n  }\n}\nclass xg extends Hc {\n  constructor() {\n    super();\n  }\n}\nclass Og extends xg {\n  constructor(e) {\n    super();\n  }\n}\nconst Ng = \"^wss?:\";\nfunction Pg(i) {\n  const e = i.match(new RegExp(/^\\w+:/, \"gi\"));\n  if (!(!e || !e.length))\n    return e[0];\n}\nfunction Rg(i, e) {\n  const t = Pg(i);\n  return typeof t > \"u\" ? !1 : new RegExp(e).test(t);\n}\nfunction Bo(i) {\n  return Rg(i, Ng);\n}\nfunction Cg(i) {\n  return new RegExp(\"wss?://localhost(:d{2,5})?\").test(i);\n}\nfunction Gc(i) {\n  return typeof i == \"object\" && \"id\" in i && \"jsonrpc\" in i && i.jsonrpc === \"2.0\";\n}\nfunction ji(i) {\n  return Gc(i) && \"method\" in i;\n}\nfunction Oi(i) {\n  return Gc(i) && (ht(i) || Ge(i));\n}\nfunction ht(i) {\n  return \"result\" in i;\n}\nfunction Ge(i) {\n  return \"error\" in i;\n}\nclass _n extends Og {\n  constructor(e) {\n    super(e), this.events = new We.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();\n  }\n  async connect(e = this.connection) {\n    await this.open(e);\n  }\n  async disconnect() {\n    await this.close();\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async request(e, t) {\n    return this.requestStrict(ti(e.method, e.params || [], e.id || vn().toString()), t);\n  }\n  async requestStrict(e, t) {\n    return new Promise(async (s, r) => {\n      if (!this.connection.connected)\n        try {\n          await this.open();\n        } catch (n) {\n          r(n);\n        }\n      this.events.on(`${e.id}`, (n) => {\n        Ge(n) ? r(n.error) : s(n.result);\n      });\n      try {\n        await this.connection.send(e, t);\n      } catch (n) {\n        r(n);\n      }\n    });\n  }\n  setConnection(e = this.connection) {\n    return e;\n  }\n  onPayload(e) {\n    this.events.emit(\"payload\", e), Oi(e) ? this.events.emit(`${e.id}`, e) : this.events.emit(\"message\", {\n      type: e.method,\n      data: e.params\n    });\n  }\n  onClose(e) {\n    e && e.code === 3e3 && this.events.emit(\"error\", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : \"\"}`)), this.events.emit(\"disconnect\");\n  }\n  async open(e = this.connection) {\n    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == \"string\" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit(\"connect\"));\n  }\n  async close() {\n    await this.connection.close();\n  }\n  registerEventListeners() {\n    this.hasRegisteredEventListeners || (this.connection.on(\"payload\", (e) => this.onPayload(e)), this.connection.on(\"close\", (e) => this.onClose(e)), this.connection.on(\"error\", (e) => this.events.emit(\"error\", e)), this.connection.on(\"register_error\", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);\n  }\n}\nconst Ag = () => typeof WebSocket < \"u\" ? WebSocket : typeof global < \"u\" && typeof global.WebSocket < \"u\" ? global.WebSocket : typeof window < \"u\" && typeof window.WebSocket < \"u\" ? window.WebSocket : typeof self < \"u\" && typeof self.WebSocket < \"u\" ? self.WebSocket : require(\"ws\"), Tg = () => typeof WebSocket < \"u\" || typeof global < \"u\" && typeof global.WebSocket < \"u\" || typeof window < \"u\" && typeof window.WebSocket < \"u\" || typeof self < \"u\" && typeof self.WebSocket < \"u\", ko = (i) => i.split(\"?\")[0], Ho = 10, $g = Ag();\nclass Wc {\n  constructor(e) {\n    if (this.url = e, this.events = new We.EventEmitter(), this.registering = !1, !Bo(e))\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);\n    this.url = e;\n  }\n  get connected() {\n    return typeof this.socket < \"u\";\n  }\n  get connecting() {\n    return this.registering;\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async open(e = this.url) {\n    await this.register(e);\n  }\n  async close() {\n    return new Promise((e, t) => {\n      if (typeof this.socket > \"u\") {\n        t(new Error(\"Connection already closed\"));\n        return;\n      }\n      this.socket.onclose = (s) => {\n        this.onClose(s), e();\n      }, this.socket.close();\n    });\n  }\n  async send(e, t) {\n    typeof this.socket > \"u\" && (this.socket = await this.register());\n    try {\n      this.socket.send(rr(e));\n    } catch (s) {\n      this.onError(e.id, s);\n    }\n  }\n  register(e = this.url) {\n    if (!Bo(e))\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);\n    if (this.registering) {\n      const t = this.events.getMaxListeners();\n      return (this.events.listenerCount(\"register_error\") >= t || this.events.listenerCount(\"open\") >= t) && this.events.setMaxListeners(t + 1), new Promise((s, r) => {\n        this.events.once(\"register_error\", (n) => {\n          this.resetMaxListeners(), r(n);\n        }), this.events.once(\"open\", () => {\n          if (this.resetMaxListeners(), typeof this.socket > \"u\")\n            return r(new Error(\"WebSocket connection is missing or invalid\"));\n          s(this.socket);\n        });\n      });\n    }\n    return this.url = e, this.registering = !0, new Promise((t, s) => {\n      const r = kc.isReactNative() ? void 0 : { rejectUnauthorized: !Cg(e) }, n = new $g(e, [], r);\n      Tg() ? n.onerror = (o) => {\n        const c = o;\n        s(this.emitError(c.error));\n      } : n.on(\"error\", (o) => {\n        s(this.emitError(o));\n      }), n.onopen = () => {\n        this.onOpen(n), t(n);\n      };\n    });\n  }\n  onOpen(e) {\n    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = !1, this.events.emit(\"open\");\n  }\n  onClose(e) {\n    this.socket = void 0, this.registering = !1, this.events.emit(\"close\", e);\n  }\n  onPayload(e) {\n    if (typeof e.data > \"u\")\n      return;\n    const t = typeof e.data == \"string\" ? rn(e.data) : e.data;\n    this.events.emit(\"payload\", t);\n  }\n  onError(e, t) {\n    const s = this.parseError(t), r = s.message || s.toString(), n = qi(e, r);\n    this.events.emit(\"payload\", n);\n  }\n  parseError(e, t = this.url) {\n    return _g(e, ko(t), \"WS\");\n  }\n  resetMaxListeners() {\n    this.events.getMaxListeners() > Ho && this.events.setMaxListeners(Ho);\n  }\n  emitError(e) {\n    const t = this.parseError(new Error(e?.message || `WebSocket connection failed for host: ${ko(this.url)}`));\n    return this.events.emit(\"register_error\", t), t;\n  }\n}\nvar Qs = { exports: {} };\nQs.exports;\n(function(i, e) {\n  var t = 200, s = \"__lodash_hash_undefined__\", r = 1, n = 2, o = 9007199254740991, c = \"[object Arguments]\", u = \"[object Array]\", d = \"[object AsyncFunction]\", p = \"[object Boolean]\", b = \"[object Date]\", x = \"[object Error]\", O = \"[object Function]\", _ = \"[object GeneratorFunction]\", C = \"[object Map]\", F = \"[object Number]\", K = \"[object Null]\", I = \"[object Object]\", D = \"[object Promise]\", y = \"[object Proxy]\", w = \"[object RegExp]\", f = \"[object Set]\", a = \"[object String]\", l = \"[object Symbol]\", L = \"[object Undefined]\", v = \"[object WeakMap]\", R = \"[object ArrayBuffer]\", $ = \"[object DataView]\", q = \"[object Float32Array]\", m = \"[object Float64Array]\", E = \"[object Int8Array]\", B = \"[object Int16Array]\", z = \"[object Int32Array]\", j = \"[object Uint8Array]\", U = \"[object Uint8ClampedArray]\", M = \"[object Uint16Array]\", H = \"[object Uint32Array]\", te = /[\\\\^$.*+?()[\\]{}|]/g, G = /^\\[object .+?Constructor\\]$/, ie = /^(?:0|[1-9]\\d*)$/, Q = {};\n  Q[q] = Q[m] = Q[E] = Q[B] = Q[z] = Q[j] = Q[U] = Q[M] = Q[H] = !0, Q[c] = Q[u] = Q[R] = Q[p] = Q[$] = Q[b] = Q[x] = Q[O] = Q[C] = Q[F] = Q[I] = Q[w] = Q[f] = Q[a] = Q[v] = !1;\n  var se = typeof _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c == \"object\" && _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c && _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c.Object === Object && _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c, T = typeof self == \"object\" && self && self.Object === Object && self, A = se || T || Function(\"return this\")(), N = e && !e.nodeType && e, h = N && !0 && i && !i.nodeType && i, S = h && h.exports === N, W = S && se.process, X = function() {\n    try {\n      return W && W.binding && W.binding(\"util\");\n    } catch {\n    }\n  }(), fe = X && X.isTypedArray;\n  function ve(g, P) {\n    for (var k = -1, Z = g == null ? 0 : g.length, Re = 0, ae = []; ++k < Z; ) {\n      var Le = g[k];\n      P(Le, k, g) && (ae[Re++] = Le);\n    }\n    return ae;\n  }\n  function ge(g, P) {\n    for (var k = -1, Z = P.length, Re = g.length; ++k < Z; )\n      g[Re + k] = P[k];\n    return g;\n  }\n  function Se(g, P) {\n    for (var k = -1, Z = g == null ? 0 : g.length; ++k < Z; )\n      if (P(g[k], k, g))\n        return !0;\n    return !1;\n  }\n  function Me(g, P) {\n    for (var k = -1, Z = Array(g); ++k < g; )\n      Z[k] = P(k);\n    return Z;\n  }\n  function $e(g) {\n    return function(P) {\n      return g(P);\n    };\n  }\n  function be(g, P) {\n    return g.has(P);\n  }\n  function ye(g, P) {\n    return g?.[P];\n  }\n  function pe(g) {\n    var P = -1, k = Array(g.size);\n    return g.forEach(function(Z, Re) {\n      k[++P] = [Re, Z];\n    }), k;\n  }\n  function le(g, P) {\n    return function(k) {\n      return g(P(k));\n    };\n  }\n  function ue(g) {\n    var P = -1, k = Array(g.size);\n    return g.forEach(function(Z) {\n      k[++P] = Z;\n    }), k;\n  }\n  var he = Array.prototype, ce = Function.prototype, re = Object.prototype, de = A[\"__core-js_shared__\"], me = ce.toString, ne = re.hasOwnProperty, _e = function() {\n    var g = /[^.]+$/.exec(de && de.keys && de.keys.IE_PROTO || \"\");\n    return g ? \"Symbol(src)_1.\" + g : \"\";\n  }(), Ee = re.toString, De = RegExp(\n    \"^\" + me.call(ne).replace(te, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n  ), xe = S ? A.Buffer : void 0, Ie = A.Symbol, Ut = A.Uint8Array, qt = re.propertyIsEnumerable, si = he.splice, Dt = Ie ? Ie.toStringTag : void 0, fi = Object.getOwnPropertySymbols, Ki = xe ? xe.isBuffer : void 0, Os = le(Object.keys, Object), qe = Pi(A, \"DataView\"), Fe = Pi(A, \"Map\"), je = Pi(A, \"Promise\"), ze = Pi(A, \"Set\"), Ke = Pi(A, \"WeakMap\"), Ue = Pi(Object, \"create\"), Qe = gi(qe), Xe = gi(Fe), Ze = gi(je), et = gi(ze), tt = gi(Ke), Ye = Ie ? Ie.prototype : void 0, Ve = Ye ? Ye.valueOf : void 0;\n  function Ae(g) {\n    var P = -1, k = g == null ? 0 : g.length;\n    for (this.clear(); ++P < k; ) {\n      var Z = g[P];\n      this.set(Z[0], Z[1]);\n    }\n  }\n  function it() {\n    this.__data__ = Ue ? Ue(null) : {}, this.size = 0;\n  }\n  function st(g) {\n    var P = this.has(g) && delete this.__data__[g];\n    return this.size -= P ? 1 : 0, P;\n  }\n  function kh(g) {\n    var P = this.__data__;\n    if (Ue) {\n      var k = P[g];\n      return k === s ? void 0 : k;\n    }\n    return ne.call(P, g) ? P[g] : void 0;\n  }\n  function Hh(g) {\n    var P = this.__data__;\n    return Ue ? P[g] !== void 0 : ne.call(P, g);\n  }\n  function Gh(g, P) {\n    var k = this.__data__;\n    return this.size += this.has(g) ? 0 : 1, k[g] = Ue && P === void 0 ? s : P, this;\n  }\n  Ae.prototype.clear = it, Ae.prototype.delete = st, Ae.prototype.get = kh, Ae.prototype.has = Hh, Ae.prototype.set = Gh;\n  function Yt(g) {\n    var P = -1, k = g == null ? 0 : g.length;\n    for (this.clear(); ++P < k; ) {\n      var Z = g[P];\n      this.set(Z[0], Z[1]);\n    }\n  }\n  function Wh() {\n    this.__data__ = [], this.size = 0;\n  }\n  function Yh(g) {\n    var P = this.__data__, k = Ps(P, g);\n    if (k < 0)\n      return !1;\n    var Z = P.length - 1;\n    return k == Z ? P.pop() : si.call(P, k, 1), --this.size, !0;\n  }\n  function Jh(g) {\n    var P = this.__data__, k = Ps(P, g);\n    return k < 0 ? void 0 : P[k][1];\n  }\n  function Qh(g) {\n    return Ps(this.__data__, g) > -1;\n  }\n  function Xh(g, P) {\n    var k = this.__data__, Z = Ps(k, g);\n    return Z < 0 ? (++this.size, k.push([g, P])) : k[Z][1] = P, this;\n  }\n  Yt.prototype.clear = Wh, Yt.prototype.delete = Yh, Yt.prototype.get = Jh, Yt.prototype.has = Qh, Yt.prototype.set = Xh;\n  function pi(g) {\n    var P = -1, k = g == null ? 0 : g.length;\n    for (this.clear(); ++P < k; ) {\n      var Z = g[P];\n      this.set(Z[0], Z[1]);\n    }\n  }\n  function Zh() {\n    this.size = 0, this.__data__ = {\n      hash: new Ae(),\n      map: new (Fe || Yt)(),\n      string: new Ae()\n    };\n  }\n  function eu(g) {\n    var P = Rs(this, g).delete(g);\n    return this.size -= P ? 1 : 0, P;\n  }\n  function tu(g) {\n    return Rs(this, g).get(g);\n  }\n  function iu(g) {\n    return Rs(this, g).has(g);\n  }\n  function su(g, P) {\n    var k = Rs(this, g), Z = k.size;\n    return k.set(g, P), this.size += k.size == Z ? 0 : 1, this;\n  }\n  pi.prototype.clear = Zh, pi.prototype.delete = eu, pi.prototype.get = tu, pi.prototype.has = iu, pi.prototype.set = su;\n  function Ns(g) {\n    var P = -1, k = g == null ? 0 : g.length;\n    for (this.__data__ = new pi(); ++P < k; )\n      this.add(g[P]);\n  }\n  function ru(g) {\n    return this.__data__.set(g, s), this;\n  }\n  function nu(g) {\n    return this.__data__.has(g);\n  }\n  Ns.prototype.add = Ns.prototype.push = ru, Ns.prototype.has = nu;\n  function ri(g) {\n    var P = this.__data__ = new Yt(g);\n    this.size = P.size;\n  }\n  function ou() {\n    this.__data__ = new Yt(), this.size = 0;\n  }\n  function au(g) {\n    var P = this.__data__, k = P.delete(g);\n    return this.size = P.size, k;\n  }\n  function cu(g) {\n    return this.__data__.get(g);\n  }\n  function hu(g) {\n    return this.__data__.has(g);\n  }\n  function uu(g, P) {\n    var k = this.__data__;\n    if (k instanceof Yt) {\n      var Z = k.__data__;\n      if (!Fe || Z.length < t - 1)\n        return Z.push([g, P]), this.size = ++k.size, this;\n      k = this.__data__ = new pi(Z);\n    }\n    return k.set(g, P), this.size = k.size, this;\n  }\n  ri.prototype.clear = ou, ri.prototype.delete = au, ri.prototype.get = cu, ri.prototype.has = hu, ri.prototype.set = uu;\n  function lu(g, P) {\n    var k = Cs(g), Z = !k && xu(g), Re = !k && !Z && gr(g), ae = !k && !Z && !Re && Kn(g), Le = k || Z || Re || ae, rt = Le ? Me(g.length, String) : [], ct = rt.length;\n    for (var Te in g)\n      (P || ne.call(g, Te)) && !(Le && // Safari 9 has enumerable `arguments.length` in strict mode.\n      (Te == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n      Re && (Te == \"offset\" || Te == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n      ae && (Te == \"buffer\" || Te == \"byteLength\" || Te == \"byteOffset\") || // Skip index properties.\n      _u(Te, ct))) && rt.push(Te);\n    return rt;\n  }\n  function Ps(g, P) {\n    for (var k = g.length; k--; )\n      if (Mn(g[k][0], P))\n        return k;\n    return -1;\n  }\n  function du(g, P, k) {\n    var Z = P(g);\n    return Cs(g) ? Z : ge(Z, k(g));\n  }\n  function Vi(g) {\n    return g == null ? g === void 0 ? L : K : Dt && Dt in Object(g) ? wu(g) : Du(g);\n  }\n  function $n(g) {\n    return Bi(g) && Vi(g) == c;\n  }\n  function Fn(g, P, k, Z, Re) {\n    return g === P ? !0 : g == null || P == null || !Bi(g) && !Bi(P) ? g !== g && P !== P : fu(g, P, k, Z, Fn, Re);\n  }\n  function fu(g, P, k, Z, Re, ae) {\n    var Le = Cs(g), rt = Cs(P), ct = Le ? u : ni(g), Te = rt ? u : ni(P);\n    ct = ct == c ? I : ct, Te = Te == c ? I : Te;\n    var xt = ct == I, Lt = Te == I, ft = ct == Te;\n    if (ft && gr(g)) {\n      if (!gr(P))\n        return !1;\n      Le = !0, xt = !1;\n    }\n    if (ft && !xt)\n      return ae || (ae = new ri()), Le || Kn(g) ? Un(g, P, k, Z, Re, ae) : mu(g, P, ct, k, Z, Re, ae);\n    if (!(k & r)) {\n      var Rt = xt && ne.call(g, \"__wrapped__\"), Ct = Lt && ne.call(P, \"__wrapped__\");\n      if (Rt || Ct) {\n        var oi = Rt ? g.value() : g, Jt = Ct ? P.value() : P;\n        return ae || (ae = new ri()), Re(oi, Jt, k, Z, ae);\n      }\n    }\n    return ft ? (ae || (ae = new ri()), bu(g, P, k, Z, Re, ae)) : !1;\n  }\n  function pu(g) {\n    if (!zn(g) || Su(g))\n      return !1;\n    var P = qn(g) ? De : G;\n    return P.test(gi(g));\n  }\n  function gu(g) {\n    return Bi(g) && jn(g.length) && !!Q[Vi(g)];\n  }\n  function yu(g) {\n    if (!Iu(g))\n      return Os(g);\n    var P = [];\n    for (var k in Object(g))\n      ne.call(g, k) && k != \"constructor\" && P.push(k);\n    return P;\n  }\n  function Un(g, P, k, Z, Re, ae) {\n    var Le = k & r, rt = g.length, ct = P.length;\n    if (rt != ct && !(Le && ct > rt))\n      return !1;\n    var Te = ae.get(g);\n    if (Te && ae.get(P))\n      return Te == P;\n    var xt = -1, Lt = !0, ft = k & n ? new Ns() : void 0;\n    for (ae.set(g, P), ae.set(P, g); ++xt < rt; ) {\n      var Rt = g[xt], Ct = P[xt];\n      if (Z)\n        var oi = Le ? Z(Ct, Rt, xt, P, g, ae) : Z(Rt, Ct, xt, g, P, ae);\n      if (oi !== void 0) {\n        if (oi)\n          continue;\n        Lt = !1;\n        break;\n      }\n      if (ft) {\n        if (!Se(P, function(Jt, yi) {\n          if (!be(ft, yi) && (Rt === Jt || Re(Rt, Jt, k, Z, ae)))\n            return ft.push(yi);\n        })) {\n          Lt = !1;\n          break;\n        }\n      } else if (!(Rt === Ct || Re(Rt, Ct, k, Z, ae))) {\n        Lt = !1;\n        break;\n      }\n    }\n    return ae.delete(g), ae.delete(P), Lt;\n  }\n  function mu(g, P, k, Z, Re, ae, Le) {\n    switch (k) {\n      case $:\n        if (g.byteLength != P.byteLength || g.byteOffset != P.byteOffset)\n          return !1;\n        g = g.buffer, P = P.buffer;\n      case R:\n        return !(g.byteLength != P.byteLength || !ae(new Ut(g), new Ut(P)));\n      case p:\n      case b:\n      case F:\n        return Mn(+g, +P);\n      case x:\n        return g.name == P.name && g.message == P.message;\n      case w:\n      case a:\n        return g == P + \"\";\n      case C:\n        var rt = pe;\n      case f:\n        var ct = Z & r;\n        if (rt || (rt = ue), g.size != P.size && !ct)\n          return !1;\n        var Te = Le.get(g);\n        if (Te)\n          return Te == P;\n        Z |= n, Le.set(g, P);\n        var xt = Un(rt(g), rt(P), Z, Re, ae, Le);\n        return Le.delete(g), xt;\n      case l:\n        if (Ve)\n          return Ve.call(g) == Ve.call(P);\n    }\n    return !1;\n  }\n  function bu(g, P, k, Z, Re, ae) {\n    var Le = k & r, rt = Ln(g), ct = rt.length, Te = Ln(P), xt = Te.length;\n    if (ct != xt && !Le)\n      return !1;\n    for (var Lt = ct; Lt--; ) {\n      var ft = rt[Lt];\n      if (!(Le ? ft in P : ne.call(P, ft)))\n        return !1;\n    }\n    var Rt = ae.get(g);\n    if (Rt && ae.get(P))\n      return Rt == P;\n    var Ct = !0;\n    ae.set(g, P), ae.set(P, g);\n    for (var oi = Le; ++Lt < ct; ) {\n      ft = rt[Lt];\n      var Jt = g[ft], yi = P[ft];\n      if (Z)\n        var Vn = Le ? Z(yi, Jt, ft, P, g, ae) : Z(Jt, yi, ft, g, P, ae);\n      if (!(Vn === void 0 ? Jt === yi || Re(Jt, yi, k, Z, ae) : Vn)) {\n        Ct = !1;\n        break;\n      }\n      oi || (oi = ft == \"constructor\");\n    }\n    if (Ct && !oi) {\n      var As = g.constructor, Ts = P.constructor;\n      As != Ts && \"constructor\" in g && \"constructor\" in P && !(typeof As == \"function\" && As instanceof As && typeof Ts == \"function\" && Ts instanceof Ts) && (Ct = !1);\n    }\n    return ae.delete(g), ae.delete(P), Ct;\n  }\n  function Ln(g) {\n    return du(g, Pu, vu);\n  }\n  function Rs(g, P) {\n    var k = g.__data__;\n    return Eu(P) ? k[typeof P == \"string\" ? \"string\" : \"hash\"] : k.map;\n  }\n  function Pi(g, P) {\n    var k = ye(g, P);\n    return pu(k) ? k : void 0;\n  }\n  function wu(g) {\n    var P = ne.call(g, Dt), k = g[Dt];\n    try {\n      g[Dt] = void 0;\n      var Z = !0;\n    } catch {\n    }\n    var Re = Ee.call(g);\n    return Z && (P ? g[Dt] = k : delete g[Dt]), Re;\n  }\n  var vu = fi ? function(g) {\n    return g == null ? [] : (g = Object(g), ve(fi(g), function(P) {\n      return qt.call(g, P);\n    }));\n  } : Ru, ni = Vi;\n  (qe && ni(new qe(new ArrayBuffer(1))) != $ || Fe && ni(new Fe()) != C || je && ni(je.resolve()) != D || ze && ni(new ze()) != f || Ke && ni(new Ke()) != v) && (ni = function(g) {\n    var P = Vi(g), k = P == I ? g.constructor : void 0, Z = k ? gi(k) : \"\";\n    if (Z)\n      switch (Z) {\n        case Qe:\n          return $;\n        case Xe:\n          return C;\n        case Ze:\n          return D;\n        case et:\n          return f;\n        case tt:\n          return v;\n      }\n    return P;\n  });\n  function _u(g, P) {\n    return P = P ?? o, !!P && (typeof g == \"number\" || ie.test(g)) && g > -1 && g % 1 == 0 && g < P;\n  }\n  function Eu(g) {\n    var P = typeof g;\n    return P == \"string\" || P == \"number\" || P == \"symbol\" || P == \"boolean\" ? g !== \"__proto__\" : g === null;\n  }\n  function Su(g) {\n    return !!_e && _e in g;\n  }\n  function Iu(g) {\n    var P = g && g.constructor, k = typeof P == \"function\" && P.prototype || re;\n    return g === k;\n  }\n  function Du(g) {\n    return Ee.call(g);\n  }\n  function gi(g) {\n    if (g != null) {\n      try {\n        return me.call(g);\n      } catch {\n      }\n      try {\n        return g + \"\";\n      } catch {\n      }\n    }\n    return \"\";\n  }\n  function Mn(g, P) {\n    return g === P || g !== g && P !== P;\n  }\n  var xu = $n(function() {\n    return arguments;\n  }()) ? $n : function(g) {\n    return Bi(g) && ne.call(g, \"callee\") && !qt.call(g, \"callee\");\n  }, Cs = Array.isArray;\n  function Ou(g) {\n    return g != null && jn(g.length) && !qn(g);\n  }\n  var gr = Ki || Cu;\n  function Nu(g, P) {\n    return Fn(g, P);\n  }\n  function qn(g) {\n    if (!zn(g))\n      return !1;\n    var P = Vi(g);\n    return P == O || P == _ || P == d || P == y;\n  }\n  function jn(g) {\n    return typeof g == \"number\" && g > -1 && g % 1 == 0 && g <= o;\n  }\n  function zn(g) {\n    var P = typeof g;\n    return g != null && (P == \"object\" || P == \"function\");\n  }\n  function Bi(g) {\n    return g != null && typeof g == \"object\";\n  }\n  var Kn = fe ? $e(fe) : gu;\n  function Pu(g) {\n    return Ou(g) ? lu(g) : yu(g);\n  }\n  function Ru() {\n    return [];\n  }\n  function Cu() {\n    return !1;\n  }\n  i.exports = Nu;\n})(Qs, Qs.exports);\nvar Fg = Qs.exports;\nconst Yc = /* @__PURE__ */ (0,_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.e)(Fg);\nfunction Ug(i, e) {\n  if (i.length >= 255)\n    throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), s = 0; s < t.length; s++)\n    t[s] = 255;\n  for (var r = 0; r < i.length; r++) {\n    var n = i.charAt(r), o = n.charCodeAt(0);\n    if (t[o] !== 255)\n      throw new TypeError(n + \" is ambiguous\");\n    t[o] = r;\n  }\n  var c = i.length, u = i.charAt(0), d = Math.log(c) / Math.log(256), p = Math.log(256) / Math.log(c);\n  function b(_) {\n    if (_ instanceof Uint8Array || (ArrayBuffer.isView(_) ? _ = new Uint8Array(_.buffer, _.byteOffset, _.byteLength) : Array.isArray(_) && (_ = Uint8Array.from(_))), !(_ instanceof Uint8Array))\n      throw new TypeError(\"Expected Uint8Array\");\n    if (_.length === 0)\n      return \"\";\n    for (var C = 0, F = 0, K = 0, I = _.length; K !== I && _[K] === 0; )\n      K++, C++;\n    for (var D = (I - K) * p + 1 >>> 0, y = new Uint8Array(D); K !== I; ) {\n      for (var w = _[K], f = 0, a = D - 1; (w !== 0 || f < F) && a !== -1; a--, f++)\n        w += 256 * y[a] >>> 0, y[a] = w % c >>> 0, w = w / c >>> 0;\n      if (w !== 0)\n        throw new Error(\"Non-zero carry\");\n      F = f, K++;\n    }\n    for (var l = D - F; l !== D && y[l] === 0; )\n      l++;\n    for (var L = u.repeat(C); l < D; ++l)\n      L += i.charAt(y[l]);\n    return L;\n  }\n  function x(_) {\n    if (typeof _ != \"string\")\n      throw new TypeError(\"Expected String\");\n    if (_.length === 0)\n      return new Uint8Array();\n    var C = 0;\n    if (_[C] !== \" \") {\n      for (var F = 0, K = 0; _[C] === u; )\n        F++, C++;\n      for (var I = (_.length - C) * d + 1 >>> 0, D = new Uint8Array(I); _[C]; ) {\n        var y = t[_.charCodeAt(C)];\n        if (y === 255)\n          return;\n        for (var w = 0, f = I - 1; (y !== 0 || w < K) && f !== -1; f--, w++)\n          y += c * D[f] >>> 0, D[f] = y % 256 >>> 0, y = y / 256 >>> 0;\n        if (y !== 0)\n          throw new Error(\"Non-zero carry\");\n        K = w, C++;\n      }\n      if (_[C] !== \" \") {\n        for (var a = I - K; a !== I && D[a] === 0; )\n          a++;\n        for (var l = new Uint8Array(F + (I - a)), L = F; a !== I; )\n          l[L++] = D[a++];\n        return l;\n      }\n    }\n  }\n  function O(_) {\n    var C = x(_);\n    if (C)\n      return C;\n    throw new Error(`Non-${e} character`);\n  }\n  return { encode: b, decodeUnsafe: x, decode: O };\n}\nvar Lg = Ug, Mg = Lg;\nconst Jc = (i) => {\n  if (i instanceof Uint8Array && i.constructor.name === \"Uint8Array\")\n    return i;\n  if (i instanceof ArrayBuffer)\n    return new Uint8Array(i);\n  if (ArrayBuffer.isView(i))\n    return new Uint8Array(i.buffer, i.byteOffset, i.byteLength);\n  throw new Error(\"Unknown type, must be binary type\");\n}, qg = (i) => new TextEncoder().encode(i), jg = (i) => new TextDecoder().decode(i);\nlet zg = class {\n  constructor(e, t, s) {\n    this.name = e, this.prefix = t, this.baseEncode = s;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array)\n      return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}, Kg = class {\n  constructor(e, t, s) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)\n      throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint)\n        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else\n      throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return Qc(this, e);\n  }\n}, Vg = class {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return Qc(this, e);\n  }\n  decode(e) {\n    const t = e[0], s = this.decoders[t];\n    if (s)\n      return s.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n};\nconst Qc = (i, e) => new Vg({ ...i.decoders || { [i.prefix]: i }, ...e.decoders || { [e.prefix]: e } });\nlet Bg = class {\n  constructor(e, t, s, r) {\n    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = r, this.encoder = new zg(e, t, s), this.decoder = new Kg(e, t, r);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n};\nconst lr = ({ name: i, prefix: e, encode: t, decode: s }) => new Bg(i, e, t, s), Ss = ({ prefix: i, name: e, alphabet: t }) => {\n  const { encode: s, decode: r } = Mg(t, e);\n  return lr({ prefix: i, name: e, encode: s, decode: (n) => Jc(r(n)) });\n}, kg = (i, e, t, s) => {\n  const r = {};\n  for (let p = 0; p < e.length; ++p)\n    r[e[p]] = p;\n  let n = i.length;\n  for (; i[n - 1] === \"=\"; )\n    --n;\n  const o = new Uint8Array(n * t / 8 | 0);\n  let c = 0, u = 0, d = 0;\n  for (let p = 0; p < n; ++p) {\n    const b = r[i[p]];\n    if (b === void 0)\n      throw new SyntaxError(`Non-${s} character`);\n    u = u << t | b, c += t, c >= 8 && (c -= 8, o[d++] = 255 & u >> c);\n  }\n  if (c >= t || 255 & u << 8 - c)\n    throw new SyntaxError(\"Unexpected end of data\");\n  return o;\n}, Hg = (i, e, t) => {\n  const s = e[e.length - 1] === \"=\", r = (1 << t) - 1;\n  let n = \"\", o = 0, c = 0;\n  for (let u = 0; u < i.length; ++u)\n    for (c = c << 8 | i[u], o += 8; o > t; )\n      o -= t, n += e[r & c >> o];\n  if (o && (n += e[r & c << t - o]), s)\n    for (; n.length * t & 7; )\n      n += \"=\";\n  return n;\n}, lt = ({ name: i, prefix: e, bitsPerChar: t, alphabet: s }) => lr({ prefix: e, name: i, encode(r) {\n  return Hg(r, s, t);\n}, decode(r) {\n  return kg(r, s, t, i);\n} }), Gg = lr({ prefix: \"\\0\", name: \"identity\", encode: (i) => jg(i), decode: (i) => qg(i) });\nvar Wg = Object.freeze({ __proto__: null, identity: Gg });\nconst Yg = lt({ prefix: \"0\", name: \"base2\", alphabet: \"01\", bitsPerChar: 1 });\nvar Jg = Object.freeze({ __proto__: null, base2: Yg });\nconst Qg = lt({ prefix: \"7\", name: \"base8\", alphabet: \"01234567\", bitsPerChar: 3 });\nvar Xg = Object.freeze({ __proto__: null, base8: Qg });\nconst Zg = Ss({ prefix: \"9\", name: \"base10\", alphabet: \"0123456789\" });\nvar ey = Object.freeze({ __proto__: null, base10: Zg });\nconst ty = lt({ prefix: \"f\", name: \"base16\", alphabet: \"0123456789abcdef\", bitsPerChar: 4 }), iy = lt({ prefix: \"F\", name: \"base16upper\", alphabet: \"0123456789ABCDEF\", bitsPerChar: 4 });\nvar sy = Object.freeze({ __proto__: null, base16: ty, base16upper: iy });\nconst ry = lt({ prefix: \"b\", name: \"base32\", alphabet: \"abcdefghijklmnopqrstuvwxyz234567\", bitsPerChar: 5 }), ny = lt({ prefix: \"B\", name: \"base32upper\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\", bitsPerChar: 5 }), oy = lt({ prefix: \"c\", name: \"base32pad\", alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\", bitsPerChar: 5 }), ay = lt({ prefix: \"C\", name: \"base32padupper\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\", bitsPerChar: 5 }), cy = lt({ prefix: \"v\", name: \"base32hex\", alphabet: \"0123456789abcdefghijklmnopqrstuv\", bitsPerChar: 5 }), hy = lt({ prefix: \"V\", name: \"base32hexupper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\", bitsPerChar: 5 }), uy = lt({ prefix: \"t\", name: \"base32hexpad\", alphabet: \"0123456789abcdefghijklmnopqrstuv=\", bitsPerChar: 5 }), ly = lt({ prefix: \"T\", name: \"base32hexpadupper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\", bitsPerChar: 5 }), dy = lt({ prefix: \"h\", name: \"base32z\", alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\", bitsPerChar: 5 });\nvar fy = Object.freeze({ __proto__: null, base32: ry, base32upper: ny, base32pad: oy, base32padupper: ay, base32hex: cy, base32hexupper: hy, base32hexpad: uy, base32hexpadupper: ly, base32z: dy });\nconst py = Ss({ prefix: \"k\", name: \"base36\", alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\" }), gy = Ss({ prefix: \"K\", name: \"base36upper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" });\nvar yy = Object.freeze({ __proto__: null, base36: py, base36upper: gy });\nconst my = Ss({ name: \"base58btc\", prefix: \"z\", alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" }), by = Ss({ name: \"base58flickr\", prefix: \"Z\", alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\" });\nvar wy = Object.freeze({ __proto__: null, base58btc: my, base58flickr: by });\nconst vy = lt({ prefix: \"m\", name: \"base64\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", bitsPerChar: 6 }), _y = lt({ prefix: \"M\", name: \"base64pad\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", bitsPerChar: 6 }), Ey = lt({ prefix: \"u\", name: \"base64url\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", bitsPerChar: 6 }), Sy = lt({ prefix: \"U\", name: \"base64urlpad\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\", bitsPerChar: 6 });\nvar Iy = Object.freeze({ __proto__: null, base64: vy, base64pad: _y, base64url: Ey, base64urlpad: Sy });\nconst Xc = Array.from(\"🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂\"), Dy = Xc.reduce((i, e, t) => (i[t] = e, i), []), xy = Xc.reduce((i, e, t) => (i[e.codePointAt(0)] = t, i), []);\nfunction Oy(i) {\n  return i.reduce((e, t) => (e += Dy[t], e), \"\");\n}\nfunction Ny(i) {\n  const e = [];\n  for (const t of i) {\n    const s = xy[t.codePointAt(0)];\n    if (s === void 0)\n      throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(s);\n  }\n  return new Uint8Array(e);\n}\nconst Py = lr({ prefix: \"🚀\", name: \"base256emoji\", encode: Oy, decode: Ny });\nvar Ry = Object.freeze({ __proto__: null, base256emoji: Py }), Cy = Zc, Go = 128, Ay = 127, Ty = ~Ay, $y = Math.pow(2, 31);\nfunction Zc(i, e, t) {\n  e = e || [], t = t || 0;\n  for (var s = t; i >= $y; )\n    e[t++] = i & 255 | Go, i /= 128;\n  for (; i & Ty; )\n    e[t++] = i & 255 | Go, i >>>= 7;\n  return e[t] = i | 0, Zc.bytes = t - s + 1, e;\n}\nvar Fy = Wr, Uy = 128, Wo = 127;\nfunction Wr(i, s) {\n  var t = 0, s = s || 0, r = 0, n = s, o, c = i.length;\n  do {\n    if (n >= c)\n      throw Wr.bytes = 0, new RangeError(\"Could not decode varint\");\n    o = i[n++], t += r < 28 ? (o & Wo) << r : (o & Wo) * Math.pow(2, r), r += 7;\n  } while (o >= Uy);\n  return Wr.bytes = n - s, t;\n}\nvar Ly = Math.pow(2, 7), My = Math.pow(2, 14), qy = Math.pow(2, 21), jy = Math.pow(2, 28), zy = Math.pow(2, 35), Ky = Math.pow(2, 42), Vy = Math.pow(2, 49), By = Math.pow(2, 56), ky = Math.pow(2, 63), Hy = function(i) {\n  return i < Ly ? 1 : i < My ? 2 : i < qy ? 3 : i < jy ? 4 : i < zy ? 5 : i < Ky ? 6 : i < Vy ? 7 : i < By ? 8 : i < ky ? 9 : 10;\n}, Gy = { encode: Cy, decode: Fy, encodingLength: Hy }, eh = Gy;\nconst Yo = (i, e, t = 0) => (eh.encode(i, e, t), e), Jo = (i) => eh.encodingLength(i), Yr = (i, e) => {\n  const t = e.byteLength, s = Jo(i), r = s + Jo(t), n = new Uint8Array(r + t);\n  return Yo(i, n, 0), Yo(t, n, s), n.set(e, r), new Wy(i, t, e, n);\n};\nlet Wy = class {\n  constructor(e, t, s, r) {\n    this.code = e, this.size = t, this.digest = s, this.bytes = r;\n  }\n};\nconst th = ({ name: i, code: e, encode: t }) => new Yy(i, e, t);\nlet Yy = class {\n  constructor(e, t, s) {\n    this.name = e, this.code = t, this.encode = s;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? Yr(this.code, t) : t.then((s) => Yr(this.code, s));\n    } else\n      throw Error(\"Unknown type, must be binary type\");\n  }\n};\nconst ih = (i) => async (e) => new Uint8Array(await crypto.subtle.digest(i, e)), Jy = th({ name: \"sha2-256\", code: 18, encode: ih(\"SHA-256\") }), Qy = th({ name: \"sha2-512\", code: 19, encode: ih(\"SHA-512\") });\nvar Xy = Object.freeze({ __proto__: null, sha256: Jy, sha512: Qy });\nconst sh = 0, Zy = \"identity\", rh = Jc, e1 = (i) => Yr(sh, rh(i)), t1 = { code: sh, name: Zy, encode: rh, digest: e1 };\nvar i1 = Object.freeze({ __proto__: null, identity: t1 });\nnew TextEncoder(), new TextDecoder();\nconst Qo = { ...Wg, ...Jg, ...Xg, ...ey, ...sy, ...fy, ...yy, ...wy, ...Iy, ...Ry };\n({ ...Xy, ...i1 });\nfunction nh(i) {\n  return globalThis.Buffer != null ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : i;\n}\nfunction s1(i = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? nh(globalThis.Buffer.allocUnsafe(i)) : new Uint8Array(i);\n}\nfunction oh(i, e, t, s) {\n  return { name: i, prefix: e, encoder: { name: i, prefix: e, encode: t }, decoder: { decode: s } };\n}\nconst Xo = oh(\"utf8\", \"u\", (i) => \"u\" + new TextDecoder(\"utf8\").decode(i), (i) => new TextEncoder().encode(i.substring(1))), Or = oh(\"ascii\", \"a\", (i) => {\n  let e = \"a\";\n  for (let t = 0; t < i.length; t++)\n    e += String.fromCharCode(i[t]);\n  return e;\n}, (i) => {\n  i = i.substring(1);\n  const e = s1(i.length);\n  for (let t = 0; t < i.length; t++)\n    e[t] = i.charCodeAt(t);\n  return e;\n}), r1 = { utf8: Xo, \"utf-8\": Xo, hex: Qo.base16, latin1: Or, ascii: Or, binary: Or, ...Qo };\nfunction n1(i, e = \"utf8\") {\n  const t = r1[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? nh(globalThis.Buffer.from(i, \"utf-8\")) : t.decoder.decode(`${t.prefix}${i}`);\n}\nconst ah = \"wc\", o1 = 2, En = \"core\", hi = `${ah}@2:${En}:`, a1 = { name: En, logger: \"error\" }, c1 = { database: \":memory:\" }, h1 = \"crypto\", Zo = \"client_ed25519_seed\", u1 = V.ONE_DAY, l1 = \"keychain\", d1 = \"0.3\", f1 = \"messages\", p1 = \"0.3\", g1 = V.SIX_HOURS, y1 = \"publisher\", ch = \"irn\", m1 = \"error\", hh = \"wss://relay.walletconnect.com\", ea = \"wss://relay.walletconnect.org\", b1 = \"relayer\", gt = { message: \"relayer_message\", message_ack: \"relayer_message_ack\", connect: \"relayer_connect\", disconnect: \"relayer_disconnect\", error: \"relayer_error\", connection_stalled: \"relayer_connection_stalled\", transport_closed: \"relayer_transport_closed\", publish: \"relayer_publish\" }, w1 = \"_subscription\", Zt = { payload: \"payload\", connect: \"connect\", disconnect: \"disconnect\", error: \"error\" }, v1 = V.ONE_SECOND, _1 = \"2.10.1\", E1 = 1e4, S1 = \"0.3\", I1 = \"WALLETCONNECT_CLIENT_ID\", Vt = { created: \"subscription_created\", deleted: \"subscription_deleted\", expired: \"subscription_expired\", disabled: \"subscription_disabled\", sync: \"subscription_sync\", resubscribed: \"subscription_resubscribed\" }, D1 = \"subscription\", x1 = \"0.3\", O1 = V.FIVE_SECONDS * 1e3, N1 = \"pairing\", P1 = \"0.3\", Xi = { wc_pairingDelete: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 0 } } }, os = { create: \"pairing_create\", expire: \"pairing_expire\", delete: \"pairing_delete\", ping: \"pairing_ping\" }, zt = { created: \"history_created\", updated: \"history_updated\", deleted: \"history_deleted\", sync: \"history_sync\" }, R1 = \"history\", C1 = \"0.3\", A1 = \"expirer\", Tt = { created: \"expirer_created\", deleted: \"expirer_deleted\", expired: \"expirer_expired\", sync: \"expirer_sync\" }, T1 = \"0.3\", Nr = \"verify-api\", Ks = \"https://verify.walletconnect.com\", ta = \"https://verify.walletconnect.org\";\nlet $1 = class {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = l1, this.version = d1, this.initialized = !1, this.storagePrefix = hi, this.init = async () => {\n      if (!this.initialized) {\n        const s = await this.getKeyChain();\n        typeof s < \"u\" && (this.keychain = s), this.initialized = !0;\n      }\n    }, this.has = (s) => (this.isInitialized(), this.keychain.has(s)), this.set = async (s, r) => {\n      this.isInitialized(), this.keychain.set(s, r), await this.persist();\n    }, this.get = (s) => {\n      this.isInitialized();\n      const r = this.keychain.get(s);\n      if (typeof r > \"u\") {\n        const { message: n } = Y(\"NO_MATCHING_KEY\", `${this.name}: ${s}`);\n        throw new Error(n);\n      }\n      return r;\n    }, this.del = async (s) => {\n      this.isInitialized(), this.keychain.delete(s), await this.persist();\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, Lc(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? Mc(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, F1 = class {\n  constructor(e, t, s) {\n    this.core = e, this.logger = t, this.name = h1, this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = (r) => (this.isInitialized(), this.keychain.has(r)), this.getClientId = async () => {\n      this.isInitialized();\n      const r = await this.getClientSeed(), n = Ws(r);\n      return an(n.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const r = tp();\n      return this.setPrivateKey(r.publicKey, r.privateKey);\n    }, this.signJWT = async (r) => {\n      this.isInitialized();\n      const n = await this.getClientSeed(), o = Ws(n), c = Hr();\n      return await Ic(c, r, u1, o);\n    }, this.generateSharedKey = (r, n, o) => {\n      this.isInitialized();\n      const c = this.getPrivateKey(r), u = ip(c, n);\n      return this.setSymKey(u, o);\n    }, this.setSymKey = async (r, n) => {\n      this.isInitialized();\n      const o = n || sp(r);\n      return await this.keychain.set(o, r), o;\n    }, this.deleteKeyPair = async (r) => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.deleteSymKey = async (r) => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.encode = async (r, n, o) => {\n      this.isInitialized();\n      const c = Uc(o), u = rr(n);\n      if (Ro(c)) {\n        const x = c.senderPublicKey, O = c.receiverPublicKey;\n        r = await this.generateSharedKey(x, O);\n      }\n      const d = this.getSymKey(r), { type: p, senderPublicKey: b } = c;\n      return np({ type: p, symKey: d, message: u, senderPublicKey: b });\n    }, this.decode = async (r, n, o) => {\n      this.isInitialized();\n      const c = cp(n, o);\n      if (Ro(c)) {\n        const u = c.receiverPublicKey, d = c.senderPublicKey;\n        r = await this.generateSharedKey(u, d);\n      }\n      try {\n        const u = this.getSymKey(r), d = op({ symKey: u, encoded: n });\n        return rn(d);\n      } catch (u) {\n        this.logger.error(`Failed to decode message from topic: '${r}', clientId: '${await this.getClientId()}'`), this.logger.error(u);\n      }\n    }, this.getPayloadType = (r) => {\n      const n = Ys(r);\n      return ws(n.type);\n    }, this.getPayloadSenderPublicKey = (r) => {\n      const n = Ys(r);\n      return n.senderPublicKey ? Ne(n.senderPublicKey, vt) : void 0;\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name), this.keychain = s || new $1(this.core, this.logger);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(Zo);\n    } catch {\n      e = Hr(), await this.keychain.set(Zo, e);\n    }\n    return n1(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, U1 = class extends gl {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = f1, this.version = p1, this.initialized = !1, this.storagePrefix = hi, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const s = await this.getRelayerMessages();\n          typeof s < \"u\" && (this.messages = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", size: this.messages.size });\n        } catch (s) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (s, r) => {\n      this.isInitialized();\n      const n = Fi(r);\n      let o = this.messages.get(s);\n      return typeof o > \"u\" && (o = {}), typeof o[n] < \"u\" || (o[n] = r, this.messages.set(s, o), await this.persist()), n;\n    }, this.get = (s) => {\n      this.isInitialized();\n      let r = this.messages.get(s);\n      return typeof r > \"u\" && (r = {}), r;\n    }, this.has = (s, r) => {\n      this.isInitialized();\n      const n = this.get(s), o = Fi(r);\n      return typeof n[o] < \"u\";\n    }, this.del = async (s) => {\n      this.isInitialized(), this.messages.delete(s), await this.persist();\n    }, this.logger = ee.generateChildLogger(e, this.name), this.core = t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, Lc(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? Mc(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, L1 = class extends yl {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new We.EventEmitter(), this.name = y1, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = V.toMiliseconds(V.TEN_SECONDS), this.needsTransportRestart = !1, this.publish = async (s, r, n) => {\n      var o;\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({ type: \"method\", method: \"publish\", params: { topic: s, message: r, opts: n } });\n      try {\n        const c = n?.ttl || g1, u = Gr(n), d = n?.prompt || !1, p = n?.tag || 0, b = n?.id || vn().toString(), x = { topic: s, message: r, opts: { ttl: c, relay: u, prompt: d, tag: p, id: b } }, O = setTimeout(() => this.queue.set(b, x), this.publishTimeout);\n        try {\n          await await ds(this.rpcPublish(s, r, c, u, d, p, b), this.publishTimeout, \"Failed to publish payload, please try again.\"), this.removeRequestFromQueue(b), this.relayer.events.emit(gt.publish, x);\n        } catch (_) {\n          if (this.logger.debug(\"Publishing Payload stalled\"), this.needsTransportRestart = !0, (o = n?.internal) != null && o.throwOnFailedPublish)\n            throw this.removeRequestFromQueue(b), _;\n          return;\n        } finally {\n          clearTimeout(O);\n        }\n        this.logger.debug(\"Successfully Published Payload\"), this.logger.trace({ type: \"method\", method: \"publish\", params: { topic: s, message: r, opts: n } });\n      } catch (c) {\n        throw this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(c), c;\n      }\n    }, this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.relayer = e, this.logger = ee.generateChildLogger(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  rpcPublish(e, t, s, r, n, o, c) {\n    var u, d, p, b;\n    const x = { method: js(r.protocol).publish, params: { topic: e, message: t, ttl: s, prompt: n, tag: o }, id: c };\n    return bt((u = x.params) == null ? void 0 : u.prompt) && ((d = x.params) == null || delete d.prompt), bt((p = x.params) == null ? void 0 : p.tag) && ((b = x.params) == null || delete b.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"message\", direction: \"outgoing\", request: x }), this.relayer.request(x);\n  }\n  removeRequestFromQueue(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async (e) => {\n      const { topic: t, message: s, opts: r } = e;\n      await this.publish(t, s, r);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, () => {\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = !1, this.relayer.events.emit(gt.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    }), this.relayer.on(gt.message_ack, (e) => {\n      this.removeRequestFromQueue(e.id.toString());\n    });\n  }\n}, M1 = class {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {\n      const s = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...s, t]);\n    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e))\n        return;\n      const s = this.get(e);\n      if (!this.exists(e, t))\n        return;\n      const r = s.filter((n) => n !== t);\n      if (!r.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, r);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n};\nvar q1 = Object.defineProperty, j1 = Object.defineProperties, z1 = Object.getOwnPropertyDescriptors, ia = Object.getOwnPropertySymbols, K1 = Object.prototype.hasOwnProperty, V1 = Object.prototype.propertyIsEnumerable, sa = (i, e, t) => e in i ? q1(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Zi = (i, e) => {\n  for (var t in e || (e = {}))\n    K1.call(e, t) && sa(i, t, e[t]);\n  if (ia)\n    for (var t of ia(e))\n      V1.call(e, t) && sa(i, t, e[t]);\n  return i;\n}, Pr = (i, e) => j1(i, z1(e));\nlet B1 = class extends wl {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new M1(), this.events = new We.EventEmitter(), this.name = D1, this.version = x1, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pollingInterval = 20, this.storagePrefix = hi, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());\n    }, this.subscribe = async (s, r) => {\n      await this.restartToComplete(), this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic: s, opts: r } });\n      try {\n        const n = Gr(r), o = { topic: s, relay: n };\n        this.pending.set(s, o);\n        const c = await this.rpcSubscribe(s, n);\n        return this.onSubscribe(c, o), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic: s, opts: r } }), c;\n      } catch (n) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(n), n;\n      }\n    }, this.unsubscribe = async (s, r) => {\n      await this.restartToComplete(), this.isInitialized(), typeof r?.id < \"u\" ? await this.unsubscribeById(s, r.id, r) : await this.unsubscribeByTopic(s, r);\n    }, this.isSubscribed = async (s) => this.topics.includes(s) ? !0 : await new Promise((r, n) => {\n      const o = new V.Watch();\n      o.start(this.pendingSubscriptionWatchLabel);\n      const c = setInterval(() => {\n        !this.pending.has(s) && this.topics.includes(s) && (clearInterval(c), o.stop(this.pendingSubscriptionWatchLabel), r(!0)), o.elapsed(this.pendingSubscriptionWatchLabel) >= O1 && (clearInterval(c), o.stop(this.pendingSubscriptionWatchLabel), n(new Error(\"Subscription resolution timeout\")));\n      }, this.pollingInterval);\n    }).catch(() => !1), this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.restart = async () => {\n      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;\n    }, this.relayer = e, this.logger = ee.generateChildLogger(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let s = !1;\n    try {\n      s = this.getSubscription(e).topic === t;\n    } catch {\n    }\n    return s;\n  }\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  async unsubscribeByTopic(e, t) {\n    const s = this.topicMap.get(e);\n    await Promise.all(s.map(async (r) => await this.unsubscribeById(e, r, t)));\n  }\n  async unsubscribeById(e, t, s) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic: e, id: t, opts: s } });\n    try {\n      const r = Gr(s);\n      await this.rpcUnsubscribe(e, t, r);\n      const n = nt(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, n), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic: e, id: t, opts: s } });\n    } catch (r) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(r), r;\n    }\n  }\n  async rpcSubscribe(e, t) {\n    const s = { method: js(t.protocol).subscribe, params: { topic: e } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: s });\n    try {\n      await await ds(this.relayer.request(s), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), this.relayer.events.emit(gt.connection_stalled);\n    }\n    return Fi(e + this.clientId);\n  }\n  async rpcBatchSubscribe(e) {\n    if (!e.length)\n      return;\n    const t = e[0].relay, s = { method: js(t.protocol).batchSubscribe, params: { topics: e.map((r) => r.topic) } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: s });\n    try {\n      return await await ds(this.relayer.request(s), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Payload stalled\"), this.relayer.events.emit(gt.connection_stalled);\n    }\n  }\n  rpcUnsubscribe(e, t, s) {\n    const r = { method: js(s.protocol).unsubscribe, params: { topic: e, id: t } };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: r }), this.relayer.request(r);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, Pr(Zi({}, t), { id: e })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach((t) => {\n      this.setSubscription(t.id, Zi({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  async onUnsubscribe(e, t, s) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({ type: \"method\", method: \"setSubscription\", id: e, subscription: t }), this.addSubscription(e, t));\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, Zi({}, t)), this.topicMap.set(t.topic, e), this.events.emit(Vt.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({ type: \"method\", method: \"getSubscription\", id: e });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const { message: s } = Y(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id: e, reason: t });\n    const s = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit(Vt.deleted, Pr(Zi({}, s), { reason: t }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(Vt.sync);\n  }\n  async reset() {\n    if (this.cached.length) {\n      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let t = 0; t < e; t++) {\n        const s = this.cached.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(s);\n      }\n    }\n    this.events.emit(Vt.resubscribed);\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.subscriptions.size) {\n        const { message: t } = Y(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async batchSubscribe(e) {\n    if (!e.length)\n      return;\n    const t = await this.rpcBatchSubscribe(e);\n    Es(t) && this.onBatchSubscribe(t.map((s, r) => Pr(Zi({}, e[r]), { id: s })));\n  }\n  async onConnect() {\n    this.restartInProgress || (await this.restart(), this.onEnable());\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  async checkPending() {\n    if (!this.initialized || this.relayer.transportExplicitlyClosed)\n      return;\n    const e = [];\n    this.pending.forEach((t) => {\n      e.push(t);\n    }), await this.batchSubscribe(e);\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, async () => {\n      await this.checkPending();\n    }), this.relayer.on(gt.connect, async () => {\n      await this.onConnect();\n    }), this.relayer.on(gt.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(Vt.created, async (e) => {\n      const t = Vt.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), await this.persist();\n    }), this.events.on(Vt.deleted, async (e) => {\n      const t = Vt.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), await this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async restartToComplete() {\n    this.restartInProgress && await new Promise((e) => {\n      const t = setInterval(() => {\n        this.restartInProgress || (clearInterval(t), e());\n      }, this.pollingInterval);\n    });\n  }\n};\nvar k1 = Object.defineProperty, ra = Object.getOwnPropertySymbols, H1 = Object.prototype.hasOwnProperty, G1 = Object.prototype.propertyIsEnumerable, na = (i, e, t) => e in i ? k1(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, W1 = (i, e) => {\n  for (var t in e || (e = {}))\n    H1.call(e, t) && na(i, t, e[t]);\n  if (ra)\n    for (var t of ra(e))\n      G1.call(e, t) && na(i, t, e[t]);\n  return i;\n};\nlet Y1 = class extends ml {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new We.EventEmitter(), this.name = b1, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = [\"socket hang up\", \"socket stalled\"], this.hasExperiencedNetworkDisruption = !1, this.request = async (t) => {\n      this.logger.debug(\"Publishing Request Payload\");\n      try {\n        return await this.toEstablishConnection(), await this.provider.request(t);\n      } catch (s) {\n        throw this.logger.debug(\"Failed to Publish Request\"), this.logger.error(s), s;\n      }\n    }, this.onPayloadHandler = (t) => {\n      this.onProviderPayload(t);\n    }, this.onConnectHandler = () => {\n      this.events.emit(gt.connect);\n    }, this.onDisconnectHandler = () => {\n      this.onProviderDisconnect();\n    }, this.onProviderErrorHandler = (t) => {\n      this.logger.error(t), this.events.emit(gt.error, t), this.logger.info(\"Fatal socket error received, closing transport\"), this.transportClose();\n    }, this.registerProviderListeners = () => {\n      this.provider.on(Zt.payload, this.onPayloadHandler), this.provider.on(Zt.connect, this.onConnectHandler), this.provider.on(Zt.disconnect, this.onDisconnectHandler), this.provider.on(Zt.error, this.onProviderErrorHandler);\n    }, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? ee.generateChildLogger(e.logger, this.name) : ee.pino(ee.getDefaultLoggerOptions({ level: e.logger || m1 })), this.messages = new U1(this.logger, e.core), this.subscriber = new B1(this, this.logger), this.publisher = new L1(this, this.logger), this.relayUrl = e?.relayUrl || hh, this.projectId = e.projectId, this.provider = {};\n  }\n  async init() {\n    this.logger.trace(\"Initialized\"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);\n    try {\n      await this.transportOpen();\n    } catch {\n      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${ea}...`), await this.restartTransport(ea);\n    }\n    this.initialized = !0, setTimeout(async () => {\n      this.subscriber.topics.length === 0 && (this.logger.info(\"No topics subscribed to after init, closing transport\"), await this.transportClose(), this.transportExplicitlyClosed = !1);\n    }, E1);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get connected() {\n    return this.provider.connection.connected;\n  }\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n  async publish(e, t, s) {\n    this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });\n  }\n  async subscribe(e, t) {\n    var s;\n    this.isInitialized();\n    let r = ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || \"\";\n    return r || (await Promise.all([new Promise((n) => {\n      this.subscriber.once(Vt.created, (o) => {\n        o.topic === e && n();\n      });\n    }), new Promise(async (n) => {\n      r = await this.subscriber.subscribe(e, t), n();\n    })]), r);\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async transportClose() {\n    this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await ds(this.provider.disconnect(), 1e3, \"provider.disconnect()\").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();\n  }\n  async transportOpen(e) {\n    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {\n      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;\n      try {\n        await Promise.all([new Promise((t) => {\n          if (!this.initialized)\n            return t();\n          this.subscriber.once(Vt.resubscribed, () => {\n            t();\n          });\n        }), new Promise(async (t, s) => {\n          try {\n            await ds(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);\n          } catch (r) {\n            s(r);\n            return;\n          }\n          t();\n        })]);\n      } catch (t) {\n        this.logger.error(t);\n        const s = t;\n        if (!this.isConnectionStalled(s.message))\n          throw t;\n        this.provider.events.emit(Zt.disconnect);\n      } finally {\n        this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1;\n      }\n    }\n  }\n  async restartTransport(e) {\n    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());\n  }\n  async confirmOnlineStateOrThrow() {\n    if (!await jo())\n      throw new Error(\"No internet connection detected. Please restart your network and try again.\");\n  }\n  isConnectionStalled(e) {\n    return this.staleConnectionErrors.some((t) => e.includes(t));\n  }\n  async createProvider() {\n    this.provider.connection && this.unregisterProviderListeners();\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = new _n(new Wc(wp({ sdkVersion: _1, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0 }))), this.registerProviderListeners();\n  }\n  async recordMessageEvent(e) {\n    const { topic: t, message: s } = e;\n    await this.messages.set(t, s);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const { topic: t, message: s } = e;\n    if (!s || s.length === 0)\n      return this.logger.debug(`Ignoring invalid/empty message: ${s}`), !0;\n    if (!await this.subscriber.isSubscribed(t))\n      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), !0;\n    const r = this.messages.has(t, s);\n    return r && this.logger.debug(`Ignoring duplicate message: ${s}`), r;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"incoming\", payload: e }), ji(e)) {\n      if (!e.method.endsWith(w1))\n        return;\n      const t = e.params, { topic: s, message: r, publishedAt: n } = t.data, o = { topic: s, message: r, publishedAt: n };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(W1({ type: \"event\", event: t.id }, o)), this.events.emit(t.id, o), await this.acknowledgePayload(e), await this.onMessageEvent(o);\n    } else\n      Oi(e) && this.events.emit(gt.message_ack, e);\n  }\n  async onMessageEvent(e) {\n    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(gt.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = xi(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  unregisterProviderListeners() {\n    this.provider.off(Zt.payload, this.onPayloadHandler), this.provider.off(Zt.connect, this.onConnectHandler), this.provider.off(Zt.disconnect, this.onDisconnectHandler), this.provider.off(Zt.error, this.onProviderErrorHandler);\n  }\n  async registerEventListeners() {\n    this.events.on(gt.connection_stalled, () => {\n      this.restartTransport().catch((t) => this.logger.error(t));\n    });\n    let e = await jo();\n    lg(async (t) => {\n      this.initialized && e !== t && (e = t, t ? await this.restartTransport().catch((s) => this.logger.error(s)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch((s) => this.logger.error(s))));\n    });\n  }\n  onProviderDisconnect() {\n    this.events.emit(gt.disconnect), this.attemptToReconnect();\n  }\n  attemptToReconnect() {\n    this.transportExplicitlyClosed || (this.logger.info(\"attemptToReconnect called. Connecting...\"), setTimeout(async () => {\n      await this.restartTransport().catch((e) => this.logger.error(e));\n    }, V.toMiliseconds(v1)));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async toEstablishConnection() {\n    if (await this.confirmOnlineStateOrThrow(), !this.connected) {\n      if (this.connectionAttemptInProgress)\n        return await new Promise((e) => {\n          const t = setInterval(() => {\n            this.connected && (clearInterval(t), e());\n          }, this.connectionStatusPollingInterval);\n        });\n      await this.restartTransport();\n    }\n  }\n};\nvar J1 = Object.defineProperty, oa = Object.getOwnPropertySymbols, Q1 = Object.prototype.hasOwnProperty, X1 = Object.prototype.propertyIsEnumerable, aa = (i, e, t) => e in i ? J1(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, ca = (i, e) => {\n  for (var t in e || (e = {}))\n    Q1.call(e, t) && aa(i, t, e[t]);\n  if (oa)\n    for (var t of oa(e))\n      X1.call(e, t) && aa(i, t, e[t]);\n  return i;\n};\nlet dr = class extends bl {\n  constructor(e, t, s, r = hi, n = void 0) {\n    super(e, t, s, r), this.core = e, this.logger = t, this.name = s, this.map = /* @__PURE__ */ new Map(), this.version = S1, this.cached = [], this.initialized = !1, this.storagePrefix = hi, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((o) => {\n        this.getKey && o !== null && !bt(o) ? this.map.set(this.getKey(o), o) : Kp(o) ? this.map.set(o.id, o) : Vp(o) && this.map.set(o.topic, o);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (o, c) => {\n      this.isInitialized(), this.map.has(o) ? await this.update(o, c) : (this.logger.debug(\"Setting value\"), this.logger.trace({ type: \"method\", method: \"set\", key: o, value: c }), this.map.set(o, c), await this.persist());\n    }, this.get = (o) => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({ type: \"method\", method: \"get\", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((c) => Object.keys(o).every((u) => Yc(c[u], o[u]))) : this.values), this.update = async (o, c) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({ type: \"method\", method: \"update\", key: o, update: c });\n      const u = ca(ca({}, this.getData(o)), c);\n      this.map.set(o, u), await this.persist();\n    }, this.delete = async (o, c) => {\n      this.isInitialized(), this.map.has(o) && (this.logger.debug(\"Deleting value\"), this.logger.trace({ type: \"method\", method: \"delete\", key: o, reason: c }), this.map.delete(o), await this.persist());\n    }, this.logger = ee.generateChildLogger(t, this.name), this.storagePrefix = r, this.getKey = n;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      const { message: s } = Y(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(s), new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.map.size) {\n        const { message: t } = Y(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", value: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, Z1 = class {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.name = N1, this.version = P1, this.events = new ir(), this.initialized = !1, this.storagePrefix = hi, this.ignoredPayloadTypes = [Di], this.registeredMethods = [], this.init = async () => {\n      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace(\"Initialized\"));\n    }, this.register = ({ methods: s }) => {\n      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s])];\n    }, this.create = async () => {\n      this.isInitialized();\n      const s = Hr(), r = await this.core.crypto.setSymKey(s), n = Mt(V.FIVE_MINUTES), o = { protocol: ch }, c = { topic: r, expiry: n, relay: o, active: !1 }, u = Ap({ protocol: this.core.protocol, version: this.core.version, topic: r, symKey: s, relay: o });\n      return await this.pairings.set(r, c), await this.core.relayer.subscribe(r), this.core.expirer.set(r, n), { topic: r, uri: u };\n    }, this.pair = async (s) => {\n      this.isInitialized(), this.isValidPair(s);\n      const { topic: r, symKey: n, relay: o } = Pp(s.uri);\n      let c;\n      if (this.pairings.keys.includes(r) && (c = this.pairings.get(r), c.active))\n        throw new Error(`Pairing already exists: ${r}. Please try again with a new connection URI.`);\n      this.core.crypto.keychain.has(r) || (await this.core.crypto.setSymKey(n, r), await this.core.relayer.subscribe(r, { relay: o }));\n      const u = Mt(V.FIVE_MINUTES), d = { topic: r, relay: o, expiry: u, active: !1 };\n      return await this.pairings.set(r, d), this.core.expirer.set(r, u), s.activatePairing && await this.activate({ topic: r }), this.events.emit(os.create, d), d;\n    }, this.activate = async ({ topic: s }) => {\n      this.isInitialized();\n      const r = Mt(V.THIRTY_DAYS);\n      await this.pairings.update(s, { active: !0, expiry: r }), this.core.expirer.set(s, r);\n    }, this.ping = async (s) => {\n      this.isInitialized(), await this.isValidPing(s);\n      const { topic: r } = s;\n      if (this.pairings.keys.includes(r)) {\n        const n = await this.sendRequest(r, \"wc_pairingPing\", {}), { done: o, resolve: c, reject: u } = Ai();\n        this.events.once(Be(\"pairing_ping\", n), ({ error: d }) => {\n          d ? u(d) : c();\n        }), await o();\n      }\n    }, this.updateExpiry = async ({ topic: s, expiry: r }) => {\n      this.isInitialized(), await this.pairings.update(s, { expiry: r });\n    }, this.updateMetadata = async ({ topic: s, metadata: r }) => {\n      this.isInitialized(), await this.pairings.update(s, { peerMetadata: r });\n    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s) => {\n      this.isInitialized(), await this.isValidDisconnect(s);\n      const { topic: r } = s;\n      this.pairings.keys.includes(r) && (await this.sendRequest(r, \"wc_pairingDelete\", nt(\"USER_DISCONNECTED\")), await this.deletePairing(r));\n    }, this.sendRequest = async (s, r, n) => {\n      const o = ti(r, n), c = await this.core.crypto.encode(s, o), u = Xi[r].req;\n      return this.core.history.set(s, o), this.core.relayer.publish(s, c, u), o.id;\n    }, this.sendResult = async (s, r, n) => {\n      const o = xi(s, n), c = await this.core.crypto.encode(r, o), u = await this.core.history.get(r, s), d = Xi[u.request.method].res;\n      await this.core.relayer.publish(r, c, d), await this.core.history.resolve(o);\n    }, this.sendError = async (s, r, n) => {\n      const o = qi(s, n), c = await this.core.crypto.encode(r, o), u = await this.core.history.get(r, s), d = Xi[u.request.method] ? Xi[u.request.method].res : Xi.unregistered_method.res;\n      await this.core.relayer.publish(r, c, d), await this.core.history.resolve(o);\n    }, this.deletePairing = async (s, r) => {\n      await this.core.relayer.unsubscribe(s), await Promise.all([this.pairings.delete(s, nt(\"USER_DISCONNECTED\")), this.core.crypto.deleteSymKey(s), r ? Promise.resolve() : this.core.expirer.del(s)]);\n    }, this.cleanup = async () => {\n      const s = this.pairings.getAll().filter((r) => ai(r.expiry));\n      await Promise.all(s.map((r) => this.deletePairing(r.topic)));\n    }, this.onRelayEventRequest = (s) => {\n      const { topic: r, payload: n } = s;\n      switch (n.method) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(r, n);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(r, n);\n        default:\n          return this.onUnknownRpcMethodRequest(r, n);\n      }\n    }, this.onRelayEventResponse = async (s) => {\n      const { topic: r, payload: n } = s, o = (await this.core.history.get(r, n.id)).request.method;\n      switch (o) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingResponse(r, n);\n        default:\n          return this.onUnknownRpcMethodResponse(o);\n      }\n    }, this.onPairingPingRequest = async (s, r) => {\n      const { id: n } = r;\n      try {\n        this.isValidPing({ topic: s }), await this.sendResult(n, s, !0), this.events.emit(os.ping, { id: n, topic: s });\n      } catch (o) {\n        await this.sendError(n, s, o), this.logger.error(o);\n      }\n    }, this.onPairingPingResponse = (s, r) => {\n      const { id: n } = r;\n      setTimeout(() => {\n        ht(r) ? this.events.emit(Be(\"pairing_ping\", n), {}) : Ge(r) && this.events.emit(Be(\"pairing_ping\", n), { error: r.error });\n      }, 500);\n    }, this.onPairingDeleteRequest = async (s, r) => {\n      const { id: n } = r;\n      try {\n        this.isValidDisconnect({ topic: s }), await this.deletePairing(s), this.events.emit(os.delete, { id: n, topic: s });\n      } catch (o) {\n        await this.sendError(n, s, o), this.logger.error(o);\n      }\n    }, this.onUnknownRpcMethodRequest = async (s, r) => {\n      const { id: n, method: o } = r;\n      try {\n        if (this.registeredMethods.includes(o))\n          return;\n        const c = nt(\"WC_METHOD_UNSUPPORTED\", o);\n        await this.sendError(n, s, c), this.logger.error(c);\n      } catch (c) {\n        await this.sendError(n, s, c), this.logger.error(c);\n      }\n    }, this.onUnknownRpcMethodResponse = (s) => {\n      this.registeredMethods.includes(s) || this.logger.error(nt(\"WC_METHOD_UNSUPPORTED\", s));\n    }, this.isValidPair = (s) => {\n      if (!St(s)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `pair() params: ${s}`);\n        throw new Error(r);\n      }\n      if (!zp(s.uri)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `pair() uri: ${s.uri}`);\n        throw new Error(r);\n      }\n    }, this.isValidPing = async (s) => {\n      if (!St(s)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `ping() params: ${s}`);\n        throw new Error(n);\n      }\n      const { topic: r } = s;\n      await this.isValidPairingTopic(r);\n    }, this.isValidDisconnect = async (s) => {\n      if (!St(s)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `disconnect() params: ${s}`);\n        throw new Error(n);\n      }\n      const { topic: r } = s;\n      await this.isValidPairingTopic(r);\n    }, this.isValidPairingTopic = async (s) => {\n      if (!ot(s, !1)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${s}`);\n        throw new Error(r);\n      }\n      if (!this.pairings.keys.includes(s)) {\n        const { message: r } = Y(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${s}`);\n        throw new Error(r);\n      }\n      if (ai(this.pairings.get(s).expiry)) {\n        await this.deletePairing(s);\n        const { message: r } = Y(\"EXPIRED\", `pairing topic: ${s}`);\n        throw new Error(r);\n      }\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name), this.pairings = new dr(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.core.relayer.on(gt.message, async (e) => {\n      const { topic: t, message: s } = e;\n      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s)))\n        return;\n      const r = await this.core.crypto.decode(t, s);\n      try {\n        ji(r) ? (this.core.history.set(t, r), this.onRelayEventRequest({ topic: t, payload: r })) : Oi(r) && (await this.core.history.resolve(r), await this.onRelayEventResponse({ topic: t, payload: r }), this.core.history.delete(t, r.id));\n      } catch (n) {\n        this.logger.error(n);\n      }\n    });\n  }\n  registerExpirerEvents() {\n    this.core.expirer.on(Tt.expired, async (e) => {\n      const { topic: t } = jc(e.target);\n      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(os.expire, { topic: t }));\n    });\n  }\n}, em = class extends pl {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new We.EventEmitter(), this.name = R1, this.version = C1, this.cached = [], this.initialized = !1, this.storagePrefix = hi, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((s) => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.set = (s, r, n) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({ type: \"method\", method: \"set\", topic: s, request: r, chainId: n }), this.records.has(r.id))\n        return;\n      const o = { id: r.id, topic: s, request: { method: r.method, params: r.params || null }, chainId: n, expiry: Mt(V.THIRTY_DAYS) };\n      this.records.set(o.id, o), this.events.emit(zt.created, o);\n    }, this.resolve = async (s) => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({ type: \"method\", method: \"update\", response: s }), !this.records.has(s.id))\n        return;\n      const r = await this.getRecord(s.id);\n      typeof r.response > \"u\" && (r.response = Ge(s) ? { error: s.error } : { result: s.result }, this.records.set(r.id, r), this.events.emit(zt.updated, r));\n    }, this.get = async (s, r) => (this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({ type: \"method\", method: \"get\", topic: s, id: r }), await this.getRecord(r)), this.delete = (s, r) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({ type: \"method\", method: \"delete\", id: r }), this.values.forEach((n) => {\n        if (n.topic === s) {\n          if (typeof r < \"u\" && n.id !== r)\n            return;\n          this.records.delete(n.id), this.events.emit(zt.deleted, n);\n        }\n      });\n    }, this.exists = async (s, r) => (this.isInitialized(), this.records.has(r) ? (await this.getRecord(r)).topic === s : !1), this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach((t) => {\n      if (typeof t.response < \"u\")\n        return;\n      const s = { topic: t.topic, request: ti(t.request.method, t.request.params, t.id), chainId: t.chainId };\n      return e.push(s);\n    }), e;\n  }\n  async setJsonRpcRecords(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const { message: s } = Y(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(zt.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getJsonRpcRecords();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.records.size) {\n        const { message: t } = Y(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", records: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(zt.created, (e) => {\n      const t = zt.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    }), this.events.on(zt.updated, (e) => {\n      const t = zt.updated;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    }), this.events.on(zt.deleted, (e) => {\n      const t = zt.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    }), this.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, () => {\n      this.cleanup();\n    });\n  }\n  cleanup() {\n    try {\n      this.records.forEach((e) => {\n        V.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));\n      });\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, tm = class extends vl {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new We.EventEmitter(), this.name = A1, this.version = T1, this.cached = [], this.initialized = !1, this.storagePrefix = hi, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((s) => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.has = (s) => {\n      try {\n        const r = this.formatTarget(s);\n        return typeof this.getExpiration(r) < \"u\";\n      } catch {\n        return !1;\n      }\n    }, this.set = (s, r) => {\n      this.isInitialized();\n      const n = this.formatTarget(s), o = { target: n, expiry: r };\n      this.expirations.set(n, o), this.checkExpiry(n, o), this.events.emit(Tt.created, { target: n, expiration: o });\n    }, this.get = (s) => {\n      this.isInitialized();\n      const r = this.formatTarget(s);\n      return this.getExpiration(r);\n    }, this.del = (s) => {\n      if (this.isInitialized(), this.has(s)) {\n        const r = this.formatTarget(s), n = this.getExpiration(r);\n        this.expirations.delete(r), this.events.emit(Tt.deleted, { target: r, expiration: n });\n      }\n    }, this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\")\n      return vp(e);\n    if (typeof e == \"number\")\n      return _p(e);\n    const { message: t } = Y(\"UNKNOWN_TYPE\", `Target type: ${typeof e}`);\n    throw new Error(t);\n  }\n  async setExpirations(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit(Tt.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getExpirations();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.expirations.size) {\n        const { message: t } = Y(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", expirations: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);\n    }\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const { message: s } = Y(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(s), new Error(s);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const { expiry: s } = t;\n    V.toMiliseconds(s) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit(Tt.expired, { target: e, expiration: t });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(Tt.created, (e) => {\n      const t = Tt.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    }), this.events.on(Tt.expired, (e) => {\n      const t = Tt.expired;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    }), this.events.on(Tt.deleted, (e) => {\n      const t = Tt.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, im = class extends _l {\n  constructor(e, t) {\n    super(e, t), this.projectId = e, this.logger = t, this.name = Nr, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async (s) => {\n      if (this.verifyDisabled || ur() || !vs())\n        return;\n      const r = s?.verifyUrl || Ks;\n      this.verifyUrl !== r && this.removeIframe(), this.verifyUrl = r;\n      try {\n        await this.createIframe();\n      } catch (n) {\n        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n);\n      }\n      if (!this.initialized) {\n        this.removeIframe(), this.verifyUrl = ta;\n        try {\n          await this.createIframe();\n        } catch (n) {\n          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n), this.verifyDisabled = !0;\n        }\n      }\n    }, this.register = async (s) => {\n      this.initialized ? this.sendPost(s.attestationId) : (this.addToQueue(s.attestationId), await this.init());\n    }, this.resolve = async (s) => {\n      if (this.isDevEnv)\n        return \"\";\n      const r = s?.verifyUrl || Ks;\n      let n;\n      try {\n        n = await this.fetchAttestation(s.attestationId, r);\n      } catch (o) {\n        this.logger.info(`failed to resolve attestation: ${s.attestationId} from url: ${r}`), this.logger.info(o), n = await this.fetchAttestation(s.attestationId, ta);\n      }\n      return n;\n    }, this.fetchAttestation = async (s, r) => {\n      this.logger.info(`resolving attestation: ${s} from url: ${r}`);\n      const n = this.startAbortTimer(V.ONE_SECOND * 2), o = await fetch(`${r}/attestation/${s}`, { signal: this.abortController.signal });\n      return clearTimeout(n), o.status === 200 ? await o.json() : void 0;\n    }, this.addToQueue = (s) => {\n      this.queue.push(s);\n    }, this.processQueue = () => {\n      this.queue.length !== 0 && (this.queue.forEach((s) => this.sendPost(s)), this.queue = []);\n    }, this.sendPost = (s) => {\n      var r;\n      try {\n        if (!this.iframe)\n          return;\n        (r = this.iframe.contentWindow) == null || r.postMessage(s, \"*\"), this.logger.info(`postMessage sent: ${s} ${this.verifyUrl}`);\n      } catch {\n      }\n    }, this.createIframe = async () => {\n      let s;\n      const r = (n) => {\n        n.data === \"verify_ready\" && (this.initialized = !0, this.processQueue(), window.removeEventListener(\"message\", r), s());\n      };\n      await Promise.race([new Promise((n) => {\n        if (document.getElementById(Nr))\n          return n();\n        window.addEventListener(\"message\", r);\n        const o = document.createElement(\"iframe\");\n        o.id = Nr, o.src = `${this.verifyUrl}/${this.projectId}`, o.style.display = \"none\", document.body.append(o), this.iframe = o, s = n;\n      }), new Promise((n, o) => setTimeout(() => {\n        window.removeEventListener(\"message\", r), o(\"verify iframe load timeout\");\n      }, V.toMiliseconds(V.FIVE_SECONDS)))]);\n    }, this.removeIframe = () => {\n      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);\n    }, this.logger = ee.generateChildLogger(t, this.name), this.verifyUrl = Ks, this.abortController = new AbortController(), this.isDevEnv = yn() && process.env.IS_VITEST;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  startAbortTimer(e) {\n    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), V.toMiliseconds(e));\n  }\n};\nvar sm = Object.defineProperty, ha = Object.getOwnPropertySymbols, rm = Object.prototype.hasOwnProperty, nm = Object.prototype.propertyIsEnumerable, ua = (i, e, t) => e in i ? sm(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, la = (i, e) => {\n  for (var t in e || (e = {}))\n    rm.call(e, t) && ua(i, t, e[t]);\n  if (ha)\n    for (var t of ha(e))\n      nm.call(e, t) && ua(i, t, e[t]);\n  return i;\n};\nlet om = class uh extends fl {\n  constructor(e) {\n    super(e), this.protocol = ah, this.version = o1, this.name = En, this.events = new We.EventEmitter(), this.initialized = !1, this.on = (s, r) => this.events.on(s, r), this.once = (s, r) => this.events.once(s, r), this.off = (s, r) => this.events.off(s, r), this.removeListener = (s, r) => this.events.removeListener(s, r), this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || hh;\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ee.pino(ee.getDefaultLoggerOptions({ level: e?.logger || a1.logger }));\n    this.logger = ee.generateChildLogger(t, this.name), this.heartbeat = new Wt.HeartBeat(), this.crypto = new F1(this, this.logger, e?.keychain), this.history = new em(this, this.logger), this.expirer = new tm(this, this.logger), this.storage = e != null && e.storage ? e.storage : new nc(la(la({}, c1), e?.storageOptions)), this.relayer = new Y1({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Z1(this, this.logger), this.verify = new im(this.projectId || \"\", this.logger);\n  }\n  static async init(e) {\n    const t = new uh(e);\n    await t.initialize();\n    const s = await t.crypto.getClientId();\n    return await t.storage.setItem(I1, s), t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  async start() {\n    this.initialized || await this.initialize();\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info(\"Core Initialization Success\");\n    } catch (e) {\n      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;\n    }\n  }\n};\nconst am = om, lh = \"wc\", dh = 2, fh = \"client\", Sn = `${lh}@${dh}:${fh}:`, Rr = { name: fh, logger: \"error\", controller: !1, relayUrl: \"wss://relay.walletconnect.com\" }, da = \"WALLETCONNECT_DEEPLINK_CHOICE\", cm = \"proposal\", hm = \"Proposal expired\", um = \"session\", Fs = V.SEVEN_DAYS, lm = \"engine\", es = { wc_sessionPropose: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, Cr = { min: V.FIVE_MINUTES, max: V.SEVEN_DAYS }, ei = { idle: \"IDLE\", active: \"ACTIVE\" }, dm = \"request\", fm = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\nvar pm = Object.defineProperty, gm = Object.defineProperties, ym = Object.getOwnPropertyDescriptors, fa = Object.getOwnPropertySymbols, mm = Object.prototype.hasOwnProperty, bm = Object.prototype.propertyIsEnumerable, pa = (i, e, t) => e in i ? pm(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Et = (i, e) => {\n  for (var t in e || (e = {}))\n    mm.call(e, t) && pa(i, t, e[t]);\n  if (fa)\n    for (var t of fa(e))\n      bm.call(e, t) && pa(i, t, e[t]);\n  return i;\n}, ts = (i, e) => gm(i, ym(e));\nlet wm = class extends Sl {\n  constructor(e) {\n    super(e), this.name = lm, this.events = new ir(), this.initialized = !1, this.ignoredPayloadTypes = [Di], this.requestQueue = { state: ei.idle, queue: [] }, this.sessionRequestQueue = { state: ei.idle, queue: [] }, this.requestQueueDelay = V.ONE_SECOND, this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(es) }), this.initialized = !0, setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();\n      }, V.toMiliseconds(this.requestQueueDelay)));\n    }, this.connect = async (t) => {\n      await this.isInitialized();\n      const s = ts(Et({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });\n      await this.isValidConnect(s);\n      const { pairingTopic: r, requiredNamespaces: n, optionalNamespaces: o, sessionProperties: c, relays: u } = s;\n      let d = r, p, b = !1;\n      if (d && (b = this.client.core.pairing.pairings.get(d).active), !d || !b) {\n        const { topic: D, uri: y } = await this.client.core.pairing.create();\n        d = D, p = y;\n      }\n      const x = await this.client.core.crypto.generateKeyPair(), O = Et({ requiredNamespaces: n, optionalNamespaces: o, relays: u ?? [{ protocol: ch }], proposer: { publicKey: x, metadata: this.client.metadata } }, c && { sessionProperties: c }), { reject: _, resolve: C, done: F } = Ai(V.FIVE_MINUTES, hm);\n      if (this.events.once(Be(\"session_connect\"), async ({ error: D, session: y }) => {\n        if (D)\n          _(D);\n        else if (y) {\n          y.self.publicKey = x;\n          const w = ts(Et({}, y), { requiredNamespaces: y.requiredNamespaces, optionalNamespaces: y.optionalNamespaces });\n          await this.client.session.set(y.topic, w), await this.setExpiry(y.topic, y.expiry), d && await this.client.core.pairing.updateMetadata({ topic: d, metadata: y.peer.metadata }), C(w);\n        }\n      }), !d) {\n        const { message: D } = Y(\"NO_MATCHING_KEY\", `connect() pairing topic: ${d}`);\n        throw new Error(D);\n      }\n      const K = await this.sendRequest({ topic: d, method: \"wc_sessionPropose\", params: O }), I = Mt(V.FIVE_MINUTES);\n      return await this.setProposal(K, Et({ id: K, expiry: I }, O)), { uri: p, approval: F };\n    }, this.pair = async (t) => (await this.isInitialized(), await this.client.core.pairing.pair(t)), this.approve = async (t) => {\n      await this.isInitialized(), await this.isValidApprove(t);\n      const { id: s, relayProtocol: r, namespaces: n, sessionProperties: o } = t, c = this.client.proposal.get(s);\n      let { pairingTopic: u, proposer: d, requiredNamespaces: p, optionalNamespaces: b } = c;\n      u = u || \"\", cs(p) || (p = Up(n, \"approve()\"));\n      const x = await this.client.core.crypto.generateKeyPair(), O = d.publicKey, _ = await this.client.core.crypto.generateSharedKey(x, O);\n      u && s && (await this.client.core.pairing.updateMetadata({ topic: u, metadata: d.metadata }), await this.sendResult({ id: s, topic: u, result: { relay: { protocol: r ?? \"irn\" }, responderPublicKey: x } }), await this.client.proposal.delete(s, nt(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({ topic: u }));\n      const C = Et({ relay: { protocol: r ?? \"irn\" }, namespaces: n, requiredNamespaces: p, optionalNamespaces: b, pairingTopic: u, controller: { publicKey: x, metadata: this.client.metadata }, expiry: Mt(Fs) }, o && { sessionProperties: o });\n      await this.client.core.relayer.subscribe(_), await this.sendRequest({ topic: _, method: \"wc_sessionSettle\", params: C, throwOnFailedPublish: !0 });\n      const F = ts(Et({}, C), { topic: _, pairingTopic: u, acknowledged: !1, self: C.controller, peer: { publicKey: d.publicKey, metadata: d.metadata }, controller: x });\n      return await this.client.session.set(_, F), await this.setExpiry(_, Mt(Fs)), { topic: _, acknowledged: () => new Promise((K) => setTimeout(() => K(this.client.session.get(_)), 500)) };\n    }, this.reject = async (t) => {\n      await this.isInitialized(), await this.isValidReject(t);\n      const { id: s, reason: r } = t, { pairingTopic: n } = this.client.proposal.get(s);\n      n && (await this.sendError(s, n, r), await this.client.proposal.delete(s, nt(\"USER_DISCONNECTED\")));\n    }, this.update = async (t) => {\n      await this.isInitialized(), await this.isValidUpdate(t);\n      const { topic: s, namespaces: r } = t, n = await this.sendRequest({ topic: s, method: \"wc_sessionUpdate\", params: { namespaces: r } }), { done: o, resolve: c, reject: u } = Ai();\n      return this.events.once(Be(\"session_update\", n), ({ error: d }) => {\n        d ? u(d) : c();\n      }), await this.client.session.update(s, { namespaces: r }), { acknowledged: o };\n    }, this.extend = async (t) => {\n      await this.isInitialized(), await this.isValidExtend(t);\n      const { topic: s } = t, r = await this.sendRequest({ topic: s, method: \"wc_sessionExtend\", params: {} }), { done: n, resolve: o, reject: c } = Ai();\n      return this.events.once(Be(\"session_extend\", r), ({ error: u }) => {\n        u ? c(u) : o();\n      }), await this.setExpiry(s, Mt(Fs)), { acknowledged: n };\n    }, this.request = async (t) => {\n      await this.isInitialized(), await this.isValidRequest(t);\n      const { chainId: s, request: r, topic: n, expiry: o } = t, c = wn(), { done: u, resolve: d, reject: p } = Ai(o);\n      return this.events.once(Be(\"session_request\", c), ({ error: b, result: x }) => {\n        b ? p(b) : d(x);\n      }), await Promise.all([new Promise(async (b) => {\n        await this.sendRequest({ clientRpcId: c, topic: n, method: \"wc_sessionRequest\", params: { request: r, chainId: s }, expiry: o, throwOnFailedPublish: !0 }).catch((x) => p(x)), this.client.events.emit(\"session_request_sent\", { topic: n, request: r, chainId: s, id: c }), b();\n      }), new Promise(async (b) => {\n        const x = await this.client.core.storage.getItem(da);\n        Ep({ id: c, topic: n, wcDeepLink: x }), b();\n      }), u()]).then((b) => b[2]);\n    }, this.respond = async (t) => {\n      await this.isInitialized(), await this.isValidRespond(t);\n      const { topic: s, response: r } = t, { id: n } = r;\n      ht(r) ? await this.sendResult({ id: n, topic: s, result: r.result, throwOnFailedPublish: !0 }) : Ge(r) && await this.sendError(n, s, r.error), this.cleanupAfterResponse(t);\n    }, this.ping = async (t) => {\n      await this.isInitialized(), await this.isValidPing(t);\n      const { topic: s } = t;\n      if (this.client.session.keys.includes(s)) {\n        const r = await this.sendRequest({ topic: s, method: \"wc_sessionPing\", params: {} }), { done: n, resolve: o, reject: c } = Ai();\n        this.events.once(Be(\"session_ping\", r), ({ error: u }) => {\n          u ? c(u) : o();\n        }), await n();\n      } else\n        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });\n    }, this.emit = async (t) => {\n      await this.isInitialized(), await this.isValidEmit(t);\n      const { topic: s, event: r, chainId: n } = t;\n      await this.sendRequest({ topic: s, method: \"wc_sessionEvent\", params: { event: r, chainId: n } });\n    }, this.disconnect = async (t) => {\n      await this.isInitialized(), await this.isValidDisconnect(t);\n      const { topic: s } = t;\n      this.client.session.keys.includes(s) ? (await this.sendRequest({ topic: s, method: \"wc_sessionDelete\", params: nt(\"USER_DISCONNECTED\"), throwOnFailedPublish: !0 }), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({ topic: s });\n    }, this.find = (t) => (this.isInitialized(), this.client.session.getAll().filter((s) => qp(s, t))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (t) => {\n      if (t.pairingTopic)\n        try {\n          const s = this.client.core.pairing.pairings.get(t.pairingTopic), r = this.client.core.pairing.pairings.getAll().filter((n) => {\n            var o, c;\n            return ((o = n.peerMetadata) == null ? void 0 : o.url) && ((c = n.peerMetadata) == null ? void 0 : c.url) === t.peer.metadata.url && n.topic && n.topic !== s.topic;\n          });\n          if (r.length === 0)\n            return;\n          this.client.logger.info(`Cleaning up ${r.length} duplicate pairing(s)`), await Promise.all(r.map((n) => this.client.core.pairing.disconnect({ topic: n.topic }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n        } catch (s) {\n          this.client.logger.error(s);\n        }\n    }, this.deleteSession = async (t, s) => {\n      const { self: r } = this.client.session.get(t);\n      await this.client.core.relayer.unsubscribe(t), this.client.session.delete(t, nt(\"USER_DISCONNECTED\")), this.client.core.crypto.keychain.has(r.publicKey) && await this.client.core.crypto.deleteKeyPair(r.publicKey), this.client.core.crypto.keychain.has(t) && await this.client.core.crypto.deleteSymKey(t), s || this.client.core.expirer.del(t), this.client.core.storage.removeItem(da).catch((n) => this.client.logger.warn(n));\n    }, this.deleteProposal = async (t, s) => {\n      await Promise.all([this.client.proposal.delete(t, nt(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(t)]);\n    }, this.deletePendingSessionRequest = async (t, s, r = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(t, s), r ? Promise.resolve() : this.client.core.expirer.del(t)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((n) => n.id !== t), r && (this.sessionRequestQueue.state = ei.idle);\n    }, this.setExpiry = async (t, s) => {\n      this.client.session.keys.includes(t) && await this.client.session.update(t, { expiry: s }), this.client.core.expirer.set(t, s);\n    }, this.setProposal = async (t, s) => {\n      await this.client.proposal.set(t, s), this.client.core.expirer.set(t, s.expiry);\n    }, this.setPendingSessionRequest = async (t) => {\n      const s = es.wc_sessionRequest.req.ttl, { id: r, topic: n, params: o, verifyContext: c } = t;\n      await this.client.pendingRequest.set(r, { id: r, topic: n, params: o, verifyContext: c }), s && this.client.core.expirer.set(r, Mt(s));\n    }, this.sendRequest = async (t) => {\n      const { topic: s, method: r, params: n, expiry: o, relayRpcId: c, clientRpcId: u, throwOnFailedPublish: d } = t, p = ti(r, n, u);\n      if (vs() && fm.includes(r)) {\n        const O = Fi(JSON.stringify(p));\n        this.client.core.verify.register({ attestationId: O });\n      }\n      const b = await this.client.core.crypto.encode(s, p), x = es[r].req;\n      return o && (x.ttl = o), c && (x.id = c), this.client.core.history.set(s, p), d ? (x.internal = ts(Et({}, x.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(s, b, x)) : this.client.core.relayer.publish(s, b, x).catch((O) => this.client.logger.error(O)), p.id;\n    }, this.sendResult = async (t) => {\n      const { id: s, topic: r, result: n, throwOnFailedPublish: o } = t, c = xi(s, n), u = await this.client.core.crypto.encode(r, c), d = await this.client.core.history.get(r, s), p = es[d.request.method].res;\n      o ? (p.internal = ts(Et({}, p.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(r, u, p)) : this.client.core.relayer.publish(r, u, p).catch((b) => this.client.logger.error(b)), await this.client.core.history.resolve(c);\n    }, this.sendError = async (t, s, r) => {\n      const n = qi(t, r), o = await this.client.core.crypto.encode(s, n), c = await this.client.core.history.get(s, t), u = es[c.request.method].res;\n      this.client.core.relayer.publish(s, o, u), await this.client.core.history.resolve(n);\n    }, this.cleanup = async () => {\n      const t = [], s = [];\n      this.client.session.getAll().forEach((r) => {\n        ai(r.expiry) && t.push(r.topic);\n      }), this.client.proposal.getAll().forEach((r) => {\n        ai(r.expiry) && s.push(r.id);\n      }), await Promise.all([...t.map((r) => this.deleteSession(r)), ...s.map((r) => this.deleteProposal(r))]);\n    }, this.onRelayEventRequest = async (t) => {\n      this.requestQueue.queue.push(t), await this.processRequestsQueue();\n    }, this.processRequestsQueue = async () => {\n      if (this.requestQueue.state === ei.active) {\n        this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {\n        this.requestQueue.state = ei.active;\n        const t = this.requestQueue.queue.shift();\n        if (t)\n          try {\n            this.processRequest(t), await new Promise((s) => setTimeout(s, 300));\n          } catch (s) {\n            this.client.logger.warn(s);\n          }\n      }\n      this.requestQueue.state = ei.idle;\n    }, this.processRequest = (t) => {\n      const { topic: s, payload: r } = t, n = r.method;\n      switch (n) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, r);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, r);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, r);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, r);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, r);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, r);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, r);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, r);\n        default:\n          return this.client.logger.info(`Unsupported request method ${n}`);\n      }\n    }, this.onRelayEventResponse = async (t) => {\n      const { topic: s, payload: r } = t, n = (await this.client.core.history.get(s, r.id)).request.method;\n      switch (n) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, r);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, r);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, r);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, r);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, r);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, r);\n        default:\n          return this.client.logger.info(`Unsupported response method ${n}`);\n      }\n    }, this.onRelayEventUnknownPayload = (t) => {\n      const { topic: s } = t, { message: r } = Y(\"MISSING_OR_INVALID\", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(r);\n    }, this.onSessionProposeRequest = async (t, s) => {\n      const { params: r, id: n } = s;\n      try {\n        this.isValidConnect(Et({}, s.params));\n        const o = Mt(V.FIVE_MINUTES), c = Et({ id: n, pairingTopic: t, expiry: o }, r);\n        await this.setProposal(n, c);\n        const u = Fi(JSON.stringify(s)), d = await this.getVerifyContext(u, c.proposer.metadata);\n        this.client.events.emit(\"session_proposal\", { id: n, params: c, verifyContext: d });\n      } catch (o) {\n        await this.sendError(n, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionProposeResponse = async (t, s) => {\n      const { id: r } = s;\n      if (ht(s)) {\n        const { result: n } = s;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result: n });\n        const o = this.client.proposal.get(r);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal: o });\n        const c = o.proposer.publicKey;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", selfPublicKey: c });\n        const u = n.responderPublicKey;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", peerPublicKey: u });\n        const d = await this.client.core.crypto.generateSharedKey(c, u);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", sessionTopic: d });\n        const p = await this.client.core.relayer.subscribe(d);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", subscriptionId: p }), await this.client.core.pairing.activate({ topic: t });\n      } else\n        Ge(s) && (await this.client.proposal.delete(r, nt(\"USER_DISCONNECTED\")), this.events.emit(Be(\"session_connect\"), { error: s.error }));\n    }, this.onSessionSettleRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        this.isValidSessionSettleRequest(n);\n        const { relay: o, controller: c, expiry: u, namespaces: d, requiredNamespaces: p, optionalNamespaces: b, sessionProperties: x, pairingTopic: O } = s.params, _ = Et({ topic: t, relay: o, expiry: u, namespaces: d, acknowledged: !0, pairingTopic: O, requiredNamespaces: p, optionalNamespaces: b, controller: c.publicKey, self: { publicKey: \"\", metadata: this.client.metadata }, peer: { publicKey: c.publicKey, metadata: c.metadata } }, x && { sessionProperties: x });\n        await this.sendResult({ id: s.id, topic: t, result: !0 }), this.events.emit(Be(\"session_connect\"), { session: _ }), this.cleanupDuplicatePairings(_);\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionSettleResponse = async (t, s) => {\n      const { id: r } = s;\n      ht(s) ? (await this.client.session.update(t, { acknowledged: !0 }), this.events.emit(Be(\"session_approve\", r), {})) : Ge(s) && (await this.client.session.delete(t, nt(\"USER_DISCONNECTED\")), this.events.emit(Be(\"session_approve\", r), { error: s.error }));\n    }, this.onSessionUpdateRequest = async (t, s) => {\n      const { params: r, id: n } = s;\n      try {\n        const o = `${t}_session_update`, c = $s.get(o);\n        if (c && this.isRequestOutOfSync(c, n)) {\n          this.client.logger.info(`Discarding out of sync request - ${n}`);\n          return;\n        }\n        this.isValidUpdate(Et({ topic: t }, r)), await this.client.session.update(t, { namespaces: r.namespaces }), await this.sendResult({ id: n, topic: t, result: !0 }), this.client.events.emit(\"session_update\", { id: n, topic: t, params: r }), $s.set(o, n);\n      } catch (o) {\n        await this.sendError(n, t, o), this.client.logger.error(o);\n      }\n    }, this.isRequestOutOfSync = (t, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(t.toString().slice(0, -3)), this.onSessionUpdateResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(Be(\"session_update\", r), {}) : Ge(s) && this.events.emit(Be(\"session_update\", r), { error: s.error });\n    }, this.onSessionExtendRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidExtend({ topic: t }), await this.setExpiry(t, Mt(Fs)), await this.sendResult({ id: r, topic: t, result: !0 }), this.client.events.emit(\"session_extend\", { id: r, topic: t });\n      } catch (n) {\n        await this.sendError(r, t, n), this.client.logger.error(n);\n      }\n    }, this.onSessionExtendResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(Be(\"session_extend\", r), {}) : Ge(s) && this.events.emit(Be(\"session_extend\", r), { error: s.error });\n    }, this.onSessionPingRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidPing({ topic: t }), await this.sendResult({ id: r, topic: t, result: !0 }), this.client.events.emit(\"session_ping\", { id: r, topic: t });\n      } catch (n) {\n        await this.sendError(r, t, n), this.client.logger.error(n);\n      }\n    }, this.onSessionPingResponse = (t, s) => {\n      const { id: r } = s;\n      setTimeout(() => {\n        ht(s) ? this.events.emit(Be(\"session_ping\", r), {}) : Ge(s) && this.events.emit(Be(\"session_ping\", r), { error: s.error });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidDisconnect({ topic: t, reason: s.params }), await Promise.all([new Promise((n) => {\n          this.client.core.relayer.once(gt.publish, async () => {\n            n(await this.deleteSession(t));\n          });\n        }), this.sendResult({ id: r, topic: t, result: !0 })]), this.client.events.emit(\"session_delete\", { id: r, topic: t });\n      } catch (n) {\n        this.client.logger.error(n);\n      }\n    }, this.onSessionRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        this.isValidRequest(Et({ topic: t }, n));\n        const o = Fi(JSON.stringify(ti(\"wc_sessionRequest\", n, r))), c = this.client.session.get(t), u = await this.getVerifyContext(o, c.peer.metadata), d = { id: r, topic: t, params: n, verifyContext: u };\n        await this.setPendingSessionRequest(d), this.addSessionRequestToSessionRequestQueue(d), this.processSessionRequestQueue();\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionRequestResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(Be(\"session_request\", r), { result: s.result }) : Ge(s) && this.events.emit(Be(\"session_request\", r), { error: s.error });\n    }, this.onSessionEventRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        const o = `${t}_session_event_${n.event.name}`, c = $s.get(o);\n        if (c && this.isRequestOutOfSync(c, r)) {\n          this.client.logger.info(`Discarding out of sync request - ${r}`);\n          return;\n        }\n        this.isValidEmit(Et({ topic: t }, n)), this.client.events.emit(\"session_event\", { id: r, topic: t, params: n }), $s.set(o, r);\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.addSessionRequestToSessionRequestQueue = (t) => {\n      this.sessionRequestQueue.queue.push(t);\n    }, this.cleanupAfterResponse = (t) => {\n      this.deletePendingSessionRequest(t.response.id, { message: \"fulfilled\", code: 0 }), setTimeout(() => {\n        this.sessionRequestQueue.state = ei.idle, this.processSessionRequestQueue();\n      }, V.toMiliseconds(this.requestQueueDelay));\n    }, this.processSessionRequestQueue = () => {\n      if (this.sessionRequestQueue.state === ei.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const t = this.sessionRequestQueue.queue[0];\n      if (!t) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = ei.active, this.client.events.emit(\"session_request\", t);\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.onPairingCreated = (t) => {\n      if (t.active)\n        return;\n      const s = this.client.proposal.getAll().find((r) => r.pairingTopic === t.topic);\n      s && this.onSessionProposeRequest(t.topic, ti(\"wc_sessionPropose\", { requiredNamespaces: s.requiredNamespaces, optionalNamespaces: s.optionalNamespaces, relays: s.relays, proposer: s.proposer }, s.id));\n    }, this.isValidConnect = async (t) => {\n      if (!St(t)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(t)}`);\n        throw new Error(u);\n      }\n      const { pairingTopic: s, requiredNamespaces: r, optionalNamespaces: n, sessionProperties: o, relays: c } = t;\n      if (bt(s) || await this.isValidPairingTopic(s), !Qp(c, !0)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `connect() relays: ${c}`);\n        throw new Error(u);\n      }\n      !bt(r) && cs(r) !== 0 && this.validateNamespaces(r, \"requiredNamespaces\"), !bt(n) && cs(n) !== 0 && this.validateNamespaces(n, \"optionalNamespaces\"), bt(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.validateNamespaces = (t, s) => {\n      const r = Jp(t, \"connect()\", s);\n      if (r)\n        throw new Error(r.message);\n    }, this.isValidApprove = async (t) => {\n      if (!St(t))\n        throw new Error(Y(\"MISSING_OR_INVALID\", `approve() params: ${t}`).message);\n      const { id: s, namespaces: r, relayProtocol: n, sessionProperties: o } = t;\n      await this.isValidProposalId(s);\n      const c = this.client.proposal.get(s), u = zs(r, \"approve()\");\n      if (u)\n        throw new Error(u.message);\n      const d = Mo(c.requiredNamespaces, r, \"approve()\");\n      if (d)\n        throw new Error(d.message);\n      if (!ot(n, !0)) {\n        const { message: p } = Y(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${n}`);\n        throw new Error(p);\n      }\n      bt(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.isValidReject = async (t) => {\n      if (!St(t)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `reject() params: ${t}`);\n        throw new Error(n);\n      }\n      const { id: s, reason: r } = t;\n      if (await this.isValidProposalId(s), !Zp(r)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(r)}`);\n        throw new Error(n);\n      }\n    }, this.isValidSessionSettleRequest = (t) => {\n      if (!St(t)) {\n        const { message: d } = Y(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${t}`);\n        throw new Error(d);\n      }\n      const { relay: s, controller: r, namespaces: n, expiry: o } = t;\n      if (!Kc(s)) {\n        const { message: d } = Y(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(d);\n      }\n      const c = Bp(r, \"onSessionSettleRequest()\");\n      if (c)\n        throw new Error(c.message);\n      const u = zs(n, \"onSessionSettleRequest()\");\n      if (u)\n        throw new Error(u.message);\n      if (ai(o)) {\n        const { message: d } = Y(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(d);\n      }\n    }, this.isValidUpdate = async (t) => {\n      if (!St(t)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `update() params: ${t}`);\n        throw new Error(u);\n      }\n      const { topic: s, namespaces: r } = t;\n      await this.isValidSessionTopic(s);\n      const n = this.client.session.get(s), o = zs(r, \"update()\");\n      if (o)\n        throw new Error(o.message);\n      const c = Mo(n.requiredNamespaces, r, \"update()\");\n      if (c)\n        throw new Error(c.message);\n    }, this.isValidExtend = async (t) => {\n      if (!St(t)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `extend() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async (t) => {\n      if (!St(t)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `request() params: ${t}`);\n        throw new Error(u);\n      }\n      const { topic: s, request: r, chainId: n, expiry: o } = t;\n      await this.isValidSessionTopic(s);\n      const { namespaces: c } = this.client.session.get(s);\n      if (!Lo(c, n)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `request() chainId: ${n}`);\n        throw new Error(u);\n      }\n      if (!eg(r)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(r)}`);\n        throw new Error(u);\n      }\n      if (!sg(c, n, r.method)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `request() method: ${r.method}`);\n        throw new Error(u);\n      }\n      if (o && !ag(o, Cr)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${Cr.min} and ${Cr.max}`);\n        throw new Error(u);\n      }\n    }, this.isValidRespond = async (t) => {\n      if (!St(t)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `respond() params: ${t}`);\n        throw new Error(n);\n      }\n      const { topic: s, response: r } = t;\n      if (await this.isValidSessionTopic(s), !tg(r)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(r)}`);\n        throw new Error(n);\n      }\n    }, this.isValidPing = async (t) => {\n      if (!St(t)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `ping() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async (t) => {\n      if (!St(t)) {\n        const { message: c } = Y(\"MISSING_OR_INVALID\", `emit() params: ${t}`);\n        throw new Error(c);\n      }\n      const { topic: s, event: r, chainId: n } = t;\n      await this.isValidSessionTopic(s);\n      const { namespaces: o } = this.client.session.get(s);\n      if (!Lo(o, n)) {\n        const { message: c } = Y(\"MISSING_OR_INVALID\", `emit() chainId: ${n}`);\n        throw new Error(c);\n      }\n      if (!ig(r)) {\n        const { message: c } = Y(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(r)}`);\n        throw new Error(c);\n      }\n      if (!rg(o, n, r.name)) {\n        const { message: c } = Y(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(r)}`);\n        throw new Error(c);\n      }\n    }, this.isValidDisconnect = async (t) => {\n      if (!St(t)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `disconnect() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.getVerifyContext = async (t, s) => {\n      const r = { verified: { verifyUrl: s.verifyUrl || Ks, validation: \"UNKNOWN\", origin: s.url || \"\" } };\n      try {\n        const n = await this.client.core.verify.resolve({ attestationId: t, verifyUrl: s.verifyUrl });\n        n && (r.verified.origin = n.origin, r.verified.isScam = n.isScam, r.verified.validation = n.origin === new URL(s.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (n) {\n        this.client.logger.info(n);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(r)}`), r;\n    }, this.validateSessionProps = (t, s) => {\n      Object.values(t).forEach((r) => {\n        if (!ot(r, !1)) {\n          const { message: n } = Y(\"MISSING_OR_INVALID\", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(r)}`);\n          throw new Error(n);\n        }\n      });\n    };\n  }\n  async isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(gt.message, async (e) => {\n      const { topic: t, message: s } = e;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))\n        return;\n      const r = await this.client.core.crypto.decode(t, s);\n      try {\n        ji(r) ? (this.client.core.history.set(t, r), this.onRelayEventRequest({ topic: t, payload: r })) : Oi(r) ? (await this.client.core.history.resolve(r), await this.onRelayEventResponse({ topic: t, payload: r }), this.client.core.history.delete(t, r.id)) : this.onRelayEventUnknownPayload({ topic: t, payload: r });\n      } catch (n) {\n        this.client.logger.error(n);\n      }\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(Tt.expired, async (e) => {\n      const { topic: t, id: s } = jc(e.target);\n      if (s && this.client.pendingRequest.keys.includes(s))\n        return await this.deletePendingSessionRequest(s, Y(\"EXPIRED\"), !0);\n      t ? this.client.session.keys.includes(t) && (await this.deleteSession(t, !0), this.client.events.emit(\"session_expire\", { topic: t })) : s && (await this.deleteProposal(s, !0), this.client.events.emit(\"proposal_expire\", { id: s }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(os.create, (e) => this.onPairingCreated(e));\n  }\n  isValidPairingTopic(e) {\n    if (!ot(e, !1)) {\n      const { message: t } = Y(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(e)) {\n      const { message: t } = Y(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ai(this.client.core.pairing.pairings.get(e).expiry)) {\n      const { message: t } = Y(\"EXPIRED\", `pairing topic: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidSessionTopic(e) {\n    if (!ot(e, !1)) {\n      const { message: t } = Y(\"MISSING_OR_INVALID\", `session topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.session.keys.includes(e)) {\n      const { message: t } = Y(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ai(this.client.session.get(e).expiry)) {\n      await this.deleteSession(e);\n      const { message: t } = Y(\"EXPIRED\", `session topic: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidSessionOrPairingTopic(e) {\n    if (this.client.session.keys.includes(e))\n      await this.isValidSessionTopic(e);\n    else if (this.client.core.pairing.pairings.keys.includes(e))\n      this.isValidPairingTopic(e);\n    else if (ot(e, !1)) {\n      const { message: t } = Y(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${e}`);\n      throw new Error(t);\n    } else {\n      const { message: t } = Y(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidProposalId(e) {\n    if (!Xp(e)) {\n      const { message: t } = Y(\"MISSING_OR_INVALID\", `proposal id should be a number: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.proposal.keys.includes(e)) {\n      const { message: t } = Y(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ai(this.client.proposal.get(e).expiry)) {\n      await this.deleteProposal(e);\n      const { message: t } = Y(\"EXPIRED\", `proposal id: ${e}`);\n      throw new Error(t);\n    }\n  }\n}, vm = class extends dr {\n  constructor(e, t) {\n    super(e, t, cm, Sn), this.core = e, this.logger = t;\n  }\n}, _m = class extends dr {\n  constructor(e, t) {\n    super(e, t, um, Sn), this.core = e, this.logger = t;\n  }\n}, Em = class extends dr {\n  constructor(e, t) {\n    super(e, t, dm, Sn, (s) => s.id), this.core = e, this.logger = t;\n  }\n}, Sm = class ph extends El {\n  constructor(e) {\n    super(e), this.protocol = lh, this.version = dh, this.name = Rr.name, this.events = new We.EventEmitter(), this.on = (s, r) => this.events.on(s, r), this.once = (s, r) => this.events.once(s, r), this.off = (s, r) => this.events.off(s, r), this.removeListener = (s, r) => this.events.removeListener(s, r), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {\n      try {\n        return await this.engine.connect(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.pair = async (s) => {\n      try {\n        return await this.engine.pair(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.approve = async (s) => {\n      try {\n        return await this.engine.approve(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.reject = async (s) => {\n      try {\n        return await this.engine.reject(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.update = async (s) => {\n      try {\n        return await this.engine.update(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.extend = async (s) => {\n      try {\n        return await this.engine.extend(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.request = async (s) => {\n      try {\n        return await this.engine.request(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.respond = async (s) => {\n      try {\n        return await this.engine.respond(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.ping = async (s) => {\n      try {\n        return await this.engine.ping(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.emit = async (s) => {\n      try {\n        return await this.engine.emit(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.disconnect = async (s) => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.find = (s) => {\n      try {\n        return this.engine.find(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = e?.name || Rr.name, this.metadata = e?.metadata || gp();\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ee.pino(ee.getDefaultLoggerOptions({ level: e?.logger || Rr.logger }));\n    this.core = e?.core || new am(e), this.logger = ee.generateChildLogger(t, this.name), this.session = new _m(this.core, this.logger), this.proposal = new vm(this.core, this.logger), this.pendingRequest = new Em(this.core, this.logger), this.engine = new wm(this);\n  }\n  static async init(e) {\n    const t = new ph(e);\n    return await t.initialize(), t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info(\"SignClient Initialization Success\");\n    } catch (e) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(e.message), e;\n    }\n  }\n};\nconst Im = () => {\n  const e = hn()?.os?.toLowerCase();\n  return e?.includes(\"android\") ? \"android\" : e?.toLowerCase().includes(\"ios\") || e?.toLowerCase().includes(\"mac\") && navigator.maxTouchPoints > 1 ? \"ios\" : \"desktop\";\n}, Us = Im(), Dm = {\n  position: \"fixed\",\n  top: \"0\",\n  left: \"0\",\n  right: \"0\",\n  bottom: \"0\",\n  backgroundColor: \"rgba(0,0,0,0.8)\",\n  backdropFilter: \"blur(10px)\",\n  zIndex: \"9999\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  flexDirection: \"column\",\n  color: \"white\",\n  fontWeight: \"500\",\n  fontFamily: \"'Barlow', sans-serif\"\n}, xm = {\n  width: \"840px\",\n  height: \"540px\",\n  zIndex: \"99999\",\n  backgroundColor: \"white\",\n  border: \"none\",\n  outline: \"none\",\n  borderRadius: \"40px\",\n  boxShadow: \"0px 4px 40px 0px rgb(0 0 0), 0px 4px 8px 0px rgb(0 0 0 / 25%)\",\n  position: \"fixed\",\n  top: \"50%\",\n  left: \"50%\",\n  transform: \"translate(-50%,-50%)\"\n}, Om = `\n  <div id=\"argent-mobile-modal-container\" style=\"position: relative\">\n    <iframe class=\"argent-iframe\" allow=\"clipboard-write\"></iframe>\n    <div class=\"argent-close-button\" style=\"position: absolute; top: 24px; right: 24px; cursor: pointer;\">\n      <svg width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <circle cx=\"16\" cy=\"16\" r=\"16\" fill=\"#F5F3F0\"/>\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M22.2462 9.75382C22.7018 10.2094 22.7018 10.9481 22.2462 11.4037L17.6499 16L22.2462 20.5963C22.7018 21.0519 22.7018 21.7906 22.2462 22.2462C21.7905 22.7018 21.0519 22.7018 20.5962 22.2462L16 17.6499L11.4039 22.246C10.9482 22.7017 10.2096 22.7017 9.75394 22.246C9.29833 21.7904 9.29833 21.0517 9.75394 20.5961L14.3501 16L9.75394 11.4039C9.29833 10.9483 9.29833 10.2096 9.75394 9.75396C10.2096 9.29835 10.9482 9.29835 11.4039 9.75396L16 14.3501L20.5962 9.75382C21.0519 9.29821 21.7905 9.29821 22.2462 9.75382Z\" fill=\"#333332\"/>\n      </svg>\n    </div>\n  </div>\n`;\nclass Nm {\n  constructor() {\n    we(this, \"bridgeUrl\", \"https://login.argent.xyz\");\n    we(this, \"mobileUrl\", \"argent://\");\n    we(this, \"type\", \"overlay\");\n    we(this, \"wcUri\");\n    we(this, \"overlay\");\n    we(this, \"popupWindow\");\n    we(this, \"closingTimeout\");\n    we(this, \"close\", () => {\n      this.overlay?.remove(), this.popupWindow?.close(), this.overlay = void 0, this.popupWindow = void 0;\n    });\n  }\n  showConnectionModal(e) {\n    const t = encodeURIComponent(e), s = encodeURIComponent(window.location.href);\n    this.showModal({\n      desktop: `${this.bridgeUrl}?wc=${t}&device=desktop`,\n      ios: `${this.mobileUrl}app/wc?uri=${t}&href=${s}&device=mobile`,\n      android: `${this.mobileUrl}app/wc?uri=${t}&href=${s}&device=mobile`\n    });\n  }\n  showApprovalModal(e) {\n    if (Us === \"desktop\") {\n      this.showModal({\n        desktop: `${this.bridgeUrl}?action=sign`,\n        ios: \"\",\n        android: \"\"\n      });\n      return;\n    }\n    const t = encodeURIComponent(window.location.href);\n    this.showModal({\n      desktop: `${this.bridgeUrl}?action=sign&device=desktop`,\n      ios: `${this.mobileUrl}app/wc/request?href=${t}&device=mobile`,\n      android: `${this.mobileUrl}app/wc/request?href=${t}&device=mobile`\n    });\n  }\n  closeModal(e) {\n    e ? (this.overlay?.querySelector(\"iframe\")?.contentWindow?.postMessage(\"argent-login.success\", \"*\"), this.popupWindow?.postMessage(\"argent-login.success\", \"*\"), this.closingTimeout = setTimeout(this.close, 3400)) : this.close();\n  }\n  showModal(e) {\n    if (clearTimeout(this.closingTimeout), (this.overlay || this.popupWindow) && this.close(), Us === \"android\" || Us === \"ios\") {\n      const n = document.createElement(\"button\");\n      n.style.display = \"none\", n.addEventListener(\"click\", () => {\n        window.location.href = e[Us];\n      }), n.click();\n      return;\n    }\n    if (this.type === \"window\") {\n      const n = \"menubar=no,location=no,resizable=no,scrollbars=no,status=no,width=840,height=540\";\n      this.popupWindow = window.open(e.desktop, \"_blank\", n) || void 0;\n      return;\n    }\n    const t = document.createElement(\"div\");\n    t.innerHTML = Om, t.id = \"argent-mobile-modal-overlay\";\n    for (const [n, o] of Object.entries(Dm))\n      t.style[n] = o;\n    document.body.appendChild(t), t.addEventListener(\"click\", () => this.closeModal()), this.overlay = t;\n    const s = t.querySelector(\"iframe\");\n    s.setAttribute(\"src\", e.desktop);\n    for (const [n, o] of Object.entries(xm))\n      s.style[n] = o;\n    t.querySelector(\n      \".argent-close-button\"\n    ).addEventListener(\"click\", () => this.closeModal());\n  }\n}\nconst kt = new Nm(), Xs = starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName, Pm = async ({\n  projectId: i,\n  chainId: e,\n  name: t,\n  description: s,\n  rpcUrl: r,\n  bridgeUrl: n = Rm(e),\n  mobileUrl: o = Cm(e),\n  modalType: c = \"overlay\",\n  url: u,\n  icons: d,\n  walletConnect: p,\n  provider: b\n}, x) => {\n  if (!n)\n    throw new Error(\"bridgeUrl is required\");\n  if (!o)\n    throw new Error(\"mobileUrl is required\");\n  kt.bridgeUrl = n, kt.mobileUrl = o, kt.type = c;\n  const O = {\n    projectId: i,\n    metadata: {\n      name: t ?? \"Unknown dapp\",\n      description: s ?? \"Unknown dapp description\",\n      url: u ?? \"#\",\n      icons: d ?? [],\n      ...p?.metadata\n    }\n  }, _ = await Sm.init(O), C = new x({ client: _, chainId: e, rpcUrl: r, provider: b });\n  _.on(\"session_event\", (F) => {\n  }), _.on(\"session_update\", ({ topic: F, params: K }) => {\n    const { namespaces: I } = K, D = _.session.get(F);\n    C.updateSession({ ...D, namespaces: I });\n  }), _.on(\"session_delete\", () => {\n  });\n  try {\n    const F = _.session.getAll().find(C.isValidSession);\n    if (F)\n      return C.updateSession(F), C;\n    const K = { requiredNamespaces: C.getRequiredNamespaces() };\n    (0,_index_70f373da_js__WEBPACK_IMPORTED_MODULE_2__.r)(), await new Promise((y) => setTimeout(y, 200));\n    const { uri: I, approval: D } = await _.connect(K);\n    if (I) {\n      kt.showConnectionModal(I), kt.wcUri = I;\n      const y = await D();\n      C.updateSession(y), kt.closeModal(\"animateSuccess\");\n    }\n    return C;\n  } catch {\n    return console.error(\"@argent/login::error\"), kt.closeModal(), null;\n  }\n}, Rm = (i) => {\n  if (!i)\n    throw new Error(\n      `Unknown or unsupported chainId (${i}), either specify a supported chain or set bridgeUrl.`\n    );\n  const e = parseInt(`${i}`);\n  if (String(i).startsWith(Xs.SN_SEPOLIA) || e === 11155111)\n    return \"https://login.hydrogen.argent47.net\";\n  if (String(i).startsWith(Xs.SN_MAIN) || e === 1)\n    return \"https://login.argent.xyz\";\n}, Cm = (i) => {\n  if (!i)\n    throw new Error(\n      `Unknown or unsupported chainId (${i}), either specify a supported chain or set mobileUrl.`\n    );\n  const e = parseInt(`${i}`);\n  if (String(i).startsWith(Xs.SN_SEPOLIA) || e === 11155111)\n    return \"argent-dev://\";\n  if (String(i).startsWith(Xs.SN_MAIN) || e === 1)\n    return \"argent://\";\n};\nclass Am extends Nt {\n  constructor(e) {\n    super(), this.opts = e, this.protocol = \"wc\", this.version = 2;\n  }\n}\nclass Tm extends Nt {\n  constructor(e, t) {\n    super(), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map();\n  }\n}\nclass $m {\n  constructor(e, t) {\n    this.logger = e, this.core = t;\n  }\n}\nclass Fm extends Nt {\n  constructor(e, t) {\n    super(), this.relayer = e, this.logger = t;\n  }\n}\nlet Um = class extends Nt {\n  constructor(e) {\n    super();\n  }\n}, Lm = class {\n  constructor(e, t, s, r) {\n    this.core = e, this.logger = t, this.name = s;\n  }\n};\nclass Mm extends Nt {\n  constructor(e, t) {\n    super(), this.relayer = e, this.logger = t;\n  }\n}\nclass qm extends Nt {\n  constructor(e, t) {\n    super(), this.core = e, this.logger = t;\n  }\n}\nclass jm {\n  constructor(e, t) {\n    this.projectId = e, this.logger = t;\n  }\n}\nlet zm = class {\n  constructor(e) {\n    this.opts = e, this.protocol = \"wc\", this.version = 2;\n  }\n}, Km = class {\n  constructor(e) {\n    this.client = e;\n  }\n};\nconst gh = \":\";\nfunction Vm(i) {\n  const { namespace: e, reference: t } = i;\n  return [e, t].join(gh);\n}\nfunction Bm(i) {\n  const [e, t, s] = i.split(gh);\n  return { namespace: e, reference: t, address: s };\n}\nfunction km(i, e) {\n  const t = [];\n  return i.forEach((s) => {\n    const r = e(s);\n    t.includes(r) || t.push(r);\n  }), t;\n}\nfunction Hm(i) {\n  const { namespace: e, reference: t } = Bm(i);\n  return Vm({ namespace: e, reference: t });\n}\nfunction Gm(i) {\n  return km(i, Hm);\n}\nfunction Wm(i, e = []) {\n  const t = [];\n  return Object.keys(i).forEach((s) => {\n    if (e.length && !e.includes(s))\n      return;\n    const r = i[s];\n    t.push(...r.accounts);\n  }), t;\n}\nfunction Ym(i, e = []) {\n  const t = [];\n  return Object.keys(i).forEach((s) => {\n    if (e.length && !e.includes(s))\n      return;\n    const r = i[s];\n    t.push(...Gm(r.accounts));\n  }), t;\n}\nfunction Jm(i, e = []) {\n  const t = [];\n  return Object.keys(i).forEach((s) => {\n    if (e.length && !e.includes(s))\n      return;\n    const r = i[s];\n    t.push(...In(s, r));\n  }), t;\n}\nfunction In(i, e) {\n  return i.includes(\":\") ? [i] : e.chains || [];\n}\nconst yh = \"base10\", _t = \"base16\", Jr = \"base64pad\", Dn = \"utf8\", mh = 0, Ni = 1, Qm = 0, ga = 1, Qr = 12, xn = 32;\nfunction Xm() {\n  const i = ms.generateKeyPair();\n  return { privateKey: Ne(i.secretKey, _t), publicKey: Ne(i.publicKey, _t) };\n}\nfunction Xr() {\n  const i = li.randomBytes(xn);\n  return Ne(i, _t);\n}\nfunction Zm(i, e) {\n  const t = ms.sharedKey(Ce(i, _t), Ce(e, _t)), s = new Rc(Si.SHA256, t).expand(xn);\n  return Ne(s, _t);\n}\nfunction eb(i) {\n  const e = Si.hash(Ce(i, _t));\n  return Ne(e, _t);\n}\nfunction Ui(i) {\n  const e = Si.hash(Ce(i, Dn));\n  return Ne(e, _t);\n}\nfunction tb(i) {\n  return Ce(`${i}`, yh);\n}\nfunction Is(i) {\n  return Number(Ne(i, yh));\n}\nfunction ib(i) {\n  const e = tb(typeof i.type < \"u\" ? i.type : mh);\n  if (Is(e) === Ni && typeof i.senderPublicKey > \"u\")\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof i.senderPublicKey < \"u\" ? Ce(i.senderPublicKey, _t) : void 0, s = typeof i.iv < \"u\" ? Ce(i.iv, _t) : li.randomBytes(Qr), r = new gs.ChaCha20Poly1305(Ce(i.symKey, _t)).seal(s, Ce(i.message, Dn));\n  return rb({ type: e, sealed: r, iv: s, senderPublicKey: t });\n}\nfunction sb(i) {\n  const e = new gs.ChaCha20Poly1305(Ce(i.symKey, _t)), { sealed: t, iv: s } = Zs(i.encoded), r = e.open(s, t);\n  if (r === null)\n    throw new Error(\"Failed to decrypt\");\n  return Ne(r, Dn);\n}\nfunction rb(i) {\n  if (Is(i.type) === Ni) {\n    if (typeof i.senderPublicKey > \"u\")\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    return Ne(ls([i.type, i.senderPublicKey, i.iv, i.sealed]), Jr);\n  }\n  return Ne(ls([i.type, i.iv, i.sealed]), Jr);\n}\nfunction Zs(i) {\n  const e = Ce(i, Jr), t = e.slice(Qm, ga), s = ga;\n  if (Is(t) === Ni) {\n    const c = s + xn, u = c + Qr, d = e.slice(s, c), p = e.slice(c, u), b = e.slice(u);\n    return { type: t, sealed: b, iv: p, senderPublicKey: d };\n  }\n  const r = s + Qr, n = e.slice(s, r), o = e.slice(r);\n  return { type: t, sealed: o, iv: n };\n}\nfunction nb(i, e) {\n  const t = Zs(i);\n  return bh({ type: Is(t.type), senderPublicKey: typeof t.senderPublicKey < \"u\" ? Ne(t.senderPublicKey, _t) : void 0, receiverPublicKey: e?.receiverPublicKey });\n}\nfunction bh(i) {\n  const e = i?.type || mh;\n  if (e === Ni) {\n    if (typeof i?.senderPublicKey > \"u\")\n      throw new Error(\"missing sender public key\");\n    if (typeof i?.receiverPublicKey > \"u\")\n      throw new Error(\"missing receiver public key\");\n  }\n  return { type: e, senderPublicKey: i?.senderPublicKey, receiverPublicKey: i?.receiverPublicKey };\n}\nfunction ya(i) {\n  return i.type === Ni && typeof i.senderPublicKey == \"string\" && typeof i.receiverPublicKey == \"string\";\n}\nvar ob = Object.defineProperty, ma = Object.getOwnPropertySymbols, ab = Object.prototype.hasOwnProperty, cb = Object.prototype.propertyIsEnumerable, ba = (i, e, t) => e in i ? ob(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, wa = (i, e) => {\n  for (var t in e || (e = {}))\n    ab.call(e, t) && ba(i, t, e[t]);\n  if (ma)\n    for (var t of ma(e))\n      cb.call(e, t) && ba(i, t, e[t]);\n  return i;\n};\nconst hb = \"ReactNative\", as = { reactNative: \"react-native\", node: \"node\", browser: \"browser\", unknown: \"unknown\" }, ub = \"js\";\nfunction On() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction wh() {\n  return !un() && !!bs() && navigator.product === hb;\n}\nfunction Nn() {\n  return !On() && !!bs();\n}\nfunction lb() {\n  return wh() ? as.reactNative : On() ? as.node : Nn() ? as.browser : as.unknown;\n}\nfunction db(i, e) {\n  let t = ii.parse(i);\n  return t = wa(wa({}, t), e), i = ii.stringify(t), i;\n}\nfunction fb() {\n  return fn() || { name: \"\", description: \"\", url: \"\", icons: [\"\"] };\n}\nfunction pb() {\n  const i = hn();\n  if (i === null)\n    return \"unknown\";\n  const e = i.os ? i.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return i.type === \"browser\" ? [e, i.name, i.version].join(\"-\") : [e, i.version].join(\"-\");\n}\nfunction gb() {\n  var i;\n  const e = lb();\n  return e === as.browser ? [e, ((i = ln()) == null ? void 0 : i.host) || \"unknown\"].join(\":\") : e;\n}\nfunction yb(i, e, t) {\n  const s = pb(), r = gb();\n  return [[i, e].join(\"-\"), [ub, t].join(\"-\"), s, r].join(\"/\");\n}\nfunction mb({ protocol: i, version: e, relayUrl: t, sdkVersion: s, auth: r, projectId: n, useOnCloseEvent: o }) {\n  const c = t.split(\"?\"), u = yb(i, e, s), d = { auth: r, ua: u, projectId: n, useOnCloseEvent: o || void 0 }, p = db(c[1] || \"\", d);\n  return c[0] + \"?\" + p;\n}\nfunction Ei(i, e) {\n  return i.filter((t) => e.includes(t)).length === i.length;\n}\nfunction vh(i) {\n  return Object.fromEntries(i.entries());\n}\nfunction _h(i) {\n  return new Map(Object.entries(i));\n}\nfunction Ti(i = V.FIVE_MINUTES, e) {\n  const t = V.toMiliseconds(i || V.FIVE_MINUTES);\n  let s, r, n;\n  return { resolve: (o) => {\n    n && s && (clearTimeout(n), s(o));\n  }, reject: (o) => {\n    n && r && (clearTimeout(n), r(o));\n  }, done: () => new Promise((o, c) => {\n    n = setTimeout(() => {\n      c(new Error(e));\n    }, t), s = o, r = c;\n  }) };\n}\nfunction er(i, e, t) {\n  return new Promise(async (s, r) => {\n    const n = setTimeout(() => r(new Error(t)), e);\n    try {\n      const o = await i;\n      s(o);\n    } catch (o) {\n      r(o);\n    }\n    clearTimeout(n);\n  });\n}\nfunction Eh(i, e) {\n  if (typeof e == \"string\" && e.startsWith(`${i}:`))\n    return e;\n  if (i.toLowerCase() === \"topic\") {\n    if (typeof e != \"string\")\n      throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${e}`;\n  } else if (i.toLowerCase() === \"id\") {\n    if (typeof e != \"number\")\n      throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${e}`;\n  }\n  throw new Error(`Unknown expirer target type: ${i}`);\n}\nfunction bb(i) {\n  return Eh(\"topic\", i);\n}\nfunction wb(i) {\n  return Eh(\"id\", i);\n}\nfunction Sh(i) {\n  const [e, t] = i.split(\":\"), s = { id: void 0, topic: void 0 };\n  if (e === \"topic\" && typeof t == \"string\")\n    s.topic = t;\n  else if (e === \"id\" && Number.isInteger(Number(t)))\n    s.id = Number(t);\n  else\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);\n  return s;\n}\nfunction Ht(i, e) {\n  return V.fromMiliseconds((e || Date.now()) + V.toMiliseconds(i));\n}\nfunction ci(i) {\n  return Date.now() >= V.toMiliseconds(i);\n}\nfunction ke(i, e) {\n  return `${i}${e ? `:${e}` : \"\"}`;\n}\nconst vb = \"irn\";\nfunction Zr(i) {\n  return i?.relay || { protocol: vb };\n}\nfunction Vs(i) {\n  const e = Ac[i];\n  if (typeof e > \"u\")\n    throw new Error(`Relay Protocol not supported: ${i}`);\n  return e;\n}\nvar _b = Object.defineProperty, va = Object.getOwnPropertySymbols, Eb = Object.prototype.hasOwnProperty, Sb = Object.prototype.propertyIsEnumerable, _a = (i, e, t) => e in i ? _b(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Ib = (i, e) => {\n  for (var t in e || (e = {}))\n    Eb.call(e, t) && _a(i, t, e[t]);\n  if (va)\n    for (var t of va(e))\n      Sb.call(e, t) && _a(i, t, e[t]);\n  return i;\n};\nfunction Db(i, e = \"-\") {\n  const t = {}, s = \"relay\" + e;\n  return Object.keys(i).forEach((r) => {\n    if (r.startsWith(s)) {\n      const n = r.replace(s, \"\"), o = i[r];\n      t[n] = o;\n    }\n  }), t;\n}\nfunction xb(i) {\n  const e = i.indexOf(\":\"), t = i.indexOf(\"?\") !== -1 ? i.indexOf(\"?\") : void 0, s = i.substring(0, e), r = i.substring(e + 1, t).split(\"@\"), n = typeof t < \"u\" ? i.substring(t) : \"\", o = ii.parse(n);\n  return { protocol: s, topic: Ob(r[0]), version: parseInt(r[1], 10), symKey: o.symKey, relay: Db(o) };\n}\nfunction Ob(i) {\n  return i.startsWith(\"//\") ? i.substring(2) : i;\n}\nfunction Nb(i, e = \"-\") {\n  const t = \"relay\", s = {};\n  return Object.keys(i).forEach((r) => {\n    const n = t + e + r;\n    i[r] && (s[n] = i[r]);\n  }), s;\n}\nfunction Pb(i) {\n  return `${i.protocol}:${i.topic}@${i.version}?` + ii.stringify(Ib({ symKey: i.symKey }, Nb(i.relay)));\n}\nfunction zi(i) {\n  const e = [];\n  return i.forEach((t) => {\n    const [s, r] = t.split(\":\");\n    e.push(`${s}:${r}`);\n  }), e;\n}\nfunction Rb(i) {\n  const e = [];\n  return Object.values(i).forEach((t) => {\n    e.push(...zi(t.accounts));\n  }), e;\n}\nfunction Cb(i, e) {\n  const t = [];\n  return Object.values(i).forEach((s) => {\n    zi(s.accounts).includes(e) && t.push(...s.methods);\n  }), t;\n}\nfunction Ab(i, e) {\n  const t = [];\n  return Object.values(i).forEach((s) => {\n    zi(s.accounts).includes(e) && t.push(...s.events);\n  }), t;\n}\nfunction Tb(i, e) {\n  const t = Bs(i, e);\n  if (t)\n    throw new Error(t.message);\n  const s = {};\n  for (const [r, n] of Object.entries(i))\n    s[r] = { methods: n.methods, events: n.events, chains: n.accounts.map((o) => `${o.split(\":\")[0]}:${o.split(\":\")[1]}`) };\n  return s;\n}\nconst $b = { INVALID_METHOD: { message: \"Invalid method.\", code: 1001 }, INVALID_EVENT: { message: \"Invalid event.\", code: 1002 }, INVALID_UPDATE_REQUEST: { message: \"Invalid update request.\", code: 1003 }, INVALID_EXTEND_REQUEST: { message: \"Invalid extend request.\", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: \"Invalid session settle request.\", code: 1005 }, UNAUTHORIZED_METHOD: { message: \"Unauthorized method.\", code: 3001 }, UNAUTHORIZED_EVENT: { message: \"Unauthorized event.\", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: \"Unauthorized update request.\", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: \"Unauthorized extend request.\", code: 3004 }, USER_REJECTED: { message: \"User rejected.\", code: 5e3 }, USER_REJECTED_CHAINS: { message: \"User rejected chains.\", code: 5001 }, USER_REJECTED_METHODS: { message: \"User rejected methods.\", code: 5002 }, USER_REJECTED_EVENTS: { message: \"User rejected events.\", code: 5003 }, UNSUPPORTED_CHAINS: { message: \"Unsupported chains.\", code: 5100 }, UNSUPPORTED_METHODS: { message: \"Unsupported methods.\", code: 5101 }, UNSUPPORTED_EVENTS: { message: \"Unsupported events.\", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: \"Unsupported accounts.\", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: \"Unsupported namespace key.\", code: 5104 }, USER_DISCONNECTED: { message: \"User disconnected.\", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: \"Session settlement failed.\", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: \"Unsupported wc_ method.\", code: 10001 } }, Fb = { NOT_INITIALIZED: { message: \"Not initialized.\", code: 1 }, NO_MATCHING_KEY: { message: \"No matching key.\", code: 2 }, RESTORE_WILL_OVERRIDE: { message: \"Restore will override.\", code: 3 }, RESUBSCRIBED: { message: \"Resubscribed.\", code: 4 }, MISSING_OR_INVALID: { message: \"Missing or invalid.\", code: 5 }, EXPIRED: { message: \"Expired.\", code: 6 }, UNKNOWN_TYPE: { message: \"Unknown type.\", code: 7 }, MISMATCHED_TOPIC: { message: \"Mismatched topic.\", code: 8 }, NON_CONFORMING_NAMESPACES: { message: \"Non conforming namespaces.\", code: 9 } };\nfunction J(i, e) {\n  const { message: t, code: s } = Fb[i];\n  return { message: e ? `${t} ${e}` : t, code: s };\n}\nfunction Je(i, e) {\n  const { message: t, code: s } = $b[i];\n  return { message: e ? `${t} ${e}` : t, code: s };\n}\nfunction Ds(i, e) {\n  return Array.isArray(i) ? typeof e < \"u\" && i.length ? i.every(e) : !0 : !1;\n}\nfunction us(i) {\n  return Object.getPrototypeOf(i) === Object.prototype && Object.keys(i).length;\n}\nfunction wt(i) {\n  return typeof i > \"u\";\n}\nfunction at(i, e) {\n  return e && wt(i) ? !0 : typeof i == \"string\" && !!i.trim().length;\n}\nfunction Pn(i, e) {\n  return e && wt(i) ? !0 : typeof i == \"number\" && !isNaN(i);\n}\nfunction Ub(i, e) {\n  const { requiredNamespaces: t } = e, s = Object.keys(i.namespaces), r = Object.keys(t);\n  let n = !0;\n  return Ei(r, s) ? (s.forEach((o) => {\n    const { accounts: c, methods: u, events: d } = i.namespaces[o], p = zi(c), b = t[o];\n    (!Ei(In(o, b), p) || !Ei(b.methods, u) || !Ei(b.events, d)) && (n = !1);\n  }), n) : !1;\n}\nfunction Rn(i) {\n  return at(i, !1) && i.includes(\":\") ? i.split(\":\").length === 2 : !1;\n}\nfunction Lb(i) {\n  if (at(i, !1) && i.includes(\":\")) {\n    const e = i.split(\":\");\n    if (e.length === 3) {\n      const t = e[0] + \":\" + e[1];\n      return !!e[2] && Rn(t);\n    }\n  }\n  return !1;\n}\nfunction Mb(i) {\n  if (at(i, !1))\n    try {\n      return typeof new URL(i) < \"u\";\n    } catch {\n      return !1;\n    }\n  return !1;\n}\nfunction qb(i) {\n  var e;\n  return (e = i?.proposer) == null ? void 0 : e.publicKey;\n}\nfunction jb(i) {\n  return i?.topic;\n}\nfunction zb(i, e) {\n  let t = null;\n  return at(i?.publicKey, !1) || (t = J(\"MISSING_OR_INVALID\", `${e} controller public key should be a string`)), t;\n}\nfunction Ea(i) {\n  let e = !0;\n  return Ds(i) ? i.length && (e = i.every((t) => at(t, !1))) : e = !1, e;\n}\nfunction Kb(i, e, t) {\n  let s = null;\n  return Ds(e) ? e.forEach((r) => {\n    s || (!Rn(r) || !r.includes(i)) && (s = Je(\"UNSUPPORTED_CHAINS\", `${t}, chain ${r} should be a string and conform to \"namespace:chainId\" format`));\n  }) : s = Je(\"UNSUPPORTED_CHAINS\", `${t}, chains ${e} should be an array of strings conforming to \"namespace:chainId\" format`), s;\n}\nfunction Vb(i, e) {\n  let t = null;\n  return Object.entries(i).forEach(([s, r]) => {\n    if (t)\n      return;\n    const n = Kb(s, In(s, r), `${e} requiredNamespace`);\n    n && (t = n);\n  }), t;\n}\nfunction Bb(i, e) {\n  let t = null;\n  return Ds(i) ? i.forEach((s) => {\n    t || Lb(s) || (t = Je(\"UNSUPPORTED_ACCOUNTS\", `${e}, account ${s} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = Je(\"UNSUPPORTED_ACCOUNTS\", `${e}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction kb(i, e) {\n  let t = null;\n  return Object.values(i).forEach((s) => {\n    if (t)\n      return;\n    const r = Bb(s?.accounts, `${e} namespace`);\n    r && (t = r);\n  }), t;\n}\nfunction Hb(i, e) {\n  let t = null;\n  return Ea(i?.methods) ? Ea(i?.events) || (t = Je(\"UNSUPPORTED_EVENTS\", `${e}, events should be an array of strings or empty array for no events`)) : t = Je(\"UNSUPPORTED_METHODS\", `${e}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction Ih(i, e) {\n  let t = null;\n  return Object.values(i).forEach((s) => {\n    if (t)\n      return;\n    const r = Hb(s, `${e}, namespace`);\n    r && (t = r);\n  }), t;\n}\nfunction Gb(i, e, t) {\n  let s = null;\n  if (i && us(i)) {\n    const r = Ih(i, e);\n    r && (s = r);\n    const n = Vb(i, e);\n    n && (s = n);\n  } else\n    s = J(\"MISSING_OR_INVALID\", `${e}, ${t} should be an object with data`);\n  return s;\n}\nfunction Bs(i, e) {\n  let t = null;\n  if (i && us(i)) {\n    const s = Ih(i, e);\n    s && (t = s);\n    const r = kb(i, e);\n    r && (t = r);\n  } else\n    t = J(\"MISSING_OR_INVALID\", `${e}, namespaces should be an object with data`);\n  return t;\n}\nfunction Dh(i) {\n  return at(i.protocol, !0);\n}\nfunction Wb(i, e) {\n  let t = !1;\n  return e && !i ? t = !0 : i && Ds(i) && i.length && i.forEach((s) => {\n    t = Dh(s);\n  }), t;\n}\nfunction Yb(i) {\n  return typeof i == \"number\";\n}\nfunction It(i) {\n  return typeof i < \"u\" && typeof i !== null;\n}\nfunction Jb(i) {\n  return !(!i || typeof i != \"object\" || !i.code || !Pn(i.code, !1) || !i.message || !at(i.message, !1));\n}\nfunction Qb(i) {\n  return !(wt(i) || !at(i.method, !1));\n}\nfunction Xb(i) {\n  return !(wt(i) || wt(i.result) && wt(i.error) || !Pn(i.id, !1) || !at(i.jsonrpc, !1));\n}\nfunction Zb(i) {\n  return !(wt(i) || !at(i.name, !1));\n}\nfunction Sa(i, e) {\n  return !(!Rn(e) || !Rb(i).includes(e));\n}\nfunction ew(i, e, t) {\n  return at(t, !1) ? Cb(i, e).includes(t) : !1;\n}\nfunction tw(i, e, t) {\n  return at(t, !1) ? Ab(i, e).includes(t) : !1;\n}\nfunction Ia(i, e, t) {\n  let s = null;\n  const r = iw(i), n = sw(e), o = Object.keys(r), c = Object.keys(n), u = Da(Object.keys(i)), d = Da(Object.keys(e)), p = u.filter((b) => !d.includes(b));\n  return p.length && (s = J(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${p.toString()}\n      Received: ${Object.keys(e).toString()}`)), Ei(o, c) || (s = J(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${o.toString()}\n      Approved: ${c.toString()}`)), Object.keys(e).forEach((b) => {\n    if (!b.includes(\":\") || s)\n      return;\n    const x = zi(e[b].accounts);\n    x.includes(b) || (s = J(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${b}\n        Required: ${b}\n        Approved: ${x.toString()}`));\n  }), o.forEach((b) => {\n    s || (Ei(r[b].methods, n[b].methods) ? Ei(r[b].events, n[b].events) || (s = J(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${b}`)) : s = J(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${b}`));\n  }), s;\n}\nfunction iw(i) {\n  const e = {};\n  return Object.keys(i).forEach((t) => {\n    var s;\n    t.includes(\":\") ? e[t] = i[t] : (s = i[t].chains) == null || s.forEach((r) => {\n      e[r] = { methods: i[t].methods, events: i[t].events };\n    });\n  }), e;\n}\nfunction Da(i) {\n  return [...new Set(i.map((e) => e.includes(\":\") ? e.split(\":\")[0] : e))];\n}\nfunction sw(i) {\n  const e = {};\n  return Object.keys(i).forEach((t) => {\n    t.includes(\":\") ? e[t] = i[t] : zi(i[t].accounts)?.forEach((r) => {\n      e[r] = { accounts: i[t].accounts.filter((n) => n.includes(`${r}:`)), methods: i[t].methods, events: i[t].events };\n    });\n  }), e;\n}\nfunction rw(i, e) {\n  return Pn(i, !1) && i <= e.max && i >= e.min;\n}\nfunction nw(i, e) {\n  if (i.length >= 255)\n    throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), s = 0; s < t.length; s++)\n    t[s] = 255;\n  for (var r = 0; r < i.length; r++) {\n    var n = i.charAt(r), o = n.charCodeAt(0);\n    if (t[o] !== 255)\n      throw new TypeError(n + \" is ambiguous\");\n    t[o] = r;\n  }\n  var c = i.length, u = i.charAt(0), d = Math.log(c) / Math.log(256), p = Math.log(256) / Math.log(c);\n  function b(_) {\n    if (_ instanceof Uint8Array || (ArrayBuffer.isView(_) ? _ = new Uint8Array(_.buffer, _.byteOffset, _.byteLength) : Array.isArray(_) && (_ = Uint8Array.from(_))), !(_ instanceof Uint8Array))\n      throw new TypeError(\"Expected Uint8Array\");\n    if (_.length === 0)\n      return \"\";\n    for (var C = 0, F = 0, K = 0, I = _.length; K !== I && _[K] === 0; )\n      K++, C++;\n    for (var D = (I - K) * p + 1 >>> 0, y = new Uint8Array(D); K !== I; ) {\n      for (var w = _[K], f = 0, a = D - 1; (w !== 0 || f < F) && a !== -1; a--, f++)\n        w += 256 * y[a] >>> 0, y[a] = w % c >>> 0, w = w / c >>> 0;\n      if (w !== 0)\n        throw new Error(\"Non-zero carry\");\n      F = f, K++;\n    }\n    for (var l = D - F; l !== D && y[l] === 0; )\n      l++;\n    for (var L = u.repeat(C); l < D; ++l)\n      L += i.charAt(y[l]);\n    return L;\n  }\n  function x(_) {\n    if (typeof _ != \"string\")\n      throw new TypeError(\"Expected String\");\n    if (_.length === 0)\n      return new Uint8Array();\n    var C = 0;\n    if (_[C] !== \" \") {\n      for (var F = 0, K = 0; _[C] === u; )\n        F++, C++;\n      for (var I = (_.length - C) * d + 1 >>> 0, D = new Uint8Array(I); _[C]; ) {\n        var y = t[_.charCodeAt(C)];\n        if (y === 255)\n          return;\n        for (var w = 0, f = I - 1; (y !== 0 || w < K) && f !== -1; f--, w++)\n          y += c * D[f] >>> 0, D[f] = y % 256 >>> 0, y = y / 256 >>> 0;\n        if (y !== 0)\n          throw new Error(\"Non-zero carry\");\n        K = w, C++;\n      }\n      if (_[C] !== \" \") {\n        for (var a = I - K; a !== I && D[a] === 0; )\n          a++;\n        for (var l = new Uint8Array(F + (I - a)), L = F; a !== I; )\n          l[L++] = D[a++];\n        return l;\n      }\n    }\n  }\n  function O(_) {\n    var C = x(_);\n    if (C)\n      return C;\n    throw new Error(`Non-${e} character`);\n  }\n  return { encode: b, decodeUnsafe: x, decode: O };\n}\nvar ow = nw, aw = ow;\nconst xh = (i) => {\n  if (i instanceof Uint8Array && i.constructor.name === \"Uint8Array\")\n    return i;\n  if (i instanceof ArrayBuffer)\n    return new Uint8Array(i);\n  if (ArrayBuffer.isView(i))\n    return new Uint8Array(i.buffer, i.byteOffset, i.byteLength);\n  throw new Error(\"Unknown type, must be binary type\");\n}, cw = (i) => new TextEncoder().encode(i), hw = (i) => new TextDecoder().decode(i);\nclass uw {\n  constructor(e, t, s) {\n    this.name = e, this.prefix = t, this.baseEncode = s;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array)\n      return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass lw {\n  constructor(e, t, s) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)\n      throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint)\n        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else\n      throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return Oh(this, e);\n  }\n}\nclass dw {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return Oh(this, e);\n  }\n  decode(e) {\n    const t = e[0], s = this.decoders[t];\n    if (s)\n      return s.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst Oh = (i, e) => new dw({ ...i.decoders || { [i.prefix]: i }, ...e.decoders || { [e.prefix]: e } });\nclass fw {\n  constructor(e, t, s, r) {\n    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = r, this.encoder = new uw(e, t, s), this.decoder = new lw(e, t, r);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst fr = ({ name: i, prefix: e, encode: t, decode: s }) => new fw(i, e, t, s), xs = ({ prefix: i, name: e, alphabet: t }) => {\n  const { encode: s, decode: r } = aw(t, e);\n  return fr({ prefix: i, name: e, encode: s, decode: (n) => xh(r(n)) });\n}, pw = (i, e, t, s) => {\n  const r = {};\n  for (let p = 0; p < e.length; ++p)\n    r[e[p]] = p;\n  let n = i.length;\n  for (; i[n - 1] === \"=\"; )\n    --n;\n  const o = new Uint8Array(n * t / 8 | 0);\n  let c = 0, u = 0, d = 0;\n  for (let p = 0; p < n; ++p) {\n    const b = r[i[p]];\n    if (b === void 0)\n      throw new SyntaxError(`Non-${s} character`);\n    u = u << t | b, c += t, c >= 8 && (c -= 8, o[d++] = 255 & u >> c);\n  }\n  if (c >= t || 255 & u << 8 - c)\n    throw new SyntaxError(\"Unexpected end of data\");\n  return o;\n}, gw = (i, e, t) => {\n  const s = e[e.length - 1] === \"=\", r = (1 << t) - 1;\n  let n = \"\", o = 0, c = 0;\n  for (let u = 0; u < i.length; ++u)\n    for (c = c << 8 | i[u], o += 8; o > t; )\n      o -= t, n += e[r & c >> o];\n  if (o && (n += e[r & c << t - o]), s)\n    for (; n.length * t & 7; )\n      n += \"=\";\n  return n;\n}, dt = ({ name: i, prefix: e, bitsPerChar: t, alphabet: s }) => fr({ prefix: e, name: i, encode(r) {\n  return gw(r, s, t);\n}, decode(r) {\n  return pw(r, s, t, i);\n} }), yw = fr({ prefix: \"\\0\", name: \"identity\", encode: (i) => hw(i), decode: (i) => cw(i) });\nvar mw = Object.freeze({ __proto__: null, identity: yw });\nconst bw = dt({ prefix: \"0\", name: \"base2\", alphabet: \"01\", bitsPerChar: 1 });\nvar ww = Object.freeze({ __proto__: null, base2: bw });\nconst vw = dt({ prefix: \"7\", name: \"base8\", alphabet: \"01234567\", bitsPerChar: 3 });\nvar _w = Object.freeze({ __proto__: null, base8: vw });\nconst Ew = xs({ prefix: \"9\", name: \"base10\", alphabet: \"0123456789\" });\nvar Sw = Object.freeze({ __proto__: null, base10: Ew });\nconst Iw = dt({ prefix: \"f\", name: \"base16\", alphabet: \"0123456789abcdef\", bitsPerChar: 4 }), Dw = dt({ prefix: \"F\", name: \"base16upper\", alphabet: \"0123456789ABCDEF\", bitsPerChar: 4 });\nvar xw = Object.freeze({ __proto__: null, base16: Iw, base16upper: Dw });\nconst Ow = dt({ prefix: \"b\", name: \"base32\", alphabet: \"abcdefghijklmnopqrstuvwxyz234567\", bitsPerChar: 5 }), Nw = dt({ prefix: \"B\", name: \"base32upper\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\", bitsPerChar: 5 }), Pw = dt({ prefix: \"c\", name: \"base32pad\", alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\", bitsPerChar: 5 }), Rw = dt({ prefix: \"C\", name: \"base32padupper\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\", bitsPerChar: 5 }), Cw = dt({ prefix: \"v\", name: \"base32hex\", alphabet: \"0123456789abcdefghijklmnopqrstuv\", bitsPerChar: 5 }), Aw = dt({ prefix: \"V\", name: \"base32hexupper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\", bitsPerChar: 5 }), Tw = dt({ prefix: \"t\", name: \"base32hexpad\", alphabet: \"0123456789abcdefghijklmnopqrstuv=\", bitsPerChar: 5 }), $w = dt({ prefix: \"T\", name: \"base32hexpadupper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\", bitsPerChar: 5 }), Fw = dt({ prefix: \"h\", name: \"base32z\", alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\", bitsPerChar: 5 });\nvar Uw = Object.freeze({ __proto__: null, base32: Ow, base32upper: Nw, base32pad: Pw, base32padupper: Rw, base32hex: Cw, base32hexupper: Aw, base32hexpad: Tw, base32hexpadupper: $w, base32z: Fw });\nconst Lw = xs({ prefix: \"k\", name: \"base36\", alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\" }), Mw = xs({ prefix: \"K\", name: \"base36upper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" });\nvar qw = Object.freeze({ __proto__: null, base36: Lw, base36upper: Mw });\nconst jw = xs({ name: \"base58btc\", prefix: \"z\", alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" }), zw = xs({ name: \"base58flickr\", prefix: \"Z\", alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\" });\nvar Kw = Object.freeze({ __proto__: null, base58btc: jw, base58flickr: zw });\nconst Vw = dt({ prefix: \"m\", name: \"base64\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", bitsPerChar: 6 }), Bw = dt({ prefix: \"M\", name: \"base64pad\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", bitsPerChar: 6 }), kw = dt({ prefix: \"u\", name: \"base64url\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", bitsPerChar: 6 }), Hw = dt({ prefix: \"U\", name: \"base64urlpad\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\", bitsPerChar: 6 });\nvar Gw = Object.freeze({ __proto__: null, base64: Vw, base64pad: Bw, base64url: kw, base64urlpad: Hw });\nconst Nh = Array.from(\"🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂\"), Ww = Nh.reduce((i, e, t) => (i[t] = e, i), []), Yw = Nh.reduce((i, e, t) => (i[e.codePointAt(0)] = t, i), []);\nfunction Jw(i) {\n  return i.reduce((e, t) => (e += Ww[t], e), \"\");\n}\nfunction Qw(i) {\n  const e = [];\n  for (const t of i) {\n    const s = Yw[t.codePointAt(0)];\n    if (s === void 0)\n      throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(s);\n  }\n  return new Uint8Array(e);\n}\nconst Xw = fr({ prefix: \"🚀\", name: \"base256emoji\", encode: Jw, decode: Qw });\nvar Zw = Object.freeze({ __proto__: null, base256emoji: Xw }), e0 = Ph, xa = 128, t0 = 127, i0 = ~t0, s0 = Math.pow(2, 31);\nfunction Ph(i, e, t) {\n  e = e || [], t = t || 0;\n  for (var s = t; i >= s0; )\n    e[t++] = i & 255 | xa, i /= 128;\n  for (; i & i0; )\n    e[t++] = i & 255 | xa, i >>>= 7;\n  return e[t] = i | 0, Ph.bytes = t - s + 1, e;\n}\nvar r0 = en, n0 = 128, Oa = 127;\nfunction en(i, s) {\n  var t = 0, s = s || 0, r = 0, n = s, o, c = i.length;\n  do {\n    if (n >= c)\n      throw en.bytes = 0, new RangeError(\"Could not decode varint\");\n    o = i[n++], t += r < 28 ? (o & Oa) << r : (o & Oa) * Math.pow(2, r), r += 7;\n  } while (o >= n0);\n  return en.bytes = n - s, t;\n}\nvar o0 = Math.pow(2, 7), a0 = Math.pow(2, 14), c0 = Math.pow(2, 21), h0 = Math.pow(2, 28), u0 = Math.pow(2, 35), l0 = Math.pow(2, 42), d0 = Math.pow(2, 49), f0 = Math.pow(2, 56), p0 = Math.pow(2, 63), g0 = function(i) {\n  return i < o0 ? 1 : i < a0 ? 2 : i < c0 ? 3 : i < h0 ? 4 : i < u0 ? 5 : i < l0 ? 6 : i < d0 ? 7 : i < f0 ? 8 : i < p0 ? 9 : 10;\n}, y0 = { encode: e0, decode: r0, encodingLength: g0 }, Rh = y0;\nconst Na = (i, e, t = 0) => (Rh.encode(i, e, t), e), Pa = (i) => Rh.encodingLength(i), tn = (i, e) => {\n  const t = e.byteLength, s = Pa(i), r = s + Pa(t), n = new Uint8Array(r + t);\n  return Na(i, n, 0), Na(t, n, s), n.set(e, r), new m0(i, t, e, n);\n};\nclass m0 {\n  constructor(e, t, s, r) {\n    this.code = e, this.size = t, this.digest = s, this.bytes = r;\n  }\n}\nconst Ch = ({ name: i, code: e, encode: t }) => new b0(i, e, t);\nclass b0 {\n  constructor(e, t, s) {\n    this.name = e, this.code = t, this.encode = s;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? tn(this.code, t) : t.then((s) => tn(this.code, s));\n    } else\n      throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst Ah = (i) => async (e) => new Uint8Array(await crypto.subtle.digest(i, e)), w0 = Ch({ name: \"sha2-256\", code: 18, encode: Ah(\"SHA-256\") }), v0 = Ch({ name: \"sha2-512\", code: 19, encode: Ah(\"SHA-512\") });\nvar _0 = Object.freeze({ __proto__: null, sha256: w0, sha512: v0 });\nconst Th = 0, E0 = \"identity\", $h = xh, S0 = (i) => tn(Th, $h(i)), I0 = { code: Th, name: E0, encode: $h, digest: S0 };\nvar D0 = Object.freeze({ __proto__: null, identity: I0 });\nnew TextEncoder(), new TextDecoder();\nconst Ra = { ...mw, ...ww, ..._w, ...Sw, ...xw, ...Uw, ...qw, ...Kw, ...Gw, ...Zw };\n({ ..._0, ...D0 });\nfunction Fh(i) {\n  return globalThis.Buffer != null ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : i;\n}\nfunction x0(i = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Fh(globalThis.Buffer.allocUnsafe(i)) : new Uint8Array(i);\n}\nfunction Uh(i, e, t, s) {\n  return { name: i, prefix: e, encoder: { name: i, prefix: e, encode: t }, decoder: { decode: s } };\n}\nconst Ca = Uh(\"utf8\", \"u\", (i) => \"u\" + new TextDecoder(\"utf8\").decode(i), (i) => new TextEncoder().encode(i.substring(1))), Ar = Uh(\"ascii\", \"a\", (i) => {\n  let e = \"a\";\n  for (let t = 0; t < i.length; t++)\n    e += String.fromCharCode(i[t]);\n  return e;\n}, (i) => {\n  i = i.substring(1);\n  const e = x0(i.length);\n  for (let t = 0; t < i.length; t++)\n    e[t] = i.charCodeAt(t);\n  return e;\n}), O0 = { utf8: Ca, \"utf-8\": Ca, hex: Ra.base16, latin1: Ar, ascii: Ar, binary: Ar, ...Ra };\nfunction N0(i, e = \"utf8\") {\n  const t = O0[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Fh(globalThis.Buffer.from(i, \"utf-8\")) : t.decoder.decode(`${t.prefix}${i}`);\n}\nconst Lh = \"wc\", P0 = 2, Cn = \"core\", ui = `${Lh}@2:${Cn}:`, R0 = { name: Cn, logger: \"error\" }, C0 = { database: \":memory:\" }, A0 = \"crypto\", Aa = \"client_ed25519_seed\", T0 = V.ONE_DAY, $0 = \"keychain\", F0 = \"0.3\", U0 = \"messages\", L0 = \"0.3\", M0 = V.SIX_HOURS, q0 = \"publisher\", Mh = \"irn\", j0 = \"error\", qh = \"wss://relay.walletconnect.com\", z0 = \"relayer\", He = { message: \"relayer_message\", message_ack: \"relayer_message_ack\", connect: \"relayer_connect\", disconnect: \"relayer_disconnect\", error: \"relayer_error\", connection_stalled: \"relayer_connection_stalled\", transport_closed: \"relayer_transport_closed\", publish: \"relayer_publish\" }, K0 = \"_subscription\", is = { payload: \"payload\", connect: \"connect\", disconnect: \"disconnect\", error: \"error\" }, V0 = V.ONE_SECOND / 2, B0 = \"y\", k0 = 1e4, H0 = \"0.3\", Bt = { created: \"subscription_created\", deleted: \"subscription_deleted\", expired: \"subscription_expired\", disabled: \"subscription_disabled\", sync: \"subscription_sync\", resubscribed: \"subscription_resubscribed\" }, G0 = \"subscription\", W0 = \"0.3\", Y0 = V.FIVE_SECONDS * 1e3, J0 = \"pairing\", Q0 = \"0.3\", ss = { wc_pairingDelete: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 0 } } }, Kt = { created: \"history_created\", updated: \"history_updated\", deleted: \"history_deleted\", sync: \"history_sync\" }, X0 = \"history\", Z0 = \"0.3\", ev = \"expirer\", $t = { created: \"expirer_created\", deleted: \"expirer_deleted\", expired: \"expirer_expired\", sync: \"expirer_sync\" }, tv = \"0.3\", Tr = \"verify-api\", Ta = \"https://verify.walletconnect.com\";\nclass iv {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = $0, this.version = F0, this.initialized = !1, this.storagePrefix = ui, this.init = async () => {\n      if (!this.initialized) {\n        const s = await this.getKeyChain();\n        typeof s < \"u\" && (this.keychain = s), this.initialized = !0;\n      }\n    }, this.has = (s) => (this.isInitialized(), this.keychain.has(s)), this.set = async (s, r) => {\n      this.isInitialized(), this.keychain.set(s, r), await this.persist();\n    }, this.get = (s) => {\n      this.isInitialized();\n      const r = this.keychain.get(s);\n      if (typeof r > \"u\") {\n        const { message: n } = J(\"NO_MATCHING_KEY\", `${this.name}: ${s}`);\n        throw new Error(n);\n      }\n      return r;\n    }, this.del = async (s) => {\n      this.isInitialized(), this.keychain.delete(s), await this.persist();\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, vh(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? _h(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass sv {\n  constructor(e, t, s) {\n    this.core = e, this.logger = t, this.name = A0, this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = (r) => (this.isInitialized(), this.keychain.has(r)), this.getClientId = async () => {\n      this.isInitialized();\n      const r = await this.getClientSeed(), n = Ws(r);\n      return an(n.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const r = Xm();\n      return this.setPrivateKey(r.publicKey, r.privateKey);\n    }, this.signJWT = async (r) => {\n      this.isInitialized();\n      const n = await this.getClientSeed(), o = Ws(n), c = Xr();\n      return await Ic(c, r, T0, o);\n    }, this.generateSharedKey = (r, n, o) => {\n      this.isInitialized();\n      const c = this.getPrivateKey(r), u = Zm(c, n);\n      return this.setSymKey(u, o);\n    }, this.setSymKey = async (r, n) => {\n      this.isInitialized();\n      const o = n || eb(r);\n      return await this.keychain.set(o, r), o;\n    }, this.deleteKeyPair = async (r) => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.deleteSymKey = async (r) => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.encode = async (r, n, o) => {\n      this.isInitialized();\n      const c = bh(o), u = rr(n);\n      if (ya(c)) {\n        const x = c.senderPublicKey, O = c.receiverPublicKey;\n        r = await this.generateSharedKey(x, O);\n      }\n      const d = this.getSymKey(r), { type: p, senderPublicKey: b } = c;\n      return ib({ type: p, symKey: d, message: u, senderPublicKey: b });\n    }, this.decode = async (r, n, o) => {\n      this.isInitialized();\n      const c = nb(n, o);\n      if (ya(c)) {\n        const p = c.receiverPublicKey, b = c.senderPublicKey;\n        r = await this.generateSharedKey(p, b);\n      }\n      const u = this.getSymKey(r), d = sb({ symKey: u, encoded: n });\n      return rn(d);\n    }, this.getPayloadType = (r) => {\n      const n = Zs(r);\n      return Is(n.type);\n    }, this.getPayloadSenderPublicKey = (r) => {\n      const n = Zs(r);\n      return n.senderPublicKey ? Ne(n.senderPublicKey, _t) : void 0;\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name), this.keychain = s || new iv(this.core, this.logger);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(Aa);\n    } catch {\n      e = Xr(), await this.keychain.set(Aa, e);\n    }\n    return N0(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass rv extends $m {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = U0, this.version = L0, this.initialized = !1, this.storagePrefix = ui, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const s = await this.getRelayerMessages();\n          typeof s < \"u\" && (this.messages = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", size: this.messages.size });\n        } catch (s) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (s, r) => {\n      this.isInitialized();\n      const n = Ui(r);\n      let o = this.messages.get(s);\n      return typeof o > \"u\" && (o = {}), typeof o[n] < \"u\" || (o[n] = r, this.messages.set(s, o), await this.persist()), n;\n    }, this.get = (s) => {\n      this.isInitialized();\n      let r = this.messages.get(s);\n      return typeof r > \"u\" && (r = {}), r;\n    }, this.has = (s, r) => {\n      this.isInitialized();\n      const n = this.get(s), o = Ui(r);\n      return typeof n[o] < \"u\";\n    }, this.del = async (s) => {\n      this.isInitialized(), this.messages.delete(s), await this.persist();\n    }, this.logger = ee.generateChildLogger(e, this.name), this.core = t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, vh(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? _h(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass nv extends Fm {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new We.EventEmitter(), this.name = q0, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = 1e4, this.publish = async (s, r, n) => {\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({ type: \"method\", method: \"publish\", params: { topic: s, message: r, opts: n } });\n      try {\n        const o = n?.ttl || M0, c = Zr(n), u = n?.prompt || !1, d = n?.tag || 0, p = n?.id || vn().toString(), b = { topic: s, message: r, opts: { ttl: o, relay: c, prompt: u, tag: d, id: p } };\n        this.queue.set(p, b);\n        try {\n          await await er(this.rpcPublish(s, r, o, c, u, d, p), this.publishTimeout), this.relayer.events.emit(He.publish, b);\n        } catch {\n          this.logger.debug(\"Publishing Payload stalled\"), this.relayer.events.emit(He.connection_stalled);\n          return;\n        }\n        this.logger.debug(\"Successfully Published Payload\"), this.logger.trace({ type: \"method\", method: \"publish\", params: { topic: s, message: r, opts: n } });\n      } catch (o) {\n        throw this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(o), o;\n      }\n    }, this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.relayer = e, this.logger = ee.generateChildLogger(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  rpcPublish(e, t, s, r, n, o, c) {\n    var u, d, p, b;\n    const x = { method: Vs(r.protocol).publish, params: { topic: e, message: t, ttl: s, prompt: n, tag: o }, id: c };\n    return wt((u = x.params) == null ? void 0 : u.prompt) && ((d = x.params) == null || delete d.prompt), wt((p = x.params) == null ? void 0 : p.tag) && ((b = x.params) == null || delete b.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"message\", direction: \"outgoing\", request: x }), this.relayer.request(x);\n  }\n  onPublish(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async (e) => {\n      const { topic: t, message: s, opts: r } = e;\n      await this.publish(t, s, r);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, () => {\n      this.checkQueue();\n    }), this.relayer.on(He.message_ack, (e) => {\n      this.onPublish(e.id.toString());\n    });\n  }\n}\nclass ov {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {\n      const s = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...s, t]);\n    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e))\n        return;\n      const s = this.get(e);\n      if (!this.exists(e, t))\n        return;\n      const r = s.filter((n) => n !== t);\n      if (!r.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, r);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar av = Object.defineProperty, cv = Object.defineProperties, hv = Object.getOwnPropertyDescriptors, $a = Object.getOwnPropertySymbols, uv = Object.prototype.hasOwnProperty, lv = Object.prototype.propertyIsEnumerable, Fa = (i, e, t) => e in i ? av(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, rs = (i, e) => {\n  for (var t in e || (e = {}))\n    uv.call(e, t) && Fa(i, t, e[t]);\n  if ($a)\n    for (var t of $a(e))\n      lv.call(e, t) && Fa(i, t, e[t]);\n  return i;\n}, $r = (i, e) => cv(i, hv(e));\nclass dv extends Mm {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new ov(), this.events = new We.EventEmitter(), this.name = G0, this.version = W0, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pollingInterval = 20, this.storagePrefix = ui, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restart(), this.registerEventListeners(), this.onEnable(), this.clientId = await this.relayer.core.crypto.getClientId());\n    }, this.subscribe = async (s, r) => {\n      await this.restartToComplete(), this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic: s, opts: r } });\n      try {\n        const n = Zr(r), o = { topic: s, relay: n };\n        this.pending.set(s, o);\n        const c = await this.rpcSubscribe(s, n);\n        return this.onSubscribe(c, o), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic: s, opts: r } }), c;\n      } catch (n) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(n), n;\n      }\n    }, this.unsubscribe = async (s, r) => {\n      await this.restartToComplete(), this.isInitialized(), typeof r?.id < \"u\" ? await this.unsubscribeById(s, r.id, r) : await this.unsubscribeByTopic(s, r);\n    }, this.isSubscribed = async (s) => this.topics.includes(s) ? !0 : await new Promise((r, n) => {\n      const o = new V.Watch();\n      o.start(this.pendingSubscriptionWatchLabel);\n      const c = setInterval(() => {\n        !this.pending.has(s) && this.topics.includes(s) && (clearInterval(c), o.stop(this.pendingSubscriptionWatchLabel), r(!0)), o.elapsed(this.pendingSubscriptionWatchLabel) >= Y0 && (clearInterval(c), o.stop(this.pendingSubscriptionWatchLabel), n(new Error(\"Subscription resolution timeout\")));\n      }, this.pollingInterval);\n    }).catch(() => !1), this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.restart = async () => {\n      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;\n    }, this.relayer = e, this.logger = ee.generateChildLogger(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let s = !1;\n    try {\n      s = this.getSubscription(e).topic === t;\n    } catch {\n    }\n    return s;\n  }\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  async unsubscribeByTopic(e, t) {\n    const s = this.topicMap.get(e);\n    await Promise.all(s.map(async (r) => await this.unsubscribeById(e, r, t)));\n  }\n  async unsubscribeById(e, t, s) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic: e, id: t, opts: s } });\n    try {\n      const r = Zr(s);\n      await this.rpcUnsubscribe(e, t, r);\n      const n = Je(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, n), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic: e, id: t, opts: s } });\n    } catch (r) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(r), r;\n    }\n  }\n  async rpcSubscribe(e, t) {\n    const s = { method: Vs(t.protocol).subscribe, params: { topic: e } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: s });\n    try {\n      await await er(this.relayer.request(s), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), this.relayer.events.emit(He.connection_stalled);\n    }\n    return Ui(e + this.clientId);\n  }\n  async rpcBatchSubscribe(e) {\n    if (!e.length)\n      return;\n    const t = e[0].relay, s = { method: Vs(t.protocol).batchSubscribe, params: { topics: e.map((r) => r.topic) } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: s });\n    try {\n      return await await er(this.relayer.request(s), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Payload stalled\"), this.relayer.events.emit(He.connection_stalled);\n    }\n  }\n  rpcUnsubscribe(e, t, s) {\n    const r = { method: Vs(s.protocol).unsubscribe, params: { topic: e, id: t } };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: r }), this.relayer.request(r);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, $r(rs({}, t), { id: e })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach((t) => {\n      this.setSubscription(t.id, rs({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  async onUnsubscribe(e, t, s) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({ type: \"method\", method: \"setSubscription\", id: e, subscription: t }), this.addSubscription(e, t));\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, rs({}, t)), this.topicMap.set(t.topic, e), this.events.emit(Bt.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({ type: \"method\", method: \"getSubscription\", id: e });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const { message: s } = J(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id: e, reason: t });\n    const s = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit(Bt.deleted, $r(rs({}, s), { reason: t }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(Bt.sync);\n  }\n  async reset() {\n    if (this.cached.length) {\n      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let t = 0; t < e; t++) {\n        const s = this.cached.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(s);\n      }\n    }\n    this.events.emit(Bt.resubscribed);\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.subscriptions.size) {\n        const { message: t } = J(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async batchSubscribe(e) {\n    if (!e.length)\n      return;\n    const t = await this.rpcBatchSubscribe(e);\n    Ds(t) && this.onBatchSubscribe(t.map((s, r) => $r(rs({}, e[r]), { id: s })));\n  }\n  async onConnect() {\n    this.restartInProgress || (await this.restart(), this.onEnable());\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  async checkPending() {\n    if (this.relayer.transportExplicitlyClosed)\n      return;\n    const e = [];\n    this.pending.forEach((t) => {\n      e.push(t);\n    }), await this.batchSubscribe(e);\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, async () => {\n      await this.checkPending();\n    }), this.relayer.on(He.connect, async () => {\n      await this.onConnect();\n    }), this.relayer.on(He.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(Bt.created, async (e) => {\n      const t = Bt.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), await this.persist();\n    }), this.events.on(Bt.deleted, async (e) => {\n      const t = Bt.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), await this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async restartToComplete() {\n    this.restartInProgress && await new Promise((e) => {\n      const t = setInterval(() => {\n        this.restartInProgress || (clearInterval(t), e());\n      }, this.pollingInterval);\n    });\n  }\n}\nvar fv = Object.defineProperty, Ua = Object.getOwnPropertySymbols, pv = Object.prototype.hasOwnProperty, gv = Object.prototype.propertyIsEnumerable, La = (i, e, t) => e in i ? fv(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, yv = (i, e) => {\n  for (var t in e || (e = {}))\n    pv.call(e, t) && La(i, t, e[t]);\n  if (Ua)\n    for (var t of Ua(e))\n      gv.call(e, t) && La(i, t, e[t]);\n  return i;\n};\nclass mv extends Um {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new We.EventEmitter(), this.name = z0, this.transportExplicitlyClosed = !1, this.initialized = !1, this.reconnecting = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = [\"socket hang up\", \"socket stalled\"], this.request = async (t) => {\n      this.logger.debug(\"Publishing Request Payload\");\n      try {\n        return await this.toEstablishConnection(), await this.provider.request(t);\n      } catch (s) {\n        throw this.logger.debug(\"Failed to Publish Request\"), this.logger.error(s), s;\n      }\n    }, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? ee.generateChildLogger(e.logger, this.name) : ee.pino(ee.getDefaultLoggerOptions({ level: e.logger || j0 })), this.messages = new rv(this.logger, e.core), this.subscriber = new dv(this, this.logger), this.publisher = new nv(this, this.logger), this.relayUrl = e?.relayUrl || qh, this.projectId = e.projectId, this.provider = {};\n  }\n  async init() {\n    this.logger.trace(\"Initialized\"), await this.createProvider(), await Promise.all([this.messages.init(), this.transportOpen(), this.subscriber.init()]), this.registerEventListeners(), this.initialized = !0, setTimeout(async () => {\n      this.subscriber.topics.length === 0 && (this.logger.info(\"No topics subscribted to after init, closing transport\"), await this.transportClose(), this.transportExplicitlyClosed = !1);\n    }, k0);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get connected() {\n    return this.provider.connection.connected;\n  }\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n  async publish(e, t, s) {\n    this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });\n  }\n  async subscribe(e, t) {\n    this.isInitialized();\n    let s = \"\";\n    return await Promise.all([new Promise((r) => {\n      this.subscriber.once(Bt.created, (n) => {\n        n.topic === e && r();\n      });\n    }), new Promise(async (r) => {\n      s = await this.subscriber.subscribe(e, t), r();\n    })]), s;\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async transportClose() {\n    this.transportExplicitlyClosed = !0, this.connected && (await this.provider.disconnect(), this.events.emit(He.transport_closed));\n  }\n  async transportOpen(e) {\n    if (this.transportExplicitlyClosed = !1, !this.reconnecting) {\n      this.relayUrl = e || this.relayUrl, this.reconnecting = !0;\n      try {\n        await Promise.all([new Promise((t) => {\n          this.initialized || t(), this.subscriber.once(Bt.resubscribed, () => {\n            t();\n          });\n        }), await Promise.race([new Promise(async (t, s) => {\n          await er(this.provider.connect(), 5e3, \"socket stalled\").catch((r) => s(r)).then(() => t()).finally(() => this.removeListener(He.transport_closed, this.rejectTransportOpen));\n        }), new Promise((t) => this.once(He.transport_closed, this.rejectTransportOpen))])]);\n      } catch (t) {\n        this.logger.error(t);\n        const s = t;\n        if (!this.isConnectionStalled(s.message))\n          throw t;\n        this.events.emit(He.transport_closed);\n      } finally {\n        this.reconnecting = !1;\n      }\n    }\n  }\n  async restartTransport(e) {\n    this.transportExplicitlyClosed || (this.relayUrl = e || this.relayUrl, this.connected && await Promise.all([new Promise((t) => {\n      this.provider.once(is.disconnect, () => {\n        t();\n      });\n    }), this.transportClose()]), await this.createProvider(), await this.transportOpen());\n  }\n  isConnectionStalled(e) {\n    return this.staleConnectionErrors.some((t) => e.includes(t));\n  }\n  rejectTransportOpen() {\n    throw new Error(\"closeTransport called before connection was established\");\n  }\n  async createProvider() {\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = new _n(new Wc(mb({ sdkVersion: B0, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0 }))), this.registerProviderListeners();\n  }\n  async recordMessageEvent(e) {\n    const { topic: t, message: s } = e;\n    await this.messages.set(t, s);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const { topic: t, message: s } = e;\n    return await this.subscriber.isSubscribed(t) ? this.messages.has(t, s) : !0;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"incoming\", payload: e }), ji(e)) {\n      if (!e.method.endsWith(K0))\n        return;\n      const t = e.params, { topic: s, message: r, publishedAt: n } = t.data, o = { topic: s, message: r, publishedAt: n };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(yv({ type: \"event\", event: t.id }, o)), this.events.emit(t.id, o), await this.acknowledgePayload(e), await this.onMessageEvent(o);\n    } else\n      Oi(e) && this.events.emit(He.message_ack, e);\n  }\n  async onMessageEvent(e) {\n    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(He.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = xi(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  registerProviderListeners() {\n    this.provider.on(is.payload, (e) => this.onProviderPayload(e)), this.provider.on(is.connect, () => {\n      this.events.emit(He.connect);\n    }), this.provider.on(is.disconnect, () => {\n      this.onProviderDisconnect();\n    }), this.provider.on(is.error, (e) => {\n      this.logger.error(e), this.events.emit(He.error, e);\n    });\n  }\n  registerEventListeners() {\n    this.events.on(He.connection_stalled, async () => {\n      await this.restartTransport();\n    });\n  }\n  onProviderDisconnect() {\n    this.events.emit(He.disconnect), this.attemptToReconnect();\n  }\n  attemptToReconnect() {\n    this.transportExplicitlyClosed || setTimeout(async () => {\n      await this.restartTransport();\n    }, V.toMiliseconds(V0));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async toEstablishConnection() {\n    if (!this.connected) {\n      if (this.connecting)\n        return await new Promise((e) => {\n          const t = setInterval(() => {\n            this.connected && (clearInterval(t), e());\n          }, this.connectionStatusPollingInterval);\n        });\n      await this.restartTransport();\n    }\n  }\n}\nvar bv = Object.defineProperty, Ma = Object.getOwnPropertySymbols, wv = Object.prototype.hasOwnProperty, vv = Object.prototype.propertyIsEnumerable, qa = (i, e, t) => e in i ? bv(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, ja = (i, e) => {\n  for (var t in e || (e = {}))\n    wv.call(e, t) && qa(i, t, e[t]);\n  if (Ma)\n    for (var t of Ma(e))\n      vv.call(e, t) && qa(i, t, e[t]);\n  return i;\n};\nclass pr extends Lm {\n  constructor(e, t, s, r = ui, n = void 0) {\n    super(e, t, s, r), this.core = e, this.logger = t, this.name = s, this.map = /* @__PURE__ */ new Map(), this.version = H0, this.cached = [], this.initialized = !1, this.storagePrefix = ui, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((o) => {\n        this.getKey && o !== null && !wt(o) ? this.map.set(this.getKey(o), o) : qb(o) ? this.map.set(o.id, o) : jb(o) && this.map.set(o.topic, o);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (o, c) => {\n      this.isInitialized(), this.map.has(o) ? await this.update(o, c) : (this.logger.debug(\"Setting value\"), this.logger.trace({ type: \"method\", method: \"set\", key: o, value: c }), this.map.set(o, c), await this.persist());\n    }, this.get = (o) => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({ type: \"method\", method: \"get\", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((c) => Object.keys(o).every((u) => Yc(c[u], o[u]))) : this.values), this.update = async (o, c) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({ type: \"method\", method: \"update\", key: o, update: c });\n      const u = ja(ja({}, this.getData(o)), c);\n      this.map.set(o, u), await this.persist();\n    }, this.delete = async (o, c) => {\n      this.isInitialized(), this.map.has(o) && (this.logger.debug(\"Deleting value\"), this.logger.trace({ type: \"method\", method: \"delete\", key: o, reason: c }), this.map.delete(o), await this.persist());\n    }, this.logger = ee.generateChildLogger(t, this.name), this.storagePrefix = r, this.getKey = n;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      const { message: s } = J(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(s), new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.map.size) {\n        const { message: t } = J(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", value: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass _v {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.name = J0, this.version = Q0, this.events = new ir(), this.initialized = !1, this.storagePrefix = ui, this.ignoredPayloadTypes = [Ni], this.registeredMethods = [], this.init = async () => {\n      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace(\"Initialized\"));\n    }, this.register = ({ methods: s }) => {\n      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s])];\n    }, this.create = async () => {\n      this.isInitialized();\n      const s = Xr(), r = await this.core.crypto.setSymKey(s), n = Ht(V.FIVE_MINUTES), o = { protocol: Mh }, c = { topic: r, expiry: n, relay: o, active: !1 }, u = Pb({ protocol: this.core.protocol, version: this.core.version, topic: r, symKey: s, relay: o });\n      return await this.pairings.set(r, c), await this.core.relayer.subscribe(r), this.core.expirer.set(r, n), { topic: r, uri: u };\n    }, this.pair = async (s) => {\n      this.isInitialized(), this.isValidPair(s);\n      const { topic: r, symKey: n, relay: o } = xb(s.uri);\n      if (this.pairings.keys.includes(r))\n        throw new Error(`Pairing already exists: ${r}`);\n      if (this.core.crypto.hasKeys(r))\n        throw new Error(`Keychain already exists: ${r}`);\n      const c = Ht(V.FIVE_MINUTES), u = { topic: r, relay: o, expiry: c, active: !1 };\n      return await this.pairings.set(r, u), await this.core.crypto.setSymKey(n, r), await this.core.relayer.subscribe(r, { relay: o }), this.core.expirer.set(r, c), s.activatePairing && await this.activate({ topic: r }), u;\n    }, this.activate = async ({ topic: s }) => {\n      this.isInitialized();\n      const r = Ht(V.THIRTY_DAYS);\n      await this.pairings.update(s, { active: !0, expiry: r }), this.core.expirer.set(s, r);\n    }, this.ping = async (s) => {\n      this.isInitialized(), await this.isValidPing(s);\n      const { topic: r } = s;\n      if (this.pairings.keys.includes(r)) {\n        const n = await this.sendRequest(r, \"wc_pairingPing\", {}), { done: o, resolve: c, reject: u } = Ti();\n        this.events.once(ke(\"pairing_ping\", n), ({ error: d }) => {\n          d ? u(d) : c();\n        }), await o();\n      }\n    }, this.updateExpiry = async ({ topic: s, expiry: r }) => {\n      this.isInitialized(), await this.pairings.update(s, { expiry: r });\n    }, this.updateMetadata = async ({ topic: s, metadata: r }) => {\n      this.isInitialized(), await this.pairings.update(s, { peerMetadata: r });\n    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s) => {\n      this.isInitialized(), await this.isValidDisconnect(s);\n      const { topic: r } = s;\n      this.pairings.keys.includes(r) && (await this.sendRequest(r, \"wc_pairingDelete\", Je(\"USER_DISCONNECTED\")), await this.deletePairing(r));\n    }, this.sendRequest = async (s, r, n) => {\n      const o = ti(r, n), c = await this.core.crypto.encode(s, o), u = ss[r].req;\n      return this.core.history.set(s, o), this.core.relayer.publish(s, c, u), o.id;\n    }, this.sendResult = async (s, r, n) => {\n      const o = xi(s, n), c = await this.core.crypto.encode(r, o), u = await this.core.history.get(r, s), d = ss[u.request.method].res;\n      await this.core.relayer.publish(r, c, d), await this.core.history.resolve(o);\n    }, this.sendError = async (s, r, n) => {\n      const o = qi(s, n), c = await this.core.crypto.encode(r, o), u = await this.core.history.get(r, s), d = ss[u.request.method] ? ss[u.request.method].res : ss.unregistered_method.res;\n      await this.core.relayer.publish(r, c, d), await this.core.history.resolve(o);\n    }, this.deletePairing = async (s, r) => {\n      await this.core.relayer.unsubscribe(s), await Promise.all([this.pairings.delete(s, Je(\"USER_DISCONNECTED\")), this.core.crypto.deleteSymKey(s), r ? Promise.resolve() : this.core.expirer.del(s)]);\n    }, this.cleanup = async () => {\n      const s = this.pairings.getAll().filter((r) => ci(r.expiry));\n      await Promise.all(s.map((r) => this.deletePairing(r.topic)));\n    }, this.onRelayEventRequest = (s) => {\n      const { topic: r, payload: n } = s, o = n.method;\n      if (this.pairings.keys.includes(r))\n        switch (o) {\n          case \"wc_pairingPing\":\n            return this.onPairingPingRequest(r, n);\n          case \"wc_pairingDelete\":\n            return this.onPairingDeleteRequest(r, n);\n          default:\n            return this.onUnknownRpcMethodRequest(r, n);\n        }\n    }, this.onRelayEventResponse = async (s) => {\n      const { topic: r, payload: n } = s, o = (await this.core.history.get(r, n.id)).request.method;\n      if (this.pairings.keys.includes(r))\n        switch (o) {\n          case \"wc_pairingPing\":\n            return this.onPairingPingResponse(r, n);\n          default:\n            return this.onUnknownRpcMethodResponse(o);\n        }\n    }, this.onPairingPingRequest = async (s, r) => {\n      const { id: n } = r;\n      try {\n        this.isValidPing({ topic: s }), await this.sendResult(n, s, !0), this.events.emit(\"pairing_ping\", { id: n, topic: s });\n      } catch (o) {\n        await this.sendError(n, s, o), this.logger.error(o);\n      }\n    }, this.onPairingPingResponse = (s, r) => {\n      const { id: n } = r;\n      setTimeout(() => {\n        ht(r) ? this.events.emit(ke(\"pairing_ping\", n), {}) : Ge(r) && this.events.emit(ke(\"pairing_ping\", n), { error: r.error });\n      }, 500);\n    }, this.onPairingDeleteRequest = async (s, r) => {\n      const { id: n } = r;\n      try {\n        this.isValidDisconnect({ topic: s }), await this.deletePairing(s), this.events.emit(\"pairing_delete\", { id: n, topic: s });\n      } catch (o) {\n        await this.sendError(n, s, o), this.logger.error(o);\n      }\n    }, this.onUnknownRpcMethodRequest = async (s, r) => {\n      const { id: n, method: o } = r;\n      try {\n        if (this.registeredMethods.includes(o))\n          return;\n        const c = Je(\"WC_METHOD_UNSUPPORTED\", o);\n        await this.sendError(n, s, c), this.logger.error(c);\n      } catch (c) {\n        await this.sendError(n, s, c), this.logger.error(c);\n      }\n    }, this.onUnknownRpcMethodResponse = (s) => {\n      this.registeredMethods.includes(s) || this.logger.error(Je(\"WC_METHOD_UNSUPPORTED\", s));\n    }, this.isValidPair = (s) => {\n      if (!It(s)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `pair() params: ${s}`);\n        throw new Error(r);\n      }\n      if (!Mb(s.uri)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `pair() uri: ${s.uri}`);\n        throw new Error(r);\n      }\n    }, this.isValidPing = async (s) => {\n      if (!It(s)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `ping() params: ${s}`);\n        throw new Error(n);\n      }\n      const { topic: r } = s;\n      await this.isValidPairingTopic(r);\n    }, this.isValidDisconnect = async (s) => {\n      if (!It(s)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `disconnect() params: ${s}`);\n        throw new Error(n);\n      }\n      const { topic: r } = s;\n      await this.isValidPairingTopic(r);\n    }, this.isValidPairingTopic = async (s) => {\n      if (!at(s, !1)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${s}`);\n        throw new Error(r);\n      }\n      if (!this.pairings.keys.includes(s)) {\n        const { message: r } = J(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${s}`);\n        throw new Error(r);\n      }\n      if (ci(this.pairings.get(s).expiry)) {\n        await this.deletePairing(s);\n        const { message: r } = J(\"EXPIRED\", `pairing topic: ${s}`);\n        throw new Error(r);\n      }\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name), this.pairings = new pr(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.core.relayer.on(He.message, async (e) => {\n      const { topic: t, message: s } = e;\n      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s)))\n        return;\n      const r = await this.core.crypto.decode(t, s);\n      ji(r) ? (this.core.history.set(t, r), this.onRelayEventRequest({ topic: t, payload: r })) : Oi(r) && (await this.core.history.resolve(r), this.onRelayEventResponse({ topic: t, payload: r }));\n    });\n  }\n  registerExpirerEvents() {\n    this.core.expirer.on($t.expired, async (e) => {\n      const { topic: t } = Sh(e.target);\n      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(\"pairing_expire\", { topic: t }));\n    });\n  }\n}\nclass Ev extends Tm {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new We.EventEmitter(), this.name = X0, this.version = Z0, this.cached = [], this.initialized = !1, this.storagePrefix = ui, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((s) => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.set = (s, r, n) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({ type: \"method\", method: \"set\", topic: s, request: r, chainId: n }), this.records.has(r.id))\n        return;\n      const o = { id: r.id, topic: s, request: { method: r.method, params: r.params || null }, chainId: n };\n      this.records.set(o.id, o), this.events.emit(Kt.created, o);\n    }, this.resolve = async (s) => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({ type: \"method\", method: \"update\", response: s }), !this.records.has(s.id))\n        return;\n      const r = await this.getRecord(s.id);\n      typeof r.response > \"u\" && (r.response = Ge(s) ? { error: s.error } : { result: s.result }, this.records.set(r.id, r), this.events.emit(Kt.updated, r));\n    }, this.get = async (s, r) => (this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({ type: \"method\", method: \"get\", topic: s, id: r }), await this.getRecord(r)), this.delete = (s, r) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({ type: \"method\", method: \"delete\", id: r }), this.values.forEach((n) => {\n        if (n.topic === s) {\n          if (typeof r < \"u\" && n.id !== r)\n            return;\n          this.records.delete(n.id), this.events.emit(Kt.deleted, n);\n        }\n      });\n    }, this.exists = async (s, r) => (this.isInitialized(), this.records.has(r) ? (await this.getRecord(r)).topic === s : !1), this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach((t) => {\n      if (typeof t.response < \"u\")\n        return;\n      const s = { topic: t.topic, request: ti(t.request.method, t.request.params, t.id), chainId: t.chainId };\n      return e.push(s);\n    }), e;\n  }\n  async setJsonRpcRecords(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const { message: s } = J(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(Kt.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getJsonRpcRecords();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.records.size) {\n        const { message: t } = J(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", records: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(Kt.created, (e) => {\n      const t = Kt.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    }), this.events.on(Kt.updated, (e) => {\n      const t = Kt.updated;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    }), this.events.on(Kt.deleted, (e) => {\n      const t = Kt.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Sv extends qm {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new We.EventEmitter(), this.name = ev, this.version = tv, this.cached = [], this.initialized = !1, this.storagePrefix = ui, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((s) => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.has = (s) => {\n      try {\n        const r = this.formatTarget(s);\n        return typeof this.getExpiration(r) < \"u\";\n      } catch {\n        return !1;\n      }\n    }, this.set = (s, r) => {\n      this.isInitialized();\n      const n = this.formatTarget(s), o = { target: n, expiry: r };\n      this.expirations.set(n, o), this.checkExpiry(n, o), this.events.emit($t.created, { target: n, expiration: o });\n    }, this.get = (s) => {\n      this.isInitialized();\n      const r = this.formatTarget(s);\n      return this.getExpiration(r);\n    }, this.del = (s) => {\n      if (this.isInitialized(), this.has(s)) {\n        const r = this.formatTarget(s), n = this.getExpiration(r);\n        this.expirations.delete(r), this.events.emit($t.deleted, { target: r, expiration: n });\n      }\n    }, this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\")\n      return bb(e);\n    if (typeof e == \"number\")\n      return wb(e);\n    const { message: t } = J(\"UNKNOWN_TYPE\", `Target type: ${typeof e}`);\n    throw new Error(t);\n  }\n  async setExpirations(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit($t.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getExpirations();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.expirations.size) {\n        const { message: t } = J(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", expirations: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);\n    }\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const { message: s } = J(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(s), new Error(s);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const { expiry: s } = t;\n    V.toMiliseconds(s) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit($t.expired, { target: e, expiration: t });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on($t.created, (e) => {\n      const t = $t.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    }), this.events.on($t.expired, (e) => {\n      const t = $t.expired;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    }), this.events.on($t.deleted, (e) => {\n      const t = $t.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Iv extends jm {\n  constructor(e, t) {\n    super(e, t), this.projectId = e, this.logger = t, this.name = Tr, this.initialized = !1, this.init = async (s) => {\n      wh() || !Nn() || (this.verifyUrl = s?.verifyUrl || Ta, await this.createIframe());\n    }, this.register = async (s) => {\n      var r;\n      this.initialized || await this.init(), this.iframe && ((r = this.iframe.contentWindow) == null || r.postMessage(s.attestationId, this.verifyUrl), this.logger.info(`postMessage sent: ${s.attestationId} ${this.verifyUrl}`));\n    }, this.resolve = async (s) => {\n      var r;\n      if (this.isDevEnv)\n        return \"\";\n      this.logger.info(`resolving attestation: ${s.attestationId}`);\n      const n = this.startAbortTimer(V.FIVE_SECONDS), o = await fetch(`${this.verifyUrl}/attestation/${s.attestationId}`, { signal: this.abortController.signal });\n      return clearTimeout(n), o.status === 200 ? (r = await o.json()) == null ? void 0 : r.origin : \"\";\n    }, this.createIframe = async () => {\n      try {\n        await Promise.race([new Promise((s, r) => {\n          if (document.getElementById(Tr))\n            return s();\n          const n = document.createElement(\"iframe\");\n          n.setAttribute(\"id\", Tr), n.setAttribute(\"src\", `${this.verifyUrl}/${this.projectId}`), n.style.display = \"none\", n.addEventListener(\"load\", () => {\n            this.initialized = !0, s();\n          }), n.addEventListener(\"error\", (o) => {\n            r(o);\n          }), document.body.append(n), this.iframe = n;\n        }), new Promise((s) => {\n          setTimeout(() => s(\"iframe load timeout\"), V.toMiliseconds(V.ONE_SECOND / 2));\n        })]);\n      } catch (s) {\n        this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(s);\n      }\n    }, this.logger = ee.generateChildLogger(t, this.name), this.verifyUrl = Ta, this.abortController = new AbortController(), this.isDevEnv = On() && process.env.IS_VITEST;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  startAbortTimer(e) {\n    return setTimeout(() => this.abortController.abort(), V.toMiliseconds(e));\n  }\n}\nvar Dv = Object.defineProperty, za = Object.getOwnPropertySymbols, xv = Object.prototype.hasOwnProperty, Ov = Object.prototype.propertyIsEnumerable, Ka = (i, e, t) => e in i ? Dv(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Va = (i, e) => {\n  for (var t in e || (e = {}))\n    xv.call(e, t) && Ka(i, t, e[t]);\n  if (za)\n    for (var t of za(e))\n      Ov.call(e, t) && Ka(i, t, e[t]);\n  return i;\n};\nlet Nv = class jh extends Am {\n  constructor(e) {\n    super(e), this.protocol = Lh, this.version = P0, this.name = Cn, this.events = new We.EventEmitter(), this.initialized = !1, this.on = (s, r) => this.events.on(s, r), this.once = (s, r) => this.events.once(s, r), this.off = (s, r) => this.events.off(s, r), this.removeListener = (s, r) => this.events.removeListener(s, r), this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || qh;\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ee.pino(ee.getDefaultLoggerOptions({ level: e?.logger || R0.logger }));\n    this.logger = ee.generateChildLogger(t, this.name), this.heartbeat = new Wt.HeartBeat(), this.crypto = new sv(this, this.logger, e?.keychain), this.history = new Ev(this, this.logger), this.expirer = new Sv(this, this.logger), this.storage = e != null && e.storage ? e.storage : new nc(Va(Va({}, C0), e?.storageOptions)), this.relayer = new mv({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new _v(this, this.logger), this.verify = new Iv(this.projectId || \"\", this.logger);\n  }\n  static async init(e) {\n    const t = new jh(e);\n    return await t.initialize(), t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  async start() {\n    this.initialized || await this.initialize();\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info(\"Core Initialization Success\");\n    } catch (e) {\n      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;\n    }\n  }\n};\nconst Pv = Nv, zh = \"wc\", Kh = 2, Vh = \"client\", An = `${zh}@${Kh}:${Vh}:`, Fr = { name: Vh, logger: \"error\", controller: !1, relayUrl: \"wss://relay.walletconnect.com\" }, Rv = \"proposal\", Cv = \"Proposal expired\", Av = \"session\", Ls = V.SEVEN_DAYS, Tv = \"engine\", ns = { wc_sessionPropose: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, Ur = { min: V.FIVE_MINUTES, max: V.SEVEN_DAYS }, $v = \"request\", Fv = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\nvar Uv = Object.defineProperty, Lv = Object.defineProperties, Mv = Object.getOwnPropertyDescriptors, Ba = Object.getOwnPropertySymbols, qv = Object.prototype.hasOwnProperty, jv = Object.prototype.propertyIsEnumerable, ka = (i, e, t) => e in i ? Uv(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, At = (i, e) => {\n  for (var t in e || (e = {}))\n    qv.call(e, t) && ka(i, t, e[t]);\n  if (Ba)\n    for (var t of Ba(e))\n      jv.call(e, t) && ka(i, t, e[t]);\n  return i;\n}, Lr = (i, e) => Lv(i, Mv(e));\nclass zv extends Km {\n  constructor(e) {\n    super(e), this.name = Tv, this.events = new ir(), this.initialized = !1, this.ignoredPayloadTypes = [Ni], this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(ns) }), this.initialized = !0);\n    }, this.connect = async (t) => {\n      this.isInitialized();\n      const s = Lr(At({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });\n      await this.isValidConnect(s);\n      const { pairingTopic: r, requiredNamespaces: n, optionalNamespaces: o, sessionProperties: c, relays: u } = s;\n      let d = r, p, b = !1;\n      if (d && (b = this.client.core.pairing.pairings.get(d).active), !d || !b) {\n        const { topic: D, uri: y } = await this.client.core.pairing.create();\n        d = D, p = y;\n      }\n      const x = await this.client.core.crypto.generateKeyPair(), O = At({ requiredNamespaces: n, optionalNamespaces: o, relays: u ?? [{ protocol: Mh }], proposer: { publicKey: x, metadata: this.client.metadata } }, c && { sessionProperties: c }), { reject: _, resolve: C, done: F } = Ti(V.FIVE_MINUTES, Cv);\n      if (this.events.once(ke(\"session_connect\"), async ({ error: D, session: y }) => {\n        if (D)\n          _(D);\n        else if (y) {\n          y.self.publicKey = x;\n          const w = Lr(At({}, y), { requiredNamespaces: y.requiredNamespaces, optionalNamespaces: y.optionalNamespaces });\n          await this.client.session.set(y.topic, w), await this.setExpiry(y.topic, y.expiry), d && await this.client.core.pairing.updateMetadata({ topic: d, metadata: y.peer.metadata }), C(w);\n        }\n      }), !d) {\n        const { message: D } = J(\"NO_MATCHING_KEY\", `connect() pairing topic: ${d}`);\n        throw new Error(D);\n      }\n      const K = await this.sendRequest(d, \"wc_sessionPropose\", O), I = Ht(V.FIVE_MINUTES);\n      return await this.setProposal(K, At({ id: K, expiry: I }, O)), { uri: p, approval: F };\n    }, this.pair = async (t) => (this.isInitialized(), await this.client.core.pairing.pair(t)), this.approve = async (t) => {\n      this.isInitialized(), await this.isValidApprove(t);\n      const { id: s, relayProtocol: r, namespaces: n, sessionProperties: o } = t, c = this.client.proposal.get(s);\n      let { pairingTopic: u, proposer: d, requiredNamespaces: p, optionalNamespaces: b } = c;\n      u = u || \"\", us(p) || (p = Tb(n, \"approve()\"));\n      const x = await this.client.core.crypto.generateKeyPair(), O = d.publicKey, _ = await this.client.core.crypto.generateSharedKey(x, O);\n      u && s && (await this.client.core.pairing.updateMetadata({ topic: u, metadata: d.metadata }), await this.sendResult(s, u, { relay: { protocol: r ?? \"irn\" }, responderPublicKey: x }), await this.client.proposal.delete(s, Je(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({ topic: u }));\n      const C = At({ relay: { protocol: r ?? \"irn\" }, namespaces: n, requiredNamespaces: p, optionalNamespaces: b, pairingTopic: u, controller: { publicKey: x, metadata: this.client.metadata }, expiry: Ht(Ls) }, o && { sessionProperties: o });\n      await this.client.core.relayer.subscribe(_), await this.sendRequest(_, \"wc_sessionSettle\", C);\n      const F = Lr(At({}, C), { topic: _, pairingTopic: u, acknowledged: !1, self: C.controller, peer: { publicKey: d.publicKey, metadata: d.metadata }, controller: x });\n      return await this.client.session.set(_, F), await this.setExpiry(_, Ht(Ls)), { topic: _, acknowledged: () => new Promise((K) => setTimeout(() => K(this.client.session.get(_)), 500)) };\n    }, this.reject = async (t) => {\n      this.isInitialized(), await this.isValidReject(t);\n      const { id: s, reason: r } = t, { pairingTopic: n } = this.client.proposal.get(s);\n      n && (await this.sendError(s, n, r), await this.client.proposal.delete(s, Je(\"USER_DISCONNECTED\")));\n    }, this.update = async (t) => {\n      this.isInitialized(), await this.isValidUpdate(t);\n      const { topic: s, namespaces: r } = t, n = await this.sendRequest(s, \"wc_sessionUpdate\", { namespaces: r }), { done: o, resolve: c, reject: u } = Ti();\n      return this.events.once(ke(\"session_update\", n), ({ error: d }) => {\n        d ? u(d) : c();\n      }), await this.client.session.update(s, { namespaces: r }), { acknowledged: o };\n    }, this.extend = async (t) => {\n      this.isInitialized(), await this.isValidExtend(t);\n      const { topic: s } = t, r = await this.sendRequest(s, \"wc_sessionExtend\", {}), { done: n, resolve: o, reject: c } = Ti();\n      return this.events.once(ke(\"session_extend\", r), ({ error: u }) => {\n        u ? c(u) : o();\n      }), await this.setExpiry(s, Ht(Ls)), { acknowledged: n };\n    }, this.request = async (t) => {\n      this.isInitialized(), await this.isValidRequest(t);\n      const { chainId: s, request: r, topic: n, expiry: o } = t, c = await this.sendRequest(n, \"wc_sessionRequest\", { request: r, chainId: s }, o), { done: u, resolve: d, reject: p } = Ti(o);\n      return this.events.once(ke(\"session_request\", c), ({ error: b, result: x }) => {\n        b ? p(b) : d(x);\n      }), this.client.events.emit(\"session_request_sent\", { topic: n, request: r, chainId: s, id: c }), await u();\n    }, this.respond = async (t) => {\n      this.isInitialized(), await this.isValidRespond(t);\n      const { topic: s, response: r } = t, { id: n } = r;\n      ht(r) ? await this.sendResult(n, s, r.result) : Ge(r) && await this.sendError(n, s, r.error), this.deletePendingSessionRequest(t.response.id, { message: \"fulfilled\", code: 0 });\n    }, this.ping = async (t) => {\n      this.isInitialized(), await this.isValidPing(t);\n      const { topic: s } = t;\n      if (this.client.session.keys.includes(s)) {\n        const r = await this.sendRequest(s, \"wc_sessionPing\", {}), { done: n, resolve: o, reject: c } = Ti();\n        this.events.once(ke(\"session_ping\", r), ({ error: u }) => {\n          u ? c(u) : o();\n        }), await n();\n      } else\n        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });\n    }, this.emit = async (t) => {\n      this.isInitialized(), await this.isValidEmit(t);\n      const { topic: s, event: r, chainId: n } = t;\n      await this.sendRequest(s, \"wc_sessionEvent\", { event: r, chainId: n });\n    }, this.disconnect = async (t) => {\n      this.isInitialized(), await this.isValidDisconnect(t);\n      const { topic: s } = t;\n      this.client.session.keys.includes(s) ? (await this.sendRequest(s, \"wc_sessionDelete\", Je(\"USER_DISCONNECTED\")), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({ topic: s });\n    }, this.find = (t) => (this.isInitialized(), this.client.session.getAll().filter((s) => Ub(s, t))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (t) => {\n      try {\n        const s = this.client.core.pairing.pairings.get(t.pairingTopic), r = this.client.core.pairing.pairings.getAll().filter((n) => {\n          var o, c;\n          return ((o = n.peerMetadata) == null ? void 0 : o.url) && ((c = n.peerMetadata) == null ? void 0 : c.url) === t.self.metadata.url && n.topic !== s.topic;\n        });\n        if (r.length === 0)\n          return;\n        this.client.logger.info(`Cleaning up ${r.length} duplicate pairing(s)`), await Promise.all(r.map((n) => this.client.core.pairing.disconnect({ topic: n.topic }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.deleteSession = async (t, s) => {\n      const { self: r } = this.client.session.get(t);\n      await this.client.core.relayer.unsubscribe(t), await Promise.all([this.client.session.delete(t, Je(\"USER_DISCONNECTED\")), this.client.core.crypto.deleteKeyPair(r.publicKey), this.client.core.crypto.deleteSymKey(t), s ? Promise.resolve() : this.client.core.expirer.del(t)]);\n    }, this.deleteProposal = async (t, s) => {\n      await Promise.all([this.client.proposal.delete(t, Je(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(t)]);\n    }, this.deletePendingSessionRequest = async (t, s, r = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(t, s), r ? Promise.resolve() : this.client.core.expirer.del(t)]);\n    }, this.setExpiry = async (t, s) => {\n      this.client.session.keys.includes(t) && await this.client.session.update(t, { expiry: s }), this.client.core.expirer.set(t, s);\n    }, this.setProposal = async (t, s) => {\n      await this.client.proposal.set(t, s), this.client.core.expirer.set(t, s.expiry);\n    }, this.setPendingSessionRequest = async (t) => {\n      const s = ns.wc_sessionRequest.req.ttl, { id: r, topic: n, params: o } = t;\n      await this.client.pendingRequest.set(r, { id: r, topic: n, params: o }), s && this.client.core.expirer.set(r, Ht(s));\n    }, this.sendRequest = async (t, s, r, n) => {\n      const o = ti(s, r);\n      if (Nn() && Fv.includes(s)) {\n        const d = Ui(JSON.stringify(o));\n        await this.client.core.verify.register({ attestationId: d });\n      }\n      const c = await this.client.core.crypto.encode(t, o), u = ns[s].req;\n      return n && (u.ttl = n), this.client.core.history.set(t, o), this.client.core.relayer.publish(t, c, u), o.id;\n    }, this.sendResult = async (t, s, r) => {\n      const n = xi(t, r), o = await this.client.core.crypto.encode(s, n), c = await this.client.core.history.get(s, t), u = ns[c.request.method].res;\n      this.client.core.relayer.publish(s, o, u), await this.client.core.history.resolve(n);\n    }, this.sendError = async (t, s, r) => {\n      const n = qi(t, r), o = await this.client.core.crypto.encode(s, n), c = await this.client.core.history.get(s, t), u = ns[c.request.method].res;\n      this.client.core.relayer.publish(s, o, u), await this.client.core.history.resolve(n);\n    }, this.cleanup = async () => {\n      const t = [], s = [];\n      this.client.session.getAll().forEach((r) => {\n        ci(r.expiry) && t.push(r.topic);\n      }), this.client.proposal.getAll().forEach((r) => {\n        ci(r.expiry) && s.push(r.id);\n      }), await Promise.all([...t.map((r) => this.deleteSession(r)), ...s.map((r) => this.deleteProposal(r))]);\n    }, this.onRelayEventRequest = (t) => {\n      const { topic: s, payload: r } = t, n = r.method;\n      switch (n) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, r);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, r);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, r);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, r);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, r);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, r);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, r);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, r);\n        default:\n          return this.client.logger.info(`Unsupported request method ${n}`);\n      }\n    }, this.onRelayEventResponse = async (t) => {\n      const { topic: s, payload: r } = t, n = (await this.client.core.history.get(s, r.id)).request.method;\n      switch (n) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, r);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, r);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, r);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, r);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, r);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, r);\n        default:\n          return this.client.logger.info(`Unsupported response method ${n}`);\n      }\n    }, this.onSessionProposeRequest = async (t, s) => {\n      const { params: r, id: n } = s;\n      try {\n        this.isValidConnect(At({}, s.params));\n        const o = Ht(V.FIVE_MINUTES), c = At({ id: n, pairingTopic: t, expiry: o }, r);\n        await this.setProposal(n, c);\n        const u = Ui(JSON.stringify(s)), d = await this.getVerifyContext(u, c.proposer.metadata);\n        this.client.events.emit(\"session_proposal\", { id: n, params: c, verifyContext: d });\n      } catch (o) {\n        await this.sendError(n, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionProposeResponse = async (t, s) => {\n      const { id: r } = s;\n      if (ht(s)) {\n        const { result: n } = s;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result: n });\n        const o = this.client.proposal.get(r);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal: o });\n        const c = o.proposer.publicKey;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", selfPublicKey: c });\n        const u = n.responderPublicKey;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", peerPublicKey: u });\n        const d = await this.client.core.crypto.generateSharedKey(c, u);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", sessionTopic: d });\n        const p = await this.client.core.relayer.subscribe(d);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", subscriptionId: p }), await this.client.core.pairing.activate({ topic: t });\n      } else\n        Ge(s) && (await this.client.proposal.delete(r, Je(\"USER_DISCONNECTED\")), this.events.emit(ke(\"session_connect\"), { error: s.error }));\n    }, this.onSessionSettleRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        this.isValidSessionSettleRequest(n);\n        const { relay: o, controller: c, expiry: u, namespaces: d, requiredNamespaces: p, optionalNamespaces: b, sessionProperties: x, pairingTopic: O } = s.params, _ = At({ topic: t, relay: o, expiry: u, namespaces: d, acknowledged: !0, pairingTopic: O, requiredNamespaces: p, optionalNamespaces: b, controller: c.publicKey, self: { publicKey: \"\", metadata: this.client.metadata }, peer: { publicKey: c.publicKey, metadata: c.metadata } }, x && { sessionProperties: x });\n        await this.sendResult(s.id, t, !0), this.events.emit(ke(\"session_connect\"), { session: _ }), this.cleanupDuplicatePairings(_);\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionSettleResponse = async (t, s) => {\n      const { id: r } = s;\n      ht(s) ? (await this.client.session.update(t, { acknowledged: !0 }), this.events.emit(ke(\"session_approve\", r), {})) : Ge(s) && (await this.client.session.delete(t, Je(\"USER_DISCONNECTED\")), this.events.emit(ke(\"session_approve\", r), { error: s.error }));\n    }, this.onSessionUpdateRequest = async (t, s) => {\n      const { params: r, id: n } = s;\n      try {\n        this.isValidUpdate(At({ topic: t }, r)), await this.client.session.update(t, { namespaces: r.namespaces }), await this.sendResult(n, t, !0), this.client.events.emit(\"session_update\", { id: n, topic: t, params: r });\n      } catch (o) {\n        await this.sendError(n, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionUpdateResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(ke(\"session_update\", r), {}) : Ge(s) && this.events.emit(ke(\"session_update\", r), { error: s.error });\n    }, this.onSessionExtendRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidExtend({ topic: t }), await this.setExpiry(t, Ht(Ls)), await this.sendResult(r, t, !0), this.client.events.emit(\"session_extend\", { id: r, topic: t });\n      } catch (n) {\n        await this.sendError(r, t, n), this.client.logger.error(n);\n      }\n    }, this.onSessionExtendResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(ke(\"session_extend\", r), {}) : Ge(s) && this.events.emit(ke(\"session_extend\", r), { error: s.error });\n    }, this.onSessionPingRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidPing({ topic: t }), await this.sendResult(r, t, !0), this.client.events.emit(\"session_ping\", { id: r, topic: t });\n      } catch (n) {\n        await this.sendError(r, t, n), this.client.logger.error(n);\n      }\n    }, this.onSessionPingResponse = (t, s) => {\n      const { id: r } = s;\n      setTimeout(() => {\n        ht(s) ? this.events.emit(ke(\"session_ping\", r), {}) : Ge(s) && this.events.emit(ke(\"session_ping\", r), { error: s.error });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidDisconnect({ topic: t, reason: s.params }), await Promise.all([new Promise((n) => {\n          this.client.core.relayer.once(He.publish, async () => {\n            n(await this.deleteSession(t));\n          });\n        }), this.sendResult(r, t, !0)]), this.client.events.emit(\"session_delete\", { id: r, topic: t });\n      } catch (n) {\n        await this.sendError(r, t, n), this.client.logger.error(n);\n      }\n    }, this.onSessionRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        this.isValidRequest(At({ topic: t }, n)), await this.setPendingSessionRequest({ id: r, topic: t, params: n });\n        const o = Ui(JSON.stringify(s)), c = this.client.session.get(t), u = await this.getVerifyContext(o, c.peer.metadata);\n        this.client.events.emit(\"session_request\", { id: r, topic: t, params: n, verifyContext: u });\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionRequestResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(ke(\"session_request\", r), { result: s.result }) : Ge(s) && this.events.emit(ke(\"session_request\", r), { error: s.error });\n    }, this.onSessionEventRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        this.isValidEmit(At({ topic: t }, n)), this.client.events.emit(\"session_event\", { id: r, topic: t, params: n });\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.isValidConnect = async (t) => {\n      if (!It(t)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(t)}`);\n        throw new Error(u);\n      }\n      const { pairingTopic: s, requiredNamespaces: r, optionalNamespaces: n, sessionProperties: o, relays: c } = t;\n      if (wt(s) || await this.isValidPairingTopic(s), !Wb(c, !0)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `connect() relays: ${c}`);\n        throw new Error(u);\n      }\n      !wt(r) && us(r) !== 0 && this.validateNamespaces(r, \"requiredNamespaces\"), !wt(n) && us(n) !== 0 && this.validateNamespaces(n, \"optionalNamespaces\"), wt(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.validateNamespaces = (t, s) => {\n      const r = Gb(t, \"connect()\", s);\n      if (r)\n        throw new Error(r.message);\n    }, this.isValidApprove = async (t) => {\n      if (!It(t))\n        throw new Error(J(\"MISSING_OR_INVALID\", `approve() params: ${t}`).message);\n      const { id: s, namespaces: r, relayProtocol: n, sessionProperties: o } = t;\n      await this.isValidProposalId(s);\n      const c = this.client.proposal.get(s), u = Bs(r, \"approve()\");\n      if (u)\n        throw new Error(u.message);\n      const d = Ia(c.requiredNamespaces, r, \"approve()\");\n      if (d)\n        throw new Error(d.message);\n      if (!at(n, !0)) {\n        const { message: p } = J(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${n}`);\n        throw new Error(p);\n      }\n      wt(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.isValidReject = async (t) => {\n      if (!It(t)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `reject() params: ${t}`);\n        throw new Error(n);\n      }\n      const { id: s, reason: r } = t;\n      if (await this.isValidProposalId(s), !Jb(r)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(r)}`);\n        throw new Error(n);\n      }\n    }, this.isValidSessionSettleRequest = (t) => {\n      if (!It(t)) {\n        const { message: d } = J(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${t}`);\n        throw new Error(d);\n      }\n      const { relay: s, controller: r, namespaces: n, expiry: o } = t;\n      if (!Dh(s)) {\n        const { message: d } = J(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(d);\n      }\n      const c = zb(r, \"onSessionSettleRequest()\");\n      if (c)\n        throw new Error(c.message);\n      const u = Bs(n, \"onSessionSettleRequest()\");\n      if (u)\n        throw new Error(u.message);\n      if (ci(o)) {\n        const { message: d } = J(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(d);\n      }\n    }, this.isValidUpdate = async (t) => {\n      if (!It(t)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `update() params: ${t}`);\n        throw new Error(u);\n      }\n      const { topic: s, namespaces: r } = t;\n      await this.isValidSessionTopic(s);\n      const n = this.client.session.get(s), o = Bs(r, \"update()\");\n      if (o)\n        throw new Error(o.message);\n      const c = Ia(n.requiredNamespaces, r, \"update()\");\n      if (c)\n        throw new Error(c.message);\n    }, this.isValidExtend = async (t) => {\n      if (!It(t)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `extend() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async (t) => {\n      if (!It(t)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `request() params: ${t}`);\n        throw new Error(u);\n      }\n      const { topic: s, request: r, chainId: n, expiry: o } = t;\n      await this.isValidSessionTopic(s);\n      const { namespaces: c } = this.client.session.get(s);\n      if (!Sa(c, n)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `request() chainId: ${n}`);\n        throw new Error(u);\n      }\n      if (!Qb(r)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(r)}`);\n        throw new Error(u);\n      }\n      if (!ew(c, n, r.method)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `request() method: ${r.method}`);\n        throw new Error(u);\n      }\n      if (o && !rw(o, Ur)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${Ur.min} and ${Ur.max}`);\n        throw new Error(u);\n      }\n    }, this.isValidRespond = async (t) => {\n      if (!It(t)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `respond() params: ${t}`);\n        throw new Error(n);\n      }\n      const { topic: s, response: r } = t;\n      if (await this.isValidSessionTopic(s), !Xb(r)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(r)}`);\n        throw new Error(n);\n      }\n    }, this.isValidPing = async (t) => {\n      if (!It(t)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `ping() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async (t) => {\n      if (!It(t)) {\n        const { message: c } = J(\"MISSING_OR_INVALID\", `emit() params: ${t}`);\n        throw new Error(c);\n      }\n      const { topic: s, event: r, chainId: n } = t;\n      await this.isValidSessionTopic(s);\n      const { namespaces: o } = this.client.session.get(s);\n      if (!Sa(o, n)) {\n        const { message: c } = J(\"MISSING_OR_INVALID\", `emit() chainId: ${n}`);\n        throw new Error(c);\n      }\n      if (!Zb(r)) {\n        const { message: c } = J(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(r)}`);\n        throw new Error(c);\n      }\n      if (!tw(o, n, r.name)) {\n        const { message: c } = J(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(r)}`);\n        throw new Error(c);\n      }\n    }, this.isValidDisconnect = async (t) => {\n      if (!It(t)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `disconnect() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.getVerifyContext = async (t, s) => {\n      const r = { verified: { verifyUrl: s.verifyUrl || \"\", validation: \"UNKNOWN\", origin: s.url || \"\" } };\n      try {\n        const n = await this.client.core.verify.resolve({ attestationId: t, verifyUrl: s.verifyUrl });\n        n && (r.verified.origin = n, r.verified.validation = n === s.url ? \"VALID\" : \"INVALID\");\n      } catch (n) {\n        this.client.logger.error(n);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(r)}`), r;\n    }, this.validateSessionProps = (t, s) => {\n      Object.values(t).forEach((r) => {\n        if (!at(r, !1)) {\n          const { message: n } = J(\"MISSING_OR_INVALID\", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(r)}`);\n          throw new Error(n);\n        }\n      });\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(He.message, async (e) => {\n      const { topic: t, message: s } = e;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))\n        return;\n      const r = await this.client.core.crypto.decode(t, s);\n      ji(r) ? (this.client.core.history.set(t, r), this.onRelayEventRequest({ topic: t, payload: r })) : Oi(r) && (await this.client.core.history.resolve(r), this.onRelayEventResponse({ topic: t, payload: r }));\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on($t.expired, async (e) => {\n      const { topic: t, id: s } = Sh(e.target);\n      if (s && this.client.pendingRequest.keys.includes(s))\n        return await this.deletePendingSessionRequest(s, J(\"EXPIRED\"), !0);\n      t ? this.client.session.keys.includes(t) && (await this.deleteSession(t, !0), this.client.events.emit(\"session_expire\", { topic: t })) : s && (await this.deleteProposal(s, !0), this.client.events.emit(\"proposal_expire\", { id: s }));\n    });\n  }\n  isValidPairingTopic(e) {\n    if (!at(e, !1)) {\n      const { message: t } = J(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(e)) {\n      const { message: t } = J(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ci(this.client.core.pairing.pairings.get(e).expiry)) {\n      const { message: t } = J(\"EXPIRED\", `pairing topic: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidSessionTopic(e) {\n    if (!at(e, !1)) {\n      const { message: t } = J(\"MISSING_OR_INVALID\", `session topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.session.keys.includes(e)) {\n      const { message: t } = J(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ci(this.client.session.get(e).expiry)) {\n      await this.deleteSession(e);\n      const { message: t } = J(\"EXPIRED\", `session topic: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidSessionOrPairingTopic(e) {\n    if (this.client.session.keys.includes(e))\n      await this.isValidSessionTopic(e);\n    else if (this.client.core.pairing.pairings.keys.includes(e))\n      this.isValidPairingTopic(e);\n    else if (at(e, !1)) {\n      const { message: t } = J(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${e}`);\n      throw new Error(t);\n    } else {\n      const { message: t } = J(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidProposalId(e) {\n    if (!Yb(e)) {\n      const { message: t } = J(\"MISSING_OR_INVALID\", `proposal id should be a number: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.proposal.keys.includes(e)) {\n      const { message: t } = J(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ci(this.client.proposal.get(e).expiry)) {\n      await this.deleteProposal(e);\n      const { message: t } = J(\"EXPIRED\", `proposal id: ${e}`);\n      throw new Error(t);\n    }\n  }\n}\nclass Kv extends pr {\n  constructor(e, t) {\n    super(e, t, Rv, An), this.core = e, this.logger = t;\n  }\n}\nclass Vv extends pr {\n  constructor(e, t) {\n    super(e, t, Av, An), this.core = e, this.logger = t;\n  }\n}\nclass Bv extends pr {\n  constructor(e, t) {\n    super(e, t, $v, An, (s) => s.id), this.core = e, this.logger = t;\n  }\n}\nclass Tn extends zm {\n  constructor(e) {\n    super(e), this.protocol = zh, this.version = Kh, this.name = Fr.name, this.events = new We.EventEmitter(), this.on = (s, r) => this.events.on(s, r), this.once = (s, r) => this.events.once(s, r), this.off = (s, r) => this.events.off(s, r), this.removeListener = (s, r) => this.events.removeListener(s, r), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {\n      try {\n        return await this.engine.connect(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.pair = async (s) => {\n      try {\n        return await this.engine.pair(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.approve = async (s) => {\n      try {\n        return await this.engine.approve(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.reject = async (s) => {\n      try {\n        return await this.engine.reject(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.update = async (s) => {\n      try {\n        return await this.engine.update(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.extend = async (s) => {\n      try {\n        return await this.engine.extend(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.request = async (s) => {\n      try {\n        return await this.engine.request(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.respond = async (s) => {\n      try {\n        return await this.engine.respond(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.ping = async (s) => {\n      try {\n        return await this.engine.ping(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.emit = async (s) => {\n      try {\n        return await this.engine.emit(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.disconnect = async (s) => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.find = (s) => {\n      try {\n        return this.engine.find(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = e?.name || Fr.name, this.metadata = e?.metadata || fb();\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ee.pino(ee.getDefaultLoggerOptions({ level: e?.logger || Fr.logger }));\n    this.core = e?.core || new Pv(e), this.logger = ee.generateChildLogger(t, this.name), this.session = new Vv(this.core, this.logger), this.proposal = new Kv(this.core, this.logger), this.pendingRequest = new Bv(this.core, this.logger), this.engine = new zv(this);\n  }\n  static async init(e) {\n    const t = new Tn(e);\n    return await t.initialize(), t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info(\"SignClient Initialization Success\");\n    } catch (e) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(e.message), e;\n    }\n  }\n}\nfunction kv(i) {\n  return typeof i < \"u\" && typeof i.context < \"u\";\n}\nconst Gt = { init: \"signer_init\", uri: \"signer_uri\", created: \"signer_created\", updated: \"signer_updated\", deleted: \"signer_deleted\", event: \"signer_event\" };\nclass Hv extends Dg {\n  constructor(e) {\n    super(), this.events = new We.EventEmitter(), this.pending = !1, this.initializing = !1, this.requiredNamespaces = e?.requiredNamespaces || {}, this.opts = e?.client;\n  }\n  get connected() {\n    return typeof this.session < \"u\";\n  }\n  get connecting() {\n    return this.pending;\n  }\n  get chains() {\n    return this.session ? Ym(this.session.namespaces) : Jm(this.requiredNamespaces);\n  }\n  get accounts() {\n    return this.session ? Wm(this.session.namespaces) : [];\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async open() {\n    if (this.pending)\n      return new Promise((e, t) => {\n        this.events.once(\"open\", () => {\n          if (this.events.once(\"open_error\", (s) => {\n            t(s);\n          }), typeof this.client > \"u\")\n            return t(new Error(\"Sign Client not initialized\"));\n          e();\n        });\n      });\n    try {\n      this.pending = !0;\n      const e = await this.register(), t = e.find({ requiredNamespaces: this.requiredNamespaces });\n      if (t.length)\n        return this.onOpen(t[0]);\n      const { uri: s, approval: r } = await e.connect({ requiredNamespaces: this.requiredNamespaces });\n      this.events.emit(Gt.uri, { uri: s }), this.session = await r(), this.events.emit(Gt.created, this.session), this.onOpen();\n    } catch (e) {\n      throw this.events.emit(\"open_error\", e), e;\n    }\n  }\n  async close() {\n    typeof this.session > \"u\" || (await (await this.register()).disconnect({ topic: this.session.topic, reason: Je(\"USER_DISCONNECTED\") }), this.onClose());\n  }\n  async send(e, t) {\n    if (typeof this.client > \"u\" && (this.client = await this.register(), this.connected || await this.open()), typeof this.session > \"u\")\n      throw new Error(\"Signer connection is missing session\");\n    this.client.request({ topic: this.session.topic, request: e, chainId: t?.chainId }).then((s) => this.events.emit(\"payload\", xi(e.id, s))).catch((s) => this.events.emit(\"payload\", qi(e.id, s.message)));\n  }\n  async register(e = this.opts) {\n    if (typeof this.client < \"u\")\n      return this.client;\n    if (this.initializing)\n      return new Promise((t, s) => {\n        this.events.once(\"register_error\", (r) => {\n          s(r);\n        }), this.events.once(Gt.init, () => {\n          if (typeof this.client > \"u\")\n            return s(new Error(\"Sign Client not initialized\"));\n          t(this.client);\n        });\n      });\n    if (kv(e))\n      return this.client = e, this.registerEventListeners(), this.client;\n    try {\n      return this.initializing = !0, this.client = await Tn.init(e), this.initializing = !1, this.registerEventListeners(), this.events.emit(Gt.init), this.client;\n    } catch (t) {\n      throw this.events.emit(\"register_error\", t), t;\n    }\n  }\n  onOpen(e) {\n    this.pending = !1, e && (this.session = e), this.events.emit(\"open\");\n  }\n  onClose() {\n    this.pending = !1, this.client && (this.client = void 0), this.events.emit(\"close\");\n  }\n  registerEventListeners() {\n    typeof this.client < \"u\" && (this.client.on(\"session_event\", (e) => {\n      var t;\n      this.session && ((t = this.session) == null ? void 0 : t.topic) !== e.topic || this.events.emit(Gt.event, e.params);\n    }), this.client.on(\"session_update\", (e) => {\n      var t;\n      typeof this.client < \"u\" && (this.session && ((t = this.session) == null ? void 0 : t.topic) !== e.topic || (this.session = this.client.session.get(e.topic), this.events.emit(Gt.updated, this.session)));\n    }), this.client.on(\"session_delete\", (e) => {\n      var t;\n      this.session && (this.session && ((t = this.session) == null ? void 0 : t.topic) !== e.topic || (this.onClose(), this.events.emit(Gt.deleted, this.session), this.session = void 0));\n    }));\n  }\n}\nconst Bh = \":\";\nfunction Gv(i) {\n  const { namespace: e, reference: t } = i;\n  return [e, t].join(Bh);\n}\nfunction Wv(i) {\n  const [e, t, s] = i.split(Bh);\n  return { namespace: e, reference: t, address: s };\n}\nfunction Yv(i, e) {\n  const t = [];\n  return i.forEach((s) => {\n    const r = e(s);\n    t.includes(r) || t.push(r);\n  }), t;\n}\nfunction Jv(i) {\n  const { namespace: e, reference: t } = Wv(i);\n  return Gv({ namespace: e, reference: t });\n}\nfunction Qv(i) {\n  return Yv(i, Jv);\n}\nfunction Xv(i, e = []) {\n  const t = [];\n  return Object.keys(i).forEach((s) => {\n    if (e.length && !e.includes(s))\n      return;\n    const r = i[s];\n    t.push(...r.accounts);\n  }), t;\n}\nfunction Zv(i, e = []) {\n  const t = [];\n  return Object.keys(i).forEach((s) => {\n    if (e.length && !e.includes(s))\n      return;\n    const r = i[s];\n    t.push(...Qv(r.accounts));\n  }), t;\n}\nclass e_ {\n  constructor() {\n    we(this, \"accounts\", []);\n    we(this, \"eventEmitter\", new We.EventEmitter());\n    we(this, \"updateSession\", (e) => {\n      if (!this.isValidSession(e))\n        throw console.warn(\n          \"updateSession incompatible session\",\n          e,\n          \"for adapter\",\n          this.formatChainId(this.chainId)\n        ), new Error(\"Invalid session\");\n      this.session = e;\n      const t = Zv(e.namespaces, [this.namespace]);\n      this.setChainIds(t);\n      const s = Xv(e.namespaces, [\n        this.namespace\n      ]);\n      this.setAccounts(s);\n    });\n    we(this, \"isValidSession\", ({\n      namespaces: e,\n      requiredNamespaces: t\n    }) => {\n      const s = this.formatChainId(this.chainId);\n      return t ? !!t[this.namespace]?.chains?.includes(s) : !!e?.[this.namespace]?.accounts.some(\n        (r) => r.startsWith(s)\n      );\n    });\n  }\n  getRequiredNamespaces() {\n    const e = [this.formatChainId(this.chainId)];\n    return {\n      [this.namespace]: { chains: e, methods: this.methods, events: this.events }\n    };\n  }\n  isCompatibleChainId(e) {\n    return typeof e == \"string\" ? e.startsWith(`${this.namespace}:`) : !1;\n  }\n  setChainIds(e) {\n    const s = e.filter((r) => this.isCompatibleChainId(r)).map((r) => this.parseChainId(r)).filter((r) => r !== this.chainId);\n    s.length && (this.chainId = s[0], this.eventEmitter.emit(\"chainChanged\", this.chainId));\n  }\n  setChainId(e) {\n    if (this.isCompatibleChainId(e)) {\n      const t = this.parseChainId(e);\n      this.chainId = t, this.eventEmitter.emit(\"chainChanged\", this.chainId);\n    }\n  }\n  parseAccountId(e) {\n    const [t, s, r] = e.split(\":\");\n    return { chainId: `${t}:${s}`, address: r };\n  }\n  getSignerConnection(e) {\n    return new Hv({\n      requiredNamespaces: {\n        [this.namespace]: {\n          chains: this.rpc.chains,\n          methods: this.rpc.methods,\n          events: this.rpc.events\n        }\n      },\n      client: e\n    });\n  }\n  registerEventListeners() {\n    this.rpcProvider.on(\"connect\", () => {\n      const { chains: e, accounts: t } = this.signerConnection;\n      e?.length && this.setChainIds(e), t?.length && this.setAccounts(t);\n    }), this.signerConnection.on(Gt.created, this.updateSession), this.signerConnection.on(Gt.updated, this.updateSession), this.signerConnection.on(Gt.event, (e) => {\n      if (!this.rpc.chains.includes(e.chainId))\n        return;\n      const { event: t } = e;\n      t.name === \"accountsChanged\" ? (this.accounts = t.data, this.eventEmitter.emit(\"accountsChanged\", this.accounts)) : t.name === \"chainChanged\" ? this.setChainId(t.data) : this.eventEmitter.emit(t.name, t.data);\n    }), this.rpcProvider.on(\"disconnect\", () => {\n      this.eventEmitter.emit(\"disconnect\");\n    });\n  }\n}\nclass Ha extends starknet__WEBPACK_IMPORTED_MODULE_1__.Account {\n  constructor(e, t, s, r) {\n    super(e, t, s), this.wallet = r;\n  }\n  async execute(e, t = void 0, s = {}) {\n    return e = Array.isArray(e) ? e : [e], await this.wallet.starknet_requestAddInvokeTransaction({\n      accountAddress: this.address,\n      executionRequest: { calls: e, abis: t, invocationDetails: s }\n    });\n  }\n  async declare(e, t) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async deployAccount(e, t) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n}\nclass t_ {\n  constructor(e) {\n    this.wallet = e;\n  }\n  async getPubKey() {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async signMessage(e, t) {\n    const { signature: s } = await this.wallet.starknet_signTypedData({\n      accountAddress: t,\n      typedData: e\n    });\n    return s;\n  }\n  async signTransaction(e, t, s) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async signDeployAccountTransaction(e) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async signDeclareTransaction(e) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n}\nconst i_ = (i) => i.replace(/^SN_/, \"SN\"), s_ = (i) => i.replace(/^SN/, \"SN_\");\nclass r_ extends e_ {\n  constructor({ client: t, chainId: s, rpcUrl: r, provider: n }) {\n    super();\n    we(this, \"id\", \"argentMobile\");\n    we(this, \"name\", \"Argent Mobile\");\n    we(this, \"version\", \"0.1.0\");\n    we(this, \"icon\", \"\");\n    we(this, \"provider\");\n    we(this, \"signer\");\n    we(this, \"account\");\n    we(this, \"selectedAddress\", \"\");\n    // NamespaceAdapter\n    we(this, \"namespace\", \"starknet\");\n    we(this, \"methods\", [\n      \"starknet_signTypedData\",\n      \"starknet_requestAddInvokeTransaction\"\n    ]);\n    we(this, \"events\", [\"chainChanged\", \"accountsChanged\"]);\n    we(this, \"remoteSigner\");\n    we(this, \"signerConnection\");\n    we(this, \"rpcProvider\");\n    we(this, \"chainId\");\n    we(this, \"client\");\n    we(this, \"session\");\n    we(this, \"rpc\");\n    we(this, \"walletRpc\");\n    we(this, \"on\", (t, s) => {\n      this.eventEmitter.on(t, s);\n    });\n    we(this, \"off\", (t, s) => {\n      this.eventEmitter.off(t, s);\n    });\n    this.chainId = String(s ?? starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_MAIN), this.rpc = {\n      chains: s ? [this.formatChainId(this.chainId)] : [],\n      methods: this.methods,\n      events: this.events\n    }, this.signerConnection = this.getSignerConnection(t), this.rpcProvider = new _n(this.signerConnection), this.client = t, this.registerEventListeners(), this.walletRpc = new Proxy({}, {\n      get: (o, c) => (u) => this.requestWallet({ method: c, params: u })\n    }), this.remoteSigner = new t_(this.walletRpc), this.provider = n || new starknet__WEBPACK_IMPORTED_MODULE_1__.RpcProvider({ nodeUrl: r }), this.account = new Ha(\n      this.provider,\n      \"\",\n      this.remoteSigner,\n      this.walletRpc\n    );\n  }\n  getNetworkName(t) {\n    if (t === \"SN_SEPOLIA\")\n      return starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_SEPOLIA;\n    if (t === \"SN_MAIN\")\n      return starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_MAIN;\n    throw new Error(`Unknown starknet.js network name for chainId ${t}`);\n  }\n  // StarknetWindowObject\n  async request(t) {\n    throw new Error(\"Not implemented: .request()\");\n  }\n  async enable() {\n    return await this.rpcProvider.connect(), this.accounts;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  get isConnected() {\n    return !0;\n  }\n  async isPreauthorized() {\n    return !!this.client.session.getAll().find(this.isValidSession);\n  }\n  async requestWallet(t) {\n    if (!this.session)\n      throw new Error(\"No session\");\n    try {\n      const { topic: s } = this.session, r = this.formatChainId(this.chainId);\n      kt.showApprovalModal(t);\n      const n = await this.client.request({ topic: s, chainId: r, request: t });\n      return kt.closeModal(\"animateSuccess\"), n;\n    } catch (s) {\n      throw kt.closeModal(), s instanceof Error ? new Error(s.message) : new Error(\"Unknow error on requestWallet\");\n    }\n  }\n  // NamespaceAdapter\n  get isConnecting() {\n    return this.signerConnection.connecting;\n  }\n  async disable() {\n    await this.rpcProvider.disconnect();\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  // NamespaceAdapter private methods\n  registerEventListeners() {\n    super.registerEventListeners(), this.eventEmitter.on(\"chainChanged\", (t) => {\n      throw new Error(\"Not implemented: chainChanged\");\n    });\n  }\n  formatChainId(t) {\n    return `${this.namespace}:${i_(t)}`;\n  }\n  parseChainId(t) {\n    return s_(t.split(\":\")[1]);\n  }\n  setAccounts(t) {\n    this.accounts = t.filter(\n      (n) => this.parseChainId(this.parseAccountId(n).chainId) === this.chainId\n    ).map((n) => this.parseAccountId(n).address);\n    const { address: s } = this.parseAccountId(t[0]), r = s.startsWith(\"0x\") ? s : `0x${s}`;\n    this.account = new Ha(\n      this.provider,\n      r,\n      this.remoteSigner,\n      this.walletRpc\n    ), this.eventEmitter.emit(\"accountsChanged\", this.accounts), this.selectedAddress = r;\n  }\n}\nconst Y_ = async (i) => Pm(i, r_);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9pbmRleC0wMDQ1MWYxYS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDd0U7QUFDSztBQUMvQjtBQUNSO0FBQ3RDLFdBQVcsYUFBYTtBQUN4QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBNEQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNENBQTRDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHFJQUFxSSxPQUFPO0FBQzVJO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxTUFBcU0sVUFBVTtBQUMvTSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0Q7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FB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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJCQUEyQiw2REFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0EsK0RBQStELFNBQVM7QUFDeEUsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQSx3RUFBd0UsTUFBTTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsR0FBRztBQUM5QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWSxFQUFFLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCLElBQUksV0FBVyw2Q0FBNkMsWUFBWTtBQUNuSjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQiw4QkFBOEIsNEJBQTRCO0FBQ3RJO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CLGVBQWUscUJBQXFCLGlCQUFpQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQ0FBMEMsaUNBQWlDLGlDQUFpQztBQUMxSCxVQUFVLHVCQUF1QjtBQUNqQyxjQUFjLHdEQUF3RDtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0EsU0FBUyxrQkFBa0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLG1DQUFtQyxHQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsQ0FBQyxVQUFVLGlEQUFpRCxVQUFVO0FBQ3RFO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsR0FBRyxhQUFhLDRFQUE0RTtBQUM1Rix5QkFBeUIsK0JBQStCO0FBQ3hELGdCQUFnQiw0REFBNEQ7QUFDNUUseUJBQXlCLDRCQUE0QjtBQUNyRCxnQkFBZ0Isa0VBQWtFO0FBQ2xGLHlCQUF5Qiw0QkFBNEI7QUFDckQsZ0JBQWdCLHFEQUFxRDtBQUNyRSx5QkFBeUIsNkJBQTZCO0FBQ3RELGdCQUFnQiwyRUFBMkUsYUFBYSxnRkFBZ0Y7QUFDeEwseUJBQXlCLDhDQUE4QztBQUN2RSxnQkFBZ0IsMkZBQTJGLGFBQWEsZ0dBQWdHLGFBQWEsK0ZBQStGLGFBQWEsb0dBQW9HLGFBQWEsOEZBQThGLGFBQWEsbUdBQW1HLGFBQWEsa0dBQWtHLGFBQWEsdUdBQXVHLGFBQWEsNEZBQTRGO0FBQzU5Qix5QkFBeUIsMEtBQTBLO0FBQ25NLGdCQUFnQiwrRUFBK0UsYUFBYSxvRkFBb0Y7QUFDaE0seUJBQXlCLDhDQUE4QztBQUN2RSxnQkFBZ0Isd0dBQXdHLGFBQWEsMkdBQTJHO0FBQ2hQLHlCQUF5QixrREFBa0Q7QUFDM0UsZ0JBQWdCLDJIQUEySCxhQUFhLCtIQUErSCxhQUFhLDhIQUE4SCxhQUFhLGtJQUFrSTtBQUNqakIseUJBQXlCLDZFQUE2RTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBNEQ7QUFDNUUseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFNBQVMsNENBQTRDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLG1EQUFtRCxhQUFhLG1EQUFtRDtBQUM5TSx5QkFBeUIseUNBQXlDO0FBQ2xFLDBFQUEwRTtBQUMxRSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0EsYUFBYTtBQUNiLEdBQUcsY0FBYztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCLCtCQUErQixhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxDQUFDLFVBQVU7QUFDWDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRTtBQUMvQyx1S0FBdUssU0FBUyxFQUFFLEVBQUU7QUFDcEw7QUFDQSw4Q0FBOEMsR0FBRyxLQUFLLEdBQUcsV0FBVywyQkFBMkIsU0FBUyxzQkFBc0Isd1JBQXdSLGtSQUFrUiwrQkFBK0Isa0ZBQWtGLGlHQUFpRyw0TUFBNE0saUdBQWlHLG9CQUFvQixPQUFPLHNDQUFzQyxTQUFTLHlDQUF5QyxvQkFBb0IsT0FBTyw4Q0FBOEMsU0FBUyxnREFBZ0QseUJBQXlCLE9BQU8sb0NBQW9DLFNBQVMsd0NBQXdDLFNBQVMsb0dBQW9HLFNBQVMsMEdBQTBHLHFEQUFxRCwwR0FBMEc7QUFDaDVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLDBCQUEwQixVQUFVLElBQUksRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4QkFBOEI7QUFDbkUsa0JBQWtCLG9EQUFvRDtBQUN0RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUJBQXVCO0FBQ3JFO0FBQ0EsUUFBUTtBQUNSLG1FQUFtRSxFQUFFLGdCQUFnQix5QkFBeUI7QUFDOUc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csVUFBVSx3QkFBd0IsNkRBQTZEO0FBQ3ZNLFVBQVU7QUFDViw2REFBNkQsVUFBVTtBQUN2RSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsNkNBQTZDLGlDQUFpQztBQUNqSjtBQUNBLHFIQUFxSCw4QkFBOEIsOENBQThDO0FBQ2pNO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxpRkFBaUYsNkNBQTZDLGlDQUFpQztBQUMvSixRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQTBDLGlEQUFpRDtBQUMzRyxvUUFBb1Esb0RBQW9EO0FBQ3hUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ1FBQWdRLDBEQUEwRDtBQUMxVCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3SEFBd0gsK0NBQStDLHFCQUFxQjtBQUM1TDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsK0dBQStHLCtDQUErQyxxQkFBcUI7QUFDbkwsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxpREFBaUQsNEJBQTRCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVLElBQUksRUFBRTtBQUMzRCxtSEFBbUgsaURBQWlELDRCQUE0QjtBQUNoTSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQTRDO0FBQzVELHFFQUFxRSxvREFBb0Q7QUFDekg7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpREFBaUQ7QUFDakYscUVBQXFFLG9EQUFvRDtBQUN6SDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUE4QztBQUM5RCw0RUFBNEUsb0RBQW9EO0FBQ2hJO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUSxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxtRUFBbUU7QUFDcEs7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsbUVBQW1FLGtEQUFrRDtBQUNySDtBQUNBO0FBQ0EsY0FBYyxhQUFhLDBCQUEwQixVQUFVLElBQUksRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGdFQUFnRTtBQUNwSTtBQUNBLHlHQUF5RyxRQUFRLFdBQVc7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3Qix5REFBeUQsVUFBVSxJQUFJLDRCQUE0QjtBQUNuRztBQUNBLG9GQUFvRixVQUFVLHdCQUF3QiwrREFBK0Q7QUFDckwsTUFBTTtBQUNOLCtEQUErRCxVQUFVO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXLE9BQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsRUFBRSx3QkFBd0Isa0NBQWtDO0FBQy9GLEtBQUs7QUFDTDtBQUNBLG1DQUFtQyxFQUFFLHdCQUF3QixrQ0FBa0M7QUFDL0YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJMQUEyTCwwREFBMEQ7QUFDclAsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyw4S0FBOEssdUJBQXVCO0FBQzFNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUNBQXlDLGVBQWUsb0RBQW9ELEdBQUc7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsK0NBQStDO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLCtGQUErRixjQUFjO0FBQzdHLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtKQUFrSjtBQUN6TDtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQSxrRUFBa0UsRUFBRTtBQUNwRTtBQUNBLDRFQUE0RSxFQUFFO0FBQzlFO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBLHlFQUF5RSxvREFBb0Q7QUFDN0g7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUMsZ0JBQWdCO0FBQ25GLDRFQUE0RSw0QkFBNEI7QUFDeEcsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyTEFBMkwsMERBQTBEO0FBQ3JQLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxpSUFBaUksaURBQWlEO0FBQ2xMLEtBQUssbUdBQW1HLHVDQUF1QztBQUMvSSxxRkFBcUYscURBQXFEO0FBQzFJLHdCQUF3QjtBQUN4QjtBQUNBLEtBQUs7QUFDTCx5R0FBeUcscURBQXFEO0FBQzlKLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSwwQkFBMEIsVUFBVSxJQUFJLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsNEVBQTRFLFVBQVUsd0JBQXdCLHVEQUF1RDtBQUNySyxNQUFNO0FBQ04sdURBQXVELFVBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCLFlBQVk7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2RkFBNkYsY0FBYyxRQUFRLDJDQUEyQyxXQUFXLHlGQUF5RjtBQUNsUSxpSEFBaUg7QUFDakgsS0FBSztBQUNMO0FBQ0EsY0FBYyxnQ0FBZ0M7QUFDOUM7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JELDBIQUEwSCxVQUFVO0FBQ3BJLDBDQUEwQztBQUMxQyxvSEFBb0gsVUFBVTtBQUM5SCxLQUFLLDJCQUEyQixVQUFVO0FBQzFDO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdELEtBQUs7QUFDTDtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLGdFQUFnRSxLQUFLLGlDQUFpQztBQUN0RyxtREFBbUQsVUFBVTtBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUssK0JBQStCLHFCQUFxQjtBQUN6RCw0REFBNEQsV0FBVztBQUN2RSxLQUFLLGlDQUFpQyx1QkFBdUI7QUFDN0QsNERBQTRELGlCQUFpQjtBQUM3RSxLQUFLO0FBQ0w7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLFFBQVE7QUFDdEI7QUFDQSwyQkFBMkIsVUFBVSxnRUFBZ0UsaUJBQWlCO0FBQ3RILFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsUUFBUTtBQUN0QjtBQUNBLDBEQUEwRCx1REFBdUQsZ0JBQWdCO0FBQ2pJLE9BQU87QUFDUCxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsaUNBQWlDLFVBQVUsOERBQThELGlCQUFpQjtBQUMxSCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsYUFBYSw0Q0FBNEMsRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSx5Q0FBeUMsTUFBTTtBQUM1RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGFBQWEsNENBQTRDLEVBQUU7QUFDM0U7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixhQUFhLGtEQUFrRCxFQUFFO0FBQ2pGO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsYUFBYSwrREFBK0QsRUFBRTtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSx1REFBdUQsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLGlDQUFpQyxFQUFFO0FBQ2hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxzQkFBc0IscUZBQXFGLHNCQUFzQjtBQUMxTSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsNkdBQTZHLFVBQVU7QUFDdkgsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrSEFBa0gsaUVBQWlFO0FBQ25MO0FBQ0Esa0JBQWtCLCtCQUErQiw0Q0FBNEM7QUFDN0Y7QUFDQSxLQUFLO0FBQ0wsb0hBQW9ILCtDQUErQztBQUNuSztBQUNBO0FBQ0EseURBQXlELGlCQUFpQixJQUFJLGtCQUFrQjtBQUNoRyxLQUFLLDZHQUE2RyxnREFBZ0Q7QUFDbEssc0ZBQXNGLHlDQUF5QztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSwwQkFBMEIsVUFBVSxJQUFJLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsOEVBQThFLFVBQVUsd0JBQXdCLHlEQUF5RDtBQUN6SyxNQUFNO0FBQ04seURBQXlELFVBQVU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxFQUFFLHdCQUF3QixvQ0FBb0M7QUFDakcsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLEVBQUUsd0JBQXdCLG9DQUFvQztBQUNqRyxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsRUFBRSx3QkFBd0Isb0NBQW9DO0FBQ2pHLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyxLQUFLO0FBQ3BILE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNENBQTRDO0FBQzVDLHlGQUF5RiwwQkFBMEI7QUFDbkgsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUVBQW1FLDBCQUEwQjtBQUM3RjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWEsb0NBQW9DLFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxrRkFBa0YsVUFBVSx3QkFBd0IsNkRBQTZEO0FBQ2pMLE1BQU07QUFDTiw2REFBNkQsVUFBVTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLDBCQUEwQixVQUFVLElBQUksRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwwQkFBMEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRSx3QkFBd0Isa0NBQWtDO0FBQy9GLEtBQUs7QUFDTDtBQUNBLG1DQUFtQyxFQUFFLHdCQUF3QixrQ0FBa0M7QUFDL0YsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLEVBQUUsd0JBQXdCLGtDQUFrQztBQUMvRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBEQUEwRCxlQUFlO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNERBQTRELGVBQWU7QUFDM0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMkRBQTJELGlCQUFpQixZQUFZLEVBQUU7QUFDMUY7QUFDQTtBQUNBLEtBQUs7QUFDTCxpREFBaUQsR0FBRyxZQUFZLEVBQUU7QUFDbEUsMkVBQTJFLEVBQUUsZUFBZSxFQUFFLEtBQUsscUNBQXFDO0FBQ3hJO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILEdBQUcsRUFBRSxlQUFlO0FBQ3BJLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZSxHQUFHLGVBQWU7QUFDL0QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUssaUpBQWlKLE9BQU87QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJMQUEyTCwwREFBMEQ7QUFDclAsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCwrQkFBK0I7QUFDdEosMFNBQTBTLG9EQUFvRCxxRkFBcUY7QUFDbmI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxRUFBcUUsV0FBVztBQUNoRjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFdBQVcsc0ZBQXNGLDJJQUEySSxxQkFBcUIsT0FBTyw0Q0FBNEMsU0FBUyw4Q0FBOEMsc0JBQXNCLE9BQU8sNENBQTRDLFNBQVMsOENBQThDLHNCQUFzQixPQUFPLHVDQUF1QyxTQUFTLHlDQUF5QyxzQkFBc0IsT0FBTyx1Q0FBdUMsU0FBUyx5Q0FBeUMsdUJBQXVCLE9BQU8sNENBQTRDLFNBQVMsOENBQThDLHFCQUFxQixPQUFPLDRDQUE0QyxTQUFTLDhDQUE4QyxzQkFBc0IsT0FBTyx1Q0FBdUMsU0FBUyx5Q0FBeUMsb0JBQW9CLE9BQU8sOENBQThDLFNBQVMsa0RBQWtELFNBQVMsd0NBQXdDLFNBQVMsZ0NBQWdDO0FBQ24zQyxnUUFBZ1EsMERBQTBEO0FBQzFULDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxvSUFBb0ksMkJBQTJCLCtCQUErQiwyQkFBMkI7QUFDek4sK0tBQStLLDBCQUEwQjtBQUN6TTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSx3QkFBd0IsUUFBUSw4Q0FBOEMsa0RBQWtEO0FBQ2hJO0FBQ0EsY0FBYyxpR0FBaUc7QUFDL0c7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBLDBFQUEwRSw4REFBOEQsY0FBYyxlQUFlLGdEQUFnRCxTQUFTLHNCQUFzQixLQUFLLGlDQUFpQztBQUMxUiwyREFBMkQsc0JBQXNCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsb0ZBQW9GO0FBQ3hILG1KQUFtSixxQ0FBcUM7QUFDeEw7QUFDQSxPQUFPO0FBQ1AsZ0JBQWdCLGFBQWEsbURBQW1ELEVBQUU7QUFDbEY7QUFDQTtBQUNBLHlDQUF5QyxrREFBa0Q7QUFDM0YsNENBQTRDLGtCQUFrQixTQUFTO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBLGNBQWMsK0RBQStEO0FBQzdFLFlBQVksNkVBQTZFO0FBQ3pGO0FBQ0E7QUFDQSxpRUFBaUUsZ0NBQWdDLDJCQUEyQiwyQkFBMkIsU0FBUyxzQkFBc0IsMkJBQTJCLDRHQUE0RyxVQUFVO0FBQ3ZVLHFCQUFxQixTQUFTLHNCQUFzQiw4RkFBOEYsOENBQThDLGtCQUFrQixTQUFTLHNCQUFzQjtBQUNqUCw0RUFBNEUsMkVBQTJFO0FBQ3ZKLHdCQUF3QixRQUFRLHlFQUF5RSw4Q0FBOEMsaUJBQWlCO0FBQ3hLLHFGQUFxRjtBQUNyRixLQUFLO0FBQ0w7QUFDQSxjQUFjLG1CQUFtQixPQUFPLGtCQUFrQjtBQUMxRDtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsMEJBQTBCLGtDQUFrQyxnREFBZ0QsaUJBQWlCLEtBQUssaUNBQWlDO0FBQ2pMLDBEQUEwRCxVQUFVO0FBQ3BFO0FBQ0EsT0FBTyx5Q0FBeUMsZUFBZSxLQUFLO0FBQ3BFLEtBQUs7QUFDTDtBQUNBLGNBQWMsV0FBVyxrQ0FBa0Msa0RBQWtELEtBQUssaUNBQWlDO0FBQ25KLDBEQUEwRCxVQUFVO0FBQ3BFO0FBQ0EsT0FBTyxzQ0FBc0M7QUFDN0MsS0FBSztBQUNMO0FBQ0EsY0FBYyw4Q0FBOEMsaUJBQWlCLGlDQUFpQztBQUM5RywyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0EsT0FBTztBQUNQLGlDQUFpQyxpRUFBaUUsd0JBQXdCLHVDQUF1Qyx3RUFBd0UseUNBQXlDO0FBQ2xSLE9BQU87QUFDUDtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxjQUFjLHdCQUF3QixPQUFPLFFBQVE7QUFDckQsc0NBQXNDLDZEQUE2RDtBQUNuRyxLQUFLO0FBQ0w7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSwyQ0FBMkMsZ0RBQWdELEtBQUssaUNBQWlDO0FBQ2pJLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUixvR0FBb0csVUFBVTtBQUM5RyxLQUFLO0FBQ0w7QUFDQSxjQUFjLGlDQUFpQztBQUMvQywrQkFBK0IsK0NBQStDLHdCQUF3QjtBQUN0RyxLQUFLO0FBQ0w7QUFDQSxjQUFjLFdBQVc7QUFDekIsdUVBQXVFLGlHQUFpRyw4RUFBOEUsVUFBVTtBQUNoUSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsaURBQWlELFVBQVUsNkZBQTZGLGdCQUFnQjtBQUN4SyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLFVBQVU7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsb0ZBQW9GLFdBQVc7QUFDL0YsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLGdEQUFnRCwrQ0FBK0M7QUFDL0YsZ0RBQWdELDhDQUE4QztBQUM5RixLQUFLO0FBQ0wsY0FBYyxvR0FBb0c7QUFDbEg7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBLDhHQUE4RyxpQkFBaUIsMEJBQTBCO0FBQ3pKLEtBQUs7QUFDTCxjQUFjLHNEQUFzRDtBQUNwRSxnQ0FBZ0MsaUJBQWlCLDBCQUEwQjtBQUMzRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdDQUFnQyxZQUFZLG9DQUFvQztBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxFQUFFO0FBQ3pFO0FBQ0EsS0FBSztBQUNMLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBLEtBQUs7QUFDTCxjQUFjLFdBQVcsT0FBTyxhQUFhLHNEQUFzRCxHQUFHO0FBQ3RHO0FBQ0EsS0FBSztBQUNMLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0EsaUNBQWlDO0FBQ2pDLCtDQUErQyxtQ0FBbUM7QUFDbEY7QUFDQTtBQUNBLHNEQUFzRCxvQ0FBb0M7QUFDMUYsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUIsbUNBQW1DLCtEQUErRDtBQUNsRztBQUNBLG1DQUFtQyxpRUFBaUU7QUFDcEc7QUFDQSxtQ0FBbUMsc0VBQXNFO0FBQ3pHO0FBQ0EsbUNBQW1DLHNFQUFzRTtBQUN6RztBQUNBLG1DQUFtQyxxRUFBcUU7QUFDeEc7QUFDQSxtQ0FBbUMsdUVBQXVFLDZDQUE2QyxVQUFVO0FBQ2pLLFFBQVE7QUFDUiwySEFBMkgsZ0JBQWdCO0FBQzNJLEtBQUs7QUFDTCxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0EsZ0JBQWdCLHlJQUF5SSxxQkFBcUIsZ0tBQWdLLCtDQUErQyxVQUFVLGdEQUFnRCxTQUFTLHNCQUFzQjtBQUN0ZCxnQ0FBZ0MsZ0NBQWdDLDZDQUE2QyxZQUFZO0FBQ3pILFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsUUFBUTtBQUN0QixxREFBcUQsa0JBQWtCLGdEQUFnRCwwSEFBMEgsZ0JBQWdCO0FBQ2pRLEtBQUs7QUFDTCxjQUFjLG1CQUFtQjtBQUNqQztBQUNBLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0Esc0VBQXNFLEVBQUU7QUFDeEU7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLDZDQUE2QywwQkFBMEIsMkJBQTJCLDZCQUE2QiwrQ0FBK0MsNEJBQTRCO0FBQ3BQLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsUUFBUTtBQUN0QiwwREFBMEQseURBQXlELGdCQUFnQjtBQUNuSSxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsNkJBQTZCLFVBQVUsNERBQTRELDZCQUE2QiwrQ0FBK0MsaUJBQWlCO0FBQ2hNLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsUUFBUTtBQUN0QiwwREFBMEQseURBQXlELGdCQUFnQjtBQUNuSSxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsMkJBQTJCLFVBQVUsMkJBQTJCLDZCQUE2Qiw2Q0FBNkMsaUJBQWlCO0FBQzNKLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsUUFBUTtBQUN0QjtBQUNBLDBEQUEwRCx1REFBdUQsZ0JBQWdCO0FBQ2pJLE9BQU87QUFDUCxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsaUNBQWlDLDRCQUE0QjtBQUM3RDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVMscUJBQXFCLDZCQUE2QixpREFBaUQsaUJBQWlCO0FBQzdILFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0MsZ0tBQWdLO0FBQ2hLO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCLDJEQUEyRCxrQkFBa0IsMERBQTBELGdCQUFnQjtBQUN2SixLQUFLO0FBQ0wsY0FBYyxtQkFBbUI7QUFDakM7QUFDQSxxQkFBcUIsRUFBRSxpQkFBaUIsYUFBYTtBQUNyRDtBQUNBLHNFQUFzRSxFQUFFO0FBQ3hFO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxrREFBa0QsNEJBQTRCO0FBQ3RILFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLHdEQUF3RCwrQkFBK0I7QUFDdkY7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsNEhBQTRIO0FBQ3ZNLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixhQUFhLCtDQUErQyxrQkFBa0I7QUFDOUY7QUFDQTtBQUNBLGNBQWMsaUdBQWlHO0FBQy9HO0FBQ0EsZ0JBQWdCLGFBQWEsK0NBQStDLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFLGNBQWMsK0RBQStEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxzREFBc0QsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsYUFBYSw4Q0FBOEMsRUFBRTtBQUM3RTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQSxnQkFBZ0IsYUFBYSw4Q0FBOEMsa0JBQWtCO0FBQzdGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsYUFBYSw4REFBOEQsRUFBRTtBQUM3RjtBQUNBO0FBQ0EsY0FBYyxvREFBb0Q7QUFDbEU7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGFBQWEsOENBQThDLEVBQUU7QUFDN0U7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGFBQWEsOENBQThDLEVBQUU7QUFDN0U7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixhQUFhLCtDQUErQyxFQUFFO0FBQzlFO0FBQ0E7QUFDQSxjQUFjLDhDQUE4QztBQUM1RDtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0EsZ0JBQWdCLGFBQWEsZ0RBQWdELEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsdUNBQXVDLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSwrQ0FBK0MsU0FBUztBQUNyRjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSwrQ0FBK0MsRUFBRSxpREFBaUQsUUFBUSxNQUFNLE9BQU87QUFDcEo7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixhQUFhLCtDQUErQyxFQUFFO0FBQzlFO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBLGdCQUFnQixhQUFhLGlEQUFpRCxrQkFBa0I7QUFDaEc7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixhQUFhLDRDQUE0QyxFQUFFO0FBQzNFO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsYUFBYSw0Q0FBNEMsRUFBRTtBQUMzRTtBQUNBO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0M7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBLGdCQUFnQixhQUFhLDZDQUE2QyxFQUFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLDJDQUEyQyxrQkFBa0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsMkNBQTJDLGtCQUFrQjtBQUMxRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGFBQWEsa0RBQWtELEVBQUU7QUFDakY7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBLDBEQUEwRCwwQ0FBMEM7QUFDcEc7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUUsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSw2QkFBNkIsR0FBRyxzREFBc0Qsa0JBQWtCO0FBQ3ZJO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysc0JBQXNCLDJGQUEyRixzQkFBc0IsaUZBQWlGLHNCQUFzQjtBQUM5VCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0EsZ0lBQWdJLFVBQVUsMEZBQTBGLE9BQU87QUFDM08sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSwrREFBK0QsRUFBRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsdURBQXVELEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLGlDQUFpQyxFQUFFO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsK0RBQStELEVBQUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLHVEQUF1RCxFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLGlDQUFpQyxFQUFFO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSxrRUFBa0UsRUFBRTtBQUMvRjtBQUNBLE1BQU07QUFDTixjQUFjLGFBQWEsMEVBQTBFLEVBQUU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSw2REFBNkQsRUFBRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEscURBQXFELEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsK0JBQStCLEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUhBQXVILCtCQUErQjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwS0FBMEssb0NBQW9DO0FBQzlNLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnRUFBZ0UsV0FBVyxhQUFhLGdCQUFnQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZSxNQUFNLEVBQUU7QUFDekMsY0FBYyxlQUFlLGFBQWEsRUFBRSxRQUFRLEVBQUU7QUFDdEQsa0JBQWtCLGVBQWUsYUFBYSxFQUFFLFFBQVEsRUFBRTtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakMsY0FBYyxlQUFlLHNCQUFzQixFQUFFO0FBQ3JELGtCQUFrQixlQUFlLHNCQUFzQixFQUFFO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQ0FBb0MsK0NBQStDO0FBQ3RGO0FBQ0EsR0FBRyw2QkFBNkIscUJBQXFCO0FBQ3JELFlBQVksZ0JBQWdCO0FBQzVCLHNCQUFzQixxQkFBcUI7QUFDM0MsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixJQUFJLHFEQUFFO0FBQ04sWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0Esd0JBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0Esd0JBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkMsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQStDO0FBQzdEO0FBQ0E7QUFDQSx5REFBeUQsbUJBQW1CO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpSkFBaUo7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkxBQTJMLDBEQUEwRDtBQUNyUCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1GQUFtRjtBQUNwSDtBQUNBLGdCQUFnQixPQUFPLGlCQUFpQixPQUFPLDBCQUEwQixPQUFPO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdHQUFnRztBQUM5RyxpREFBaUQsNERBQTREO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCLElBQUk7QUFDSjtBQUNBO0FBQ0EsaUJBQWlCLEVBQUU7QUFDbkI7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsRUFBRSxHQUFHLEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUU7QUFDdkQ7QUFDQTtBQUNBLDJMQUEyTCwwREFBMEQ7QUFDclAsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSxXQUFXLEdBQUcsUUFBUSxHQUFHLFVBQVUsdUJBQXVCLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFLEdBQUcsRUFBRTtBQUNyQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVFQUF1RSxnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDdkg7QUFDQTtBQUNBLGFBQWEsa0JBQWtCLHdDQUF3QyxtQkFBbUIsdUNBQXVDLDRCQUE0QixnREFBZ0QsNEJBQTRCLGdEQUFnRCxvQ0FBb0Msd0RBQXdELHlCQUF5Qiw2Q0FBNkMsd0JBQXdCLDRDQUE0QyxpQ0FBaUMscURBQXFELGlDQUFpQyxxREFBcUQsbUJBQW1CLHNDQUFzQywwQkFBMEIsOENBQThDLDJCQUEyQiwrQ0FBK0MsMEJBQTBCLDhDQUE4Qyx3QkFBd0IsNENBQTRDLHlCQUF5Qiw2Q0FBNkMsd0JBQXdCLDRDQUE0QywwQkFBMEIsOENBQThDLCtCQUErQixtREFBbUQsdUJBQXVCLDBDQUEwQywrQkFBK0Isa0RBQWtELDJCQUEyQixtREFBbUQsU0FBUyxtQkFBbUIsc0NBQXNDLHFCQUFxQixzQ0FBc0MsMkJBQTJCLDRDQUE0QyxrQkFBa0IsbUNBQW1DLHdCQUF3Qix5Q0FBeUMsYUFBYSw4QkFBOEIsa0JBQWtCLG1DQUFtQyxzQkFBc0IsdUNBQXVDLCtCQUErQjtBQUM1L0Q7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQyxXQUFXLGdCQUFnQixHQUFHLEVBQUUsRUFBRTtBQUNsQztBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEMsV0FBVyxnQkFBZ0IsR0FBRyxFQUFFLEVBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUUsVUFBVSxHQUFHO0FBQ3ZGLEdBQUcsb0NBQW9DLEVBQUUsV0FBVyxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUUsWUFBWSxHQUFHO0FBQ3RFLEdBQUcsc0NBQXNDLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLEVBQUUsMEdBQTBHLEVBQUU7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUU7QUFDekI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQ0FBbUMsRUFBRSxJQUFJLEdBQUc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxHQUFHO0FBQy9ELGtCQUFrQjtBQUNsQixrQkFBa0IsMEJBQTBCLHdEQUF3RCxHQUFHO0FBQ3ZHLGtCQUFrQjtBQUNsQixrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsR0FBRywyREFBMkQ7QUFDMUgsb0JBQW9CO0FBQ3BCLG9CQUFvQixhQUFhO0FBQ2pDLEdBQUc7QUFDSCxrSEFBa0gsR0FBRyx1REFBdUQsRUFBRSw0Q0FBNEMsR0FBRyx5REFBeUQsRUFBRTtBQUN4UixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQW9ELEVBQUU7QUFDckUsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQSwrREFBK0QsU0FBUztBQUN4RSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQ0FBZ0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixHQUFHO0FBQzlCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZLEVBQUUsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0IsSUFBSSxXQUFXLDZDQUE2QyxZQUFZO0FBQ25KO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCLDhCQUE4Qiw0QkFBNEI7QUFDdEk7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUIsZUFBZSxxQkFBcUIsaUJBQWlCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQyxpQ0FBaUMsaUNBQWlDO0FBQzFILFVBQVUsdUJBQXVCO0FBQ2pDLGNBQWMsd0RBQXdEO0FBQ3RFLENBQUM7QUFDRDtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTLGtCQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsbUNBQW1DLEdBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEMsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxDQUFDLFVBQVUsaURBQWlELFVBQVU7QUFDdEU7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxHQUFHLGFBQWEsNEVBQTRFO0FBQzVGLHlCQUF5QiwrQkFBK0I7QUFDeEQsZ0JBQWdCLDREQUE0RDtBQUM1RSx5QkFBeUIsNEJBQTRCO0FBQ3JELGdCQUFnQixrRUFBa0U7QUFDbEYseUJBQXlCLDRCQUE0QjtBQUNyRCxnQkFBZ0IscURBQXFEO0FBQ3JFLHlCQUF5Qiw2QkFBNkI7QUFDdEQsZ0JBQWdCLDJFQUEyRSxhQUFhLGdGQUFnRjtBQUN4TCx5QkFBeUIsOENBQThDO0FBQ3ZFLGdCQUFnQiwyRkFBMkYsYUFBYSxnR0FBZ0csYUFBYSwrRkFBK0YsYUFBYSxvR0FBb0csYUFBYSw4RkFBOEYsYUFBYSxtR0FBbUcsYUFBYSxrR0FBa0csYUFBYSx1R0FBdUcsYUFBYSw0RkFBNEY7QUFDNTlCLHlCQUF5QiwwS0FBMEs7QUFDbk0sZ0JBQWdCLCtFQUErRSxhQUFhLG9GQUFvRjtBQUNoTSx5QkFBeUIsOENBQThDO0FBQ3ZFLGdCQUFnQix3R0FBd0csYUFBYSwyR0FBMkc7QUFDaFAseUJBQXlCLGtEQUFrRDtBQUMzRSxnQkFBZ0IsMkhBQTJILGFBQWEsK0hBQStILGFBQWEsOEhBQThILGFBQWEsa0lBQWtJO0FBQ2pqQix5QkFBeUIsNkVBQTZFO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxFQUFFO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUE0RDtBQUM1RSx5QkFBeUIsbUNBQW1DO0FBQzVEO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsU0FBUyw0Q0FBNEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsbURBQW1ELGFBQWEsbURBQW1EO0FBQzlNLHlCQUF5Qix5Q0FBeUM7QUFDbEUsMEVBQTBFO0FBQzFFLHlCQUF5QiwrQkFBK0I7QUFDeEQ7QUFDQSxhQUFhO0FBQ2IsR0FBRyxjQUFjO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0IsK0JBQStCLGFBQWE7QUFDdEY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBLENBQUMsVUFBVTtBQUNYO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxFQUFFO0FBQy9DLHVLQUF1SyxTQUFTLEVBQUUsRUFBRTtBQUNwTDtBQUNBLDhDQUE4QyxHQUFHLEtBQUssR0FBRyxXQUFXLDJCQUEyQixTQUFTLHNCQUFzQixrUEFBa1Asa1JBQWtSLCtCQUErQixrRkFBa0YsZ0VBQWdFLDRNQUE0TSxpR0FBaUcsb0JBQW9CLE9BQU8sc0NBQXNDLFNBQVMseUNBQXlDLG9CQUFvQixPQUFPLDhDQUE4QyxTQUFTLGdEQUFnRCx5QkFBeUIsT0FBTyxvQ0FBb0MsU0FBUyx3Q0FBd0MsU0FBUywwR0FBMEcscURBQXFELDBHQUEwRztBQUM1dEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsMEJBQTBCLFVBQVUsSUFBSSxFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDhCQUE4QjtBQUNuRSxrQkFBa0Isb0RBQW9EO0FBQ3RFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUJBQXVCO0FBQ25FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLFVBQVUsd0JBQXdCLDZEQUE2RDtBQUN2TSxVQUFVO0FBQ1YsNkRBQTZELFVBQVU7QUFDdkUsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw2Q0FBNkMsaUNBQWlDO0FBQ2pKO0FBQ0EscUhBQXFILDhCQUE4QjtBQUNuSjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDZDQUE2QyxpQ0FBaUM7QUFDL0osUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUEwQyxpREFBaUQ7QUFDM0csb1FBQW9RLG9EQUFvRDtBQUN4VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdDQUFnQztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnUUFBZ1EsMERBQTBEO0FBQzFULDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdIQUF3SCwrQ0FBK0MscUJBQXFCO0FBQzVMO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSwrR0FBK0csK0NBQStDLHFCQUFxQjtBQUNuTCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGlEQUFpRCw0QkFBNEI7QUFDL0k7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVUsSUFBSSxFQUFFO0FBQzNELG1IQUFtSCxpREFBaUQsNEJBQTRCO0FBQ2hNLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBNEM7QUFDNUQscUVBQXFFLG9EQUFvRDtBQUN6SDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlEQUFpRDtBQUNqRixxRUFBcUUsb0RBQW9EO0FBQ3pIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQThDO0FBQzlELDRFQUE0RSxvREFBb0Q7QUFDaEk7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLG1FQUFtRTtBQUNwSztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxtRUFBbUUsa0RBQWtEO0FBQ3JIO0FBQ0E7QUFDQSxjQUFjLGFBQWEsMEJBQTBCLFVBQVUsSUFBSSxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZ0VBQWdFO0FBQ3BJO0FBQ0EseUdBQXlHLFFBQVEsV0FBVztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCLHlEQUF5RCxVQUFVLElBQUksNEJBQTRCO0FBQ25HO0FBQ0Esb0ZBQW9GLFVBQVUsd0JBQXdCLCtEQUErRDtBQUNyTCxNQUFNO0FBQ04sK0RBQStELFVBQVU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFdBQVcsT0FBTztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLG1DQUFtQyxFQUFFLHdCQUF3QixrQ0FBa0M7QUFDL0YsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLEVBQUUsd0JBQXdCLGtDQUFrQztBQUMvRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkxBQTJMLDBEQUEwRDtBQUNyUCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLLDhLQUE4Syx1QkFBdUI7QUFDMU07QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRywrQ0FBK0M7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrSkFBa0o7QUFDekw7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxvREFBb0Q7QUFDN0g7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUMsZ0JBQWdCO0FBQ25GLDRFQUE0RSw0QkFBNEI7QUFDeEcsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJMQUEyTCwwREFBMEQ7QUFDclAsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLGlJQUFpSSxpREFBaUQ7QUFDbEwsS0FBSyxtR0FBbUcsdUNBQXVDO0FBQy9JLHFGQUFxRixxREFBcUQ7QUFDMUksd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSztBQUNMLHlHQUF5RyxxREFBcUQ7QUFDOUosS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLDBCQUEwQixVQUFVLElBQUksRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSw0RUFBNEUsVUFBVSx3QkFBd0IsdURBQXVEO0FBQ3JLLE1BQU07QUFDTix1REFBdUQsVUFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxQkFBcUIsWUFBWTtBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBLDZGQUE2RixjQUFjLFFBQVEsMkNBQTJDLFdBQVcseUZBQXlGO0FBQ2xRLGlIQUFpSDtBQUNqSCxLQUFLO0FBQ0w7QUFDQSxjQUFjLGdDQUFnQztBQUM5QztBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQsMENBQTBDO0FBQzFDLDJIQUEySCxVQUFVLDJFQUEyRSxVQUFVO0FBQzFOLEtBQUssMkJBQTJCLFVBQVU7QUFDMUM7QUFDQTtBQUNBLHNDQUFzQyx1QkFBdUI7QUFDN0QsS0FBSztBQUNMO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsZ0VBQWdFLEtBQUssaUNBQWlDO0FBQ3RHLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSywrQkFBK0IscUJBQXFCO0FBQ3pELDREQUE0RCxXQUFXO0FBQ3ZFLEtBQUssaUNBQWlDLHVCQUF1QjtBQUM3RCw0REFBNEQsaUJBQWlCO0FBQzdFLEtBQUs7QUFDTDtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLFFBQVE7QUFDdEI7QUFDQSwyQkFBMkIsVUFBVSx1RUFBdUUsaUJBQWlCO0FBQzdILFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsUUFBUTtBQUN0QjtBQUNBLDBEQUEwRCx1REFBdUQsZ0JBQWdCO0FBQ2pJLE9BQU87QUFDUCxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsaUNBQWlDLFVBQVUscUVBQXFFLGlCQUFpQjtBQUNqSSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsYUFBYSw0Q0FBNEMsRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSx5Q0FBeUMsTUFBTTtBQUM1RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGFBQWEsNENBQTRDLEVBQUU7QUFDM0U7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixhQUFhLGtEQUFrRCxFQUFFO0FBQ2pGO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsYUFBYSwrREFBK0QsRUFBRTtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSx1REFBdUQsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLGlDQUFpQyxFQUFFO0FBQ2hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsc0JBQXNCLCtFQUErRSxzQkFBc0I7QUFDbE0sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixvSEFBb0gsVUFBVTtBQUM5SCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtIQUFrSCxpRUFBaUU7QUFDbkw7QUFDQSxrQkFBa0IsK0JBQStCLDRDQUE0QztBQUM3RjtBQUNBLEtBQUs7QUFDTCxvSEFBb0gsK0NBQStDO0FBQ25LO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCLElBQUksa0JBQWtCO0FBQ2hHLEtBQUssNkdBQTZHLGdEQUFnRDtBQUNsSyxzRkFBc0YseUNBQXlDO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLDBCQUEwQixVQUFVLElBQUksRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSw4RUFBOEUsVUFBVSx3QkFBd0IseURBQXlEO0FBQ3pLLE1BQU07QUFDTix5REFBeUQsVUFBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUUsd0JBQXdCLG9DQUFvQztBQUNqRyxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsRUFBRSx3QkFBd0Isb0NBQW9DO0FBQ2pHLEtBQUs7QUFDTDtBQUNBLG1DQUFtQyxFQUFFLHdCQUF3QixvQ0FBb0M7QUFDakcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNENBQTRDO0FBQzVDLHlGQUF5RiwwQkFBMEI7QUFDbkgsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUVBQW1FLDBCQUEwQjtBQUM3RjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWEsb0NBQW9DLFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxrRkFBa0YsVUFBVSx3QkFBd0IsNkRBQTZEO0FBQ2pMLE1BQU07QUFDTiw2REFBNkQsVUFBVTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLDBCQUEwQixVQUFVLElBQUksRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwwQkFBMEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRSx3QkFBd0Isa0NBQWtDO0FBQy9GLEtBQUs7QUFDTDtBQUNBLG1DQUFtQyxFQUFFLHdCQUF3QixrQ0FBa0M7QUFDL0YsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLEVBQUUsd0JBQXdCLGtDQUFrQztBQUMvRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4TEFBOEwsaUJBQWlCLEVBQUUsZUFBZTtBQUNoTyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRSx5RUFBeUUsZUFBZSxlQUFlLGdCQUFnQixLQUFLLHFDQUFxQztBQUNqSztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGVBQWUsR0FBRyxlQUFlO0FBQzlGO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IsMkRBQTJELGVBQWU7QUFDMUU7QUFDQSxLQUFLLGlKQUFpSixPQUFPO0FBQzdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyTEFBMkwsMERBQTBEO0FBQ3JQLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUgsK0JBQStCO0FBQ3RKLDBTQUEwUyxvREFBb0QscUZBQXFGO0FBQ25iO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxRUFBcUUsV0FBVztBQUNoRjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFdBQVcsc0ZBQXNGLHFHQUFxRyxxQkFBcUIsT0FBTyw0Q0FBNEMsU0FBUyw4Q0FBOEMsc0JBQXNCLE9BQU8sNENBQTRDLFNBQVMsOENBQThDLHNCQUFzQixPQUFPLHVDQUF1QyxTQUFTLHlDQUF5QyxzQkFBc0IsT0FBTyx1Q0FBdUMsU0FBUyx5Q0FBeUMsdUJBQXVCLE9BQU8sNENBQTRDLFNBQVMsOENBQThDLHFCQUFxQixPQUFPLDRDQUE0QyxTQUFTLDhDQUE4QyxzQkFBc0IsT0FBTyx1Q0FBdUMsU0FBUyx5Q0FBeUMsb0JBQW9CLE9BQU8sOENBQThDLFNBQVMsa0RBQWtELFNBQVMsd0NBQXdDO0FBQ3B5QyxnUUFBZ1EsMERBQTBEO0FBQzFULDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlKQUFpSiwwQkFBMEI7QUFDM0ssS0FBSztBQUNMO0FBQ0Esd0JBQXdCLFFBQVEsOENBQThDLGtEQUFrRDtBQUNoSTtBQUNBLGNBQWMsaUdBQWlHO0FBQy9HO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQSwwRUFBMEUsOERBQThELGNBQWMsZUFBZSxnREFBZ0QsU0FBUyxzQkFBc0IsS0FBSyxpQ0FBaUM7QUFDMVIsMkRBQTJELHNCQUFzQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRLG9GQUFvRjtBQUN4SCxtSkFBbUoscUNBQXFDO0FBQ3hMO0FBQ0EsT0FBTztBQUNQLGdCQUFnQixhQUFhLG1EQUFtRCxFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0IsU0FBUztBQUN2RSxLQUFLO0FBQ0w7QUFDQSxjQUFjLCtEQUErRDtBQUM3RSxZQUFZLDZFQUE2RTtBQUN6RjtBQUNBO0FBQ0EsaUVBQWlFLGdDQUFnQyxpQ0FBaUMsU0FBUyxzQkFBc0IseUJBQXlCLDRHQUE0RyxVQUFVO0FBQ2hULHFCQUFxQixTQUFTLHNCQUFzQiw4RkFBOEYsOENBQThDLGtCQUFrQixTQUFTLHNCQUFzQjtBQUNqUDtBQUNBLHdCQUF3QixRQUFRLHlFQUF5RSw4Q0FBOEMsaUJBQWlCO0FBQ3hLLHFGQUFxRjtBQUNyRixLQUFLO0FBQ0w7QUFDQSxjQUFjLG1CQUFtQixPQUFPLGtCQUFrQjtBQUMxRDtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsMEJBQTBCLHlEQUF5RCxlQUFlLEtBQUssaUNBQWlDO0FBQ3RKLDBEQUEwRCxVQUFVO0FBQ3BFO0FBQ0EsT0FBTyx5Q0FBeUMsZUFBZSxLQUFLO0FBQ3BFLEtBQUs7QUFDTDtBQUNBLGNBQWMsV0FBVyx5REFBeUQsS0FBSyxpQ0FBaUM7QUFDeEgsMERBQTBELFVBQVU7QUFDcEU7QUFDQSxPQUFPLHNDQUFzQztBQUM3QyxLQUFLO0FBQ0w7QUFDQSxjQUFjLDhDQUE4QywwREFBMEQsd0JBQXdCLFFBQVEsaUNBQWlDO0FBQ3ZMLDJEQUEyRCxxQkFBcUI7QUFDaEY7QUFDQSxPQUFPLHFEQUFxRCx5Q0FBeUM7QUFDckcsS0FBSztBQUNMO0FBQ0EsY0FBYyx3QkFBd0IsT0FBTyxRQUFRO0FBQ3JELHNKQUFzSiwrQkFBK0I7QUFDckwsS0FBSztBQUNMO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsZ0VBQWdFLEtBQUssaUNBQWlDO0FBQ3RHLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUixvR0FBb0csVUFBVTtBQUM5RyxLQUFLO0FBQ0w7QUFDQSxjQUFjLGlDQUFpQztBQUMvQyxxREFBcUQsc0JBQXNCO0FBQzNFLEtBQUs7QUFDTDtBQUNBLGNBQWMsV0FBVztBQUN6QixpTUFBaU0sVUFBVTtBQUMzTSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQyxVQUFVLDZGQUE2RixnQkFBZ0I7QUFDdEssUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLG9GQUFvRixXQUFXO0FBQy9GLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxnREFBZ0QsNkJBQTZCO0FBQzdFLGdEQUFnRCw0QkFBNEI7QUFDNUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxFQUFFO0FBQ3pFO0FBQ0EsS0FBSztBQUNMLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBLEtBQUs7QUFDTCxjQUFjLG1CQUFtQjtBQUNqQztBQUNBLGlDQUFpQztBQUNqQywrQ0FBK0MsbUNBQW1DO0FBQ2xGO0FBQ0E7QUFDQSxzREFBc0Qsb0NBQW9DO0FBQzFGLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGdCQUFnQixZQUFZO0FBQzVCLG1DQUFtQywrREFBK0Q7QUFDbEc7QUFDQSxtQ0FBbUMsaUVBQWlFO0FBQ3BHO0FBQ0EsbUNBQW1DLHNFQUFzRTtBQUN6RztBQUNBLG1DQUFtQyxzRUFBc0U7QUFDekc7QUFDQSxtQ0FBbUMscUVBQXFFO0FBQ3hHO0FBQ0EsbUNBQW1DLHVFQUF1RSw2Q0FBNkMsVUFBVTtBQUNqSyxRQUFRO0FBQ1IsMkhBQTJILGdCQUFnQjtBQUMzSSxLQUFLO0FBQ0wsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBLGdCQUFnQix5SUFBeUkscUJBQXFCLGdLQUFnSywrQ0FBK0MsVUFBVSxnREFBZ0QsU0FBUyxzQkFBc0I7QUFDdGQsc0ZBQXNGLFlBQVk7QUFDbEcsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCLHFEQUFxRCxrQkFBa0IsZ0RBQWdELDBIQUEwSCxnQkFBZ0I7QUFDalEsS0FBSztBQUNMLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0EsZ0NBQWdDLFVBQVUsNkNBQTZDLDBCQUEwQixnRkFBZ0YsNEJBQTRCO0FBQzdOLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsUUFBUTtBQUN0QiwwREFBMEQseURBQXlELGdCQUFnQjtBQUNuSSxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsNkJBQTZCLFVBQVUsaUhBQWlILGlCQUFpQjtBQUN6SyxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLFFBQVE7QUFDdEIsMERBQTBELHlEQUF5RCxnQkFBZ0I7QUFDbkksS0FBSztBQUNMLGNBQWMsUUFBUTtBQUN0QjtBQUNBLDJCQUEyQixVQUFVLDhFQUE4RSxpQkFBaUI7QUFDcEksUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsMERBQTBELHVEQUF1RCxnQkFBZ0I7QUFDakksT0FBTztBQUNQLEtBQUs7QUFDTCxjQUFjLFFBQVE7QUFDdEI7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUyw0RUFBNEUsaUJBQWlCO0FBQ3RHLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0EsaUNBQWlDLFVBQVUsNkNBQTZDLDRCQUE0QjtBQUNwSDtBQUNBLHFEQUFxRCw4Q0FBOEM7QUFDbkcsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxRQUFRO0FBQ3RCLDJEQUEyRCxrQkFBa0IsMERBQTBELGdCQUFnQjtBQUN2SixLQUFLO0FBQ0wsY0FBYyxtQkFBbUI7QUFDakM7QUFDQSw4QkFBOEIsVUFBVSxrREFBa0QsNEJBQTRCO0FBQ3RILFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGFBQWEsK0NBQStDLGtCQUFrQjtBQUM5RjtBQUNBO0FBQ0EsY0FBYyxpR0FBaUc7QUFDL0c7QUFDQSxnQkFBZ0IsYUFBYSwrQ0FBK0MsRUFBRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUVBQXFFLEVBQUU7QUFDdkUsY0FBYywrREFBK0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLHNEQUFzRCxFQUFFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixhQUFhLDhDQUE4QyxFQUFFO0FBQzdFO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBLGdCQUFnQixhQUFhLDhDQUE4QyxrQkFBa0I7QUFDN0Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixhQUFhLDhEQUE4RCxFQUFFO0FBQzdGO0FBQ0E7QUFDQSxjQUFjLG9EQUFvRDtBQUNsRTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsYUFBYSw4Q0FBOEMsRUFBRTtBQUM3RTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsYUFBYSw4Q0FBOEMsRUFBRTtBQUM3RTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGFBQWEsK0NBQStDLEVBQUU7QUFDOUU7QUFDQTtBQUNBLGNBQWMsOENBQThDO0FBQzVEO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQSxnQkFBZ0IsYUFBYSxnREFBZ0QsRUFBRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSx1Q0FBdUMsa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtDQUErQyxTQUFTO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtDQUErQyxFQUFFLGlEQUFpRCxRQUFRLE1BQU0sT0FBTztBQUNwSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGFBQWEsK0NBQStDLEVBQUU7QUFDOUU7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0EsZ0JBQWdCLGFBQWEsaURBQWlELGtCQUFrQjtBQUNoRztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGFBQWEsNENBQTRDLEVBQUU7QUFDM0U7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixhQUFhLDRDQUE0QyxFQUFFO0FBQzNFO0FBQ0E7QUFDQSxjQUFjLGlDQUFpQztBQUMvQztBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0EsZ0JBQWdCLGFBQWEsNkNBQTZDLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsMkNBQTJDLGtCQUFrQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSwyQ0FBMkMsa0JBQWtCO0FBQzFGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsYUFBYSxrREFBa0QsRUFBRTtBQUNqRjtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0EsMERBQTBELDBDQUEwQztBQUNwRztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQixhQUFhLDZCQUE2QixHQUFHLHNEQUFzRCxrQkFBa0I7QUFDdkk7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHNCQUFzQixzRkFBc0Ysc0JBQXNCO0FBQ2hOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0EsZ0lBQWdJLFVBQVUsMEZBQTBGLE9BQU87QUFDM08sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSwrREFBK0QsRUFBRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsdURBQXVELEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLGlDQUFpQyxFQUFFO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsK0RBQStELEVBQUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLHVEQUF1RCxFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLGlDQUFpQyxFQUFFO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSxrRUFBa0UsRUFBRTtBQUMvRjtBQUNBLE1BQU07QUFDTixjQUFjLGFBQWEsMEVBQTBFLEVBQUU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSw2REFBNkQsRUFBRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEscURBQXFELEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsK0JBQStCLEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUhBQXVILCtCQUErQjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwS0FBMEssb0NBQW9DO0FBQzlNLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0pBQWtKO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxvREFBb0QsNkNBQTZDO0FBQ2pHO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQixvQkFBb0IsNkNBQTZDO0FBQ3JHLGlDQUFpQyxRQUFRO0FBQ3pDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSw0REFBNEQ7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNERBQTREO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWSxFQUFFLEdBQUcsRUFBRTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0IsbUVBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0xBQXNMO0FBQzNMLGlEQUFpRCxzQkFBc0I7QUFDdkUsS0FBSyx3RUFBd0UsaURBQUUsR0FBRyxZQUFZO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNFQUF5QjtBQUN0QztBQUNBLGFBQWEsbUVBQXNCO0FBQ25DLG9FQUFvRSxFQUFFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSw0Q0FBNEMsa0NBQWtDO0FBQzlFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsZUFBZSxHQUFHLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYSwrREFBK0QsRUFBRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9pbmRleC0wMDQ1MWYxYS5qcz82MGQ5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBBdSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBUdSA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBBdShpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQ7XG52YXIgd2UgPSAoaSwgZSwgdCkgPT4gKFR1KGksIHR5cGVvZiBlICE9IFwic3ltYm9sXCIgPyBlICsgXCJcIiA6IGUsIHQpLCB0KTtcbmltcG9ydCB7IGUgYXMgR2EsIGMgYXMgbXQsIGcgYXMgV2EgfSBmcm9tIFwiLi9sYXN0Q29ubmVjdGVkLWI5NjRkYzMwLmpzXCI7XG5pbXBvcnQgeyBjb25zdGFudHMgYXMgTXMsIEFjY291bnQgYXMgJHUsIFJwY1Byb3ZpZGVyIGFzIEZ1IH0gZnJvbSBcInN0YXJrbmV0XCI7XG5pbXBvcnQgeyByIGFzIFV1IH0gZnJvbSBcIi4vaW5kZXgtNzBmMzczZGEuanNcIjtcbmltcG9ydCBcIi4vcHVibGljUmNwTm9kZXMtYmUwNDE1ODguanNcIjtcbnZhciBzbiA9IHsgZXhwb3J0czoge30gfSwgJGkgPSB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiID8gUmVmbGVjdCA6IG51bGwsIEJuID0gJGkgJiYgdHlwZW9mICRpLmFwcGx5ID09IFwiZnVuY3Rpb25cIiA/ICRpLmFwcGx5IDogZnVuY3Rpb24oZSwgdCwgcykge1xuICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoZSwgdCwgcyk7XG59LCBxcztcbiRpICYmIHR5cGVvZiAkaS5vd25LZXlzID09IFwiZnVuY3Rpb25cIiA/IHFzID0gJGkub3duS2V5cyA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBxcyA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpKTtcbn0gOiBxcyA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpO1xufTtcbmZ1bmN0aW9uIEx1KGkpIHtcbiAgY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgY29uc29sZS53YXJuKGkpO1xufVxudmFyIFlhID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgIT09IGU7XG59O1xuZnVuY3Rpb24gT2UoKSB7XG4gIE9lLmluaXQuY2FsbCh0aGlzKTtcbn1cbnNuLmV4cG9ydHMgPSBPZTtcbnNuLmV4cG9ydHMub25jZSA9IHp1O1xuT2UuRXZlbnRFbWl0dGVyID0gT2U7XG5PZS5wcm90b3R5cGUuX2V2ZW50cyA9IHZvaWQgMDtcbk9lLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuT2UucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB2b2lkIDA7XG52YXIga24gPSAxMDtcbmZ1bmN0aW9uIHRyKGkpIHtcbiAgaWYgKHR5cGVvZiBpICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGkpO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9lLCBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ga247XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oaSkge1xuICAgIGlmICh0eXBlb2YgaSAhPSBcIm51bWJlclwiIHx8IGkgPCAwIHx8IFlhKGkpKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgaSArIFwiLlwiKTtcbiAgICBrbiA9IGk7XG4gIH1cbn0pO1xuT2UuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAodGhpcy5fZXZlbnRzID09PSB2b2lkIDAgfHwgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykgJiYgKHRoaXMuX2V2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0aGlzLl9ldmVudHNDb3VudCA9IDApLCB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdm9pZCAwO1xufTtcbk9lLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihlKSB7XG4gIGlmICh0eXBlb2YgZSAhPSBcIm51bWJlclwiIHx8IGUgPCAwIHx8IFlhKGUpKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGUgKyBcIi5cIik7XG4gIHJldHVybiB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBlLCB0aGlzO1xufTtcbmZ1bmN0aW9uIEphKGkpIHtcbiAgcmV0dXJuIGkuX21heExpc3RlbmVycyA9PT0gdm9pZCAwID8gT2UuZGVmYXVsdE1heExpc3RlbmVycyA6IGkuX21heExpc3RlbmVycztcbn1cbk9lLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEphKHRoaXMpO1xufTtcbk9lLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZSkge1xuICBmb3IgKHZhciB0ID0gW10sIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKVxuICAgIHQucHVzaChhcmd1bWVudHNbc10pO1xuICB2YXIgciA9IGUgPT09IFwiZXJyb3JcIiwgbiA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKG4gIT09IHZvaWQgMClcbiAgICByID0gciAmJiBuLmVycm9yID09PSB2b2lkIDA7XG4gIGVsc2UgaWYgKCFyKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHIpIHtcbiAgICB2YXIgbztcbiAgICBpZiAodC5sZW5ndGggPiAwICYmIChvID0gdFswXSksIG8gaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgIHRocm93IG87XG4gICAgdmFyIGMgPSBuZXcgRXJyb3IoXCJVbmhhbmRsZWQgZXJyb3IuXCIgKyAobyA/IFwiIChcIiArIG8ubWVzc2FnZSArIFwiKVwiIDogXCJcIikpO1xuICAgIHRocm93IGMuY29udGV4dCA9IG8sIGM7XG4gIH1cbiAgdmFyIHUgPSBuW2VdO1xuICBpZiAodSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHR5cGVvZiB1ID09IFwiZnVuY3Rpb25cIilcbiAgICBCbih1LCB0aGlzLCB0KTtcbiAgZWxzZVxuICAgIGZvciAodmFyIGQgPSB1Lmxlbmd0aCwgcCA9IHRjKHUsIGQpLCBzID0gMDsgcyA8IGQ7ICsrcylcbiAgICAgIEJuKHBbc10sIHRoaXMsIHQpO1xuICByZXR1cm4gITA7XG59O1xuZnVuY3Rpb24gUWEoaSwgZSwgdCwgcykge1xuICB2YXIgciwgbiwgbztcbiAgaWYgKHRyKHQpLCBuID0gaS5fZXZlbnRzLCBuID09PSB2b2lkIDAgPyAobiA9IGkuX2V2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBpLl9ldmVudHNDb3VudCA9IDApIDogKG4ubmV3TGlzdGVuZXIgIT09IHZvaWQgMCAmJiAoaS5lbWl0KFxuICAgIFwibmV3TGlzdGVuZXJcIixcbiAgICBlLFxuICAgIHQubGlzdGVuZXIgPyB0Lmxpc3RlbmVyIDogdFxuICApLCBuID0gaS5fZXZlbnRzKSwgbyA9IG5bZV0pLCBvID09PSB2b2lkIDApXG4gICAgbyA9IG5bZV0gPSB0LCArK2kuX2V2ZW50c0NvdW50O1xuICBlbHNlIGlmICh0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyBvID0gbltlXSA9IHMgPyBbdCwgb10gOiBbbywgdF0gOiBzID8gby51bnNoaWZ0KHQpIDogby5wdXNoKHQpLCByID0gSmEoaSksIHIgPiAwICYmIG8ubGVuZ3RoID4gciAmJiAhby53YXJuZWQpIHtcbiAgICBvLndhcm5lZCA9ICEwO1xuICAgIHZhciBjID0gbmV3IEVycm9yKFwiUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiBcIiArIG8ubGVuZ3RoICsgXCIgXCIgKyBTdHJpbmcoZSkgKyBcIiBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0XCIpO1xuICAgIGMubmFtZSA9IFwiTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nXCIsIGMuZW1pdHRlciA9IGksIGMudHlwZSA9IGUsIGMuY291bnQgPSBvLmxlbmd0aCwgTHUoYyk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5PZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBRYSh0aGlzLCBlLCB0LCAhMSk7XG59O1xuT2UucHJvdG90eXBlLm9uID0gT2UucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuT2UucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIFFhKHRoaXMsIGUsIHQsICEwKTtcbn07XG5mdW5jdGlvbiBNdSgpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKVxuICAgIHJldHVybiB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKSwgdGhpcy5maXJlZCA9ICEwLCBhcmd1bWVudHMubGVuZ3RoID09PSAwID8gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KSA6IHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBYYShpLCBlLCB0KSB7XG4gIHZhciBzID0geyBmaXJlZDogITEsIHdyYXBGbjogdm9pZCAwLCB0YXJnZXQ6IGksIHR5cGU6IGUsIGxpc3RlbmVyOiB0IH0sIHIgPSBNdS5iaW5kKHMpO1xuICByZXR1cm4gci5saXN0ZW5lciA9IHQsIHMud3JhcEZuID0gciwgcjtcbn1cbk9lLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gdHIodCksIHRoaXMub24oZSwgWGEodGhpcywgZSwgdCkpLCB0aGlzO1xufTtcbk9lLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gdHIodCksIHRoaXMucHJlcGVuZExpc3RlbmVyKGUsIFhhKHRoaXMsIGUsIHQpKSwgdGhpcztcbn07XG5PZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHZhciBzLCByLCBuLCBvLCBjO1xuICBpZiAodHIodCksIHIgPSB0aGlzLl9ldmVudHMsIHIgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHMgPSByW2VdLCBzID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmIChzID09PSB0IHx8IHMubGlzdGVuZXIgPT09IHQpXG4gICAgLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCA/IHRoaXMuX2V2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpIDogKGRlbGV0ZSByW2VdLCByLnJlbW92ZUxpc3RlbmVyICYmIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsIGUsIHMubGlzdGVuZXIgfHwgdCkpO1xuICBlbHNlIGlmICh0eXBlb2YgcyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKG4gPSAtMSwgbyA9IHMubGVuZ3RoIC0gMTsgbyA+PSAwOyBvLS0pXG4gICAgICBpZiAoc1tvXSA9PT0gdCB8fCBzW29dLmxpc3RlbmVyID09PSB0KSB7XG4gICAgICAgIGMgPSBzW29dLmxpc3RlbmVyLCBuID0gbztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgaWYgKG4gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgbiA9PT0gMCA/IHMuc2hpZnQoKSA6IHF1KHMsIG4pLCBzLmxlbmd0aCA9PT0gMSAmJiAocltlXSA9IHNbMF0pLCByLnJlbW92ZUxpc3RlbmVyICE9PSB2b2lkIDAgJiYgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgZSwgYyB8fCB0KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5PZS5wcm90b3R5cGUub2ZmID0gT2UucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuT2UucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQsIHMsIHI7XG4gIGlmIChzID0gdGhpcy5fZXZlbnRzLCBzID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmIChzLnJlbW92ZUxpc3RlbmVyID09PSB2b2lkIDApXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyAodGhpcy5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRoaXMuX2V2ZW50c0NvdW50ID0gMCkgOiBzW2VdICE9PSB2b2lkIDAgJiYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDAgPyB0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IGRlbGV0ZSBzW2VdKSwgdGhpcztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgbiA9IE9iamVjdC5rZXlzKHMpLCBvO1xuICAgIGZvciAociA9IDA7IHIgPCBuLmxlbmd0aDsgKytyKVxuICAgICAgbyA9IG5bcl0sIG8gIT09IFwicmVtb3ZlTGlzdGVuZXJcIiAmJiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhvKTtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZW1vdmVMaXN0ZW5lclwiKSwgdGhpcy5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRoaXMuX2V2ZW50c0NvdW50ID0gMCwgdGhpcztcbiAgfVxuICBpZiAodCA9IHNbZV0sIHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGUsIHQpO1xuICBlbHNlIGlmICh0ICE9PSB2b2lkIDApXG4gICAgZm9yIChyID0gdC5sZW5ndGggLSAxOyByID49IDA7IHItLSlcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZSwgdFtyXSk7XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIFphKGksIGUsIHQpIHtcbiAgdmFyIHMgPSBpLl9ldmVudHM7XG4gIGlmIChzID09PSB2b2lkIDApXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgciA9IHNbZV07XG4gIHJldHVybiByID09PSB2b2lkIDAgPyBbXSA6IHR5cGVvZiByID09IFwiZnVuY3Rpb25cIiA/IHQgPyBbci5saXN0ZW5lciB8fCByXSA6IFtyXSA6IHQgPyBqdShyKSA6IHRjKHIsIHIubGVuZ3RoKTtcbn1cbk9lLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBaYSh0aGlzLCBlLCAhMCk7XG59O1xuT2UucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIFphKHRoaXMsIGUsICExKTtcbn07XG5PZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oaSwgZSkge1xuICByZXR1cm4gdHlwZW9mIGkubGlzdGVuZXJDb3VudCA9PSBcImZ1bmN0aW9uXCIgPyBpLmxpc3RlbmVyQ291bnQoZSkgOiBlYy5jYWxsKGksIGUpO1xufTtcbk9lLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZWM7XG5mdW5jdGlvbiBlYyhpKSB7XG4gIHZhciBlID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZSAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHQgPSBlW2ldO1xuICAgIGlmICh0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gMTtcbiAgICBpZiAodCAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHQubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufVxuT2UucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IHFzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5mdW5jdGlvbiB0YyhpLCBlKSB7XG4gIGZvciAodmFyIHQgPSBuZXcgQXJyYXkoZSksIHMgPSAwOyBzIDwgZTsgKytzKVxuICAgIHRbc10gPSBpW3NdO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIHF1KGksIGUpIHtcbiAgZm9yICg7IGUgKyAxIDwgaS5sZW5ndGg7IGUrKylcbiAgICBpW2VdID0gaVtlICsgMV07XG4gIGkucG9wKCk7XG59XG5mdW5jdGlvbiBqdShpKSB7XG4gIGZvciAodmFyIGUgPSBuZXcgQXJyYXkoaS5sZW5ndGgpLCB0ID0gMDsgdCA8IGUubGVuZ3RoOyArK3QpXG4gICAgZVt0XSA9IGlbdF0ubGlzdGVuZXIgfHwgaVt0XTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB6dShpLCBlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0LCBzKSB7XG4gICAgZnVuY3Rpb24gcihvKSB7XG4gICAgICBpLnJlbW92ZUxpc3RlbmVyKGUsIG4pLCBzKG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuKCkge1xuICAgICAgdHlwZW9mIGkucmVtb3ZlTGlzdGVuZXIgPT0gXCJmdW5jdGlvblwiICYmIGkucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCByKSwgdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBpYyhpLCBlLCBuLCB7IG9uY2U6ICEwIH0pLCBlICE9PSBcImVycm9yXCIgJiYgS3UoaSwgciwgeyBvbmNlOiAhMCB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBLdShpLCBlLCB0KSB7XG4gIHR5cGVvZiBpLm9uID09IFwiZnVuY3Rpb25cIiAmJiBpYyhpLCBcImVycm9yXCIsIGUsIHQpO1xufVxuZnVuY3Rpb24gaWMoaSwgZSwgdCwgcykge1xuICBpZiAodHlwZW9mIGkub24gPT0gXCJmdW5jdGlvblwiKVxuICAgIHMub25jZSA/IGkub25jZShlLCB0KSA6IGkub24oZSwgdCk7XG4gIGVsc2UgaWYgKHR5cGVvZiBpLmFkZEV2ZW50TGlzdGVuZXIgPT0gXCJmdW5jdGlvblwiKVxuICAgIGkuYWRkRXZlbnRMaXN0ZW5lcihlLCBmdW5jdGlvbiByKG4pIHtcbiAgICAgIHMub25jZSAmJiBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgciksIHQobik7XG4gICAgfSk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGkpO1xufVxudmFyIFdlID0gc24uZXhwb3J0cztcbmNvbnN0IGlyID0gLyogQF9fUFVSRV9fICovIEdhKFdlKTtcbnZhciBzciA9IHt9LCBzYyA9IHsgZXhwb3J0czoge30gfTtcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuKGZ1bmN0aW9uKGkpIHtcbiAgdmFyIGUsIHQsIHMsIHIsIG4sIG8sIGMsIHUsIGQsIHAsIGIsIHgsIE8sIF8sIEMsIEYsIEssIEksIEQsIHksIHcsIGYsIGE7XG4gIChmdW5jdGlvbihsKSB7XG4gICAgdmFyIEwgPSB0eXBlb2YgbXQgPT0gXCJvYmplY3RcIiA/IG10IDogdHlwZW9mIHNlbGYgPT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xuICAgIGwodihMLCB2KGkuZXhwb3J0cykpKTtcbiAgICBmdW5jdGlvbiB2KFIsICQpIHtcbiAgICAgIHJldHVybiBSICE9PSBMICYmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoUiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pIDogUi5fX2VzTW9kdWxlID0gITApLCBmdW5jdGlvbihxLCBtKSB7XG4gICAgICAgIHJldHVybiBSW3FdID0gJCA/ICQocSwgbSkgOiBtO1xuICAgICAgfTtcbiAgICB9XG4gIH0pKGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgTCA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKHYsIFIpIHtcbiAgICAgIHYuX19wcm90b19fID0gUjtcbiAgICB9IHx8IGZ1bmN0aW9uKHYsIFIpIHtcbiAgICAgIGZvciAodmFyICQgaW4gUilcbiAgICAgICAgUi5oYXNPd25Qcm9wZXJ0eSgkKSAmJiAodlskXSA9IFJbJF0pO1xuICAgIH07XG4gICAgZSA9IGZ1bmN0aW9uKHYsIFIpIHtcbiAgICAgIEwodiwgUik7XG4gICAgICBmdW5jdGlvbiAkKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gdjtcbiAgICAgIH1cbiAgICAgIHYucHJvdG90eXBlID0gUiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoUikgOiAoJC5wcm90b3R5cGUgPSBSLnByb3RvdHlwZSwgbmV3ICQoKSk7XG4gICAgfSwgdCA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgUiwgJCA9IDEsIHEgPSBhcmd1bWVudHMubGVuZ3RoOyAkIDwgcTsgJCsrKSB7XG4gICAgICAgIFIgPSBhcmd1bWVudHNbJF07XG4gICAgICAgIGZvciAodmFyIG0gaW4gUilcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUiwgbSkgJiYgKHZbbV0gPSBSW21dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0sIHMgPSBmdW5jdGlvbih2LCBSKSB7XG4gICAgICB2YXIgJCA9IHt9O1xuICAgICAgZm9yICh2YXIgcSBpbiB2KVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodiwgcSkgJiYgUi5pbmRleE9mKHEpIDwgMCAmJiAoJFtxXSA9IHZbcV0pO1xuICAgICAgaWYgKHYgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIG0gPSAwLCBxID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2KTsgbSA8IHEubGVuZ3RoOyBtKyspXG4gICAgICAgICAgUi5pbmRleE9mKHFbbV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodiwgcVttXSkgJiYgKCRbcVttXV0gPSB2W3FbbV1dKTtcbiAgICAgIHJldHVybiAkO1xuICAgIH0sIHIgPSBmdW5jdGlvbih2LCBSLCAkLCBxKSB7XG4gICAgICB2YXIgbSA9IGFyZ3VtZW50cy5sZW5ndGgsIEUgPSBtIDwgMyA/IFIgOiBxID09PSBudWxsID8gcSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUiwgJCkgOiBxLCBCO1xuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBFID0gUmVmbGVjdC5kZWNvcmF0ZSh2LCBSLCAkLCBxKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZm9yICh2YXIgeiA9IHYubGVuZ3RoIC0gMTsgeiA+PSAwOyB6LS0pXG4gICAgICAgICAgKEIgPSB2W3pdKSAmJiAoRSA9IChtIDwgMyA/IEIoRSkgOiBtID4gMyA/IEIoUiwgJCwgRSkgOiBCKFIsICQpKSB8fCBFKTtcbiAgICAgIHJldHVybiBtID4gMyAmJiBFICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSLCAkLCBFKSwgRTtcbiAgICB9LCBuID0gZnVuY3Rpb24odiwgUikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCQsIHEpIHtcbiAgICAgICAgUigkLCBxLCB2KTtcbiAgICAgIH07XG4gICAgfSwgbyA9IGZ1bmN0aW9uKHYsIFIpIHtcbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEodiwgUik7XG4gICAgfSwgYyA9IGZ1bmN0aW9uKHYsIFIsICQsIHEpIHtcbiAgICAgIGZ1bmN0aW9uIG0oRSkge1xuICAgICAgICByZXR1cm4gRSBpbnN0YW5jZW9mICQgPyBFIDogbmV3ICQoZnVuY3Rpb24oQikge1xuICAgICAgICAgIEIoRSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyAoJCB8fCAoJCA9IFByb21pc2UpKShmdW5jdGlvbihFLCBCKSB7XG4gICAgICAgIGZ1bmN0aW9uIHooTSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBVKHEubmV4dChNKSk7XG4gICAgICAgICAgfSBjYXRjaCAoSCkge1xuICAgICAgICAgICAgQihIKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaihNKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFUocS50aHJvdyhNKSk7XG4gICAgICAgICAgfSBjYXRjaCAoSCkge1xuICAgICAgICAgICAgQihIKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gVShNKSB7XG4gICAgICAgICAgTS5kb25lID8gRShNLnZhbHVlKSA6IG0oTS52YWx1ZSkudGhlbih6LCBqKTtcbiAgICAgICAgfVxuICAgICAgICBVKChxID0gcS5hcHBseSh2LCBSIHx8IFtdKSkubmV4dCgpKTtcbiAgICAgIH0pO1xuICAgIH0sIHUgPSBmdW5jdGlvbih2LCBSKSB7XG4gICAgICB2YXIgJCA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoRVswXSAmIDEpXG4gICAgICAgICAgdGhyb3cgRVsxXTtcbiAgICAgICAgcmV0dXJuIEVbMV07XG4gICAgICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBxLCBtLCBFLCBCO1xuICAgICAgcmV0dXJuIEIgPSB7IG5leHQ6IHooMCksIHRocm93OiB6KDEpLCByZXR1cm46IHooMikgfSwgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgKEJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pLCBCO1xuICAgICAgZnVuY3Rpb24geihVKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgcmV0dXJuIGooW1UsIE1dKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGooVSkge1xuICAgICAgICBpZiAocSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgZm9yICg7ICQ7IClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHEgPSAxLCBtICYmIChFID0gVVswXSAmIDIgPyBtLnJldHVybiA6IFVbMF0gPyBtLnRocm93IHx8ICgoRSA9IG0ucmV0dXJuKSAmJiBFLmNhbGwobSksIDApIDogbS5uZXh0KSAmJiAhKEUgPSBFLmNhbGwobSwgVVsxXSkpLmRvbmUpXG4gICAgICAgICAgICAgIHJldHVybiBFO1xuICAgICAgICAgICAgc3dpdGNoIChtID0gMCwgRSAmJiAoVSA9IFtVWzBdICYgMiwgRS52YWx1ZV0pLCBVWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIEUgPSBVO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQubGFiZWwrKywgeyB2YWx1ZTogVVsxXSwgZG9uZTogITEgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICQubGFiZWwrKywgbSA9IFVbMV0sIFUgPSBbMF07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBVID0gJC5vcHMucG9wKCksICQudHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoRSA9ICQudHJ5cywgIShFID0gRS5sZW5ndGggPiAwICYmIEVbRS5sZW5ndGggLSAxXSkgJiYgKFVbMF0gPT09IDYgfHwgVVswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICQgPSAwO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChVWzBdID09PSAzICYmICghRSB8fCBVWzFdID4gRVswXSAmJiBVWzFdIDwgRVszXSkpIHtcbiAgICAgICAgICAgICAgICAgICQubGFiZWwgPSBVWzFdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChVWzBdID09PSA2ICYmICQubGFiZWwgPCBFWzFdKSB7XG4gICAgICAgICAgICAgICAgICAkLmxhYmVsID0gRVsxXSwgRSA9IFU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEUgJiYgJC5sYWJlbCA8IEVbMl0pIHtcbiAgICAgICAgICAgICAgICAgICQubGFiZWwgPSBFWzJdLCAkLm9wcy5wdXNoKFUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEVbMl0gJiYgJC5vcHMucG9wKCksICQudHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFUgPSBSLmNhbGwodiwgJCk7XG4gICAgICAgICAgfSBjYXRjaCAoTSkge1xuICAgICAgICAgICAgVSA9IFs2LCBNXSwgbSA9IDA7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHEgPSBFID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChVWzBdICYgNSlcbiAgICAgICAgICB0aHJvdyBVWzFdO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogVVswXSA/IFVbMV0gOiB2b2lkIDAsIGRvbmU6ICEwIH07XG4gICAgICB9XG4gICAgfSwgYSA9IGZ1bmN0aW9uKHYsIFIsICQsIHEpIHtcbiAgICAgIHEgPT09IHZvaWQgMCAmJiAocSA9ICQpLCB2W3FdID0gUlskXTtcbiAgICB9LCBkID0gZnVuY3Rpb24odiwgUikge1xuICAgICAgZm9yICh2YXIgJCBpbiB2KVxuICAgICAgICAkICE9PSBcImRlZmF1bHRcIiAmJiAhUi5oYXNPd25Qcm9wZXJ0eSgkKSAmJiAoUlskXSA9IHZbJF0pO1xuICAgIH0sIHAgPSBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgUiA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgJCA9IFIgJiYgdltSXSwgcSA9IDA7XG4gICAgICBpZiAoJClcbiAgICAgICAgcmV0dXJuICQuY2FsbCh2KTtcbiAgICAgIGlmICh2ICYmIHR5cGVvZiB2Lmxlbmd0aCA9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHYgJiYgcSA+PSB2Lmxlbmd0aCAmJiAodiA9IHZvaWQgMCksIHsgdmFsdWU6IHYgJiYgdltxKytdLCBkb25lOiAhdiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoUiA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB9LCBiID0gZnVuY3Rpb24odiwgUikge1xuICAgICAgdmFyICQgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB2W1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoISQpXG4gICAgICAgIHJldHVybiB2O1xuICAgICAgdmFyIHEgPSAkLmNhbGwodiksIG0sIEUgPSBbXSwgQjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOyAoUiA9PT0gdm9pZCAwIHx8IFItLSA+IDApICYmICEobSA9IHEubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgRS5wdXNoKG0udmFsdWUpO1xuICAgICAgfSBjYXRjaCAoeikge1xuICAgICAgICBCID0geyBlcnJvcjogeiB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtICYmICFtLmRvbmUgJiYgKCQgPSBxLnJldHVybikgJiYgJC5jYWxsKHEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChCKVxuICAgICAgICAgICAgdGhyb3cgQi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEU7XG4gICAgfSwgeCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgdiA9IFtdLCBSID0gMDsgUiA8IGFyZ3VtZW50cy5sZW5ndGg7IFIrKylcbiAgICAgICAgdiA9IHYuY29uY2F0KGIoYXJndW1lbnRzW1JdKSk7XG4gICAgICByZXR1cm4gdjtcbiAgICB9LCBPID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciB2ID0gMCwgUiA9IDAsICQgPSBhcmd1bWVudHMubGVuZ3RoOyBSIDwgJDsgUisrKVxuICAgICAgICB2ICs9IGFyZ3VtZW50c1tSXS5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBxID0gQXJyYXkodiksIG0gPSAwLCBSID0gMDsgUiA8ICQ7IFIrKylcbiAgICAgICAgZm9yICh2YXIgRSA9IGFyZ3VtZW50c1tSXSwgQiA9IDAsIHogPSBFLmxlbmd0aDsgQiA8IHo7IEIrKywgbSsrKVxuICAgICAgICAgIHFbbV0gPSBFW0JdO1xuICAgICAgcmV0dXJuIHE7XG4gICAgfSwgXyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgXyA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfKHYpO1xuICAgIH0sIEMgPSBmdW5jdGlvbih2LCBSLCAkKSB7XG4gICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgdmFyIHEgPSAkLmFwcGx5KHYsIFIgfHwgW10pLCBtLCBFID0gW107XG4gICAgICByZXR1cm4gbSA9IHt9LCBCKFwibmV4dFwiKSwgQihcInRocm93XCIpLCBCKFwicmV0dXJuXCIpLCBtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIG07XG4gICAgICBmdW5jdGlvbiBCKHRlKSB7XG4gICAgICAgIHFbdGVdICYmIChtW3RlXSA9IGZ1bmN0aW9uKEcpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaWUsIFEpIHtcbiAgICAgICAgICAgIEUucHVzaChbdGUsIEcsIGllLCBRXSkgPiAxIHx8IHoodGUsIEcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHoodGUsIEcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBqKHFbdGVdKEcpKTtcbiAgICAgICAgfSBjYXRjaCAoaWUpIHtcbiAgICAgICAgICBIKEVbMF1bM10sIGllKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaih0ZSkge1xuICAgICAgICB0ZS52YWx1ZSBpbnN0YW5jZW9mIF8gPyBQcm9taXNlLnJlc29sdmUodGUudmFsdWUudikudGhlbihVLCBNKSA6IEgoRVswXVsyXSwgdGUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gVSh0ZSkge1xuICAgICAgICB6KFwibmV4dFwiLCB0ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBNKHRlKSB7XG4gICAgICAgIHooXCJ0aHJvd1wiLCB0ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBIKHRlLCBHKSB7XG4gICAgICAgIHRlKEcpLCBFLnNoaWZ0KCksIEUubGVuZ3RoICYmIHooRVswXVswXSwgRVswXVsxXSk7XG4gICAgICB9XG4gICAgfSwgRiA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciBSLCAkO1xuICAgICAgcmV0dXJuIFIgPSB7fSwgcShcIm5leHRcIiksIHEoXCJ0aHJvd1wiLCBmdW5jdGlvbihtKSB7XG4gICAgICAgIHRocm93IG07XG4gICAgICB9KSwgcShcInJldHVyblwiKSwgUltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgUjtcbiAgICAgIGZ1bmN0aW9uIHEobSwgRSkge1xuICAgICAgICBSW21dID0gdlttXSA/IGZ1bmN0aW9uKEIpIHtcbiAgICAgICAgICByZXR1cm4gKCQgPSAhJCkgPyB7IHZhbHVlOiBfKHZbbV0oQikpLCBkb25lOiBtID09PSBcInJldHVyblwiIH0gOiBFID8gRShCKSA6IEI7XG4gICAgICAgIH0gOiBFO1xuICAgICAgfVxuICAgIH0sIEsgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgdmFyIFIgPSB2W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgJDtcbiAgICAgIHJldHVybiBSID8gUi5jYWxsKHYpIDogKHYgPSB0eXBlb2YgcCA9PSBcImZ1bmN0aW9uXCIgPyBwKHYpIDogdltTeW1ib2wuaXRlcmF0b3JdKCksICQgPSB7fSwgcShcIm5leHRcIiksIHEoXCJ0aHJvd1wiKSwgcShcInJldHVyblwiKSwgJFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCAkKTtcbiAgICAgIGZ1bmN0aW9uIHEoRSkge1xuICAgICAgICAkW0VdID0gdltFXSAmJiBmdW5jdGlvbihCKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHosIGopIHtcbiAgICAgICAgICAgIEIgPSB2W0VdKEIpLCBtKHosIGosIEIuZG9uZSwgQi52YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtKEUsIEIsIHosIGopIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGopLnRoZW4oZnVuY3Rpb24oVSkge1xuICAgICAgICAgIEUoeyB2YWx1ZTogVSwgZG9uZTogeiB9KTtcbiAgICAgICAgfSwgQik7XG4gICAgICB9XG4gICAgfSwgSSA9IGZ1bmN0aW9uKHYsIFIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodiwgXCJyYXdcIiwgeyB2YWx1ZTogUiB9KSA6IHYucmF3ID0gUiwgdjtcbiAgICB9LCBEID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKHYgJiYgdi5fX2VzTW9kdWxlKVxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIHZhciBSID0ge307XG4gICAgICBpZiAodiAhPSBudWxsKVxuICAgICAgICBmb3IgKHZhciAkIGluIHYpXG4gICAgICAgICAgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodiwgJCkgJiYgKFJbJF0gPSB2WyRdKTtcbiAgICAgIHJldHVybiBSLmRlZmF1bHQgPSB2LCBSO1xuICAgIH0sIHkgPSBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdiAmJiB2Ll9fZXNNb2R1bGUgPyB2IDogeyBkZWZhdWx0OiB2IH07XG4gICAgfSwgdyA9IGZ1bmN0aW9uKHYsIFIpIHtcbiAgICAgIGlmICghUi5oYXModikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xuICAgICAgcmV0dXJuIFIuZ2V0KHYpO1xuICAgIH0sIGYgPSBmdW5jdGlvbih2LCBSLCAkKSB7XG4gICAgICBpZiAoIVIuaGFzKHYpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgICAgIHJldHVybiBSLnNldCh2LCAkKSwgJDtcbiAgICB9LCBsKFwiX19leHRlbmRzXCIsIGUpLCBsKFwiX19hc3NpZ25cIiwgdCksIGwoXCJfX3Jlc3RcIiwgcyksIGwoXCJfX2RlY29yYXRlXCIsIHIpLCBsKFwiX19wYXJhbVwiLCBuKSwgbChcIl9fbWV0YWRhdGFcIiwgbyksIGwoXCJfX2F3YWl0ZXJcIiwgYyksIGwoXCJfX2dlbmVyYXRvclwiLCB1KSwgbChcIl9fZXhwb3J0U3RhclwiLCBkKSwgbChcIl9fY3JlYXRlQmluZGluZ1wiLCBhKSwgbChcIl9fdmFsdWVzXCIsIHApLCBsKFwiX19yZWFkXCIsIGIpLCBsKFwiX19zcHJlYWRcIiwgeCksIGwoXCJfX3NwcmVhZEFycmF5c1wiLCBPKSwgbChcIl9fYXdhaXRcIiwgXyksIGwoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIEMpLCBsKFwiX19hc3luY0RlbGVnYXRvclwiLCBGKSwgbChcIl9fYXN5bmNWYWx1ZXNcIiwgSyksIGwoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBJKSwgbChcIl9faW1wb3J0U3RhclwiLCBEKSwgbChcIl9faW1wb3J0RGVmYXVsdFwiLCB5KSwgbChcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgdyksIGwoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIGYpO1xuICB9KTtcbn0pKHNjKTtcbnZhciBGdCA9IHNjLmV4cG9ydHMsIGZzID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmZ1bmN0aW9uIFZ1KGkpIHtcbiAgaWYgKHR5cGVvZiBpICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2FmZSBqc29uIHBhcnNlIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgaX1gKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShpKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGk7XG4gIH1cbn1cbmZzLnNhZmVKc29uUGFyc2UgPSBWdTtcbmZ1bmN0aW9uIEJ1KGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpID09IFwic3RyaW5nXCIgPyBpIDogSlNPTi5zdHJpbmdpZnkoaSwgKGUsIHQpID0+IHR5cGVvZiB0ID4gXCJ1XCIgPyBudWxsIDogdCk7XG59XG5mcy5zYWZlSnNvblN0cmluZ2lmeSA9IEJ1O1xudmFyIGtpID0geyBleHBvcnRzOiB7fSB9LCBIbjtcbmZ1bmN0aW9uIGt1KCkge1xuICByZXR1cm4gSG4gfHwgKEhuID0gMSwgZnVuY3Rpb24oKSB7XG4gICAgbGV0IGk7XG4gICAgZnVuY3Rpb24gZSgpIHtcbiAgICB9XG4gICAgaSA9IGUsIGkucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNPd25Qcm9wZXJ0eSh0KSA/IFN0cmluZyh0aGlzW3RdKSA6IG51bGw7XG4gICAgfSwgaS5wcm90b3R5cGUuc2V0SXRlbSA9IGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgIHRoaXNbdF0gPSBTdHJpbmcocyk7XG4gICAgfSwgaS5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW3RdO1xuICAgIH0sIGkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcztcbiAgICAgIE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgICB0W3NdID0gdm9pZCAwLCBkZWxldGUgdFtzXTtcbiAgICAgIH0pO1xuICAgIH0sIGkucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0ID0gdCB8fCAwLCBPYmplY3Qua2V5cyh0aGlzKVt0XTtcbiAgICB9LCBpLnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFwibGVuZ3RoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLmxlbmd0aDtcbiAgICB9KSwgdHlwZW9mIG10IDwgXCJ1XCIgJiYgbXQubG9jYWxTdG9yYWdlID8ga2kuZXhwb3J0cyA9IG10LmxvY2FsU3RvcmFnZSA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cubG9jYWxTdG9yYWdlID8ga2kuZXhwb3J0cyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UgOiBraS5leHBvcnRzID0gbmV3IGUoKTtcbiAgfSgpKSwga2kuZXhwb3J0cztcbn1cbnZhciB5ciA9IHt9LCBIaSA9IHt9LCBHbjtcbmZ1bmN0aW9uIEh1KCkge1xuICBpZiAoR24pXG4gICAgcmV0dXJuIEhpO1xuICBHbiA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBIaS5JS2V5VmFsdWVTdG9yYWdlID0gdm9pZCAwO1xuICBjbGFzcyBpIHtcbiAgfVxuICByZXR1cm4gSGkuSUtleVZhbHVlU3RvcmFnZSA9IGksIEhpO1xufVxudmFyIEdpID0ge30sIFduO1xuZnVuY3Rpb24gR3UoKSB7XG4gIGlmIChXbilcbiAgICByZXR1cm4gR2k7XG4gIFduID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEdpLnBhcnNlRW50cnkgPSB2b2lkIDA7XG4gIGNvbnN0IGkgPSBmcztcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgdmFyIHM7XG4gICAgcmV0dXJuIFt0WzBdLCBpLnNhZmVKc29uUGFyc2UoKHMgPSB0WzFdKSAhPT0gbnVsbCAmJiBzICE9PSB2b2lkIDAgPyBzIDogXCJcIildO1xuICB9XG4gIHJldHVybiBHaS5wYXJzZUVudHJ5ID0gZSwgR2k7XG59XG52YXIgWW47XG5mdW5jdGlvbiBXdSgpIHtcbiAgcmV0dXJuIFluIHx8IChZbiA9IDEsIGZ1bmN0aW9uKGkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgIGNvbnN0IGUgPSBGdDtcbiAgICBlLl9fZXhwb3J0U3RhcihIdSgpLCBpKSwgZS5fX2V4cG9ydFN0YXIoR3UoKSwgaSk7XG4gIH0oeXIpKSwgeXI7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc3IsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnNyLktleVZhbHVlU3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IENpID0gRnQsIEpuID0gZnMsIFl1ID0gQ2kuX19pbXBvcnREZWZhdWx0KGt1KCkpLCBKdSA9IFd1KCk7XG5jbGFzcyByYyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlID0gWXUuZGVmYXVsdDtcbiAgfVxuICBnZXRLZXlzKCkge1xuICAgIHJldHVybiBDaS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5sb2NhbFN0b3JhZ2UpO1xuICAgIH0pO1xuICB9XG4gIGdldEVudHJpZXMoKSB7XG4gICAgcmV0dXJuIENpLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLmxvY2FsU3RvcmFnZSkubWFwKEp1LnBhcnNlRW50cnkpO1xuICAgIH0pO1xuICB9XG4gIGdldEl0ZW0oZSkge1xuICAgIHJldHVybiBDaS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShlKTtcbiAgICAgIGlmICh0ICE9PSBudWxsKVxuICAgICAgICByZXR1cm4gSm4uc2FmZUpzb25QYXJzZSh0KTtcbiAgICB9KTtcbiAgfVxuICBzZXRJdGVtKGUsIHQpIHtcbiAgICByZXR1cm4gQ2kuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShlLCBKbi5zYWZlSnNvblN0cmluZ2lmeSh0KSk7XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlSXRlbShlKSB7XG4gICAgcmV0dXJuIENpLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZSk7XG4gICAgfSk7XG4gIH1cbn1cbnNyLktleVZhbHVlU3RvcmFnZSA9IHJjO1xudmFyIG5jID0gc3IuZGVmYXVsdCA9IHJjLCBXdCA9IHt9LCBXaSA9IHt9LCBWID0ge30sIG1yID0ge30sIFlpID0ge30sIFFuO1xuZnVuY3Rpb24gUXUoKSB7XG4gIGlmIChRbilcbiAgICByZXR1cm4gWWk7XG4gIFFuID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFlpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFlpLmRlbGF5ID0gdm9pZCAwO1xuICBmdW5jdGlvbiBpKGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0KCEwKTtcbiAgICAgIH0sIGUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBZaS5kZWxheSA9IGksIFlpO1xufVxudmFyIG1pID0ge30sIGJyID0ge30sIGJpID0ge30sIFhuO1xuZnVuY3Rpb24gWHUoKSB7XG4gIHJldHVybiBYbiB8fCAoWG4gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYmksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgYmkuT05FX1RIT1VTQU5EID0gYmkuT05FX0hVTkRSRUQgPSB2b2lkIDAsIGJpLk9ORV9IVU5EUkVEID0gMTAwLCBiaS5PTkVfVEhPVVNBTkQgPSAxZTMpLCBiaTtcbn1cbnZhciB3ciA9IHt9LCBabjtcbmZ1bmN0aW9uIFp1KCkge1xuICByZXR1cm4gWm4gfHwgKFpuID0gMSwgZnVuY3Rpb24oaSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGkuT05FX1lFQVIgPSBpLkZPVVJfV0VFS1MgPSBpLlRIUkVFX1dFRUtTID0gaS5UV09fV0VFS1MgPSBpLk9ORV9XRUVLID0gaS5USElSVFlfREFZUyA9IGkuU0VWRU5fREFZUyA9IGkuRklWRV9EQVlTID0gaS5USFJFRV9EQVlTID0gaS5PTkVfREFZID0gaS5UV0VOVFlfRk9VUl9IT1VSUyA9IGkuVFdFTFZFX0hPVVJTID0gaS5TSVhfSE9VUlMgPSBpLlRIUkVFX0hPVVJTID0gaS5PTkVfSE9VUiA9IGkuU0lYVFlfTUlOVVRFUyA9IGkuVEhJUlRZX01JTlVURVMgPSBpLlRFTl9NSU5VVEVTID0gaS5GSVZFX01JTlVURVMgPSBpLk9ORV9NSU5VVEUgPSBpLlNJWFRZX1NFQ09ORFMgPSBpLlRISVJUWV9TRUNPTkRTID0gaS5URU5fU0VDT05EUyA9IGkuRklWRV9TRUNPTkRTID0gaS5PTkVfU0VDT05EID0gdm9pZCAwLCBpLk9ORV9TRUNPTkQgPSAxLCBpLkZJVkVfU0VDT05EUyA9IDUsIGkuVEVOX1NFQ09ORFMgPSAxMCwgaS5USElSVFlfU0VDT05EUyA9IDMwLCBpLlNJWFRZX1NFQ09ORFMgPSA2MCwgaS5PTkVfTUlOVVRFID0gaS5TSVhUWV9TRUNPTkRTLCBpLkZJVkVfTUlOVVRFUyA9IGkuT05FX01JTlVURSAqIDUsIGkuVEVOX01JTlVURVMgPSBpLk9ORV9NSU5VVEUgKiAxMCwgaS5USElSVFlfTUlOVVRFUyA9IGkuT05FX01JTlVURSAqIDMwLCBpLlNJWFRZX01JTlVURVMgPSBpLk9ORV9NSU5VVEUgKiA2MCwgaS5PTkVfSE9VUiA9IGkuU0lYVFlfTUlOVVRFUywgaS5USFJFRV9IT1VSUyA9IGkuT05FX0hPVVIgKiAzLCBpLlNJWF9IT1VSUyA9IGkuT05FX0hPVVIgKiA2LCBpLlRXRUxWRV9IT1VSUyA9IGkuT05FX0hPVVIgKiAxMiwgaS5UV0VOVFlfRk9VUl9IT1VSUyA9IGkuT05FX0hPVVIgKiAyNCwgaS5PTkVfREFZID0gaS5UV0VOVFlfRk9VUl9IT1VSUywgaS5USFJFRV9EQVlTID0gaS5PTkVfREFZICogMywgaS5GSVZFX0RBWVMgPSBpLk9ORV9EQVkgKiA1LCBpLlNFVkVOX0RBWVMgPSBpLk9ORV9EQVkgKiA3LCBpLlRISVJUWV9EQVlTID0gaS5PTkVfREFZICogMzAsIGkuT05FX1dFRUsgPSBpLlNFVkVOX0RBWVMsIGkuVFdPX1dFRUtTID0gaS5PTkVfV0VFSyAqIDIsIGkuVEhSRUVfV0VFS1MgPSBpLk9ORV9XRUVLICogMywgaS5GT1VSX1dFRUtTID0gaS5PTkVfV0VFSyAqIDQsIGkuT05FX1lFQVIgPSBpLk9ORV9EQVkgKiAzNjU7XG4gIH0od3IpKSwgd3I7XG59XG52YXIgZW87XG5mdW5jdGlvbiBvYygpIHtcbiAgcmV0dXJuIGVvIHx8IChlbyA9IDEsIGZ1bmN0aW9uKGkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgIGNvbnN0IGUgPSBGdDtcbiAgICBlLl9fZXhwb3J0U3RhcihYdSgpLCBpKSwgZS5fX2V4cG9ydFN0YXIoWnUoKSwgaSk7XG4gIH0oYnIpKSwgYnI7XG59XG52YXIgdG87XG5mdW5jdGlvbiBlbCgpIHtcbiAgaWYgKHRvKVxuICAgIHJldHVybiBtaTtcbiAgdG8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobWksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbWkuZnJvbU1pbGlzZWNvbmRzID0gbWkudG9NaWxpc2Vjb25kcyA9IHZvaWQgMDtcbiAgY29uc3QgaSA9IG9jKCk7XG4gIGZ1bmN0aW9uIGUocykge1xuICAgIHJldHVybiBzICogaS5PTkVfVEhPVVNBTkQ7XG4gIH1cbiAgbWkudG9NaWxpc2Vjb25kcyA9IGU7XG4gIGZ1bmN0aW9uIHQocykge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHMgLyBpLk9ORV9USE9VU0FORCk7XG4gIH1cbiAgcmV0dXJuIG1pLmZyb21NaWxpc2Vjb25kcyA9IHQsIG1pO1xufVxudmFyIGlvO1xuZnVuY3Rpb24gdGwoKSB7XG4gIHJldHVybiBpbyB8fCAoaW8gPSAxLCBmdW5jdGlvbihpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgICBjb25zdCBlID0gRnQ7XG4gICAgZS5fX2V4cG9ydFN0YXIoUXUoKSwgaSksIGUuX19leHBvcnRTdGFyKGVsKCksIGkpO1xuICB9KG1yKSksIG1yO1xufVxudmFyIFJpID0ge30sIHNvO1xuZnVuY3Rpb24gaWwoKSB7XG4gIGlmIChzbylcbiAgICByZXR1cm4gUmk7XG4gIHNvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFJpLldhdGNoID0gdm9pZCAwO1xuICBjbGFzcyBpIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMudGltZXN0YW1wcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHN0YXJ0KHQpIHtcbiAgICAgIGlmICh0aGlzLnRpbWVzdGFtcHMuaGFzKHQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdhdGNoIGFscmVhZHkgc3RhcnRlZCBmb3IgbGFiZWw6ICR7dH1gKTtcbiAgICAgIHRoaXMudGltZXN0YW1wcy5zZXQodCwgeyBzdGFydGVkOiBEYXRlLm5vdygpIH0pO1xuICAgIH1cbiAgICBzdG9wKHQpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmdldCh0KTtcbiAgICAgIGlmICh0eXBlb2Ygcy5lbGFwc2VkIDwgXCJ1XCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV2F0Y2ggYWxyZWFkeSBzdG9wcGVkIGZvciBsYWJlbDogJHt0fWApO1xuICAgICAgY29uc3QgciA9IERhdGUubm93KCkgLSBzLnN0YXJ0ZWQ7XG4gICAgICB0aGlzLnRpbWVzdGFtcHMuc2V0KHQsIHsgc3RhcnRlZDogcy5zdGFydGVkLCBlbGFwc2VkOiByIH0pO1xuICAgIH1cbiAgICBnZXQodCkge1xuICAgICAgY29uc3QgcyA9IHRoaXMudGltZXN0YW1wcy5nZXQodCk7XG4gICAgICBpZiAodHlwZW9mIHMgPiBcInVcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0aW1lc3RhbXAgZm91bmQgZm9yIGxhYmVsOiAke3R9YCk7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgZWxhcHNlZCh0KSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5nZXQodCk7XG4gICAgICByZXR1cm4gcy5lbGFwc2VkIHx8IERhdGUubm93KCkgLSBzLnN0YXJ0ZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBSaS5XYXRjaCA9IGksIFJpLmRlZmF1bHQgPSBpLCBSaTtcbn1cbnZhciB2ciA9IHt9LCBKaSA9IHt9LCBybztcbmZ1bmN0aW9uIHNsKCkge1xuICBpZiAocm8pXG4gICAgcmV0dXJuIEppO1xuICBybyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShKaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBKaS5JV2F0Y2ggPSB2b2lkIDA7XG4gIGNsYXNzIGkge1xuICB9XG4gIHJldHVybiBKaS5JV2F0Y2ggPSBpLCBKaTtcbn1cbnZhciBubztcbmZ1bmN0aW9uIHJsKCkge1xuICByZXR1cm4gbm8gfHwgKG5vID0gMSwgZnVuY3Rpb24oaSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEZ0Ll9fZXhwb3J0U3RhcihzbCgpLCBpKTtcbiAgfSh2cikpLCB2cjtcbn1cbihmdW5jdGlvbihpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIGNvbnN0IGUgPSBGdDtcbiAgZS5fX2V4cG9ydFN0YXIodGwoKSwgaSksIGUuX19leHBvcnRTdGFyKGlsKCksIGkpLCBlLl9fZXhwb3J0U3RhcihybCgpLCBpKSwgZS5fX2V4cG9ydFN0YXIob2MoKSwgaSk7XG59KShWKTtcbnZhciBfciA9IHt9LCBRaSA9IHt9O1xubGV0IE50ID0gY2xhc3Mge1xufTtcbmNvbnN0IG5sID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgSUV2ZW50czogTnRcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIG9sID0gLyogQF9fUFVSRV9fICovIFdhKG5sKTtcbnZhciBvbztcbmZ1bmN0aW9uIGFsKCkge1xuICBpZiAob28pXG4gICAgcmV0dXJuIFFpO1xuICBvbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBRaS5JSGVhcnRCZWF0ID0gdm9pZCAwO1xuICBjb25zdCBpID0gb2w7XG4gIGNsYXNzIGUgZXh0ZW5kcyBpLklFdmVudHMge1xuICAgIGNvbnN0cnVjdG9yKHMpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBRaS5JSGVhcnRCZWF0ID0gZSwgUWk7XG59XG52YXIgYW87XG5mdW5jdGlvbiBhYygpIHtcbiAgcmV0dXJuIGFvIHx8IChhbyA9IDEsIGZ1bmN0aW9uKGkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBGdC5fX2V4cG9ydFN0YXIoYWwoKSwgaSk7XG4gIH0oX3IpKSwgX3I7XG59XG52YXIgRXIgPSB7fSwgd2kgPSB7fSwgY287XG5mdW5jdGlvbiBjbCgpIHtcbiAgaWYgKGNvKVxuICAgIHJldHVybiB3aTtcbiAgY28gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkod2ksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgd2kuSEVBUlRCRUFUX0VWRU5UUyA9IHdpLkhFQVJUQkVBVF9JTlRFUlZBTCA9IHZvaWQgMDtcbiAgY29uc3QgaSA9IFY7XG4gIHJldHVybiB3aS5IRUFSVEJFQVRfSU5URVJWQUwgPSBpLkZJVkVfU0VDT05EUywgd2kuSEVBUlRCRUFUX0VWRU5UUyA9IHtcbiAgICBwdWxzZTogXCJoZWFydGJlYXRfcHVsc2VcIlxuICB9LCB3aTtcbn1cbnZhciBobztcbmZ1bmN0aW9uIGNjKCkge1xuICByZXR1cm4gaG8gfHwgKGhvID0gMSwgZnVuY3Rpb24oaSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEZ0Ll9fZXhwb3J0U3RhcihjbCgpLCBpKTtcbiAgfShFcikpLCBFcjtcbn1cbnZhciB1bztcbmZ1bmN0aW9uIGhsKCkge1xuICBpZiAodW8pXG4gICAgcmV0dXJuIFdpO1xuICB1byA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBXaS5IZWFydEJlYXQgPSB2b2lkIDA7XG4gIGNvbnN0IGkgPSBGdCwgZSA9IFdlLCB0ID0gViwgcyA9IGFjKCksIHIgPSBjYygpO1xuICBjbGFzcyBuIGV4dGVuZHMgcy5JSGVhcnRCZWF0IHtcbiAgICBjb25zdHJ1Y3RvcihjKSB7XG4gICAgICBzdXBlcihjKSwgdGhpcy5ldmVudHMgPSBuZXcgZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5pbnRlcnZhbCA9IHIuSEVBUlRCRUFUX0lOVEVSVkFMLCB0aGlzLmludGVydmFsID0gYz8uaW50ZXJ2YWwgfHwgci5IRUFSVEJFQVRfSU5URVJWQUw7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KGMpIHtcbiAgICAgIHJldHVybiBpLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgdSA9IG5ldyBuKGMpO1xuICAgICAgICByZXR1cm4geWllbGQgdS5pbml0KCksIHU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgIHJldHVybiBpLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgeWllbGQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbFJlZik7XG4gICAgfVxuICAgIG9uKGMsIHUpIHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uKGMsIHUpO1xuICAgIH1cbiAgICBvbmNlKGMsIHUpIHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uY2UoYywgdSk7XG4gICAgfVxuICAgIG9mZihjLCB1KSB7XG4gICAgICB0aGlzLmV2ZW50cy5vZmYoYywgdSk7XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVyKGMsIHUpIHtcbiAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGMsIHUpO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgcmV0dXJuIGkuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0aGlzLmludGVydmFsUmVmID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5wdWxzZSgpLCB0LnRvTWlsaXNlY29uZHModGhpcy5pbnRlcnZhbCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHB1bHNlKCkge1xuICAgICAgdGhpcy5ldmVudHMuZW1pdChyLkhFQVJUQkVBVF9FVkVOVFMucHVsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gV2kuSGVhcnRCZWF0ID0gbiwgV2k7XG59XG4oZnVuY3Rpb24oaSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICBjb25zdCBlID0gRnQ7XG4gIGUuX19leHBvcnRTdGFyKGhsKCksIGkpLCBlLl9fZXhwb3J0U3RhcihhYygpLCBpKSwgZS5fX2V4cG9ydFN0YXIoY2MoKSwgaSk7XG59KShXdCk7XG52YXIgZWUgPSB7fSwgU3IsIGxvO1xuZnVuY3Rpb24gdWwoKSB7XG4gIGlmIChsbylcbiAgICByZXR1cm4gU3I7XG4gIGxvID0gMTtcbiAgZnVuY3Rpb24gaSh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAnXCJbQ2lyY3VsYXJdXCInO1xuICAgIH1cbiAgfVxuICBTciA9IGU7XG4gIGZ1bmN0aW9uIGUodCwgcywgcikge1xuICAgIHZhciBuID0gciAmJiByLnN0cmluZ2lmeSB8fCBpLCBvID0gMTtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgYyA9IHMubGVuZ3RoICsgbztcbiAgICAgIGlmIChjID09PSAxKVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIHZhciB1ID0gbmV3IEFycmF5KGMpO1xuICAgICAgdVswXSA9IG4odCk7XG4gICAgICBmb3IgKHZhciBkID0gMTsgZCA8IGM7IGQrKylcbiAgICAgICAgdVtkXSA9IG4oc1tkXSk7XG4gICAgICByZXR1cm4gdS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdDtcbiAgICB2YXIgcCA9IHMubGVuZ3RoO1xuICAgIGlmIChwID09PSAwKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgZm9yICh2YXIgYiA9IFwiXCIsIHggPSAxIC0gbywgTyA9IC0xLCBfID0gdCAmJiB0Lmxlbmd0aCB8fCAwLCBDID0gMDsgQyA8IF87ICkge1xuICAgICAgaWYgKHQuY2hhckNvZGVBdChDKSA9PT0gMzcgJiYgQyArIDEgPCBfKSB7XG4gICAgICAgIHN3aXRjaCAoTyA9IE8gPiAtMSA/IE8gOiAwLCB0LmNoYXJDb2RlQXQoQyArIDEpKSB7XG4gICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgY2FzZSAxMDI6XG4gICAgICAgICAgICBpZiAoeCA+PSBwIHx8IHNbeF0gPT0gbnVsbClcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBPIDwgQyAmJiAoYiArPSB0LnNsaWNlKE8sIEMpKSwgYiArPSBOdW1iZXIoc1t4XSksIE8gPSBDICsgMiwgQysrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDU6XG4gICAgICAgICAgICBpZiAoeCA+PSBwIHx8IHNbeF0gPT0gbnVsbClcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBPIDwgQyAmJiAoYiArPSB0LnNsaWNlKE8sIEMpKSwgYiArPSBNYXRoLmZsb29yKE51bWJlcihzW3hdKSksIE8gPSBDICsgMiwgQysrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OTpcbiAgICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICBjYXNlIDEwNjpcbiAgICAgICAgICAgIGlmICh4ID49IHAgfHwgc1t4XSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIE8gPCBDICYmIChiICs9IHQuc2xpY2UoTywgQykpO1xuICAgICAgICAgICAgdmFyIEYgPSB0eXBlb2Ygc1t4XTtcbiAgICAgICAgICAgIGlmIChGID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIGIgKz0gXCInXCIgKyBzW3hdICsgXCInXCIsIE8gPSBDICsgMiwgQysrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChGID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgYiArPSBzW3hdLm5hbWUgfHwgXCI8YW5vbnltb3VzPlwiLCBPID0gQyArIDIsIEMrKztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiICs9IG4oc1t4XSksIE8gPSBDICsgMiwgQysrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICBpZiAoeCA+PSBwKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIE8gPCBDICYmIChiICs9IHQuc2xpY2UoTywgQykpLCBiICs9IFN0cmluZyhzW3hdKSwgTyA9IEMgKyAyLCBDKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgTyA8IEMgJiYgKGIgKz0gdC5zbGljZShPLCBDKSksIGIgKz0gXCIlXCIsIE8gPSBDICsgMiwgQysrLCB4LS07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICArK3g7XG4gICAgICB9XG4gICAgICArK0M7XG4gICAgfVxuICAgIHJldHVybiBPID09PSAtMSA/IHQgOiAoTyA8IF8gJiYgKGIgKz0gdC5zbGljZShPKSksIGIpO1xuICB9XG4gIHJldHVybiBTcjtcbn1cbnZhciBJciwgZm87XG5mdW5jdGlvbiBsbCgpIHtcbiAgaWYgKGZvKVxuICAgIHJldHVybiBJcjtcbiAgZm8gPSAxO1xuICBjb25zdCBpID0gdWwoKTtcbiAgSXIgPSByO1xuICBjb25zdCBlID0gdygpLmNvbnNvbGUgfHwge30sIHQgPSB7XG4gICAgbWFwSHR0cFJlcXVlc3Q6IF8sXG4gICAgbWFwSHR0cFJlc3BvbnNlOiBfLFxuICAgIHdyYXBSZXF1ZXN0U2VyaWFsaXplcjogQyxcbiAgICB3cmFwUmVzcG9uc2VTZXJpYWxpemVyOiBDLFxuICAgIHdyYXBFcnJvclNlcmlhbGl6ZXI6IEMsXG4gICAgcmVxOiBfLFxuICAgIHJlczogXyxcbiAgICBlcnI6IHhcbiAgfTtcbiAgZnVuY3Rpb24gcyhmLCBhKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZikgPyBmLmZpbHRlcihmdW5jdGlvbihMKSB7XG4gICAgICByZXR1cm4gTCAhPT0gXCIhc3RkU2VyaWFsaXplcnMuZXJyXCI7XG4gICAgfSkgOiBmID09PSAhMCA/IE9iamVjdC5rZXlzKGEpIDogITE7XG4gIH1cbiAgZnVuY3Rpb24gcihmKSB7XG4gICAgZiA9IGYgfHwge30sIGYuYnJvd3NlciA9IGYuYnJvd3NlciB8fCB7fTtcbiAgICBjb25zdCBhID0gZi5icm93c2VyLnRyYW5zbWl0O1xuICAgIGlmIChhICYmIHR5cGVvZiBhLnNlbmQgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgRXJyb3IoXCJwaW5vOiB0cmFuc21pdCBvcHRpb24gbXVzdCBoYXZlIGEgc2VuZCBmdW5jdGlvblwiKTtcbiAgICBjb25zdCBsID0gZi5icm93c2VyLndyaXRlIHx8IGU7XG4gICAgZi5icm93c2VyLndyaXRlICYmIChmLmJyb3dzZXIuYXNPYmplY3QgPSAhMCk7XG4gICAgY29uc3QgTCA9IGYuc2VyaWFsaXplcnMgfHwge30sIHYgPSBzKGYuYnJvd3Nlci5zZXJpYWxpemUsIEwpO1xuICAgIGxldCBSID0gZi5icm93c2VyLnNlcmlhbGl6ZTtcbiAgICBBcnJheS5pc0FycmF5KGYuYnJvd3Nlci5zZXJpYWxpemUpICYmIGYuYnJvd3Nlci5zZXJpYWxpemUuaW5kZXhPZihcIiFzdGRTZXJpYWxpemVycy5lcnJcIikgPiAtMSAmJiAoUiA9ICExKTtcbiAgICBjb25zdCAkID0gW1wiZXJyb3JcIiwgXCJmYXRhbFwiLCBcIndhcm5cIiwgXCJpbmZvXCIsIFwiZGVidWdcIiwgXCJ0cmFjZVwiXTtcbiAgICB0eXBlb2YgbCA9PSBcImZ1bmN0aW9uXCIgJiYgKGwuZXJyb3IgPSBsLmZhdGFsID0gbC53YXJuID0gbC5pbmZvID0gbC5kZWJ1ZyA9IGwudHJhY2UgPSBsKSwgZi5lbmFibGVkID09PSAhMSAmJiAoZi5sZXZlbCA9IFwic2lsZW50XCIpO1xuICAgIGNvbnN0IHEgPSBmLmxldmVsIHx8IFwiaW5mb1wiLCBtID0gT2JqZWN0LmNyZWF0ZShsKTtcbiAgICBtLmxvZyB8fCAobS5sb2cgPSBGKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG0sIFwibGV2ZWxWYWxcIiwge1xuICAgICAgZ2V0OiBCXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtLCBcImxldmVsXCIsIHtcbiAgICAgIGdldDogeixcbiAgICAgIHNldDogalxuICAgIH0pO1xuICAgIGNvbnN0IEUgPSB7XG4gICAgICB0cmFuc21pdDogYSxcbiAgICAgIHNlcmlhbGl6ZTogdixcbiAgICAgIGFzT2JqZWN0OiBmLmJyb3dzZXIuYXNPYmplY3QsXG4gICAgICBsZXZlbHM6ICQsXG4gICAgICB0aW1lc3RhbXA6IE8oZilcbiAgICB9O1xuICAgIG0ubGV2ZWxzID0gci5sZXZlbHMsIG0ubGV2ZWwgPSBxLCBtLnNldE1heExpc3RlbmVycyA9IG0uZ2V0TWF4TGlzdGVuZXJzID0gbS5lbWl0ID0gbS5hZGRMaXN0ZW5lciA9IG0ub24gPSBtLnByZXBlbmRMaXN0ZW5lciA9IG0ub25jZSA9IG0ucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG0ucmVtb3ZlTGlzdGVuZXIgPSBtLnJlbW92ZUFsbExpc3RlbmVycyA9IG0ubGlzdGVuZXJzID0gbS5saXN0ZW5lckNvdW50ID0gbS5ldmVudE5hbWVzID0gbS53cml0ZSA9IG0uZmx1c2ggPSBGLCBtLnNlcmlhbGl6ZXJzID0gTCwgbS5fc2VyaWFsaXplID0gdiwgbS5fc3RkRXJyU2VyaWFsaXplID0gUiwgbS5jaGlsZCA9IFUsIGEgJiYgKG0uX2xvZ0V2ZW50ID0gYigpKTtcbiAgICBmdW5jdGlvbiBCKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWwgPT09IFwic2lsZW50XCIgPyAxIC8gMCA6IHRoaXMubGV2ZWxzLnZhbHVlc1t0aGlzLmxldmVsXTtcbiAgICB9XG4gICAgZnVuY3Rpb24geigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaihNKSB7XG4gICAgICBpZiAoTSAhPT0gXCJzaWxlbnRcIiAmJiAhdGhpcy5sZXZlbHMudmFsdWVzW01dKVxuICAgICAgICB0aHJvdyBFcnJvcihcInVua25vd24gbGV2ZWwgXCIgKyBNKTtcbiAgICAgIHRoaXMuX2xldmVsID0gTSwgbihFLCBtLCBcImVycm9yXCIsIFwibG9nXCIpLCBuKEUsIG0sIFwiZmF0YWxcIiwgXCJlcnJvclwiKSwgbihFLCBtLCBcIndhcm5cIiwgXCJlcnJvclwiKSwgbihFLCBtLCBcImluZm9cIiwgXCJsb2dcIiksIG4oRSwgbSwgXCJkZWJ1Z1wiLCBcImxvZ1wiKSwgbihFLCBtLCBcInRyYWNlXCIsIFwibG9nXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVKE0sIEgpIHtcbiAgICAgIGlmICghTSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBiaW5kaW5ncyBmb3IgY2hpbGQgUGlub1wiKTtcbiAgICAgIEggPSBIIHx8IHt9LCB2ICYmIE0uc2VyaWFsaXplcnMgJiYgKEguc2VyaWFsaXplcnMgPSBNLnNlcmlhbGl6ZXJzKTtcbiAgICAgIGNvbnN0IHRlID0gSC5zZXJpYWxpemVycztcbiAgICAgIGlmICh2ICYmIHRlKSB7XG4gICAgICAgIHZhciBHID0gT2JqZWN0LmFzc2lnbih7fSwgTCwgdGUpLCBpZSA9IGYuYnJvd3Nlci5zZXJpYWxpemUgPT09ICEwID8gT2JqZWN0LmtleXMoRykgOiB2O1xuICAgICAgICBkZWxldGUgTS5zZXJpYWxpemVycywgdShbTV0sIGllLCBHLCB0aGlzLl9zdGRFcnJTZXJpYWxpemUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gUShzZSkge1xuICAgICAgICB0aGlzLl9jaGlsZExldmVsID0gKHNlLl9jaGlsZExldmVsIHwgMCkgKyAxLCB0aGlzLmVycm9yID0gZChzZSwgTSwgXCJlcnJvclwiKSwgdGhpcy5mYXRhbCA9IGQoc2UsIE0sIFwiZmF0YWxcIiksIHRoaXMud2FybiA9IGQoc2UsIE0sIFwid2FyblwiKSwgdGhpcy5pbmZvID0gZChzZSwgTSwgXCJpbmZvXCIpLCB0aGlzLmRlYnVnID0gZChzZSwgTSwgXCJkZWJ1Z1wiKSwgdGhpcy50cmFjZSA9IGQoc2UsIE0sIFwidHJhY2VcIiksIEcgJiYgKHRoaXMuc2VyaWFsaXplcnMgPSBHLCB0aGlzLl9zZXJpYWxpemUgPSBpZSksIGEgJiYgKHRoaXMuX2xvZ0V2ZW50ID0gYihcbiAgICAgICAgICBbXS5jb25jYXQoc2UuX2xvZ0V2ZW50LmJpbmRpbmdzLCBNKVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBRLnByb3RvdHlwZSA9IHRoaXMsIG5ldyBRKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfVxuICByLmxldmVscyA9IHtcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGZhdGFsOiA2MCxcbiAgICAgIGVycm9yOiA1MCxcbiAgICAgIHdhcm46IDQwLFxuICAgICAgaW5mbzogMzAsXG4gICAgICBkZWJ1ZzogMjAsXG4gICAgICB0cmFjZTogMTBcbiAgICB9LFxuICAgIGxhYmVsczoge1xuICAgICAgMTA6IFwidHJhY2VcIixcbiAgICAgIDIwOiBcImRlYnVnXCIsXG4gICAgICAzMDogXCJpbmZvXCIsXG4gICAgICA0MDogXCJ3YXJuXCIsXG4gICAgICA1MDogXCJlcnJvclwiLFxuICAgICAgNjA6IFwiZmF0YWxcIlxuICAgIH1cbiAgfSwgci5zdGRTZXJpYWxpemVycyA9IHQsIHIuc3RkVGltZUZ1bmN0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHsgbnVsbFRpbWU6IEssIGVwb2NoVGltZTogSSwgdW5peFRpbWU6IEQsIGlzb1RpbWU6IHkgfSk7XG4gIGZ1bmN0aW9uIG4oZiwgYSwgbCwgTCkge1xuICAgIGNvbnN0IHYgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSk7XG4gICAgYVtsXSA9IGEubGV2ZWxWYWwgPiBhLmxldmVscy52YWx1ZXNbbF0gPyBGIDogdltsXSA/IHZbbF0gOiBlW2xdIHx8IGVbTF0gfHwgRiwgbyhmLCBhLCBsKTtcbiAgfVxuICBmdW5jdGlvbiBvKGYsIGEsIGwpIHtcbiAgICAhZi50cmFuc21pdCAmJiBhW2xdID09PSBGIHx8IChhW2xdID0gZnVuY3Rpb24oTCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBSID0gZi50aW1lc3RhbXAoKSwgJCA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSwgcSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykgPT09IGUgPyBlIDogdGhpcztcbiAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCAkLmxlbmd0aDsgbSsrKVxuICAgICAgICAgICRbbV0gPSBhcmd1bWVudHNbbV07XG4gICAgICAgIGlmIChmLnNlcmlhbGl6ZSAmJiAhZi5hc09iamVjdCAmJiB1KCQsIHRoaXMuX3NlcmlhbGl6ZSwgdGhpcy5zZXJpYWxpemVycywgdGhpcy5fc3RkRXJyU2VyaWFsaXplKSwgZi5hc09iamVjdCA/IEwuY2FsbChxLCBjKHRoaXMsIGwsICQsIFIpKSA6IEwuYXBwbHkocSwgJCksIGYudHJhbnNtaXQpIHtcbiAgICAgICAgICBjb25zdCBFID0gZi50cmFuc21pdC5sZXZlbCB8fCBhLmxldmVsLCBCID0gci5sZXZlbHMudmFsdWVzW0VdLCB6ID0gci5sZXZlbHMudmFsdWVzW2xdO1xuICAgICAgICAgIGlmICh6IDwgQilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBwKHRoaXMsIHtcbiAgICAgICAgICAgIHRzOiBSLFxuICAgICAgICAgICAgbWV0aG9kTGV2ZWw6IGwsXG4gICAgICAgICAgICBtZXRob2RWYWx1ZTogeixcbiAgICAgICAgICAgIHRyYW5zbWl0TGV2ZWw6IEUsXG4gICAgICAgICAgICB0cmFuc21pdFZhbHVlOiByLmxldmVscy52YWx1ZXNbZi50cmFuc21pdC5sZXZlbCB8fCBhLmxldmVsXSxcbiAgICAgICAgICAgIHNlbmQ6IGYudHJhbnNtaXQuc2VuZCxcbiAgICAgICAgICAgIHZhbDogYS5sZXZlbFZhbFxuICAgICAgICAgIH0sICQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oYVtsXSkpO1xuICB9XG4gIGZ1bmN0aW9uIGMoZiwgYSwgbCwgTCkge1xuICAgIGYuX3NlcmlhbGl6ZSAmJiB1KGwsIGYuX3NlcmlhbGl6ZSwgZi5zZXJpYWxpemVycywgZi5fc3RkRXJyU2VyaWFsaXplKTtcbiAgICBjb25zdCB2ID0gbC5zbGljZSgpO1xuICAgIGxldCBSID0gdlswXTtcbiAgICBjb25zdCAkID0ge307XG4gICAgTCAmJiAoJC50aW1lID0gTCksICQubGV2ZWwgPSByLmxldmVscy52YWx1ZXNbYV07XG4gICAgbGV0IHEgPSAoZi5fY2hpbGRMZXZlbCB8IDApICsgMTtcbiAgICBpZiAocSA8IDEgJiYgKHEgPSAxKSwgUiAhPT0gbnVsbCAmJiB0eXBlb2YgUiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKDsgcS0tICYmIHR5cGVvZiB2WzBdID09IFwib2JqZWN0XCI7IClcbiAgICAgICAgT2JqZWN0LmFzc2lnbigkLCB2LnNoaWZ0KCkpO1xuICAgICAgUiA9IHYubGVuZ3RoID8gaSh2LnNoaWZ0KCksIHYpIDogdm9pZCAwO1xuICAgIH0gZWxzZVxuICAgICAgdHlwZW9mIFIgPT0gXCJzdHJpbmdcIiAmJiAoUiA9IGkodi5zaGlmdCgpLCB2KSk7XG4gICAgcmV0dXJuIFIgIT09IHZvaWQgMCAmJiAoJC5tc2cgPSBSKSwgJDtcbiAgfVxuICBmdW5jdGlvbiB1KGYsIGEsIGwsIEwpIHtcbiAgICBmb3IgKGNvbnN0IHYgaW4gZilcbiAgICAgIGlmIChMICYmIGZbdl0gaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgZlt2XSA9IHIuc3RkU2VyaWFsaXplcnMuZXJyKGZbdl0pO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGZbdl0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShmW3ZdKSlcbiAgICAgICAgZm9yIChjb25zdCBSIGluIGZbdl0pXG4gICAgICAgICAgYSAmJiBhLmluZGV4T2YoUikgPiAtMSAmJiBSIGluIGwgJiYgKGZbdl1bUl0gPSBsW1JdKGZbdl1bUl0pKTtcbiAgfVxuICBmdW5jdGlvbiBkKGYsIGEsIGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBMID0gbmV3IEFycmF5KDEgKyBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIExbMF0gPSBhO1xuICAgICAgZm9yICh2YXIgdiA9IDE7IHYgPCBMLmxlbmd0aDsgdisrKVxuICAgICAgICBMW3ZdID0gYXJndW1lbnRzW3YgLSAxXTtcbiAgICAgIHJldHVybiBmW2xdLmFwcGx5KHRoaXMsIEwpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcChmLCBhLCBsKSB7XG4gICAgY29uc3QgTCA9IGEuc2VuZCwgdiA9IGEudHMsIFIgPSBhLm1ldGhvZExldmVsLCAkID0gYS5tZXRob2RWYWx1ZSwgcSA9IGEudmFsLCBtID0gZi5fbG9nRXZlbnQuYmluZGluZ3M7XG4gICAgdShcbiAgICAgIGwsXG4gICAgICBmLl9zZXJpYWxpemUgfHwgT2JqZWN0LmtleXMoZi5zZXJpYWxpemVycyksXG4gICAgICBmLnNlcmlhbGl6ZXJzLFxuICAgICAgZi5fc3RkRXJyU2VyaWFsaXplID09PSB2b2lkIDAgPyAhMCA6IGYuX3N0ZEVyclNlcmlhbGl6ZVxuICAgICksIGYuX2xvZ0V2ZW50LnRzID0gdiwgZi5fbG9nRXZlbnQubWVzc2FnZXMgPSBsLmZpbHRlcihmdW5jdGlvbihFKSB7XG4gICAgICByZXR1cm4gbS5pbmRleE9mKEUpID09PSAtMTtcbiAgICB9KSwgZi5fbG9nRXZlbnQubGV2ZWwubGFiZWwgPSBSLCBmLl9sb2dFdmVudC5sZXZlbC52YWx1ZSA9ICQsIEwoUiwgZi5fbG9nRXZlbnQsIHEpLCBmLl9sb2dFdmVudCA9IGIobSk7XG4gIH1cbiAgZnVuY3Rpb24gYihmKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRzOiAwLFxuICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgYmluZGluZ3M6IGYgfHwgW10sXG4gICAgICBsZXZlbDogeyBsYWJlbDogXCJcIiwgdmFsdWU6IDAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24geChmKSB7XG4gICAgY29uc3QgYSA9IHtcbiAgICAgIHR5cGU6IGYuY29uc3RydWN0b3IubmFtZSxcbiAgICAgIG1zZzogZi5tZXNzYWdlLFxuICAgICAgc3RhY2s6IGYuc3RhY2tcbiAgICB9O1xuICAgIGZvciAoY29uc3QgbCBpbiBmKVxuICAgICAgYVtsXSA9PT0gdm9pZCAwICYmIChhW2xdID0gZltsXSk7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgZnVuY3Rpb24gTyhmKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBmLnRpbWVzdGFtcCA9PSBcImZ1bmN0aW9uXCIgPyBmLnRpbWVzdGFtcCA6IGYudGltZXN0YW1wID09PSAhMSA/IEsgOiBJO1xuICB9XG4gIGZ1bmN0aW9uIF8oKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGZ1bmN0aW9uIEMoZikge1xuICAgIHJldHVybiBmO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7XG4gIH1cbiAgZnVuY3Rpb24gSygpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gSSgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfVxuICBmdW5jdGlvbiBEKCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpO1xuICB9XG4gIGZ1bmN0aW9uIHkoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUubm93KCkpLnRvSVNPU3RyaW5nKCk7XG4gIH1cbiAgZnVuY3Rpb24gdygpIHtcbiAgICBmdW5jdGlvbiBmKGEpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgYSA8IFwidVwiICYmIGE7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgXCJnbG9iYWxUaGlzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuZ2xvYmFsVGhpcywgdGhpcy5nbG9iYWxUaGlzID0gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIGdsb2JhbFRoaXM7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZihzZWxmKSB8fCBmKHdpbmRvdykgfHwgZih0aGlzKSB8fCB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIElyO1xufVxudmFyIHZpID0ge30sIHBvO1xuZnVuY3Rpb24gaGMoKSB7XG4gIHJldHVybiBwbyB8fCAocG8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodmksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdmkuUElOT19DVVNUT01fQ09OVEVYVF9LRVkgPSB2aS5QSU5PX0xPR0dFUl9ERUZBVUxUUyA9IHZvaWQgMCwgdmkuUElOT19MT0dHRVJfREVGQVVMVFMgPSB7XG4gICAgbGV2ZWw6IFwiaW5mb1wiXG4gIH0sIHZpLlBJTk9fQ1VTVE9NX0NPTlRFWFRfS0VZID0gXCJjdXN0b21fY29udGV4dFwiKSwgdmk7XG59XG52YXIgeXQgPSB7fSwgZ287XG5mdW5jdGlvbiBkbCgpIHtcbiAgaWYgKGdvKVxuICAgIHJldHVybiB5dDtcbiAgZ28gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoeXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgeXQuZ2VuZXJhdGVDaGlsZExvZ2dlciA9IHl0LmZvcm1hdENoaWxkTG9nZ2VyQ29udGV4dCA9IHl0LmdldExvZ2dlckNvbnRleHQgPSB5dC5zZXRCcm93c2VyTG9nZ2VyQ29udGV4dCA9IHl0LmdldEJyb3dzZXJMb2dnZXJDb250ZXh0ID0geXQuZ2V0RGVmYXVsdExvZ2dlck9wdGlvbnMgPSB2b2lkIDA7XG4gIGNvbnN0IGkgPSBoYygpO1xuICBmdW5jdGlvbiBlKGMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjKSwgeyBsZXZlbDogYz8ubGV2ZWwgfHwgaS5QSU5PX0xPR0dFUl9ERUZBVUxUUy5sZXZlbCB9KTtcbiAgfVxuICB5dC5nZXREZWZhdWx0TG9nZ2VyT3B0aW9ucyA9IGU7XG4gIGZ1bmN0aW9uIHQoYywgdSA9IGkuUElOT19DVVNUT01fQ09OVEVYVF9LRVkpIHtcbiAgICByZXR1cm4gY1t1XSB8fCBcIlwiO1xuICB9XG4gIHl0LmdldEJyb3dzZXJMb2dnZXJDb250ZXh0ID0gdDtcbiAgZnVuY3Rpb24gcyhjLCB1LCBkID0gaS5QSU5PX0NVU1RPTV9DT05URVhUX0tFWSkge1xuICAgIHJldHVybiBjW2RdID0gdSwgYztcbiAgfVxuICB5dC5zZXRCcm93c2VyTG9nZ2VyQ29udGV4dCA9IHM7XG4gIGZ1bmN0aW9uIHIoYywgdSA9IGkuUElOT19DVVNUT01fQ09OVEVYVF9LRVkpIHtcbiAgICBsZXQgZCA9IFwiXCI7XG4gICAgcmV0dXJuIHR5cGVvZiBjLmJpbmRpbmdzID4gXCJ1XCIgPyBkID0gdChjLCB1KSA6IGQgPSBjLmJpbmRpbmdzKCkuY29udGV4dCB8fCBcIlwiLCBkO1xuICB9XG4gIHl0LmdldExvZ2dlckNvbnRleHQgPSByO1xuICBmdW5jdGlvbiBuKGMsIHUsIGQgPSBpLlBJTk9fQ1VTVE9NX0NPTlRFWFRfS0VZKSB7XG4gICAgY29uc3QgcCA9IHIoYywgZCk7XG4gICAgcmV0dXJuIHAudHJpbSgpID8gYCR7cH0vJHt1fWAgOiB1O1xuICB9XG4gIHl0LmZvcm1hdENoaWxkTG9nZ2VyQ29udGV4dCA9IG47XG4gIGZ1bmN0aW9uIG8oYywgdSwgZCA9IGkuUElOT19DVVNUT01fQ09OVEVYVF9LRVkpIHtcbiAgICBjb25zdCBwID0gbihjLCB1LCBkKSwgYiA9IGMuY2hpbGQoeyBjb250ZXh0OiBwIH0pO1xuICAgIHJldHVybiBzKGIsIHAsIGQpO1xuICB9XG4gIHJldHVybiB5dC5nZW5lcmF0ZUNoaWxkTG9nZ2VyID0gbywgeXQ7XG59XG4oZnVuY3Rpb24oaSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBpLnBpbm8gPSB2b2lkIDA7XG4gIGNvbnN0IGUgPSBGdCwgdCA9IGUuX19pbXBvcnREZWZhdWx0KGxsKCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJwaW5vXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuZGVmYXVsdDtcbiAgfSB9KSwgZS5fX2V4cG9ydFN0YXIoaGMoKSwgaSksIGUuX19leHBvcnRTdGFyKGRsKCksIGkpO1xufSkoZWUpO1xubGV0IGZsID0gY2xhc3MgZXh0ZW5kcyBOdCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLm9wdHMgPSBlLCB0aGlzLnByb3RvY29sID0gXCJ3Y1wiLCB0aGlzLnZlcnNpb24gPSAyO1xuICB9XG59LCBwbCA9IGNsYXNzIGV4dGVuZHMgTnQge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLnJlY29yZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG59LCBnbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMubG9nZ2VyID0gZSwgdGhpcy5jb3JlID0gdDtcbiAgfVxufSwgeWwgPSBjbGFzcyBleHRlbmRzIE50IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKCksIHRoaXMucmVsYXllciA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufSwgbWwgPSBjbGFzcyBleHRlbmRzIE50IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCk7XG4gIH1cbn0sIGJsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzLCByKSB7XG4gICAgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLm5hbWUgPSBzO1xuICB9XG59LCB3bCA9IGNsYXNzIGV4dGVuZHMgTnQge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59LCB2bCA9IGNsYXNzIGV4dGVuZHMgTnQge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59LCBfbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMucHJvamVjdElkID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59LCBFbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMub3B0cyA9IGUsIHRoaXMucHJvdG9jb2wgPSBcIndjXCIsIHRoaXMudmVyc2lvbiA9IDI7XG4gIH1cbn0sIFNsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5jbGllbnQgPSBlO1xuICB9XG59O1xuY29uc3QgSWwgPSAoaSkgPT4gSlNPTi5zdHJpbmdpZnkoaSwgKGUsIHQpID0+IHR5cGVvZiB0ID09IFwiYmlnaW50XCIgPyB0LnRvU3RyaW5nKCkgKyBcIm5cIiA6IHQpLCBEbCA9IChpKSA9PiB7XG4gIGNvbnN0IGUgPSAvKFtcXFs6XSk/KFxcZHsxNyx9fCg/Ols5XSg/OlsxLTldMDcxOTkyNTQ3NDA5OTF8MFsxLTldNzE5OTI1NDc0MDk5MXwwMFs4LTldMTk5MjU0NzQwOTkxfDAwN1syLTldOTkyNTQ3NDA5OTF8MDA3MTk5WzMtOV01NDc0MDk5MXwwMDcxOTkyWzYtOV00NzQwOTkxfDAwNzE5OTI1WzUtOV03NDA5OTF8MDA3MTk5MjU0WzgtOV00MDk5MXwwMDcxOTkyNTQ3WzUtOV0wOTkxfDAwNzE5OTI1NDc0WzEtOV05OTF8MDA3MTk5MjU0NzQwOTlbMi05XSkpKShbLFxcfVxcXV0pL2csIHQgPSBpLnJlcGxhY2UoZSwgJyQxXCIkMm5cIiQzJyk7XG4gIHJldHVybiBKU09OLnBhcnNlKHQsIChzLCByKSA9PiB0eXBlb2YgciA9PSBcInN0cmluZ1wiICYmIHIubWF0Y2goL15cXGQrbiQvKSA/IEJpZ0ludChyLnN1YnN0cmluZygwLCByLmxlbmd0aCAtIDEpKSA6IHIpO1xufTtcbmZ1bmN0aW9uIHJuKGkpIHtcbiAgaWYgKHR5cGVvZiBpICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2FmZSBqc29uIHBhcnNlIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgaX1gKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRGwoaSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBpO1xuICB9XG59XG5mdW5jdGlvbiBycihpKSB7XG4gIHJldHVybiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gaSA6IElsKGkpIHx8IFwiXCI7XG59XG52YXIgbm4gPSB7fSwgbGkgPSB7fSwgbnIgPSB7fSwgb3IgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShvciwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xub3IuQnJvd3NlclJhbmRvbVNvdXJjZSA9IHZvaWQgMDtcbmNvbnN0IHlvID0gNjU1MzY7XG5jbGFzcyB4bCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaXNBdmFpbGFibGUgPSAhMSwgdGhpcy5pc0luc3RhbnRpYXRlZCA9ICExO1xuICAgIGNvbnN0IGUgPSB0eXBlb2Ygc2VsZiA8IFwidVwiID8gc2VsZi5jcnlwdG8gfHwgc2VsZi5tc0NyeXB0byA6IG51bGw7XG4gICAgZSAmJiBlLmdldFJhbmRvbVZhbHVlcyAhPT0gdm9pZCAwICYmICh0aGlzLl9jcnlwdG8gPSBlLCB0aGlzLmlzQXZhaWxhYmxlID0gITAsIHRoaXMuaXNJbnN0YW50aWF0ZWQgPSAhMCk7XG4gIH1cbiAgcmFuZG9tQnl0ZXMoZSkge1xuICAgIGlmICghdGhpcy5pc0F2YWlsYWJsZSB8fCAhdGhpcy5fY3J5cHRvKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlciByYW5kb20gYnl0ZSBnZW5lcmF0b3IgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgY29uc3QgdCA9IG5ldyBVaW50OEFycmF5KGUpO1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMgKz0geW8pXG4gICAgICB0aGlzLl9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHQuc3ViYXJyYXkocywgcyArIE1hdGgubWluKHQubGVuZ3RoIC0gcywgeW8pKSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbn1cbm9yLkJyb3dzZXJSYW5kb21Tb3VyY2UgPSB4bDtcbmZ1bmN0aW9uIE9sKGkpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZHluYW1pY2FsbHkgcmVxdWlyZSBcIicgKyBpICsgJ1wiLiBQbGVhc2UgY29uZmlndXJlIHRoZSBkeW5hbWljUmVxdWlyZVRhcmdldHMgb3IvYW5kIGlnbm9yZUR5bmFtaWNSZXF1aXJlcyBvcHRpb24gb2YgQHJvbGx1cC9wbHVnaW4tY29tbW9uanMgYXBwcm9wcmlhdGVseSBmb3IgdGhpcyByZXF1aXJlIGNhbGwgdG8gd29yay4nKTtcbn1cbnZhciBhciA9IHt9LCBQdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFB0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5mdW5jdGlvbiBObChpKSB7XG4gIGZvciAodmFyIGUgPSAwOyBlIDwgaS5sZW5ndGg7IGUrKylcbiAgICBpW2VdID0gMDtcbiAgcmV0dXJuIGk7XG59XG5QdC53aXBlID0gTmw7XG5jb25zdCBQbCA9IHt9LCBSbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHQ6IFBsXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBDbCA9IC8qIEBfX1BVUkVfXyAqLyBXYShSbCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYXIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmFyLk5vZGVSYW5kb21Tb3VyY2UgPSB2b2lkIDA7XG5jb25zdCBBbCA9IFB0O1xuY2xhc3MgVGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5pc0F2YWlsYWJsZSA9ICExLCB0aGlzLmlzSW5zdGFudGlhdGVkID0gITEsIHR5cGVvZiBPbCA8IFwidVwiKSB7XG4gICAgICBjb25zdCBlID0gQ2w7XG4gICAgICBlICYmIGUucmFuZG9tQnl0ZXMgJiYgKHRoaXMuX2NyeXB0byA9IGUsIHRoaXMuaXNBdmFpbGFibGUgPSAhMCwgdGhpcy5pc0luc3RhbnRpYXRlZCA9ICEwKTtcbiAgICB9XG4gIH1cbiAgcmFuZG9tQnl0ZXMoZSkge1xuICAgIGlmICghdGhpcy5pc0F2YWlsYWJsZSB8fCAhdGhpcy5fY3J5cHRvKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZS5qcyByYW5kb20gYnl0ZSBnZW5lcmF0b3IgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgbGV0IHQgPSB0aGlzLl9jcnlwdG8ucmFuZG9tQnl0ZXMoZSk7XG4gICAgaWYgKHQubGVuZ3RoICE9PSBlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZVJhbmRvbVNvdXJjZTogZ290IGZld2VyIGJ5dGVzIHRoYW4gcmVxdWVzdGVkXCIpO1xuICAgIGNvbnN0IHMgPSBuZXcgVWludDhBcnJheShlKTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHMubGVuZ3RoOyByKyspXG4gICAgICBzW3JdID0gdFtyXTtcbiAgICByZXR1cm4gKDAsIEFsLndpcGUpKHQpLCBzO1xuICB9XG59XG5hci5Ob2RlUmFuZG9tU291cmNlID0gVGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkobnIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbm5yLlN5c3RlbVJhbmRvbVNvdXJjZSA9IHZvaWQgMDtcbmNvbnN0ICRsID0gb3IsIEZsID0gYXI7XG5jbGFzcyBVbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmlzQXZhaWxhYmxlID0gITEsIHRoaXMubmFtZSA9IFwiXCIsIHRoaXMuX3NvdXJjZSA9IG5ldyAkbC5Ccm93c2VyUmFuZG9tU291cmNlKCksIHRoaXMuX3NvdXJjZS5pc0F2YWlsYWJsZSkge1xuICAgICAgdGhpcy5pc0F2YWlsYWJsZSA9ICEwLCB0aGlzLm5hbWUgPSBcIkJyb3dzZXJcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZSA9IG5ldyBGbC5Ob2RlUmFuZG9tU291cmNlKCksIHRoaXMuX3NvdXJjZS5pc0F2YWlsYWJsZSkge1xuICAgICAgdGhpcy5pc0F2YWlsYWJsZSA9ICEwLCB0aGlzLm5hbWUgPSBcIk5vZGVcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmFuZG9tQnl0ZXMoZSkge1xuICAgIGlmICghdGhpcy5pc0F2YWlsYWJsZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5c3RlbSByYW5kb20gYnl0ZSBnZW5lcmF0b3IgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5yYW5kb21CeXRlcyhlKTtcbiAgfVxufVxubnIuU3lzdGVtUmFuZG9tU291cmNlID0gVWw7XG52YXIgb2UgPSB7fSwgdWMgPSB7fTtcbihmdW5jdGlvbihpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIGZ1bmN0aW9uIGUoYywgdSkge1xuICAgIHZhciBkID0gYyA+Pj4gMTYgJiA2NTUzNSwgcCA9IGMgJiA2NTUzNSwgYiA9IHUgPj4+IDE2ICYgNjU1MzUsIHggPSB1ICYgNjU1MzU7XG4gICAgcmV0dXJuIHAgKiB4ICsgKGQgKiB4ICsgcCAqIGIgPDwgMTYgPj4+IDApIHwgMDtcbiAgfVxuICBpLm11bCA9IE1hdGguaW11bCB8fCBlO1xuICBmdW5jdGlvbiB0KGMsIHUpIHtcbiAgICByZXR1cm4gYyArIHUgfCAwO1xuICB9XG4gIGkuYWRkID0gdDtcbiAgZnVuY3Rpb24gcyhjLCB1KSB7XG4gICAgcmV0dXJuIGMgLSB1IHwgMDtcbiAgfVxuICBpLnN1YiA9IHM7XG4gIGZ1bmN0aW9uIHIoYywgdSkge1xuICAgIHJldHVybiBjIDw8IHUgfCBjID4+PiAzMiAtIHU7XG4gIH1cbiAgaS5yb3RsID0gcjtcbiAgZnVuY3Rpb24gbihjLCB1KSB7XG4gICAgcmV0dXJuIGMgPDwgMzIgLSB1IHwgYyA+Pj4gdTtcbiAgfVxuICBpLnJvdHIgPSBuO1xuICBmdW5jdGlvbiBvKGMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGMgPT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZShjKSAmJiBNYXRoLmZsb29yKGMpID09PSBjO1xuICB9XG4gIGkuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCBvLCBpLk1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLCBpLmlzU2FmZUludGVnZXIgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIGkuaXNJbnRlZ2VyKGMpICYmIGMgPj0gLWkuTUFYX1NBRkVfSU5URUdFUiAmJiBjIDw9IGkuTUFYX1NBRkVfSU5URUdFUjtcbiAgfTtcbn0pKHVjKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShvZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGxjID0gdWM7XG5mdW5jdGlvbiBMbChpLCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgKGlbZSArIDBdIDw8IDggfCBpW2UgKyAxXSkgPDwgMTYgPj4gMTY7XG59XG5vZS5yZWFkSW50MTZCRSA9IExsO1xuZnVuY3Rpb24gTWwoaSwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gMCksIChpW2UgKyAwXSA8PCA4IHwgaVtlICsgMV0pID4+PiAwO1xufVxub2UucmVhZFVpbnQxNkJFID0gTWw7XG5mdW5jdGlvbiBxbChpLCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgKGlbZSArIDFdIDw8IDggfCBpW2VdKSA8PCAxNiA+PiAxNjtcbn1cbm9lLnJlYWRJbnQxNkxFID0gcWw7XG5mdW5jdGlvbiBqbChpLCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgKGlbZSArIDFdIDw8IDggfCBpW2VdKSA+Pj4gMDtcbn1cbm9lLnJlYWRVaW50MTZMRSA9IGpsO1xuZnVuY3Rpb24gZGMoaSwgZSwgdCkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoMikpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKSwgZVt0ICsgMF0gPSBpID4+PiA4LCBlW3QgKyAxXSA9IGkgPj4+IDAsIGU7XG59XG5vZS53cml0ZVVpbnQxNkJFID0gZGM7XG5vZS53cml0ZUludDE2QkUgPSBkYztcbmZ1bmN0aW9uIGZjKGksIGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBVaW50OEFycmF5KDIpKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCksIGVbdCArIDBdID0gaSA+Pj4gMCwgZVt0ICsgMV0gPSBpID4+PiA4LCBlO1xufVxub2Uud3JpdGVVaW50MTZMRSA9IGZjO1xub2Uud3JpdGVJbnQxNkxFID0gZmM7XG5mdW5jdGlvbiBNcihpLCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgaVtlXSA8PCAyNCB8IGlbZSArIDFdIDw8IDE2IHwgaVtlICsgMl0gPDwgOCB8IGlbZSArIDNdO1xufVxub2UucmVhZEludDMyQkUgPSBNcjtcbmZ1bmN0aW9uIHFyKGksIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApLCAoaVtlXSA8PCAyNCB8IGlbZSArIDFdIDw8IDE2IHwgaVtlICsgMl0gPDwgOCB8IGlbZSArIDNdKSA+Pj4gMDtcbn1cbm9lLnJlYWRVaW50MzJCRSA9IHFyO1xuZnVuY3Rpb24ganIoaSwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gMCksIGlbZSArIDNdIDw8IDI0IHwgaVtlICsgMl0gPDwgMTYgfCBpW2UgKyAxXSA8PCA4IHwgaVtlXTtcbn1cbm9lLnJlYWRJbnQzMkxFID0ganI7XG5mdW5jdGlvbiB6cihpLCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgKGlbZSArIDNdIDw8IDI0IHwgaVtlICsgMl0gPDwgMTYgfCBpW2UgKyAxXSA8PCA4IHwgaVtlXSkgPj4+IDA7XG59XG5vZS5yZWFkVWludDMyTEUgPSB6cjtcbmZ1bmN0aW9uIGtzKGksIGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBVaW50OEFycmF5KDQpKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCksIGVbdCArIDBdID0gaSA+Pj4gMjQsIGVbdCArIDFdID0gaSA+Pj4gMTYsIGVbdCArIDJdID0gaSA+Pj4gOCwgZVt0ICsgM10gPSBpID4+PiAwLCBlO1xufVxub2Uud3JpdGVVaW50MzJCRSA9IGtzO1xub2Uud3JpdGVJbnQzMkJFID0ga3M7XG5mdW5jdGlvbiBIcyhpLCBlLCB0KSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgVWludDhBcnJheSg0KSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDApLCBlW3QgKyAwXSA9IGkgPj4+IDAsIGVbdCArIDFdID0gaSA+Pj4gOCwgZVt0ICsgMl0gPSBpID4+PiAxNiwgZVt0ICsgM10gPSBpID4+PiAyNCwgZTtcbn1cbm9lLndyaXRlVWludDMyTEUgPSBIcztcbm9lLndyaXRlSW50MzJMRSA9IEhzO1xuZnVuY3Rpb24gemwoaSwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAwKTtcbiAgdmFyIHQgPSBNcihpLCBlKSwgcyA9IE1yKGksIGUgKyA0KTtcbiAgcmV0dXJuIHQgKiA0Mjk0OTY3Mjk2ICsgcyAtIChzID4+IDMxKSAqIDQyOTQ5NjcyOTY7XG59XG5vZS5yZWFkSW50NjRCRSA9IHpsO1xuZnVuY3Rpb24gS2woaSwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAwKTtcbiAgdmFyIHQgPSBxcihpLCBlKSwgcyA9IHFyKGksIGUgKyA0KTtcbiAgcmV0dXJuIHQgKiA0Mjk0OTY3Mjk2ICsgcztcbn1cbm9lLnJlYWRVaW50NjRCRSA9IEtsO1xuZnVuY3Rpb24gVmwoaSwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAwKTtcbiAgdmFyIHQgPSBqcihpLCBlKSwgcyA9IGpyKGksIGUgKyA0KTtcbiAgcmV0dXJuIHMgKiA0Mjk0OTY3Mjk2ICsgdCAtICh0ID4+IDMxKSAqIDQyOTQ5NjcyOTY7XG59XG5vZS5yZWFkSW50NjRMRSA9IFZsO1xuZnVuY3Rpb24gQmwoaSwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAwKTtcbiAgdmFyIHQgPSB6cihpLCBlKSwgcyA9IHpyKGksIGUgKyA0KTtcbiAgcmV0dXJuIHMgKiA0Mjk0OTY3Mjk2ICsgdDtcbn1cbm9lLnJlYWRVaW50NjRMRSA9IEJsO1xuZnVuY3Rpb24gcGMoaSwgZSwgdCkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoOCkpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKSwga3MoaSAvIDQyOTQ5NjcyOTYgPj4+IDAsIGUsIHQpLCBrcyhpID4+PiAwLCBlLCB0ICsgNCksIGU7XG59XG5vZS53cml0ZVVpbnQ2NEJFID0gcGM7XG5vZS53cml0ZUludDY0QkUgPSBwYztcbmZ1bmN0aW9uIGdjKGksIGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBVaW50OEFycmF5KDgpKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCksIEhzKGkgPj4+IDAsIGUsIHQpLCBIcyhpIC8gNDI5NDk2NzI5NiA+Pj4gMCwgZSwgdCArIDQpLCBlO1xufVxub2Uud3JpdGVVaW50NjRMRSA9IGdjO1xub2Uud3JpdGVJbnQ2NExFID0gZ2M7XG5mdW5jdGlvbiBrbChpLCBlLCB0KSB7XG4gIGlmICh0ID09PSB2b2lkIDAgJiYgKHQgPSAwKSwgaSAlIDggIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVhZFVpbnRCRSBzdXBwb3J0cyBvbmx5IGJpdExlbmd0aHMgZGl2aXNpYmxlIGJ5IDhcIik7XG4gIGlmIChpIC8gOCA+IGUubGVuZ3RoIC0gdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWFkVWludEJFOiBhcnJheSBpcyB0b28gc2hvcnQgZm9yIHRoZSBnaXZlbiBiaXRMZW5ndGhcIik7XG4gIGZvciAodmFyIHMgPSAwLCByID0gMSwgbiA9IGkgLyA4ICsgdCAtIDE7IG4gPj0gdDsgbi0tKVxuICAgIHMgKz0gZVtuXSAqIHIsIHIgKj0gMjU2O1xuICByZXR1cm4gcztcbn1cbm9lLnJlYWRVaW50QkUgPSBrbDtcbmZ1bmN0aW9uIEhsKGksIGUsIHQpIHtcbiAgaWYgKHQgPT09IHZvaWQgMCAmJiAodCA9IDApLCBpICUgOCAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWFkVWludExFIHN1cHBvcnRzIG9ubHkgYml0TGVuZ3RocyBkaXZpc2libGUgYnkgOFwiKTtcbiAgaWYgKGkgLyA4ID4gZS5sZW5ndGggLSB0KVxuICAgIHRocm93IG5ldyBFcnJvcihcInJlYWRVaW50TEU6IGFycmF5IGlzIHRvbyBzaG9ydCBmb3IgdGhlIGdpdmVuIGJpdExlbmd0aFwiKTtcbiAgZm9yICh2YXIgcyA9IDAsIHIgPSAxLCBuID0gdDsgbiA8IHQgKyBpIC8gODsgbisrKVxuICAgIHMgKz0gZVtuXSAqIHIsIHIgKj0gMjU2O1xuICByZXR1cm4gcztcbn1cbm9lLnJlYWRVaW50TEUgPSBIbDtcbmZ1bmN0aW9uIEdsKGksIGUsIHQsIHMpIHtcbiAgaWYgKHQgPT09IHZvaWQgMCAmJiAodCA9IG5ldyBVaW50OEFycmF5KGkgLyA4KSksIHMgPT09IHZvaWQgMCAmJiAocyA9IDApLCBpICUgOCAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZVVpbnRCRSBzdXBwb3J0cyBvbmx5IGJpdExlbmd0aHMgZGl2aXNpYmxlIGJ5IDhcIik7XG4gIGlmICghbGMuaXNTYWZlSW50ZWdlcihlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZVVpbnRCRSB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gIGZvciAodmFyIHIgPSAxLCBuID0gaSAvIDggKyBzIC0gMTsgbiA+PSBzOyBuLS0pXG4gICAgdFtuXSA9IGUgLyByICYgMjU1LCByICo9IDI1NjtcbiAgcmV0dXJuIHQ7XG59XG5vZS53cml0ZVVpbnRCRSA9IEdsO1xuZnVuY3Rpb24gV2woaSwgZSwgdCwgcykge1xuICBpZiAodCA9PT0gdm9pZCAwICYmICh0ID0gbmV3IFVpbnQ4QXJyYXkoaSAvIDgpKSwgcyA9PT0gdm9pZCAwICYmIChzID0gMCksIGkgJSA4ICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlVWludExFIHN1cHBvcnRzIG9ubHkgYml0TGVuZ3RocyBkaXZpc2libGUgYnkgOFwiKTtcbiAgaWYgKCFsYy5pc1NhZmVJbnRlZ2VyKGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlVWludExFIHZhbHVlIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgZm9yICh2YXIgciA9IDEsIG4gPSBzOyBuIDwgcyArIGkgLyA4OyBuKyspXG4gICAgdFtuXSA9IGUgLyByICYgMjU1LCByICo9IDI1NjtcbiAgcmV0dXJuIHQ7XG59XG5vZS53cml0ZVVpbnRMRSA9IFdsO1xuZnVuY3Rpb24gWWwoaSwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAwKTtcbiAgdmFyIHQgPSBuZXcgRGF0YVZpZXcoaS5idWZmZXIsIGkuYnl0ZU9mZnNldCwgaS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHQuZ2V0RmxvYXQzMihlKTtcbn1cbm9lLnJlYWRGbG9hdDMyQkUgPSBZbDtcbmZ1bmN0aW9uIEpsKGksIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gMCk7XG4gIHZhciB0ID0gbmV3IERhdGFWaWV3KGkuYnVmZmVyLCBpLmJ5dGVPZmZzZXQsIGkuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB0LmdldEZsb2F0MzIoZSwgITApO1xufVxub2UucmVhZEZsb2F0MzJMRSA9IEpsO1xuZnVuY3Rpb24gUWwoaSwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAwKTtcbiAgdmFyIHQgPSBuZXcgRGF0YVZpZXcoaS5idWZmZXIsIGkuYnl0ZU9mZnNldCwgaS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHQuZ2V0RmxvYXQ2NChlKTtcbn1cbm9lLnJlYWRGbG9hdDY0QkUgPSBRbDtcbmZ1bmN0aW9uIFhsKGksIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gMCk7XG4gIHZhciB0ID0gbmV3IERhdGFWaWV3KGkuYnVmZmVyLCBpLmJ5dGVPZmZzZXQsIGkuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB0LmdldEZsb2F0NjQoZSwgITApO1xufVxub2UucmVhZEZsb2F0NjRMRSA9IFhsO1xuZnVuY3Rpb24gWmwoaSwgZSwgdCkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgVWludDhBcnJheSg0KSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDApO1xuICB2YXIgcyA9IG5ldyBEYXRhVmlldyhlLmJ1ZmZlciwgZS5ieXRlT2Zmc2V0LCBlLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gcy5zZXRGbG9hdDMyKHQsIGkpLCBlO1xufVxub2Uud3JpdGVGbG9hdDMyQkUgPSBabDtcbmZ1bmN0aW9uIGVkKGksIGUsIHQpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoNCkpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKTtcbiAgdmFyIHMgPSBuZXcgRGF0YVZpZXcoZS5idWZmZXIsIGUuYnl0ZU9mZnNldCwgZS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHMuc2V0RmxvYXQzMih0LCBpLCAhMCksIGU7XG59XG5vZS53cml0ZUZsb2F0MzJMRSA9IGVkO1xuZnVuY3Rpb24gdGQoaSwgZSwgdCkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgVWludDhBcnJheSg4KSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDApO1xuICB2YXIgcyA9IG5ldyBEYXRhVmlldyhlLmJ1ZmZlciwgZS5ieXRlT2Zmc2V0LCBlLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gcy5zZXRGbG9hdDY0KHQsIGkpLCBlO1xufVxub2Uud3JpdGVGbG9hdDY0QkUgPSB0ZDtcbmZ1bmN0aW9uIGlkKGksIGUsIHQpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoOCkpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKTtcbiAgdmFyIHMgPSBuZXcgRGF0YVZpZXcoZS5idWZmZXIsIGUuYnl0ZU9mZnNldCwgZS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHMuc2V0RmxvYXQ2NCh0LCBpLCAhMCksIGU7XG59XG5vZS53cml0ZUZsb2F0NjRMRSA9IGlkO1xuKGZ1bmN0aW9uKGkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgaS5yYW5kb21TdHJpbmdGb3JFbnRyb3B5ID0gaS5yYW5kb21TdHJpbmcgPSBpLnJhbmRvbVVpbnQzMiA9IGkucmFuZG9tQnl0ZXMgPSBpLmRlZmF1bHRSYW5kb21Tb3VyY2UgPSB2b2lkIDA7XG4gIGNvbnN0IGUgPSBuciwgdCA9IG9lLCBzID0gUHQ7XG4gIGkuZGVmYXVsdFJhbmRvbVNvdXJjZSA9IG5ldyBlLlN5c3RlbVJhbmRvbVNvdXJjZSgpO1xuICBmdW5jdGlvbiByKGQsIHAgPSBpLmRlZmF1bHRSYW5kb21Tb3VyY2UpIHtcbiAgICByZXR1cm4gcC5yYW5kb21CeXRlcyhkKTtcbiAgfVxuICBpLnJhbmRvbUJ5dGVzID0gcjtcbiAgZnVuY3Rpb24gbihkID0gaS5kZWZhdWx0UmFuZG9tU291cmNlKSB7XG4gICAgY29uc3QgcCA9IHIoNCwgZCksIGIgPSAoMCwgdC5yZWFkVWludDMyTEUpKHApO1xuICAgIHJldHVybiAoMCwgcy53aXBlKShwKSwgYjtcbiAgfVxuICBpLnJhbmRvbVVpbnQzMiA9IG47XG4gIGNvbnN0IG8gPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG4gIGZ1bmN0aW9uIGMoZCwgcCA9IG8sIGIgPSBpLmRlZmF1bHRSYW5kb21Tb3VyY2UpIHtcbiAgICBpZiAocC5sZW5ndGggPCAyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmFuZG9tU3RyaW5nIGNoYXJzZXQgaXMgdG9vIHNob3J0XCIpO1xuICAgIGlmIChwLmxlbmd0aCA+IDI1NilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJhbmRvbVN0cmluZyBjaGFyc2V0IGlzIHRvbyBsb25nXCIpO1xuICAgIGxldCB4ID0gXCJcIjtcbiAgICBjb25zdCBPID0gcC5sZW5ndGgsIF8gPSAyNTYgLSAyNTYgJSBPO1xuICAgIGZvciAoOyBkID4gMDsgKSB7XG4gICAgICBjb25zdCBDID0gcihNYXRoLmNlaWwoZCAqIDI1NiAvIF8pLCBiKTtcbiAgICAgIGZvciAobGV0IEYgPSAwOyBGIDwgQy5sZW5ndGggJiYgZCA+IDA7IEYrKykge1xuICAgICAgICBjb25zdCBLID0gQ1tGXTtcbiAgICAgICAgSyA8IF8gJiYgKHggKz0gcC5jaGFyQXQoSyAlIE8pLCBkLS0pO1xuICAgICAgfVxuICAgICAgKDAsIHMud2lwZSkoQyk7XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9XG4gIGkucmFuZG9tU3RyaW5nID0gYztcbiAgZnVuY3Rpb24gdShkLCBwID0gbywgYiA9IGkuZGVmYXVsdFJhbmRvbVNvdXJjZSkge1xuICAgIGNvbnN0IHggPSBNYXRoLmNlaWwoZCAvIChNYXRoLmxvZyhwLmxlbmd0aCkgLyBNYXRoLkxOMikpO1xuICAgIHJldHVybiBjKHgsIHAsIGIpO1xuICB9XG4gIGkucmFuZG9tU3RyaW5nRm9yRW50cm9weSA9IHU7XG59KShsaSk7XG52YXIgeWMgPSB7fTtcbihmdW5jdGlvbihpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciBlID0gb2UsIHQgPSBQdDtcbiAgaS5ESUdFU1RfTEVOR1RIID0gNjQsIGkuQkxPQ0tfU0laRSA9IDEyODtcbiAgdmFyIHMgPSAoXG4gICAgLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gYygpIHtcbiAgICAgICAgdGhpcy5kaWdlc3RMZW5ndGggPSBpLkRJR0VTVF9MRU5HVEgsIHRoaXMuYmxvY2tTaXplID0gaS5CTE9DS19TSVpFLCB0aGlzLl9zdGF0ZUhpID0gbmV3IEludDMyQXJyYXkoOCksIHRoaXMuX3N0YXRlTG8gPSBuZXcgSW50MzJBcnJheSg4KSwgdGhpcy5fdGVtcEhpID0gbmV3IEludDMyQXJyYXkoMTYpLCB0aGlzLl90ZW1wTG8gPSBuZXcgSW50MzJBcnJheSgxNiksIHRoaXMuX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KDI1NiksIHRoaXMuX2J1ZmZlckxlbmd0aCA9IDAsIHRoaXMuX2J5dGVzSGFzaGVkID0gMCwgdGhpcy5fZmluaXNoZWQgPSAhMSwgdGhpcy5yZXNldCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGMucHJvdG90eXBlLl9pbml0U3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVIaVswXSA9IDE3NzkwMzM3MDMsIHRoaXMuX3N0YXRlSGlbMV0gPSAzMTQ0MTM0Mjc3LCB0aGlzLl9zdGF0ZUhpWzJdID0gMTAxMzkwNDI0MiwgdGhpcy5fc3RhdGVIaVszXSA9IDI3NzM0ODA3NjIsIHRoaXMuX3N0YXRlSGlbNF0gPSAxMzU5ODkzMTE5LCB0aGlzLl9zdGF0ZUhpWzVdID0gMjYwMDgyMjkyNCwgdGhpcy5fc3RhdGVIaVs2XSA9IDUyODczNDYzNSwgdGhpcy5fc3RhdGVIaVs3XSA9IDE1NDE0NTkyMjUsIHRoaXMuX3N0YXRlTG9bMF0gPSA0MDg5MjM1NzIwLCB0aGlzLl9zdGF0ZUxvWzFdID0gMjIyNzg3MzU5NSwgdGhpcy5fc3RhdGVMb1syXSA9IDQyNzExNzU3MjMsIHRoaXMuX3N0YXRlTG9bM10gPSAxNTk1NzUwMTI5LCB0aGlzLl9zdGF0ZUxvWzRdID0gMjkxNzU2NTEzNywgdGhpcy5fc3RhdGVMb1s1XSA9IDcyNTUxMTE5OSwgdGhpcy5fc3RhdGVMb1s2XSA9IDQyMTUzODk1NDcsIHRoaXMuX3N0YXRlTG9bN10gPSAzMjcwMzMyMDk7XG4gICAgICB9LCBjLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdFN0YXRlKCksIHRoaXMuX2J1ZmZlckxlbmd0aCA9IDAsIHRoaXMuX2J5dGVzSGFzaGVkID0gMCwgdGhpcy5fZmluaXNoZWQgPSAhMSwgdGhpcztcbiAgICAgIH0sIGMucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHQud2lwZSh0aGlzLl9idWZmZXIpLCB0LndpcGUodGhpcy5fdGVtcEhpKSwgdC53aXBlKHRoaXMuX3RlbXBMbyksIHRoaXMucmVzZXQoKTtcbiAgICAgIH0sIGMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHUsIGQpIHtcbiAgICAgICAgaWYgKGQgPT09IHZvaWQgMCAmJiAoZCA9IHUubGVuZ3RoKSwgdGhpcy5fZmluaXNoZWQpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU0hBNTEyOiBjYW4ndCB1cGRhdGUgYmVjYXVzZSBoYXNoIHdhcyBmaW5pc2hlZC5cIik7XG4gICAgICAgIHZhciBwID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX2J5dGVzSGFzaGVkICs9IGQsIHRoaXMuX2J1ZmZlckxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKDsgdGhpcy5fYnVmZmVyTGVuZ3RoIDwgaS5CTE9DS19TSVpFICYmIGQgPiAwOyApXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJbdGhpcy5fYnVmZmVyTGVuZ3RoKytdID0gdVtwKytdLCBkLS07XG4gICAgICAgICAgdGhpcy5fYnVmZmVyTGVuZ3RoID09PSB0aGlzLmJsb2NrU2l6ZSAmJiAobih0aGlzLl90ZW1wSGksIHRoaXMuX3RlbXBMbywgdGhpcy5fc3RhdGVIaSwgdGhpcy5fc3RhdGVMbywgdGhpcy5fYnVmZmVyLCAwLCB0aGlzLmJsb2NrU2l6ZSksIHRoaXMuX2J1ZmZlckxlbmd0aCA9IDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoZCA+PSB0aGlzLmJsb2NrU2l6ZSAmJiAocCA9IG4odGhpcy5fdGVtcEhpLCB0aGlzLl90ZW1wTG8sIHRoaXMuX3N0YXRlSGksIHRoaXMuX3N0YXRlTG8sIHUsIHAsIGQpLCBkICU9IHRoaXMuYmxvY2tTaXplKTsgZCA+IDA7IClcbiAgICAgICAgICB0aGlzLl9idWZmZXJbdGhpcy5fYnVmZmVyTGVuZ3RoKytdID0gdVtwKytdLCBkLS07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgYy5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24odSkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgdmFyIGQgPSB0aGlzLl9ieXRlc0hhc2hlZCwgcCA9IHRoaXMuX2J1ZmZlckxlbmd0aCwgYiA9IGQgLyA1MzY4NzA5MTIgfCAwLCB4ID0gZCA8PCAzLCBPID0gZCAlIDEyOCA8IDExMiA/IDEyOCA6IDI1NjtcbiAgICAgICAgICB0aGlzLl9idWZmZXJbcF0gPSAxMjg7XG4gICAgICAgICAgZm9yICh2YXIgXyA9IHAgKyAxOyBfIDwgTyAtIDg7IF8rKylcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlcltfXSA9IDA7XG4gICAgICAgICAgZS53cml0ZVVpbnQzMkJFKGIsIHRoaXMuX2J1ZmZlciwgTyAtIDgpLCBlLndyaXRlVWludDMyQkUoeCwgdGhpcy5fYnVmZmVyLCBPIC0gNCksIG4odGhpcy5fdGVtcEhpLCB0aGlzLl90ZW1wTG8sIHRoaXMuX3N0YXRlSGksIHRoaXMuX3N0YXRlTG8sIHRoaXMuX2J1ZmZlciwgMCwgTyksIHRoaXMuX2ZpbmlzaGVkID0gITA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgXyA9IDA7IF8gPCB0aGlzLmRpZ2VzdExlbmd0aCAvIDg7IF8rKylcbiAgICAgICAgICBlLndyaXRlVWludDMyQkUodGhpcy5fc3RhdGVIaVtfXSwgdSwgXyAqIDgpLCBlLndyaXRlVWludDMyQkUodGhpcy5fc3RhdGVMb1tfXSwgdSwgXyAqIDggKyA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHUgPSBuZXcgVWludDhBcnJheSh0aGlzLmRpZ2VzdExlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCh1KSwgdTtcbiAgICAgIH0sIGMucHJvdG90eXBlLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZmluaXNoZWQpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU0hBMjU2OiBjYW5ub3Qgc2F2ZSBmaW5pc2hlZCBzdGF0ZVwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0ZUhpOiBuZXcgSW50MzJBcnJheSh0aGlzLl9zdGF0ZUhpKSxcbiAgICAgICAgICBzdGF0ZUxvOiBuZXcgSW50MzJBcnJheSh0aGlzLl9zdGF0ZUxvKSxcbiAgICAgICAgICBidWZmZXI6IHRoaXMuX2J1ZmZlckxlbmd0aCA+IDAgPyBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIpIDogdm9pZCAwLFxuICAgICAgICAgIGJ1ZmZlckxlbmd0aDogdGhpcy5fYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgIGJ5dGVzSGFzaGVkOiB0aGlzLl9ieXRlc0hhc2hlZFxuICAgICAgICB9O1xuICAgICAgfSwgYy5wcm90b3R5cGUucmVzdG9yZVN0YXRlID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVIaS5zZXQodS5zdGF0ZUhpKSwgdGhpcy5fc3RhdGVMby5zZXQodS5zdGF0ZUxvKSwgdGhpcy5fYnVmZmVyTGVuZ3RoID0gdS5idWZmZXJMZW5ndGgsIHUuYnVmZmVyICYmIHRoaXMuX2J1ZmZlci5zZXQodS5idWZmZXIpLCB0aGlzLl9ieXRlc0hhc2hlZCA9IHUuYnl0ZXNIYXNoZWQsIHRoaXMuX2ZpbmlzaGVkID0gITEsIHRoaXM7XG4gICAgICB9LCBjLnByb3RvdHlwZS5jbGVhblNhdmVkU3RhdGUgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHQud2lwZSh1LnN0YXRlSGkpLCB0LndpcGUodS5zdGF0ZUxvKSwgdS5idWZmZXIgJiYgdC53aXBlKHUuYnVmZmVyKSwgdS5idWZmZXJMZW5ndGggPSAwLCB1LmJ5dGVzSGFzaGVkID0gMDtcbiAgICAgIH0sIGM7XG4gICAgfSgpXG4gICk7XG4gIGkuU0hBNTEyID0gcztcbiAgdmFyIHIgPSBuZXcgSW50MzJBcnJheShbXG4gICAgMTExNjM1MjQwOCxcbiAgICAzNjA5NzY3NDU4LFxuICAgIDE4OTk0NDc0NDEsXG4gICAgNjAyODkxNzI1LFxuICAgIDMwNDkzMjM0NzEsXG4gICAgMzk2NDQ4NDM5OSxcbiAgICAzOTIxMDA5NTczLFxuICAgIDIxNzMyOTU1NDgsXG4gICAgOTYxOTg3MTYzLFxuICAgIDQwODE2Mjg0NzIsXG4gICAgMTUwODk3MDk5MyxcbiAgICAzMDUzODM0MjY1LFxuICAgIDI0NTM2MzU3NDgsXG4gICAgMjkzNzY3MTU3OSxcbiAgICAyODcwNzYzMjIxLFxuICAgIDM2NjQ2MDk1NjAsXG4gICAgMzYyNDM4MTA4MCxcbiAgICAyNzM0ODgzMzk0LFxuICAgIDMxMDU5ODQwMSxcbiAgICAxMTY0OTk2NTQyLFxuICAgIDYwNzIyNTI3OCxcbiAgICAxMzIzNjEwNzY0LFxuICAgIDE0MjY4ODE5ODcsXG4gICAgMzU5MDMwNDk5NCxcbiAgICAxOTI1MDc4Mzg4LFxuICAgIDQwNjgxODIzODMsXG4gICAgMjE2MjA3ODIwNixcbiAgICA5OTEzMzYxMTMsXG4gICAgMjYxNDg4ODEwMyxcbiAgICA2MzM4MDMzMTcsXG4gICAgMzI0ODIyMjU4MCxcbiAgICAzNDc5Nzc0ODY4LFxuICAgIDM4MzUzOTA0MDEsXG4gICAgMjY2NjYxMzQ1OCxcbiAgICA0MDIyMjI0Nzc0LFxuICAgIDk0NDcxMTEzOSxcbiAgICAyNjQzNDcwNzgsXG4gICAgMjM0MTI2Mjc3MyxcbiAgICA2MDQ4MDc2MjgsXG4gICAgMjAwNzgwMDkzMyxcbiAgICA3NzAyNTU5ODMsXG4gICAgMTQ5NTk5MDkwMSxcbiAgICAxMjQ5MTUwMTIyLFxuICAgIDE4NTY0MzEyMzUsXG4gICAgMTU1NTA4MTY5MixcbiAgICAzMTc1MjE4MTMyLFxuICAgIDE5OTYwNjQ5ODYsXG4gICAgMjE5ODk1MDgzNyxcbiAgICAyNTU0MjIwODgyLFxuICAgIDM5OTk3MTkzMzksXG4gICAgMjgyMTgzNDM0OSxcbiAgICA3NjY3ODQwMTYsXG4gICAgMjk1Mjk5NjgwOCxcbiAgICAyNTY2NTk0ODc5LFxuICAgIDMyMTAzMTM2NzEsXG4gICAgMzIwMzMzNzk1NixcbiAgICAzMzM2NTcxODkxLFxuICAgIDEwMzQ0NTcwMjYsXG4gICAgMzU4NDUyODcxMSxcbiAgICAyNDY2OTQ4OTAxLFxuICAgIDExMzkyNjk5MyxcbiAgICAzNzU4MzI2MzgzLFxuICAgIDMzODI0MTg5NSxcbiAgICAxNjg3MTc5MzYsXG4gICAgNjY2MzA3MjA1LFxuICAgIDExODgxNzk5NjQsXG4gICAgNzczNTI5OTEyLFxuICAgIDE1NDYwNDU3MzQsXG4gICAgMTI5NDc1NzM3MixcbiAgICAxNTIyODA1NDg1LFxuICAgIDEzOTYxODIyOTEsXG4gICAgMjY0MzgzMzgyMyxcbiAgICAxNjk1MTgzNzAwLFxuICAgIDIzNDM1MjczOTAsXG4gICAgMTk4NjY2MTA1MSxcbiAgICAxMDE0NDc3NDgwLFxuICAgIDIxNzcwMjYzNTAsXG4gICAgMTIwNjc1OTE0MixcbiAgICAyNDU2OTU2MDM3LFxuICAgIDM0NDA3NzYyNyxcbiAgICAyNzMwNDg1OTIxLFxuICAgIDEyOTA4NjM0NjAsXG4gICAgMjgyMDMwMjQxMSxcbiAgICAzMTU4NDU0MjczLFxuICAgIDMyNTk3MzA4MDAsXG4gICAgMzUwNTk1MjY1NyxcbiAgICAzMzQ1NzY0NzcxLFxuICAgIDEwNjIxNzAwOCxcbiAgICAzNTE2MDY1ODE3LFxuICAgIDM2MDYwMDgzNDQsXG4gICAgMzYwMDM1MjgwNCxcbiAgICAxNDMyNzI1Nzc2LFxuICAgIDQwOTQ1NzE5MDksXG4gICAgMTQ2NzAzMTU5NCxcbiAgICAyNzU0MjMzNDQsXG4gICAgODUxMTY5NzIwLFxuICAgIDQzMDIyNzczNCxcbiAgICAzMTAwODIzNzUyLFxuICAgIDUwNjk0ODYxNixcbiAgICAxMzYzMjU4MTk1LFxuICAgIDY1OTA2MDU1NixcbiAgICAzNzUwNjg1NTkzLFxuICAgIDg4Mzk5Nzg3NyxcbiAgICAzNzg1MDUwMjgwLFxuICAgIDk1ODEzOTU3MSxcbiAgICAzMzE4MzA3NDI3LFxuICAgIDEzMjI4MjIyMTgsXG4gICAgMzgxMjcyMzQwMyxcbiAgICAxNTM3MDAyMDYzLFxuICAgIDIwMDMwMzQ5OTUsXG4gICAgMTc0Nzg3Mzc3OSxcbiAgICAzNjAyMDM2ODk5LFxuICAgIDE5NTU1NjIyMjIsXG4gICAgMTU3NTk5MDAxMixcbiAgICAyMDI0MTA0ODE1LFxuICAgIDExMjU1OTI5MjgsXG4gICAgMjIyNzczMDQ1MixcbiAgICAyNzE2OTA0MzA2LFxuICAgIDIzNjE4NTI0MjQsXG4gICAgNDQyNzc2MDQ0LFxuICAgIDI0Mjg0MzY0NzQsXG4gICAgNTkzNjk4MzQ0LFxuICAgIDI3NTY3MzQxODcsXG4gICAgMzczMzExMDI0OSxcbiAgICAzMjA0MDMxNDc5LFxuICAgIDI5OTkzNTE1NzMsXG4gICAgMzMyOTMyNTI5OCxcbiAgICAzODE1OTIwNDI3LFxuICAgIDMzOTE1Njk2MTQsXG4gICAgMzkyODM4MzkwMCxcbiAgICAzNTE1MjY3MjcxLFxuICAgIDU2NjI4MDcxMSxcbiAgICAzOTQwMTg3NjA2LFxuICAgIDM0NTQwNjk1MzQsXG4gICAgNDExODYzMDI3MSxcbiAgICA0MDAwMjM5OTkyLFxuICAgIDExNjQxODQ3NCxcbiAgICAxOTE0MTM4NTU0LFxuICAgIDE3NDI5MjQyMSxcbiAgICAyNzMxMDU1MjcwLFxuICAgIDI4OTM4MDM1NixcbiAgICAzMjAzOTkzMDA2LFxuICAgIDQ2MDM5MzI2OSxcbiAgICAzMjA2MjAzMTUsXG4gICAgNjg1NDcxNzMzLFxuICAgIDU4NzQ5NjgzNixcbiAgICA4NTIxNDI5NzEsXG4gICAgMTA4Njc5Mjg1MSxcbiAgICAxMDE3MDM2Mjk4LFxuICAgIDM2NTU0MzEwMCxcbiAgICAxMTI2MDAwNTgwLFxuICAgIDI2MTgyOTc2NzYsXG4gICAgMTI4ODAzMzQ3MCxcbiAgICAzNDA5ODU1MTU4LFxuICAgIDE1MDE1MDU5NDgsXG4gICAgNDIzNDUwOTg2NixcbiAgICAxNjA3MTY3OTE1LFxuICAgIDk4NzE2NzQ2OCxcbiAgICAxODE2NDAyMzE2LFxuICAgIDEyNDYxODk1OTFcbiAgXSk7XG4gIGZ1bmN0aW9uIG4oYywgdSwgZCwgcCwgYiwgeCwgTykge1xuICAgIGZvciAodmFyIF8gPSBkWzBdLCBDID0gZFsxXSwgRiA9IGRbMl0sIEsgPSBkWzNdLCBJID0gZFs0XSwgRCA9IGRbNV0sIHkgPSBkWzZdLCB3ID0gZFs3XSwgZiA9IHBbMF0sIGEgPSBwWzFdLCBsID0gcFsyXSwgTCA9IHBbM10sIHYgPSBwWzRdLCBSID0gcFs1XSwgJCA9IHBbNl0sIHEgPSBwWzddLCBtLCBFLCBCLCB6LCBqLCBVLCBNLCBIOyBPID49IDEyODsgKSB7XG4gICAgICBmb3IgKHZhciB0ZSA9IDA7IHRlIDwgMTY7IHRlKyspIHtcbiAgICAgICAgdmFyIEcgPSA4ICogdGUgKyB4O1xuICAgICAgICBjW3RlXSA9IGUucmVhZFVpbnQzMkJFKGIsIEcpLCB1W3RlXSA9IGUucmVhZFVpbnQzMkJFKGIsIEcgKyA0KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHRlID0gMDsgdGUgPCA4MDsgdGUrKykge1xuICAgICAgICB2YXIgaWUgPSBfLCBRID0gQywgc2UgPSBGLCBUID0gSywgQSA9IEksIE4gPSBELCBoID0geSwgUyA9IHcsIFcgPSBmLCBYID0gYSwgZmUgPSBsLCB2ZSA9IEwsIGdlID0gdiwgU2UgPSBSLCBNZSA9ICQsICRlID0gcTtcbiAgICAgICAgaWYgKG0gPSB3LCBFID0gcSwgaiA9IEUgJiA2NTUzNSwgVSA9IEUgPj4+IDE2LCBNID0gbSAmIDY1NTM1LCBIID0gbSA+Pj4gMTYsIG0gPSAoSSA+Pj4gMTQgfCB2IDw8IDMyIC0gMTQpIF4gKEkgPj4+IDE4IHwgdiA8PCAzMiAtIDE4KSBeICh2ID4+PiA0MSAtIDMyIHwgSSA8PCAzMiAtICg0MSAtIDMyKSksIEUgPSAodiA+Pj4gMTQgfCBJIDw8IDMyIC0gMTQpIF4gKHYgPj4+IDE4IHwgSSA8PCAzMiAtIDE4KSBeIChJID4+PiA0MSAtIDMyIHwgdiA8PCAzMiAtICg0MSAtIDMyKSksIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgbSA9IEkgJiBEIF4gfkkgJiB5LCBFID0gdiAmIFIgXiB+diAmICQsIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgbSA9IHJbdGUgKiAyXSwgRSA9IHJbdGUgKiAyICsgMV0sIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgbSA9IGNbdGUgJSAxNl0sIEUgPSB1W3RlICUgMTZdLCBqICs9IEUgJiA2NTUzNSwgVSArPSBFID4+PiAxNiwgTSArPSBtICYgNjU1MzUsIEggKz0gbSA+Pj4gMTYsIFUgKz0gaiA+Pj4gMTYsIE0gKz0gVSA+Pj4gMTYsIEggKz0gTSA+Pj4gMTYsIEIgPSBNICYgNjU1MzUgfCBIIDw8IDE2LCB6ID0gaiAmIDY1NTM1IHwgVSA8PCAxNiwgbSA9IEIsIEUgPSB6LCBqID0gRSAmIDY1NTM1LCBVID0gRSA+Pj4gMTYsIE0gPSBtICYgNjU1MzUsIEggPSBtID4+PiAxNiwgbSA9IChfID4+PiAyOCB8IGYgPDwgMzIgLSAyOCkgXiAoZiA+Pj4gMzQgLSAzMiB8IF8gPDwgMzIgLSAoMzQgLSAzMikpIF4gKGYgPj4+IDM5IC0gMzIgfCBfIDw8IDMyIC0gKDM5IC0gMzIpKSwgRSA9IChmID4+PiAyOCB8IF8gPDwgMzIgLSAyOCkgXiAoXyA+Pj4gMzQgLSAzMiB8IGYgPDwgMzIgLSAoMzQgLSAzMikpIF4gKF8gPj4+IDM5IC0gMzIgfCBmIDw8IDMyIC0gKDM5IC0gMzIpKSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBtID0gXyAmIEMgXiBfICYgRiBeIEMgJiBGLCBFID0gZiAmIGEgXiBmICYgbCBeIGEgJiBsLCBqICs9IEUgJiA2NTUzNSwgVSArPSBFID4+PiAxNiwgTSArPSBtICYgNjU1MzUsIEggKz0gbSA+Pj4gMTYsIFUgKz0gaiA+Pj4gMTYsIE0gKz0gVSA+Pj4gMTYsIEggKz0gTSA+Pj4gMTYsIFMgPSBNICYgNjU1MzUgfCBIIDw8IDE2LCAkZSA9IGogJiA2NTUzNSB8IFUgPDwgMTYsIG0gPSBULCBFID0gdmUsIGogPSBFICYgNjU1MzUsIFUgPSBFID4+PiAxNiwgTSA9IG0gJiA2NTUzNSwgSCA9IG0gPj4+IDE2LCBtID0gQiwgRSA9IHosIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgVSArPSBqID4+PiAxNiwgTSArPSBVID4+PiAxNiwgSCArPSBNID4+PiAxNiwgVCA9IE0gJiA2NTUzNSB8IEggPDwgMTYsIHZlID0gaiAmIDY1NTM1IHwgVSA8PCAxNiwgQyA9IGllLCBGID0gUSwgSyA9IHNlLCBJID0gVCwgRCA9IEEsIHkgPSBOLCB3ID0gaCwgXyA9IFMsIGEgPSBXLCBsID0gWCwgTCA9IGZlLCB2ID0gdmUsIFIgPSBnZSwgJCA9IFNlLCBxID0gTWUsIGYgPSAkZSwgdGUgJSAxNiA9PT0gMTUpXG4gICAgICAgICAgZm9yICh2YXIgRyA9IDA7IEcgPCAxNjsgRysrKVxuICAgICAgICAgICAgbSA9IGNbR10sIEUgPSB1W0ddLCBqID0gRSAmIDY1NTM1LCBVID0gRSA+Pj4gMTYsIE0gPSBtICYgNjU1MzUsIEggPSBtID4+PiAxNiwgbSA9IGNbKEcgKyA5KSAlIDE2XSwgRSA9IHVbKEcgKyA5KSAlIDE2XSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBCID0gY1soRyArIDEpICUgMTZdLCB6ID0gdVsoRyArIDEpICUgMTZdLCBtID0gKEIgPj4+IDEgfCB6IDw8IDMyIC0gMSkgXiAoQiA+Pj4gOCB8IHogPDwgMzIgLSA4KSBeIEIgPj4+IDcsIEUgPSAoeiA+Pj4gMSB8IEIgPDwgMzIgLSAxKSBeICh6ID4+PiA4IHwgQiA8PCAzMiAtIDgpIF4gKHogPj4+IDcgfCBCIDw8IDMyIC0gNyksIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgQiA9IGNbKEcgKyAxNCkgJSAxNl0sIHogPSB1WyhHICsgMTQpICUgMTZdLCBtID0gKEIgPj4+IDE5IHwgeiA8PCAzMiAtIDE5KSBeICh6ID4+PiA2MSAtIDMyIHwgQiA8PCAzMiAtICg2MSAtIDMyKSkgXiBCID4+PiA2LCBFID0gKHogPj4+IDE5IHwgQiA8PCAzMiAtIDE5KSBeIChCID4+PiA2MSAtIDMyIHwgeiA8PCAzMiAtICg2MSAtIDMyKSkgXiAoeiA+Pj4gNiB8IEIgPDwgMzIgLSA2KSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBVICs9IGogPj4+IDE2LCBNICs9IFUgPj4+IDE2LCBIICs9IE0gPj4+IDE2LCBjW0ddID0gTSAmIDY1NTM1IHwgSCA8PCAxNiwgdVtHXSA9IGogJiA2NTUzNSB8IFUgPDwgMTY7XG4gICAgICB9XG4gICAgICBtID0gXywgRSA9IGYsIGogPSBFICYgNjU1MzUsIFUgPSBFID4+PiAxNiwgTSA9IG0gJiA2NTUzNSwgSCA9IG0gPj4+IDE2LCBtID0gZFswXSwgRSA9IHBbMF0sIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgVSArPSBqID4+PiAxNiwgTSArPSBVID4+PiAxNiwgSCArPSBNID4+PiAxNiwgZFswXSA9IF8gPSBNICYgNjU1MzUgfCBIIDw8IDE2LCBwWzBdID0gZiA9IGogJiA2NTUzNSB8IFUgPDwgMTYsIG0gPSBDLCBFID0gYSwgaiA9IEUgJiA2NTUzNSwgVSA9IEUgPj4+IDE2LCBNID0gbSAmIDY1NTM1LCBIID0gbSA+Pj4gMTYsIG0gPSBkWzFdLCBFID0gcFsxXSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBVICs9IGogPj4+IDE2LCBNICs9IFUgPj4+IDE2LCBIICs9IE0gPj4+IDE2LCBkWzFdID0gQyA9IE0gJiA2NTUzNSB8IEggPDwgMTYsIHBbMV0gPSBhID0gaiAmIDY1NTM1IHwgVSA8PCAxNiwgbSA9IEYsIEUgPSBsLCBqID0gRSAmIDY1NTM1LCBVID0gRSA+Pj4gMTYsIE0gPSBtICYgNjU1MzUsIEggPSBtID4+PiAxNiwgbSA9IGRbMl0sIEUgPSBwWzJdLCBqICs9IEUgJiA2NTUzNSwgVSArPSBFID4+PiAxNiwgTSArPSBtICYgNjU1MzUsIEggKz0gbSA+Pj4gMTYsIFUgKz0gaiA+Pj4gMTYsIE0gKz0gVSA+Pj4gMTYsIEggKz0gTSA+Pj4gMTYsIGRbMl0gPSBGID0gTSAmIDY1NTM1IHwgSCA8PCAxNiwgcFsyXSA9IGwgPSBqICYgNjU1MzUgfCBVIDw8IDE2LCBtID0gSywgRSA9IEwsIGogPSBFICYgNjU1MzUsIFUgPSBFID4+PiAxNiwgTSA9IG0gJiA2NTUzNSwgSCA9IG0gPj4+IDE2LCBtID0gZFszXSwgRSA9IHBbM10sIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgVSArPSBqID4+PiAxNiwgTSArPSBVID4+PiAxNiwgSCArPSBNID4+PiAxNiwgZFszXSA9IEsgPSBNICYgNjU1MzUgfCBIIDw8IDE2LCBwWzNdID0gTCA9IGogJiA2NTUzNSB8IFUgPDwgMTYsIG0gPSBJLCBFID0gdiwgaiA9IEUgJiA2NTUzNSwgVSA9IEUgPj4+IDE2LCBNID0gbSAmIDY1NTM1LCBIID0gbSA+Pj4gMTYsIG0gPSBkWzRdLCBFID0gcFs0XSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBVICs9IGogPj4+IDE2LCBNICs9IFUgPj4+IDE2LCBIICs9IE0gPj4+IDE2LCBkWzRdID0gSSA9IE0gJiA2NTUzNSB8IEggPDwgMTYsIHBbNF0gPSB2ID0gaiAmIDY1NTM1IHwgVSA8PCAxNiwgbSA9IEQsIEUgPSBSLCBqID0gRSAmIDY1NTM1LCBVID0gRSA+Pj4gMTYsIE0gPSBtICYgNjU1MzUsIEggPSBtID4+PiAxNiwgbSA9IGRbNV0sIEUgPSBwWzVdLCBqICs9IEUgJiA2NTUzNSwgVSArPSBFID4+PiAxNiwgTSArPSBtICYgNjU1MzUsIEggKz0gbSA+Pj4gMTYsIFUgKz0gaiA+Pj4gMTYsIE0gKz0gVSA+Pj4gMTYsIEggKz0gTSA+Pj4gMTYsIGRbNV0gPSBEID0gTSAmIDY1NTM1IHwgSCA8PCAxNiwgcFs1XSA9IFIgPSBqICYgNjU1MzUgfCBVIDw8IDE2LCBtID0geSwgRSA9ICQsIGogPSBFICYgNjU1MzUsIFUgPSBFID4+PiAxNiwgTSA9IG0gJiA2NTUzNSwgSCA9IG0gPj4+IDE2LCBtID0gZFs2XSwgRSA9IHBbNl0sIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgVSArPSBqID4+PiAxNiwgTSArPSBVID4+PiAxNiwgSCArPSBNID4+PiAxNiwgZFs2XSA9IHkgPSBNICYgNjU1MzUgfCBIIDw8IDE2LCBwWzZdID0gJCA9IGogJiA2NTUzNSB8IFUgPDwgMTYsIG0gPSB3LCBFID0gcSwgaiA9IEUgJiA2NTUzNSwgVSA9IEUgPj4+IDE2LCBNID0gbSAmIDY1NTM1LCBIID0gbSA+Pj4gMTYsIG0gPSBkWzddLCBFID0gcFs3XSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBVICs9IGogPj4+IDE2LCBNICs9IFUgPj4+IDE2LCBIICs9IE0gPj4+IDE2LCBkWzddID0gdyA9IE0gJiA2NTUzNSB8IEggPDwgMTYsIHBbN10gPSBxID0gaiAmIDY1NTM1IHwgVSA8PCAxNiwgeCArPSAxMjgsIE8gLT0gMTI4O1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfVxuICBmdW5jdGlvbiBvKGMpIHtcbiAgICB2YXIgdSA9IG5ldyBzKCk7XG4gICAgdS51cGRhdGUoYyk7XG4gICAgdmFyIGQgPSB1LmRpZ2VzdCgpO1xuICAgIHJldHVybiB1LmNsZWFuKCksIGQ7XG4gIH1cbiAgaS5oYXNoID0gbztcbn0pKHljKTtcbihmdW5jdGlvbihpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGkuY29udmVydFNlY3JldEtleVRvWDI1NTE5ID0gaS5jb252ZXJ0UHVibGljS2V5VG9YMjU1MTkgPSBpLnZlcmlmeSA9IGkuc2lnbiA9IGkuZXh0cmFjdFB1YmxpY0tleUZyb21TZWNyZXRLZXkgPSBpLmdlbmVyYXRlS2V5UGFpciA9IGkuZ2VuZXJhdGVLZXlQYWlyRnJvbVNlZWQgPSBpLlNFRURfTEVOR1RIID0gaS5TRUNSRVRfS0VZX0xFTkdUSCA9IGkuUFVCTElDX0tFWV9MRU5HVEggPSBpLlNJR05BVFVSRV9MRU5HVEggPSB2b2lkIDA7XG4gIGNvbnN0IGUgPSBsaSwgdCA9IHljLCBzID0gUHQ7XG4gIGkuU0lHTkFUVVJFX0xFTkdUSCA9IDY0LCBpLlBVQkxJQ19LRVlfTEVOR1RIID0gMzIsIGkuU0VDUkVUX0tFWV9MRU5HVEggPSA2NCwgaS5TRUVEX0xFTkdUSCA9IDMyO1xuICBmdW5jdGlvbiByKFQpIHtcbiAgICBjb25zdCBBID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgaWYgKFQpXG4gICAgICBmb3IgKGxldCBOID0gMDsgTiA8IFQubGVuZ3RoOyBOKyspXG4gICAgICAgIEFbTl0gPSBUW05dO1xuICAgIHJldHVybiBBO1xuICB9XG4gIGNvbnN0IG4gPSBuZXcgVWludDhBcnJheSgzMik7XG4gIG5bMF0gPSA5O1xuICBjb25zdCBvID0gcigpLCBjID0gcihbMV0pLCB1ID0gcihbXG4gICAgMzA4ODMsXG4gICAgNDk1MyxcbiAgICAxOTkxNCxcbiAgICAzMDE4NyxcbiAgICA1NTQ2NyxcbiAgICAxNjcwNSxcbiAgICAyNjM3LFxuICAgIDExMixcbiAgICA1OTU0NCxcbiAgICAzMDU4NSxcbiAgICAxNjUwNSxcbiAgICAzNjAzOSxcbiAgICA2NTEzOSxcbiAgICAxMTExOSxcbiAgICAyNzg4NixcbiAgICAyMDk5NVxuICBdKSwgZCA9IHIoW1xuICAgIDYxNzg1LFxuICAgIDk5MDYsXG4gICAgMzk4MjgsXG4gICAgNjAzNzQsXG4gICAgNDUzOTgsXG4gICAgMzM0MTEsXG4gICAgNTI3NCxcbiAgICAyMjQsXG4gICAgNTM1NTIsXG4gICAgNjExNzEsXG4gICAgMzMwMTAsXG4gICAgNjU0MixcbiAgICA2NDc0MyxcbiAgICAyMjIzOSxcbiAgICA1NTc3MixcbiAgICA5MjIyXG4gIF0pLCBwID0gcihbXG4gICAgNTQ1NTQsXG4gICAgMzY2NDUsXG4gICAgMTE2MTYsXG4gICAgNTE1NDIsXG4gICAgNDI5MzAsXG4gICAgMzgxODEsXG4gICAgNTEwNDAsXG4gICAgMjY5MjQsXG4gICAgNTY0MTIsXG4gICAgNjQ5ODIsXG4gICAgNTc5MDUsXG4gICAgNDkzMTYsXG4gICAgMjE1MDIsXG4gICAgNTI1OTAsXG4gICAgMTQwMzUsXG4gICAgODU1M1xuICBdKSwgYiA9IHIoW1xuICAgIDI2MjAwLFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0LFxuICAgIDI2MjE0XG4gIF0pLCB4ID0gcihbXG4gICAgNDExMzYsXG4gICAgMTg5NTgsXG4gICAgNjk1MSxcbiAgICA1MDQxNCxcbiAgICA1ODQ4OCxcbiAgICA0NDMzNSxcbiAgICA2MTUwLFxuICAgIDEyMDk5LFxuICAgIDU1MjA3LFxuICAgIDE1ODY3LFxuICAgIDE1MyxcbiAgICAxMTA4NSxcbiAgICA1NzA5OSxcbiAgICAyMDQxNyxcbiAgICA5MzQ0LFxuICAgIDExMTM5XG4gIF0pO1xuICBmdW5jdGlvbiBPKFQsIEEpIHtcbiAgICBmb3IgKGxldCBOID0gMDsgTiA8IDE2OyBOKyspXG4gICAgICBUW05dID0gQVtOXSB8IDA7XG4gIH1cbiAgZnVuY3Rpb24gXyhUKSB7XG4gICAgbGV0IEEgPSAxO1xuICAgIGZvciAobGV0IE4gPSAwOyBOIDwgMTY7IE4rKykge1xuICAgICAgbGV0IGggPSBUW05dICsgQSArIDY1NTM1O1xuICAgICAgQSA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgVFtOXSA9IGggLSBBICogNjU1MzY7XG4gICAgfVxuICAgIFRbMF0gKz0gQSAtIDEgKyAzNyAqIChBIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gQyhULCBBLCBOKSB7XG4gICAgY29uc3QgaCA9IH4oTiAtIDEpO1xuICAgIGZvciAobGV0IFMgPSAwOyBTIDwgMTY7IFMrKykge1xuICAgICAgY29uc3QgVyA9IGggJiAoVFtTXSBeIEFbU10pO1xuICAgICAgVFtTXSBePSBXLCBBW1NdIF49IFc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIEYoVCwgQSkge1xuICAgIGNvbnN0IE4gPSByKCksIGggPSByKCk7XG4gICAgZm9yIChsZXQgUyA9IDA7IFMgPCAxNjsgUysrKVxuICAgICAgaFtTXSA9IEFbU107XG4gICAgXyhoKSwgXyhoKSwgXyhoKTtcbiAgICBmb3IgKGxldCBTID0gMDsgUyA8IDI7IFMrKykge1xuICAgICAgTlswXSA9IGhbMF0gLSA2NTUxNztcbiAgICAgIGZvciAobGV0IFggPSAxOyBYIDwgMTU7IFgrKylcbiAgICAgICAgTltYXSA9IGhbWF0gLSA2NTUzNSAtIChOW1ggLSAxXSA+PiAxNiAmIDEpLCBOW1ggLSAxXSAmPSA2NTUzNTtcbiAgICAgIE5bMTVdID0gaFsxNV0gLSAzMjc2NyAtIChOWzE0XSA+PiAxNiAmIDEpO1xuICAgICAgY29uc3QgVyA9IE5bMTVdID4+IDE2ICYgMTtcbiAgICAgIE5bMTRdICY9IDY1NTM1LCBDKGgsIE4sIDEgLSBXKTtcbiAgICB9XG4gICAgZm9yIChsZXQgUyA9IDA7IFMgPCAxNjsgUysrKVxuICAgICAgVFsyICogU10gPSBoW1NdICYgMjU1LCBUWzIgKiBTICsgMV0gPSBoW1NdID4+IDg7XG4gIH1cbiAgZnVuY3Rpb24gSyhULCBBKSB7XG4gICAgbGV0IE4gPSAwO1xuICAgIGZvciAobGV0IGggPSAwOyBoIDwgMzI7IGgrKylcbiAgICAgIE4gfD0gVFtoXSBeIEFbaF07XG4gICAgcmV0dXJuICgxICYgTiAtIDEgPj4+IDgpIC0gMTtcbiAgfVxuICBmdW5jdGlvbiBJKFQsIEEpIHtcbiAgICBjb25zdCBOID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBoID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHJldHVybiBGKE4sIFQpLCBGKGgsIEEpLCBLKE4sIGgpO1xuICB9XG4gIGZ1bmN0aW9uIEQoVCkge1xuICAgIGNvbnN0IEEgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcmV0dXJuIEYoQSwgVCksIEFbMF0gJiAxO1xuICB9XG4gIGZ1bmN0aW9uIHkoVCwgQSkge1xuICAgIGZvciAobGV0IE4gPSAwOyBOIDwgMTY7IE4rKylcbiAgICAgIFRbTl0gPSBBWzIgKiBOXSArIChBWzIgKiBOICsgMV0gPDwgOCk7XG4gICAgVFsxNV0gJj0gMzI3Njc7XG4gIH1cbiAgZnVuY3Rpb24gdyhULCBBLCBOKSB7XG4gICAgZm9yIChsZXQgaCA9IDA7IGggPCAxNjsgaCsrKVxuICAgICAgVFtoXSA9IEFbaF0gKyBOW2hdO1xuICB9XG4gIGZ1bmN0aW9uIGYoVCwgQSwgTikge1xuICAgIGZvciAobGV0IGggPSAwOyBoIDwgMTY7IGgrKylcbiAgICAgIFRbaF0gPSBBW2hdIC0gTltoXTtcbiAgfVxuICBmdW5jdGlvbiBhKFQsIEEsIE4pIHtcbiAgICBsZXQgaCwgUywgVyA9IDAsIFggPSAwLCBmZSA9IDAsIHZlID0gMCwgZ2UgPSAwLCBTZSA9IDAsIE1lID0gMCwgJGUgPSAwLCBiZSA9IDAsIHllID0gMCwgcGUgPSAwLCBsZSA9IDAsIHVlID0gMCwgaGUgPSAwLCBjZSA9IDAsIHJlID0gMCwgZGUgPSAwLCBtZSA9IDAsIG5lID0gMCwgX2UgPSAwLCBFZSA9IDAsIERlID0gMCwgeGUgPSAwLCBJZSA9IDAsIFV0ID0gMCwgcXQgPSAwLCBzaSA9IDAsIER0ID0gMCwgZmkgPSAwLCBLaSA9IDAsIE9zID0gMCwgcWUgPSBOWzBdLCBGZSA9IE5bMV0sIGplID0gTlsyXSwgemUgPSBOWzNdLCBLZSA9IE5bNF0sIFVlID0gTls1XSwgUWUgPSBOWzZdLCBYZSA9IE5bN10sIFplID0gTls4XSwgZXQgPSBOWzldLCB0dCA9IE5bMTBdLCBZZSA9IE5bMTFdLCBWZSA9IE5bMTJdLCBBZSA9IE5bMTNdLCBpdCA9IE5bMTRdLCBzdCA9IE5bMTVdO1xuICAgIGggPSBBWzBdLCBXICs9IGggKiBxZSwgWCArPSBoICogRmUsIGZlICs9IGggKiBqZSwgdmUgKz0gaCAqIHplLCBnZSArPSBoICogS2UsIFNlICs9IGggKiBVZSwgTWUgKz0gaCAqIFFlLCAkZSArPSBoICogWGUsIGJlICs9IGggKiBaZSwgeWUgKz0gaCAqIGV0LCBwZSArPSBoICogdHQsIGxlICs9IGggKiBZZSwgdWUgKz0gaCAqIFZlLCBoZSArPSBoICogQWUsIGNlICs9IGggKiBpdCwgcmUgKz0gaCAqIHN0LCBoID0gQVsxXSwgWCArPSBoICogcWUsIGZlICs9IGggKiBGZSwgdmUgKz0gaCAqIGplLCBnZSArPSBoICogemUsIFNlICs9IGggKiBLZSwgTWUgKz0gaCAqIFVlLCAkZSArPSBoICogUWUsIGJlICs9IGggKiBYZSwgeWUgKz0gaCAqIFplLCBwZSArPSBoICogZXQsIGxlICs9IGggKiB0dCwgdWUgKz0gaCAqIFllLCBoZSArPSBoICogVmUsIGNlICs9IGggKiBBZSwgcmUgKz0gaCAqIGl0LCBkZSArPSBoICogc3QsIGggPSBBWzJdLCBmZSArPSBoICogcWUsIHZlICs9IGggKiBGZSwgZ2UgKz0gaCAqIGplLCBTZSArPSBoICogemUsIE1lICs9IGggKiBLZSwgJGUgKz0gaCAqIFVlLCBiZSArPSBoICogUWUsIHllICs9IGggKiBYZSwgcGUgKz0gaCAqIFplLCBsZSArPSBoICogZXQsIHVlICs9IGggKiB0dCwgaGUgKz0gaCAqIFllLCBjZSArPSBoICogVmUsIHJlICs9IGggKiBBZSwgZGUgKz0gaCAqIGl0LCBtZSArPSBoICogc3QsIGggPSBBWzNdLCB2ZSArPSBoICogcWUsIGdlICs9IGggKiBGZSwgU2UgKz0gaCAqIGplLCBNZSArPSBoICogemUsICRlICs9IGggKiBLZSwgYmUgKz0gaCAqIFVlLCB5ZSArPSBoICogUWUsIHBlICs9IGggKiBYZSwgbGUgKz0gaCAqIFplLCB1ZSArPSBoICogZXQsIGhlICs9IGggKiB0dCwgY2UgKz0gaCAqIFllLCByZSArPSBoICogVmUsIGRlICs9IGggKiBBZSwgbWUgKz0gaCAqIGl0LCBuZSArPSBoICogc3QsIGggPSBBWzRdLCBnZSArPSBoICogcWUsIFNlICs9IGggKiBGZSwgTWUgKz0gaCAqIGplLCAkZSArPSBoICogemUsIGJlICs9IGggKiBLZSwgeWUgKz0gaCAqIFVlLCBwZSArPSBoICogUWUsIGxlICs9IGggKiBYZSwgdWUgKz0gaCAqIFplLCBoZSArPSBoICogZXQsIGNlICs9IGggKiB0dCwgcmUgKz0gaCAqIFllLCBkZSArPSBoICogVmUsIG1lICs9IGggKiBBZSwgbmUgKz0gaCAqIGl0LCBfZSArPSBoICogc3QsIGggPSBBWzVdLCBTZSArPSBoICogcWUsIE1lICs9IGggKiBGZSwgJGUgKz0gaCAqIGplLCBiZSArPSBoICogemUsIHllICs9IGggKiBLZSwgcGUgKz0gaCAqIFVlLCBsZSArPSBoICogUWUsIHVlICs9IGggKiBYZSwgaGUgKz0gaCAqIFplLCBjZSArPSBoICogZXQsIHJlICs9IGggKiB0dCwgZGUgKz0gaCAqIFllLCBtZSArPSBoICogVmUsIG5lICs9IGggKiBBZSwgX2UgKz0gaCAqIGl0LCBFZSArPSBoICogc3QsIGggPSBBWzZdLCBNZSArPSBoICogcWUsICRlICs9IGggKiBGZSwgYmUgKz0gaCAqIGplLCB5ZSArPSBoICogemUsIHBlICs9IGggKiBLZSwgbGUgKz0gaCAqIFVlLCB1ZSArPSBoICogUWUsIGhlICs9IGggKiBYZSwgY2UgKz0gaCAqIFplLCByZSArPSBoICogZXQsIGRlICs9IGggKiB0dCwgbWUgKz0gaCAqIFllLCBuZSArPSBoICogVmUsIF9lICs9IGggKiBBZSwgRWUgKz0gaCAqIGl0LCBEZSArPSBoICogc3QsIGggPSBBWzddLCAkZSArPSBoICogcWUsIGJlICs9IGggKiBGZSwgeWUgKz0gaCAqIGplLCBwZSArPSBoICogemUsIGxlICs9IGggKiBLZSwgdWUgKz0gaCAqIFVlLCBoZSArPSBoICogUWUsIGNlICs9IGggKiBYZSwgcmUgKz0gaCAqIFplLCBkZSArPSBoICogZXQsIG1lICs9IGggKiB0dCwgbmUgKz0gaCAqIFllLCBfZSArPSBoICogVmUsIEVlICs9IGggKiBBZSwgRGUgKz0gaCAqIGl0LCB4ZSArPSBoICogc3QsIGggPSBBWzhdLCBiZSArPSBoICogcWUsIHllICs9IGggKiBGZSwgcGUgKz0gaCAqIGplLCBsZSArPSBoICogemUsIHVlICs9IGggKiBLZSwgaGUgKz0gaCAqIFVlLCBjZSArPSBoICogUWUsIHJlICs9IGggKiBYZSwgZGUgKz0gaCAqIFplLCBtZSArPSBoICogZXQsIG5lICs9IGggKiB0dCwgX2UgKz0gaCAqIFllLCBFZSArPSBoICogVmUsIERlICs9IGggKiBBZSwgeGUgKz0gaCAqIGl0LCBJZSArPSBoICogc3QsIGggPSBBWzldLCB5ZSArPSBoICogcWUsIHBlICs9IGggKiBGZSwgbGUgKz0gaCAqIGplLCB1ZSArPSBoICogemUsIGhlICs9IGggKiBLZSwgY2UgKz0gaCAqIFVlLCByZSArPSBoICogUWUsIGRlICs9IGggKiBYZSwgbWUgKz0gaCAqIFplLCBuZSArPSBoICogZXQsIF9lICs9IGggKiB0dCwgRWUgKz0gaCAqIFllLCBEZSArPSBoICogVmUsIHhlICs9IGggKiBBZSwgSWUgKz0gaCAqIGl0LCBVdCArPSBoICogc3QsIGggPSBBWzEwXSwgcGUgKz0gaCAqIHFlLCBsZSArPSBoICogRmUsIHVlICs9IGggKiBqZSwgaGUgKz0gaCAqIHplLCBjZSArPSBoICogS2UsIHJlICs9IGggKiBVZSwgZGUgKz0gaCAqIFFlLCBtZSArPSBoICogWGUsIG5lICs9IGggKiBaZSwgX2UgKz0gaCAqIGV0LCBFZSArPSBoICogdHQsIERlICs9IGggKiBZZSwgeGUgKz0gaCAqIFZlLCBJZSArPSBoICogQWUsIFV0ICs9IGggKiBpdCwgcXQgKz0gaCAqIHN0LCBoID0gQVsxMV0sIGxlICs9IGggKiBxZSwgdWUgKz0gaCAqIEZlLCBoZSArPSBoICogamUsIGNlICs9IGggKiB6ZSwgcmUgKz0gaCAqIEtlLCBkZSArPSBoICogVWUsIG1lICs9IGggKiBRZSwgbmUgKz0gaCAqIFhlLCBfZSArPSBoICogWmUsIEVlICs9IGggKiBldCwgRGUgKz0gaCAqIHR0LCB4ZSArPSBoICogWWUsIEllICs9IGggKiBWZSwgVXQgKz0gaCAqIEFlLCBxdCArPSBoICogaXQsIHNpICs9IGggKiBzdCwgaCA9IEFbMTJdLCB1ZSArPSBoICogcWUsIGhlICs9IGggKiBGZSwgY2UgKz0gaCAqIGplLCByZSArPSBoICogemUsIGRlICs9IGggKiBLZSwgbWUgKz0gaCAqIFVlLCBuZSArPSBoICogUWUsIF9lICs9IGggKiBYZSwgRWUgKz0gaCAqIFplLCBEZSArPSBoICogZXQsIHhlICs9IGggKiB0dCwgSWUgKz0gaCAqIFllLCBVdCArPSBoICogVmUsIHF0ICs9IGggKiBBZSwgc2kgKz0gaCAqIGl0LCBEdCArPSBoICogc3QsIGggPSBBWzEzXSwgaGUgKz0gaCAqIHFlLCBjZSArPSBoICogRmUsIHJlICs9IGggKiBqZSwgZGUgKz0gaCAqIHplLCBtZSArPSBoICogS2UsIG5lICs9IGggKiBVZSwgX2UgKz0gaCAqIFFlLCBFZSArPSBoICogWGUsIERlICs9IGggKiBaZSwgeGUgKz0gaCAqIGV0LCBJZSArPSBoICogdHQsIFV0ICs9IGggKiBZZSwgcXQgKz0gaCAqIFZlLCBzaSArPSBoICogQWUsIER0ICs9IGggKiBpdCwgZmkgKz0gaCAqIHN0LCBoID0gQVsxNF0sIGNlICs9IGggKiBxZSwgcmUgKz0gaCAqIEZlLCBkZSArPSBoICogamUsIG1lICs9IGggKiB6ZSwgbmUgKz0gaCAqIEtlLCBfZSArPSBoICogVWUsIEVlICs9IGggKiBRZSwgRGUgKz0gaCAqIFhlLCB4ZSArPSBoICogWmUsIEllICs9IGggKiBldCwgVXQgKz0gaCAqIHR0LCBxdCArPSBoICogWWUsIHNpICs9IGggKiBWZSwgRHQgKz0gaCAqIEFlLCBmaSArPSBoICogaXQsIEtpICs9IGggKiBzdCwgaCA9IEFbMTVdLCByZSArPSBoICogcWUsIGRlICs9IGggKiBGZSwgbWUgKz0gaCAqIGplLCBuZSArPSBoICogemUsIF9lICs9IGggKiBLZSwgRWUgKz0gaCAqIFVlLCBEZSArPSBoICogUWUsIHhlICs9IGggKiBYZSwgSWUgKz0gaCAqIFplLCBVdCArPSBoICogZXQsIHF0ICs9IGggKiB0dCwgc2kgKz0gaCAqIFllLCBEdCArPSBoICogVmUsIGZpICs9IGggKiBBZSwgS2kgKz0gaCAqIGl0LCBPcyArPSBoICogc3QsIFcgKz0gMzggKiBkZSwgWCArPSAzOCAqIG1lLCBmZSArPSAzOCAqIG5lLCB2ZSArPSAzOCAqIF9lLCBnZSArPSAzOCAqIEVlLCBTZSArPSAzOCAqIERlLCBNZSArPSAzOCAqIHhlLCAkZSArPSAzOCAqIEllLCBiZSArPSAzOCAqIFV0LCB5ZSArPSAzOCAqIHF0LCBwZSArPSAzOCAqIHNpLCBsZSArPSAzOCAqIER0LCB1ZSArPSAzOCAqIGZpLCBoZSArPSAzOCAqIEtpLCBjZSArPSAzOCAqIE9zLCBTID0gMSwgaCA9IFcgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIFcgPSBoIC0gUyAqIDY1NTM2LCBoID0gWCArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgWCA9IGggLSBTICogNjU1MzYsIGggPSBmZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgZmUgPSBoIC0gUyAqIDY1NTM2LCBoID0gdmUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIHZlID0gaCAtIFMgKiA2NTUzNiwgaCA9IGdlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBnZSA9IGggLSBTICogNjU1MzYsIGggPSBTZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgU2UgPSBoIC0gUyAqIDY1NTM2LCBoID0gTWUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIE1lID0gaCAtIFMgKiA2NTUzNiwgaCA9ICRlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCAkZSA9IGggLSBTICogNjU1MzYsIGggPSBiZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgYmUgPSBoIC0gUyAqIDY1NTM2LCBoID0geWUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIHllID0gaCAtIFMgKiA2NTUzNiwgaCA9IHBlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBwZSA9IGggLSBTICogNjU1MzYsIGggPSBsZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgbGUgPSBoIC0gUyAqIDY1NTM2LCBoID0gdWUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIHVlID0gaCAtIFMgKiA2NTUzNiwgaCA9IGhlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBoZSA9IGggLSBTICogNjU1MzYsIGggPSBjZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgY2UgPSBoIC0gUyAqIDY1NTM2LCBoID0gcmUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIHJlID0gaCAtIFMgKiA2NTUzNiwgVyArPSBTIC0gMSArIDM3ICogKFMgLSAxKSwgUyA9IDEsIGggPSBXICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBXID0gaCAtIFMgKiA2NTUzNiwgaCA9IFggKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIFggPSBoIC0gUyAqIDY1NTM2LCBoID0gZmUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIGZlID0gaCAtIFMgKiA2NTUzNiwgaCA9IHZlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCB2ZSA9IGggLSBTICogNjU1MzYsIGggPSBnZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgZ2UgPSBoIC0gUyAqIDY1NTM2LCBoID0gU2UgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIFNlID0gaCAtIFMgKiA2NTUzNiwgaCA9IE1lICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBNZSA9IGggLSBTICogNjU1MzYsIGggPSAkZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgJGUgPSBoIC0gUyAqIDY1NTM2LCBoID0gYmUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIGJlID0gaCAtIFMgKiA2NTUzNiwgaCA9IHllICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCB5ZSA9IGggLSBTICogNjU1MzYsIGggPSBwZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgcGUgPSBoIC0gUyAqIDY1NTM2LCBoID0gbGUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIGxlID0gaCAtIFMgKiA2NTUzNiwgaCA9IHVlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCB1ZSA9IGggLSBTICogNjU1MzYsIGggPSBoZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgaGUgPSBoIC0gUyAqIDY1NTM2LCBoID0gY2UgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIGNlID0gaCAtIFMgKiA2NTUzNiwgaCA9IHJlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCByZSA9IGggLSBTICogNjU1MzYsIFcgKz0gUyAtIDEgKyAzNyAqIChTIC0gMSksIFRbMF0gPSBXLCBUWzFdID0gWCwgVFsyXSA9IGZlLCBUWzNdID0gdmUsIFRbNF0gPSBnZSwgVFs1XSA9IFNlLCBUWzZdID0gTWUsIFRbN10gPSAkZSwgVFs4XSA9IGJlLCBUWzldID0geWUsIFRbMTBdID0gcGUsIFRbMTFdID0gbGUsIFRbMTJdID0gdWUsIFRbMTNdID0gaGUsIFRbMTRdID0gY2UsIFRbMTVdID0gcmU7XG4gIH1cbiAgZnVuY3Rpb24gbChULCBBKSB7XG4gICAgYShULCBBLCBBKTtcbiAgfVxuICBmdW5jdGlvbiBMKFQsIEEpIHtcbiAgICBjb25zdCBOID0gcigpO1xuICAgIGxldCBoO1xuICAgIGZvciAoaCA9IDA7IGggPCAxNjsgaCsrKVxuICAgICAgTltoXSA9IEFbaF07XG4gICAgZm9yIChoID0gMjUzOyBoID49IDA7IGgtLSlcbiAgICAgIGwoTiwgTiksIGggIT09IDIgJiYgaCAhPT0gNCAmJiBhKE4sIE4sIEEpO1xuICAgIGZvciAoaCA9IDA7IGggPCAxNjsgaCsrKVxuICAgICAgVFtoXSA9IE5baF07XG4gIH1cbiAgZnVuY3Rpb24gdihULCBBKSB7XG4gICAgY29uc3QgTiA9IHIoKTtcbiAgICBsZXQgaDtcbiAgICBmb3IgKGggPSAwOyBoIDwgMTY7IGgrKylcbiAgICAgIE5baF0gPSBBW2hdO1xuICAgIGZvciAoaCA9IDI1MDsgaCA+PSAwOyBoLS0pXG4gICAgICBsKE4sIE4pLCBoICE9PSAxICYmIGEoTiwgTiwgQSk7XG4gICAgZm9yIChoID0gMDsgaCA8IDE2OyBoKyspXG4gICAgICBUW2hdID0gTltoXTtcbiAgfVxuICBmdW5jdGlvbiBSKFQsIEEpIHtcbiAgICBjb25zdCBOID0gcigpLCBoID0gcigpLCBTID0gcigpLCBXID0gcigpLCBYID0gcigpLCBmZSA9IHIoKSwgdmUgPSByKCksIGdlID0gcigpLCBTZSA9IHIoKTtcbiAgICBmKE4sIFRbMV0sIFRbMF0pLCBmKFNlLCBBWzFdLCBBWzBdKSwgYShOLCBOLCBTZSksIHcoaCwgVFswXSwgVFsxXSksIHcoU2UsIEFbMF0sIEFbMV0pLCBhKGgsIGgsIFNlKSwgYShTLCBUWzNdLCBBWzNdKSwgYShTLCBTLCBkKSwgYShXLCBUWzJdLCBBWzJdKSwgdyhXLCBXLCBXKSwgZihYLCBoLCBOKSwgZihmZSwgVywgUyksIHcodmUsIFcsIFMpLCB3KGdlLCBoLCBOKSwgYShUWzBdLCBYLCBmZSksIGEoVFsxXSwgZ2UsIHZlKSwgYShUWzJdLCB2ZSwgZmUpLCBhKFRbM10sIFgsIGdlKTtcbiAgfVxuICBmdW5jdGlvbiAkKFQsIEEsIE4pIHtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IDQ7IGgrKylcbiAgICAgIEMoVFtoXSwgQVtoXSwgTik7XG4gIH1cbiAgZnVuY3Rpb24gcShULCBBKSB7XG4gICAgY29uc3QgTiA9IHIoKSwgaCA9IHIoKSwgUyA9IHIoKTtcbiAgICBMKFMsIEFbMl0pLCBhKE4sIEFbMF0sIFMpLCBhKGgsIEFbMV0sIFMpLCBGKFQsIGgpLCBUWzMxXSBePSBEKE4pIDw8IDc7XG4gIH1cbiAgZnVuY3Rpb24gbShULCBBLCBOKSB7XG4gICAgTyhUWzBdLCBvKSwgTyhUWzFdLCBjKSwgTyhUWzJdLCBjKSwgTyhUWzNdLCBvKTtcbiAgICBmb3IgKGxldCBoID0gMjU1OyBoID49IDA7IC0taCkge1xuICAgICAgY29uc3QgUyA9IE5baCAvIDggfCAwXSA+PiAoaCAmIDcpICYgMTtcbiAgICAgICQoVCwgQSwgUyksIFIoQSwgVCksIFIoVCwgVCksICQoVCwgQSwgUyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIEUoVCwgQSkge1xuICAgIGNvbnN0IE4gPSBbcigpLCByKCksIHIoKSwgcigpXTtcbiAgICBPKE5bMF0sIHApLCBPKE5bMV0sIGIpLCBPKE5bMl0sIGMpLCBhKE5bM10sIHAsIGIpLCBtKFQsIE4sIEEpO1xuICB9XG4gIGZ1bmN0aW9uIEIoVCkge1xuICAgIGlmIChULmxlbmd0aCAhPT0gaS5TRUVEX0xFTkdUSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZWQyNTUxOTogc2VlZCBtdXN0IGJlICR7aS5TRUVEX0xFTkdUSH0gYnl0ZXNgKTtcbiAgICBjb25zdCBBID0gKDAsIHQuaGFzaCkoVCk7XG4gICAgQVswXSAmPSAyNDgsIEFbMzFdICY9IDEyNywgQVszMV0gfD0gNjQ7XG4gICAgY29uc3QgTiA9IG5ldyBVaW50OEFycmF5KDMyKSwgaCA9IFtyKCksIHIoKSwgcigpLCByKCldO1xuICAgIEUoaCwgQSksIHEoTiwgaCk7XG4gICAgY29uc3QgUyA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICByZXR1cm4gUy5zZXQoVCksIFMuc2V0KE4sIDMyKSwge1xuICAgICAgcHVibGljS2V5OiBOLFxuICAgICAgc2VjcmV0S2V5OiBTXG4gICAgfTtcbiAgfVxuICBpLmdlbmVyYXRlS2V5UGFpckZyb21TZWVkID0gQjtcbiAgZnVuY3Rpb24geihUKSB7XG4gICAgY29uc3QgQSA9ICgwLCBlLnJhbmRvbUJ5dGVzKSgzMiwgVCksIE4gPSBCKEEpO1xuICAgIHJldHVybiAoMCwgcy53aXBlKShBKSwgTjtcbiAgfVxuICBpLmdlbmVyYXRlS2V5UGFpciA9IHo7XG4gIGZ1bmN0aW9uIGooVCkge1xuICAgIGlmIChULmxlbmd0aCAhPT0gaS5TRUNSRVRfS0VZX0xFTkdUSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZWQyNTUxOTogc2VjcmV0IGtleSBtdXN0IGJlICR7aS5TRUNSRVRfS0VZX0xFTkdUSH0gYnl0ZXNgKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoVC5zdWJhcnJheSgzMikpO1xuICB9XG4gIGkuZXh0cmFjdFB1YmxpY0tleUZyb21TZWNyZXRLZXkgPSBqO1xuICBjb25zdCBVID0gbmV3IEZsb2F0NjRBcnJheShbXG4gICAgMjM3LFxuICAgIDIxMSxcbiAgICAyNDUsXG4gICAgOTIsXG4gICAgMjYsXG4gICAgOTksXG4gICAgMTgsXG4gICAgODgsXG4gICAgMjE0LFxuICAgIDE1NixcbiAgICAyNDcsXG4gICAgMTYyLFxuICAgIDIyMixcbiAgICAyNDksXG4gICAgMjIyLFxuICAgIDIwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDE2XG4gIF0pO1xuICBmdW5jdGlvbiBNKFQsIEEpIHtcbiAgICBsZXQgTiwgaCwgUywgVztcbiAgICBmb3IgKGggPSA2MzsgaCA+PSAzMjsgLS1oKSB7XG4gICAgICBmb3IgKE4gPSAwLCBTID0gaCAtIDMyLCBXID0gaCAtIDEyOyBTIDwgVzsgKytTKVxuICAgICAgICBBW1NdICs9IE4gLSAxNiAqIEFbaF0gKiBVW1MgLSAoaCAtIDMyKV0sIE4gPSBNYXRoLmZsb29yKChBW1NdICsgMTI4KSAvIDI1NiksIEFbU10gLT0gTiAqIDI1NjtcbiAgICAgIEFbU10gKz0gTiwgQVtoXSA9IDA7XG4gICAgfVxuICAgIGZvciAoTiA9IDAsIFMgPSAwOyBTIDwgMzI7IFMrKylcbiAgICAgIEFbU10gKz0gTiAtIChBWzMxXSA+PiA0KSAqIFVbU10sIE4gPSBBW1NdID4+IDgsIEFbU10gJj0gMjU1O1xuICAgIGZvciAoUyA9IDA7IFMgPCAzMjsgUysrKVxuICAgICAgQVtTXSAtPSBOICogVVtTXTtcbiAgICBmb3IgKGggPSAwOyBoIDwgMzI7IGgrKylcbiAgICAgIEFbaCArIDFdICs9IEFbaF0gPj4gOCwgVFtoXSA9IEFbaF0gJiAyNTU7XG4gIH1cbiAgZnVuY3Rpb24gSChUKSB7XG4gICAgY29uc3QgQSA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpO1xuICAgIGZvciAobGV0IE4gPSAwOyBOIDwgNjQ7IE4rKylcbiAgICAgIEFbTl0gPSBUW05dO1xuICAgIGZvciAobGV0IE4gPSAwOyBOIDwgNjQ7IE4rKylcbiAgICAgIFRbTl0gPSAwO1xuICAgIE0oVCwgQSk7XG4gIH1cbiAgZnVuY3Rpb24gdGUoVCwgQSkge1xuICAgIGNvbnN0IE4gPSBuZXcgRmxvYXQ2NEFycmF5KDY0KSwgaCA9IFtyKCksIHIoKSwgcigpLCByKCldLCBTID0gKDAsIHQuaGFzaCkoVC5zdWJhcnJheSgwLCAzMikpO1xuICAgIFNbMF0gJj0gMjQ4LCBTWzMxXSAmPSAxMjcsIFNbMzFdIHw9IDY0O1xuICAgIGNvbnN0IFcgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgVy5zZXQoUy5zdWJhcnJheSgzMiksIDMyKTtcbiAgICBjb25zdCBYID0gbmV3IHQuU0hBNTEyKCk7XG4gICAgWC51cGRhdGUoVy5zdWJhcnJheSgzMikpLCBYLnVwZGF0ZShBKTtcbiAgICBjb25zdCBmZSA9IFguZGlnZXN0KCk7XG4gICAgWC5jbGVhbigpLCBIKGZlKSwgRShoLCBmZSksIHEoVywgaCksIFgucmVzZXQoKSwgWC51cGRhdGUoVy5zdWJhcnJheSgwLCAzMikpLCBYLnVwZGF0ZShULnN1YmFycmF5KDMyKSksIFgudXBkYXRlKEEpO1xuICAgIGNvbnN0IHZlID0gWC5kaWdlc3QoKTtcbiAgICBIKHZlKTtcbiAgICBmb3IgKGxldCBnZSA9IDA7IGdlIDwgMzI7IGdlKyspXG4gICAgICBOW2dlXSA9IGZlW2dlXTtcbiAgICBmb3IgKGxldCBnZSA9IDA7IGdlIDwgMzI7IGdlKyspXG4gICAgICBmb3IgKGxldCBTZSA9IDA7IFNlIDwgMzI7IFNlKyspXG4gICAgICAgIE5bZ2UgKyBTZV0gKz0gdmVbZ2VdICogU1tTZV07XG4gICAgcmV0dXJuIE0oVy5zdWJhcnJheSgzMiksIE4pLCBXO1xuICB9XG4gIGkuc2lnbiA9IHRlO1xuICBmdW5jdGlvbiBHKFQsIEEpIHtcbiAgICBjb25zdCBOID0gcigpLCBoID0gcigpLCBTID0gcigpLCBXID0gcigpLCBYID0gcigpLCBmZSA9IHIoKSwgdmUgPSByKCk7XG4gICAgcmV0dXJuIE8oVFsyXSwgYyksIHkoVFsxXSwgQSksIGwoUywgVFsxXSksIGEoVywgUywgdSksIGYoUywgUywgVFsyXSksIHcoVywgVFsyXSwgVyksIGwoWCwgVyksIGwoZmUsIFgpLCBhKHZlLCBmZSwgWCksIGEoTiwgdmUsIFMpLCBhKE4sIE4sIFcpLCB2KE4sIE4pLCBhKE4sIE4sIFMpLCBhKE4sIE4sIFcpLCBhKE4sIE4sIFcpLCBhKFRbMF0sIE4sIFcpLCBsKGgsIFRbMF0pLCBhKGgsIGgsIFcpLCBJKGgsIFMpICYmIGEoVFswXSwgVFswXSwgeCksIGwoaCwgVFswXSksIGEoaCwgaCwgVyksIEkoaCwgUykgPyAtMSA6IChEKFRbMF0pID09PSBBWzMxXSA+PiA3ICYmIGYoVFswXSwgbywgVFswXSksIGEoVFszXSwgVFswXSwgVFsxXSksIDApO1xuICB9XG4gIGZ1bmN0aW9uIGllKFQsIEEsIE4pIHtcbiAgICBjb25zdCBoID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBTID0gW3IoKSwgcigpLCByKCksIHIoKV0sIFcgPSBbcigpLCByKCksIHIoKSwgcigpXTtcbiAgICBpZiAoTi5sZW5ndGggIT09IGkuU0lHTkFUVVJFX0xFTkdUSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZWQyNTUxOTogc2lnbmF0dXJlIG11c3QgYmUgJHtpLlNJR05BVFVSRV9MRU5HVEh9IGJ5dGVzYCk7XG4gICAgaWYgKEcoVywgVCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgWCA9IG5ldyB0LlNIQTUxMigpO1xuICAgIFgudXBkYXRlKE4uc3ViYXJyYXkoMCwgMzIpKSwgWC51cGRhdGUoVCksIFgudXBkYXRlKEEpO1xuICAgIGNvbnN0IGZlID0gWC5kaWdlc3QoKTtcbiAgICByZXR1cm4gSChmZSksIG0oUywgVywgZmUpLCBFKFcsIE4uc3ViYXJyYXkoMzIpKSwgUihTLCBXKSwgcShoLCBTKSwgIUsoTiwgaCk7XG4gIH1cbiAgaS52ZXJpZnkgPSBpZTtcbiAgZnVuY3Rpb24gUShUKSB7XG4gICAgbGV0IEEgPSBbcigpLCByKCksIHIoKSwgcigpXTtcbiAgICBpZiAoRyhBLCBUKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVkMjU1MTk6IGludmFsaWQgcHVibGljIGtleVwiKTtcbiAgICBsZXQgTiA9IHIoKSwgaCA9IHIoKSwgUyA9IEFbMV07XG4gICAgdyhOLCBjLCBTKSwgZihoLCBjLCBTKSwgTChoLCBoKSwgYShOLCBOLCBoKTtcbiAgICBsZXQgVyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICByZXR1cm4gRihXLCBOKSwgVztcbiAgfVxuICBpLmNvbnZlcnRQdWJsaWNLZXlUb1gyNTUxOSA9IFE7XG4gIGZ1bmN0aW9uIHNlKFQpIHtcbiAgICBjb25zdCBBID0gKDAsIHQuaGFzaCkoVC5zdWJhcnJheSgwLCAzMikpO1xuICAgIEFbMF0gJj0gMjQ4LCBBWzMxXSAmPSAxMjcsIEFbMzFdIHw9IDY0O1xuICAgIGNvbnN0IE4gPSBuZXcgVWludDhBcnJheShBLnN1YmFycmF5KDAsIDMyKSk7XG4gICAgcmV0dXJuICgwLCBzLndpcGUpKEEpLCBOO1xuICB9XG4gIGkuY29udmVydFNlY3JldEtleVRvWDI1NTE5ID0gc2U7XG59KShubik7XG5jb25zdCBzZCA9IFwiRWREU0FcIiwgcmQgPSBcIkpXVFwiLCBtYyA9IFwiLlwiLCBiYyA9IFwiYmFzZTY0dXJsXCIsIG5kID0gXCJ1dGY4XCIsIG9kID0gXCJ1dGY4XCIsIGFkID0gXCI6XCIsIGNkID0gXCJkaWRcIiwgaGQgPSBcImtleVwiLCBtbyA9IFwiYmFzZTU4YnRjXCIsIHVkID0gXCJ6XCIsIGxkID0gXCJLMzZcIiwgZGQgPSAzMjtcbmZ1bmN0aW9uIG9uKGkpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgPyBuZXcgVWludDhBcnJheShpLmJ1ZmZlciwgaS5ieXRlT2Zmc2V0LCBpLmJ5dGVMZW5ndGgpIDogaTtcbn1cbmZ1bmN0aW9uIHdjKGkgPSAwKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jVW5zYWZlICE9IG51bGwgPyBvbihnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZShpKSkgOiBuZXcgVWludDhBcnJheShpKTtcbn1cbmZ1bmN0aW9uIGxzKGksIGUpIHtcbiAgZSB8fCAoZSA9IGkucmVkdWNlKChyLCBuKSA9PiByICsgbi5sZW5ndGgsIDApKTtcbiAgY29uc3QgdCA9IHdjKGUpO1xuICBsZXQgcyA9IDA7XG4gIGZvciAoY29uc3QgciBvZiBpKVxuICAgIHQuc2V0KHIsIHMpLCBzICs9IHIubGVuZ3RoO1xuICByZXR1cm4gb24odCk7XG59XG5mdW5jdGlvbiBmZChpLCBlKSB7XG4gIGlmIChpLmxlbmd0aCA+PSAyNTUpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFscGhhYmV0IHRvbyBsb25nXCIpO1xuICBmb3IgKHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KSwgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcysrKVxuICAgIHRbc10gPSAyNTU7XG4gIGZvciAodmFyIHIgPSAwOyByIDwgaS5sZW5ndGg7IHIrKykge1xuICAgIHZhciBuID0gaS5jaGFyQXQociksIG8gPSBuLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKHRbb10gIT09IDI1NSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobiArIFwiIGlzIGFtYmlndW91c1wiKTtcbiAgICB0W29dID0gcjtcbiAgfVxuICB2YXIgYyA9IGkubGVuZ3RoLCB1ID0gaS5jaGFyQXQoMCksIGQgPSBNYXRoLmxvZyhjKSAvIE1hdGgubG9nKDI1NiksIHAgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coYyk7XG4gIGZ1bmN0aW9uIGIoXykge1xuICAgIGlmIChfIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KF8pID8gXyA9IG5ldyBVaW50OEFycmF5KF8uYnVmZmVyLCBfLmJ5dGVPZmZzZXQsIF8uYnl0ZUxlbmd0aCkgOiBBcnJheS5pc0FycmF5KF8pICYmIChfID0gVWludDhBcnJheS5mcm9tKF8pKSksICEoXyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFVpbnQ4QXJyYXlcIik7XG4gICAgaWYgKF8ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgZm9yICh2YXIgQyA9IDAsIEYgPSAwLCBLID0gMCwgSSA9IF8ubGVuZ3RoOyBLICE9PSBJICYmIF9bS10gPT09IDA7IClcbiAgICAgIEsrKywgQysrO1xuICAgIGZvciAodmFyIEQgPSAoSSAtIEspICogcCArIDEgPj4+IDAsIHkgPSBuZXcgVWludDhBcnJheShEKTsgSyAhPT0gSTsgKSB7XG4gICAgICBmb3IgKHZhciB3ID0gX1tLXSwgZiA9IDAsIGEgPSBEIC0gMTsgKHcgIT09IDAgfHwgZiA8IEYpICYmIGEgIT09IC0xOyBhLS0sIGYrKylcbiAgICAgICAgdyArPSAyNTYgKiB5W2FdID4+PiAwLCB5W2FdID0gdyAlIGMgPj4+IDAsIHcgPSB3IC8gYyA+Pj4gMDtcbiAgICAgIGlmICh3ICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24temVybyBjYXJyeVwiKTtcbiAgICAgIEYgPSBmLCBLKys7XG4gICAgfVxuICAgIGZvciAodmFyIGwgPSBEIC0gRjsgbCAhPT0gRCAmJiB5W2xdID09PSAwOyApXG4gICAgICBsKys7XG4gICAgZm9yICh2YXIgTCA9IHUucmVwZWF0KEMpOyBsIDwgRDsgKytsKVxuICAgICAgTCArPSBpLmNoYXJBdCh5W2xdKTtcbiAgICByZXR1cm4gTDtcbiAgfVxuICBmdW5jdGlvbiB4KF8pIHtcbiAgICBpZiAodHlwZW9mIF8gIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmdcIik7XG4gICAgaWYgKF8ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgdmFyIEMgPSAwO1xuICAgIGlmIChfW0NdICE9PSBcIiBcIikge1xuICAgICAgZm9yICh2YXIgRiA9IDAsIEsgPSAwOyBfW0NdID09PSB1OyApXG4gICAgICAgIEYrKywgQysrO1xuICAgICAgZm9yICh2YXIgSSA9IChfLmxlbmd0aCAtIEMpICogZCArIDEgPj4+IDAsIEQgPSBuZXcgVWludDhBcnJheShJKTsgX1tDXTsgKSB7XG4gICAgICAgIHZhciB5ID0gdFtfLmNoYXJDb2RlQXQoQyldO1xuICAgICAgICBpZiAoeSA9PT0gMjU1KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgdyA9IDAsIGYgPSBJIC0gMTsgKHkgIT09IDAgfHwgdyA8IEspICYmIGYgIT09IC0xOyBmLS0sIHcrKylcbiAgICAgICAgICB5ICs9IGMgKiBEW2ZdID4+PiAwLCBEW2ZdID0geSAlIDI1NiA+Pj4gMCwgeSA9IHkgLyAyNTYgPj4+IDA7XG4gICAgICAgIGlmICh5ICE9PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi16ZXJvIGNhcnJ5XCIpO1xuICAgICAgICBLID0gdywgQysrO1xuICAgICAgfVxuICAgICAgaWYgKF9bQ10gIT09IFwiIFwiKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBJIC0gSzsgYSAhPT0gSSAmJiBEW2FdID09PSAwOyApXG4gICAgICAgICAgYSsrO1xuICAgICAgICBmb3IgKHZhciBsID0gbmV3IFVpbnQ4QXJyYXkoRiArIChJIC0gYSkpLCBMID0gRjsgYSAhPT0gSTsgKVxuICAgICAgICAgIGxbTCsrXSA9IERbYSsrXTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIE8oXykge1xuICAgIHZhciBDID0geChfKTtcbiAgICBpZiAoQylcbiAgICAgIHJldHVybiBDO1xuICAgIHRocm93IG5ldyBFcnJvcihgTm9uLSR7ZX0gY2hhcmFjdGVyYCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGIsXG4gICAgZGVjb2RlVW5zYWZlOiB4LFxuICAgIGRlY29kZTogT1xuICB9O1xufVxudmFyIHBkID0gZmQsIGdkID0gcGQ7XG5jb25zdCB5ZCA9IChpKSA9PiB7XG4gIGlmIChpIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBpLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVWludDhBcnJheVwiKVxuICAgIHJldHVybiBpO1xuICBpZiAoaSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShpKTtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhpKSlcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIsIGkuYnl0ZU9mZnNldCwgaS5ieXRlTGVuZ3RoKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlXCIpO1xufSwgbWQgPSAoaSkgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGkpLCBiZCA9IChpKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoaSk7XG5jbGFzcyB3ZCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnByZWZpeCA9IHQsIHRoaXMuYmFzZUVuY29kZSA9IHM7XG4gIH1cbiAgZW5jb2RlKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXh9JHt0aGlzLmJhc2VFbmNvZGUoZSl9YDtcbiAgICB0aHJvdyBFcnJvcihcIlVua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZVwiKTtcbiAgfVxufVxuY2xhc3MgdmQge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzKSB7XG4gICAgaWYgKHRoaXMubmFtZSA9IGUsIHRoaXMucHJlZml4ID0gdCwgdC5jb2RlUG9pbnRBdCgwKSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyXCIpO1xuICAgIHRoaXMucHJlZml4Q29kZVBvaW50ID0gdC5jb2RlUG9pbnRBdCgwKSwgdGhpcy5iYXNlRGVjb2RlID0gcztcbiAgfVxuICBkZWNvZGUoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoZS5jb2RlUG9pbnRBdCgwKSAhPT0gdGhpcy5wcmVmaXhDb2RlUG9pbnQpXG4gICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShlKX0sICR7dGhpcy5uYW1lfSBkZWNvZGVyIG9ubHkgc3VwcG9ydHMgaW5wdXRzIHByZWZpeGVkIHdpdGggJHt0aGlzLnByZWZpeH1gKTtcbiAgICAgIHJldHVybiB0aGlzLmJhc2VEZWNvZGUoZS5zbGljZSh0aGlzLnByZWZpeC5sZW5ndGgpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IEVycm9yKFwiQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzXCIpO1xuICB9XG4gIG9yKGUpIHtcbiAgICByZXR1cm4gdmModGhpcywgZSk7XG4gIH1cbn1cbmNsYXNzIF9kIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuZGVjb2RlcnMgPSBlO1xuICB9XG4gIG9yKGUpIHtcbiAgICByZXR1cm4gdmModGhpcywgZSk7XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICBjb25zdCB0ID0gZVswXSwgcyA9IHRoaXMuZGVjb2RlcnNbdF07XG4gICAgaWYgKHMpXG4gICAgICByZXR1cm4gcy5kZWNvZGUoZSk7XG4gICAgdGhyb3cgUmFuZ2VFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkoZSl9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7T2JqZWN0LmtleXModGhpcy5kZWNvZGVycyl9IGFyZSBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuY29uc3QgdmMgPSAoaSwgZSkgPT4gbmV3IF9kKHtcbiAgLi4uaS5kZWNvZGVycyB8fCB7IFtpLnByZWZpeF06IGkgfSxcbiAgLi4uZS5kZWNvZGVycyB8fCB7IFtlLnByZWZpeF06IGUgfVxufSk7XG5jbGFzcyBFZCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMsIHIpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnByZWZpeCA9IHQsIHRoaXMuYmFzZUVuY29kZSA9IHMsIHRoaXMuYmFzZURlY29kZSA9IHIsIHRoaXMuZW5jb2RlciA9IG5ldyB3ZChlLCB0LCBzKSwgdGhpcy5kZWNvZGVyID0gbmV3IHZkKGUsIHQsIHIpO1xuICB9XG4gIGVuY29kZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoZSk7XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyLmRlY29kZShlKTtcbiAgfVxufVxuY29uc3QgY3IgPSAoeyBuYW1lOiBpLCBwcmVmaXg6IGUsIGVuY29kZTogdCwgZGVjb2RlOiBzIH0pID0+IG5ldyBFZChpLCBlLCB0LCBzKSwgcHMgPSAoeyBwcmVmaXg6IGksIG5hbWU6IGUsIGFscGhhYmV0OiB0IH0pID0+IHtcbiAgY29uc3QgeyBlbmNvZGU6IHMsIGRlY29kZTogciB9ID0gZ2QodCwgZSk7XG4gIHJldHVybiBjcih7XG4gICAgcHJlZml4OiBpLFxuICAgIG5hbWU6IGUsXG4gICAgZW5jb2RlOiBzLFxuICAgIGRlY29kZTogKG4pID0+IHlkKHIobikpXG4gIH0pO1xufSwgU2QgPSAoaSwgZSwgdCwgcykgPT4ge1xuICBjb25zdCByID0ge307XG4gIGZvciAobGV0IHAgPSAwOyBwIDwgZS5sZW5ndGg7ICsrcClcbiAgICByW2VbcF1dID0gcDtcbiAgbGV0IG4gPSBpLmxlbmd0aDtcbiAgZm9yICg7IGlbbiAtIDFdID09PSBcIj1cIjsgKVxuICAgIC0tbjtcbiAgY29uc3QgbyA9IG5ldyBVaW50OEFycmF5KG4gKiB0IC8gOCB8IDApO1xuICBsZXQgYyA9IDAsIHUgPSAwLCBkID0gMDtcbiAgZm9yIChsZXQgcCA9IDA7IHAgPCBuOyArK3ApIHtcbiAgICBjb25zdCBiID0gcltpW3BdXTtcbiAgICBpZiAoYiA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb24tJHtzfSBjaGFyYWN0ZXJgKTtcbiAgICB1ID0gdSA8PCB0IHwgYiwgYyArPSB0LCBjID49IDggJiYgKGMgLT0gOCwgb1tkKytdID0gMjU1ICYgdSA+PiBjKTtcbiAgfVxuICBpZiAoYyA+PSB0IHx8IDI1NSAmIHUgPDwgOCAtIGMpXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgZGF0YVwiKTtcbiAgcmV0dXJuIG87XG59LCBJZCA9IChpLCBlLCB0KSA9PiB7XG4gIGNvbnN0IHMgPSBlW2UubGVuZ3RoIC0gMV0gPT09IFwiPVwiLCByID0gKDEgPDwgdCkgLSAxO1xuICBsZXQgbiA9IFwiXCIsIG8gPSAwLCBjID0gMDtcbiAgZm9yIChsZXQgdSA9IDA7IHUgPCBpLmxlbmd0aDsgKyt1KVxuICAgIGZvciAoYyA9IGMgPDwgOCB8IGlbdV0sIG8gKz0gODsgbyA+IHQ7IClcbiAgICAgIG8gLT0gdCwgbiArPSBlW3IgJiBjID4+IG9dO1xuICBpZiAobyAmJiAobiArPSBlW3IgJiBjIDw8IHQgLSBvXSksIHMpXG4gICAgZm9yICg7IG4ubGVuZ3RoICogdCAmIDc7IClcbiAgICAgIG4gKz0gXCI9XCI7XG4gIHJldHVybiBuO1xufSwgdXQgPSAoeyBuYW1lOiBpLCBwcmVmaXg6IGUsIGJpdHNQZXJDaGFyOiB0LCBhbHBoYWJldDogcyB9KSA9PiBjcih7XG4gIHByZWZpeDogZSxcbiAgbmFtZTogaSxcbiAgZW5jb2RlKHIpIHtcbiAgICByZXR1cm4gSWQociwgcywgdCk7XG4gIH0sXG4gIGRlY29kZShyKSB7XG4gICAgcmV0dXJuIFNkKHIsIHMsIHQsIGkpO1xuICB9XG59KSwgRGQgPSBjcih7XG4gIHByZWZpeDogXCJcXDBcIixcbiAgbmFtZTogXCJpZGVudGl0eVwiLFxuICBlbmNvZGU6IChpKSA9PiBiZChpKSxcbiAgZGVjb2RlOiAoaSkgPT4gbWQoaSlcbn0pLCB4ZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGlkZW50aXR5OiBEZFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgT2QgPSB1dCh7XG4gIHByZWZpeDogXCIwXCIsXG4gIG5hbWU6IFwiYmFzZTJcIixcbiAgYWxwaGFiZXQ6IFwiMDFcIixcbiAgYml0c1BlckNoYXI6IDFcbn0pLCBOZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2UyOiBPZFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgUGQgPSB1dCh7XG4gIHByZWZpeDogXCI3XCIsXG4gIG5hbWU6IFwiYmFzZThcIixcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1NjdcIixcbiAgYml0c1BlckNoYXI6IDNcbn0pLCBSZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2U4OiBQZFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgQ2QgPSBwcyh7XG4gIHByZWZpeDogXCI5XCIsXG4gIG5hbWU6IFwiYmFzZTEwXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlcIlxufSksIEFkID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYmFzZTEwOiBDZFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgVGQgPSB1dCh7XG4gIHByZWZpeDogXCJmXCIsXG4gIG5hbWU6IFwiYmFzZTE2XCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZcIixcbiAgYml0c1BlckNoYXI6IDRcbn0pLCAkZCA9IHV0KHtcbiAgcHJlZml4OiBcIkZcIixcbiAgbmFtZTogXCJiYXNlMTZ1cHBlclwiLFxuICBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGXCIsXG4gIGJpdHNQZXJDaGFyOiA0XG59KSwgRmQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlMTY6IFRkLFxuICBiYXNlMTZ1cHBlcjogJGRcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIFVkID0gdXQoe1xuICBwcmVmaXg6IFwiYlwiLFxuICBuYW1lOiBcImJhc2UzMlwiLFxuICBhbHBoYWJldDogXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2N1wiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIExkID0gdXQoe1xuICBwcmVmaXg6IFwiQlwiLFxuICBuYW1lOiBcImJhc2UzMnVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCIsXG4gIGJpdHNQZXJDaGFyOiA1XG59KSwgTWQgPSB1dCh7XG4gIHByZWZpeDogXCJjXCIsXG4gIG5hbWU6IFwiYmFzZTMycGFkXCIsXG4gIGFscGhhYmV0OiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PVwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIHFkID0gdXQoe1xuICBwcmVmaXg6IFwiQ1wiLFxuICBuYW1lOiBcImJhc2UzMnBhZHVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3PVwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIGpkID0gdXQoe1xuICBwcmVmaXg6IFwidlwiLFxuICBuYW1lOiBcImJhc2UzMmhleFwiLFxuICBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dlwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIHpkID0gdXQoe1xuICBwcmVmaXg6IFwiVlwiLFxuICBuYW1lOiBcImJhc2UzMmhleHVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWXCIsXG4gIGJpdHNQZXJDaGFyOiA1XG59KSwgS2QgPSB1dCh7XG4gIHByZWZpeDogXCJ0XCIsXG4gIG5hbWU6IFwiYmFzZTMyaGV4cGFkXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PVwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIFZkID0gdXQoe1xuICBwcmVmaXg6IFwiVFwiLFxuICBuYW1lOiBcImJhc2UzMmhleHBhZHVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPVwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIEJkID0gdXQoe1xuICBwcmVmaXg6IFwiaFwiLFxuICBuYW1lOiBcImJhc2UzMnpcIixcbiAgYWxwaGFiZXQ6IFwieWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjlcIixcbiAgYml0c1BlckNoYXI6IDVcbn0pLCBrZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2UzMjogVWQsXG4gIGJhc2UzMmhleDogamQsXG4gIGJhc2UzMmhleHBhZDogS2QsXG4gIGJhc2UzMmhleHBhZHVwcGVyOiBWZCxcbiAgYmFzZTMyaGV4dXBwZXI6IHpkLFxuICBiYXNlMzJwYWQ6IE1kLFxuICBiYXNlMzJwYWR1cHBlcjogcWQsXG4gIGJhc2UzMnVwcGVyOiBMZCxcbiAgYmFzZTMyejogQmRcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEhkID0gcHMoe1xuICBwcmVmaXg6IFwia1wiLFxuICBuYW1lOiBcImJhc2UzNlwiLFxuICBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIlxufSksIEdkID0gcHMoe1xuICBwcmVmaXg6IFwiS1wiLFxuICBuYW1lOiBcImJhc2UzNnVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiXG59KSwgV2QgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlMzY6IEhkLFxuICBiYXNlMzZ1cHBlcjogR2Rcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIFlkID0gcHMoe1xuICBuYW1lOiBcImJhc2U1OGJ0Y1wiLFxuICBwcmVmaXg6IFwielwiLFxuICBhbHBoYWJldDogXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCJcbn0pLCBKZCA9IHBzKHtcbiAgbmFtZTogXCJiYXNlNThmbGlja3JcIixcbiAgcHJlZml4OiBcIlpcIixcbiAgYWxwaGFiZXQ6IFwiMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWlwiXG59KSwgUWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlNThidGM6IFlkLFxuICBiYXNlNThmbGlja3I6IEpkXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBYZCA9IHV0KHtcbiAgcHJlZml4OiBcIm1cIixcbiAgbmFtZTogXCJiYXNlNjRcIixcbiAgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLFxuICBiaXRzUGVyQ2hhcjogNlxufSksIFpkID0gdXQoe1xuICBwcmVmaXg6IFwiTVwiLFxuICBuYW1lOiBcImJhc2U2NHBhZFwiLFxuICBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLFxuICBiaXRzUGVyQ2hhcjogNlxufSksIGVmID0gdXQoe1xuICBwcmVmaXg6IFwidVwiLFxuICBuYW1lOiBcImJhc2U2NHVybFwiLFxuICBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fXCIsXG4gIGJpdHNQZXJDaGFyOiA2XG59KSwgdGYgPSB1dCh7XG4gIHByZWZpeDogXCJVXCIsXG4gIG5hbWU6IFwiYmFzZTY0dXJscGFkXCIsXG4gIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89XCIsXG4gIGJpdHNQZXJDaGFyOiA2XG59KSwgc2YgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlNjQ6IFhkLFxuICBiYXNlNjRwYWQ6IFpkLFxuICBiYXNlNjR1cmw6IGVmLFxuICBiYXNlNjR1cmxwYWQ6IHRmXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBfYyA9IEFycmF5LmZyb20oXCLwn5qA8J+qkOKYhPCfm7Dwn4yM8J+MkfCfjJLwn4yT8J+MlPCfjJXwn4yW8J+Ml/CfjJjwn4yN8J+Mj/CfjI7wn5CJ4piA8J+Su/CflqXwn5K+8J+Sv/CfmILinaTwn5iN8J+ko/CfmIrwn5mP8J+SlfCfmK3wn5iY8J+RjfCfmIXwn5GP8J+YgfCflKXwn6Ww8J+SlPCfkpbwn5KZ8J+YovCfpJTwn5iG8J+ZhPCfkqrwn5iJ4pi68J+RjPCfpJfwn5Kc8J+YlPCfmI7wn5iH8J+MufCfpKbwn46J8J+SnuKcjOKcqPCfpLfwn5ix8J+YjPCfjLjwn5mM8J+Yi/Cfkpfwn5Ka8J+Yj/Cfkpvwn5mC8J+Sk/CfpKnwn5iE8J+YgPCflqTwn5iD8J+Sr/CfmYjwn5GH8J+OtvCfmJLwn6St4p2j8J+YnPCfkovwn5GA8J+YqvCfmJHwn5Kl8J+Zi/CfmJ7wn5ip8J+YofCfpKrwn5GK8J+ls/CfmKXwn6Sk8J+RifCfkoPwn5iz4pyL8J+YmvCfmJ3wn5i08J+Mn/CfmKzwn5mD8J+NgPCfjLfwn5i78J+Yk+KtkOKchfCfpbrwn4yI8J+YiPCfpJjwn5Km4pyU8J+Yo/Cfj4Pwn5KQ4pi58J+OivCfkpjwn5ig4pid8J+YlfCfjLrwn46C8J+Mu/CfmJDwn5aV8J+SnfCfmYrwn5i58J+Xo/Cfkqvwn5KA8J+RkfCfjrXwn6Se8J+Ym/CflLTwn5ik8J+MvPCfmKvimr3wn6SZ4piV8J+PhvCfpKvwn5GI8J+YrvCfmYbwn4278J+Ng/CfkLbwn5KB8J+YsvCfjL/wn6eh8J+OgeKaofCfjJ7wn46I4p2M4pyK8J+Ri/CfmLDwn6So8J+YtvCfpJ3wn5q28J+SsPCfjZPwn5Ki8J+kn/CfmYHwn5qo8J+SqPCfpKzinIjwn46A8J+NuvCfpJPwn5iZ8J+Sn/CfjLHwn5iW8J+RtvCfpbTilrbinqHinZPwn5KO8J+SuOKsh/CfmKjwn4ya8J+mi/CfmLfwn5W64pqg8J+ZhfCfmJ/wn5i18J+RjvCfpLLwn6Sg8J+kp/Cfk4zwn5S18J+ShfCfp5Dwn5C+8J+NkvCfmJfwn6SR8J+MivCfpK/wn5C34piO8J+Sp/CfmK/wn5KG8J+RhvCfjqTwn5mH8J+NkeKdhPCfjLTwn5Kj8J+QuPCfkozwn5ON8J+lgPCfpKLwn5GF8J+SofCfkqnwn5GQ8J+TuPCfkbvwn6SQ8J+krvCfjrzwn6W18J+aqfCfjY7wn42K8J+RvPCfko3wn5Oj8J+lglwiKSwgcmYgPSBfYy5yZWR1Y2UoKGksIGUsIHQpID0+IChpW3RdID0gZSwgaSksIFtdKSwgbmYgPSBfYy5yZWR1Y2UoKGksIGUsIHQpID0+IChpW2UuY29kZVBvaW50QXQoMCldID0gdCwgaSksIFtdKTtcbmZ1bmN0aW9uIG9mKGkpIHtcbiAgcmV0dXJuIGkucmVkdWNlKChlLCB0KSA9PiAoZSArPSByZlt0XSwgZSksIFwiXCIpO1xufVxuZnVuY3Rpb24gYWYoaSkge1xuICBjb25zdCBlID0gW107XG4gIGZvciAoY29uc3QgdCBvZiBpKSB7XG4gICAgY29uc3QgcyA9IG5mW3QuY29kZVBvaW50QXQoMCldO1xuICAgIGlmIChzID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi1iYXNlMjU2ZW1vamkgY2hhcmFjdGVyOiAke3R9YCk7XG4gICAgZS5wdXNoKHMpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShlKTtcbn1cbmNvbnN0IGNmID0gY3Ioe1xuICBwcmVmaXg6IFwi8J+agFwiLFxuICBuYW1lOiBcImJhc2UyNTZlbW9qaVwiLFxuICBlbmNvZGU6IG9mLFxuICBkZWNvZGU6IGFmXG59KSwgaGYgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlMjU2ZW1vamk6IGNmXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xubmV3IFRleHRFbmNvZGVyKCk7XG5uZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGJvID0ge1xuICAuLi54ZCxcbiAgLi4uTmQsXG4gIC4uLlJkLFxuICAuLi5BZCxcbiAgLi4uRmQsXG4gIC4uLmtkLFxuICAuLi5XZCxcbiAgLi4uUWQsXG4gIC4uLnNmLFxuICAuLi5oZlxufTtcbmZ1bmN0aW9uIEVjKGksIGUsIHQsIHMpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBpLFxuICAgIHByZWZpeDogZSxcbiAgICBlbmNvZGVyOiB7XG4gICAgICBuYW1lOiBpLFxuICAgICAgcHJlZml4OiBlLFxuICAgICAgZW5jb2RlOiB0XG4gICAgfSxcbiAgICBkZWNvZGVyOiB7IGRlY29kZTogcyB9XG4gIH07XG59XG5jb25zdCB3byA9IEVjKFwidXRmOFwiLCBcInVcIiwgKGkpID0+IFwidVwiICsgbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKS5kZWNvZGUoaSksIChpKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaS5zdWJzdHJpbmcoMSkpKSwgRHIgPSBFYyhcImFzY2lpXCIsIFwiYVwiLCAoaSkgPT4ge1xuICBsZXQgZSA9IFwiYVwiO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IGkubGVuZ3RoOyB0KyspXG4gICAgZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGlbdF0pO1xuICByZXR1cm4gZTtcbn0sIChpKSA9PiB7XG4gIGkgPSBpLnN1YnN0cmluZygxKTtcbiAgY29uc3QgZSA9IHdjKGkubGVuZ3RoKTtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCBpLmxlbmd0aDsgdCsrKVxuICAgIGVbdF0gPSBpLmNoYXJDb2RlQXQodCk7XG4gIHJldHVybiBlO1xufSksIFNjID0ge1xuICB1dGY4OiB3byxcbiAgXCJ1dGYtOFwiOiB3byxcbiAgaGV4OiBiby5iYXNlMTYsXG4gIGxhdGluMTogRHIsXG4gIGFzY2lpOiBEcixcbiAgYmluYXJ5OiBEcixcbiAgLi4uYm9cbn07XG5mdW5jdGlvbiBOZShpLCBlID0gXCJ1dGY4XCIpIHtcbiAgY29uc3QgdCA9IFNjW2VdO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZX1cImApO1xuICByZXR1cm4gKGUgPT09IFwidXRmOFwiIHx8IGUgPT09IFwidXRmLThcIikgJiYgZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tICE9IG51bGwgPyBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGkuYnVmZmVyLCBpLmJ5dGVPZmZzZXQsIGkuYnl0ZUxlbmd0aCkudG9TdHJpbmcoXCJ1dGY4XCIpIDogdC5lbmNvZGVyLmVuY29kZShpKS5zdWJzdHJpbmcoMSk7XG59XG5mdW5jdGlvbiBDZShpLCBlID0gXCJ1dGY4XCIpIHtcbiAgY29uc3QgdCA9IFNjW2VdO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZX1cImApO1xuICByZXR1cm4gKGUgPT09IFwidXRmOFwiIHx8IGUgPT09IFwidXRmLThcIikgJiYgZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tICE9IG51bGwgPyBvbihnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGksIFwidXRmLThcIikpIDogdC5kZWNvZGVyLmRlY29kZShgJHt0LnByZWZpeH0ke2l9YCk7XG59XG5mdW5jdGlvbiBHcyhpKSB7XG4gIHJldHVybiBOZShDZShycihpKSwgbmQpLCBiYyk7XG59XG5mdW5jdGlvbiBhbihpKSB7XG4gIGNvbnN0IGUgPSBDZShsZCwgbW8pLCB0ID0gdWQgKyBOZShscyhbZSwgaV0pLCBtbyk7XG4gIHJldHVybiBbY2QsIGhkLCB0XS5qb2luKGFkKTtcbn1cbmZ1bmN0aW9uIHVmKGkpIHtcbiAgcmV0dXJuIE5lKGksIGJjKTtcbn1cbmZ1bmN0aW9uIGxmKGkpIHtcbiAgcmV0dXJuIENlKFtHcyhpLmhlYWRlciksIEdzKGkucGF5bG9hZCldLmpvaW4obWMpLCBvZCk7XG59XG5mdW5jdGlvbiBkZihpKSB7XG4gIHJldHVybiBbXG4gICAgR3MoaS5oZWFkZXIpLFxuICAgIEdzKGkucGF5bG9hZCksXG4gICAgdWYoaS5zaWduYXR1cmUpXG4gIF0uam9pbihtYyk7XG59XG5mdW5jdGlvbiBXcyhpID0gbGkucmFuZG9tQnl0ZXMoZGQpKSB7XG4gIHJldHVybiBubi5nZW5lcmF0ZUtleVBhaXJGcm9tU2VlZChpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEljKGksIGUsIHQsIHMsIHIgPSBWLmZyb21NaWxpc2Vjb25kcyhEYXRlLm5vdygpKSkge1xuICBjb25zdCBuID0geyBhbGc6IHNkLCB0eXA6IHJkIH0sIG8gPSBhbihzLnB1YmxpY0tleSksIGMgPSByICsgdCwgdSA9IHsgaXNzOiBvLCBzdWI6IGksIGF1ZDogZSwgaWF0OiByLCBleHA6IGMgfSwgZCA9IGxmKHsgaGVhZGVyOiBuLCBwYXlsb2FkOiB1IH0pLCBwID0gbm4uc2lnbihzLnNlY3JldEtleSwgZCk7XG4gIHJldHVybiBkZih7IGhlYWRlcjogbiwgcGF5bG9hZDogdSwgc2lnbmF0dXJlOiBwIH0pO1xufVxudmFyIGdzID0ge30sIGhyID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaHIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBwdCA9IG9lLCBLciA9IFB0LCBmZiA9IDIwO1xuZnVuY3Rpb24gcGYoaSwgZSwgdCkge1xuICBmb3IgKHZhciBzID0gMTYzNDc2MDgwNSwgciA9IDg1Nzc2MDg3OCwgbiA9IDIwMzY0NzcyMzQsIG8gPSAxNzk3Mjg1MjM2LCBjID0gdFszXSA8PCAyNCB8IHRbMl0gPDwgMTYgfCB0WzFdIDw8IDggfCB0WzBdLCB1ID0gdFs3XSA8PCAyNCB8IHRbNl0gPDwgMTYgfCB0WzVdIDw8IDggfCB0WzRdLCBkID0gdFsxMV0gPDwgMjQgfCB0WzEwXSA8PCAxNiB8IHRbOV0gPDwgOCB8IHRbOF0sIHAgPSB0WzE1XSA8PCAyNCB8IHRbMTRdIDw8IDE2IHwgdFsxM10gPDwgOCB8IHRbMTJdLCBiID0gdFsxOV0gPDwgMjQgfCB0WzE4XSA8PCAxNiB8IHRbMTddIDw8IDggfCB0WzE2XSwgeCA9IHRbMjNdIDw8IDI0IHwgdFsyMl0gPDwgMTYgfCB0WzIxXSA8PCA4IHwgdFsyMF0sIE8gPSB0WzI3XSA8PCAyNCB8IHRbMjZdIDw8IDE2IHwgdFsyNV0gPDwgOCB8IHRbMjRdLCBfID0gdFszMV0gPDwgMjQgfCB0WzMwXSA8PCAxNiB8IHRbMjldIDw8IDggfCB0WzI4XSwgQyA9IGVbM10gPDwgMjQgfCBlWzJdIDw8IDE2IHwgZVsxXSA8PCA4IHwgZVswXSwgRiA9IGVbN10gPDwgMjQgfCBlWzZdIDw8IDE2IHwgZVs1XSA8PCA4IHwgZVs0XSwgSyA9IGVbMTFdIDw8IDI0IHwgZVsxMF0gPDwgMTYgfCBlWzldIDw8IDggfCBlWzhdLCBJID0gZVsxNV0gPDwgMjQgfCBlWzE0XSA8PCAxNiB8IGVbMTNdIDw8IDggfCBlWzEyXSwgRCA9IHMsIHkgPSByLCB3ID0gbiwgZiA9IG8sIGEgPSBjLCBsID0gdSwgTCA9IGQsIHYgPSBwLCBSID0gYiwgJCA9IHgsIHEgPSBPLCBtID0gXywgRSA9IEMsIEIgPSBGLCB6ID0gSywgaiA9IEksIFUgPSAwOyBVIDwgZmY7IFUgKz0gMilcbiAgICBEID0gRCArIGEgfCAwLCBFIF49IEQsIEUgPSBFID4+PiAzMiAtIDE2IHwgRSA8PCAxNiwgUiA9IFIgKyBFIHwgMCwgYSBePSBSLCBhID0gYSA+Pj4gMzIgLSAxMiB8IGEgPDwgMTIsIHkgPSB5ICsgbCB8IDAsIEIgXj0geSwgQiA9IEIgPj4+IDMyIC0gMTYgfCBCIDw8IDE2LCAkID0gJCArIEIgfCAwLCBsIF49ICQsIGwgPSBsID4+PiAzMiAtIDEyIHwgbCA8PCAxMiwgdyA9IHcgKyBMIHwgMCwgeiBePSB3LCB6ID0geiA+Pj4gMzIgLSAxNiB8IHogPDwgMTYsIHEgPSBxICsgeiB8IDAsIEwgXj0gcSwgTCA9IEwgPj4+IDMyIC0gMTIgfCBMIDw8IDEyLCBmID0gZiArIHYgfCAwLCBqIF49IGYsIGogPSBqID4+PiAzMiAtIDE2IHwgaiA8PCAxNiwgbSA9IG0gKyBqIHwgMCwgdiBePSBtLCB2ID0gdiA+Pj4gMzIgLSAxMiB8IHYgPDwgMTIsIHcgPSB3ICsgTCB8IDAsIHogXj0gdywgeiA9IHogPj4+IDMyIC0gOCB8IHogPDwgOCwgcSA9IHEgKyB6IHwgMCwgTCBePSBxLCBMID0gTCA+Pj4gMzIgLSA3IHwgTCA8PCA3LCBmID0gZiArIHYgfCAwLCBqIF49IGYsIGogPSBqID4+PiAzMiAtIDggfCBqIDw8IDgsIG0gPSBtICsgaiB8IDAsIHYgXj0gbSwgdiA9IHYgPj4+IDMyIC0gNyB8IHYgPDwgNywgeSA9IHkgKyBsIHwgMCwgQiBePSB5LCBCID0gQiA+Pj4gMzIgLSA4IHwgQiA8PCA4LCAkID0gJCArIEIgfCAwLCBsIF49ICQsIGwgPSBsID4+PiAzMiAtIDcgfCBsIDw8IDcsIEQgPSBEICsgYSB8IDAsIEUgXj0gRCwgRSA9IEUgPj4+IDMyIC0gOCB8IEUgPDwgOCwgUiA9IFIgKyBFIHwgMCwgYSBePSBSLCBhID0gYSA+Pj4gMzIgLSA3IHwgYSA8PCA3LCBEID0gRCArIGwgfCAwLCBqIF49IEQsIGogPSBqID4+PiAzMiAtIDE2IHwgaiA8PCAxNiwgcSA9IHEgKyBqIHwgMCwgbCBePSBxLCBsID0gbCA+Pj4gMzIgLSAxMiB8IGwgPDwgMTIsIHkgPSB5ICsgTCB8IDAsIEUgXj0geSwgRSA9IEUgPj4+IDMyIC0gMTYgfCBFIDw8IDE2LCBtID0gbSArIEUgfCAwLCBMIF49IG0sIEwgPSBMID4+PiAzMiAtIDEyIHwgTCA8PCAxMiwgdyA9IHcgKyB2IHwgMCwgQiBePSB3LCBCID0gQiA+Pj4gMzIgLSAxNiB8IEIgPDwgMTYsIFIgPSBSICsgQiB8IDAsIHYgXj0gUiwgdiA9IHYgPj4+IDMyIC0gMTIgfCB2IDw8IDEyLCBmID0gZiArIGEgfCAwLCB6IF49IGYsIHogPSB6ID4+PiAzMiAtIDE2IHwgeiA8PCAxNiwgJCA9ICQgKyB6IHwgMCwgYSBePSAkLCBhID0gYSA+Pj4gMzIgLSAxMiB8IGEgPDwgMTIsIHcgPSB3ICsgdiB8IDAsIEIgXj0gdywgQiA9IEIgPj4+IDMyIC0gOCB8IEIgPDwgOCwgUiA9IFIgKyBCIHwgMCwgdiBePSBSLCB2ID0gdiA+Pj4gMzIgLSA3IHwgdiA8PCA3LCBmID0gZiArIGEgfCAwLCB6IF49IGYsIHogPSB6ID4+PiAzMiAtIDggfCB6IDw8IDgsICQgPSAkICsgeiB8IDAsIGEgXj0gJCwgYSA9IGEgPj4+IDMyIC0gNyB8IGEgPDwgNywgeSA9IHkgKyBMIHwgMCwgRSBePSB5LCBFID0gRSA+Pj4gMzIgLSA4IHwgRSA8PCA4LCBtID0gbSArIEUgfCAwLCBMIF49IG0sIEwgPSBMID4+PiAzMiAtIDcgfCBMIDw8IDcsIEQgPSBEICsgbCB8IDAsIGogXj0gRCwgaiA9IGogPj4+IDMyIC0gOCB8IGogPDwgOCwgcSA9IHEgKyBqIHwgMCwgbCBePSBxLCBsID0gbCA+Pj4gMzIgLSA3IHwgbCA8PCA3O1xuICBwdC53cml0ZVVpbnQzMkxFKEQgKyBzIHwgMCwgaSwgMCksIHB0LndyaXRlVWludDMyTEUoeSArIHIgfCAwLCBpLCA0KSwgcHQud3JpdGVVaW50MzJMRSh3ICsgbiB8IDAsIGksIDgpLCBwdC53cml0ZVVpbnQzMkxFKGYgKyBvIHwgMCwgaSwgMTIpLCBwdC53cml0ZVVpbnQzMkxFKGEgKyBjIHwgMCwgaSwgMTYpLCBwdC53cml0ZVVpbnQzMkxFKGwgKyB1IHwgMCwgaSwgMjApLCBwdC53cml0ZVVpbnQzMkxFKEwgKyBkIHwgMCwgaSwgMjQpLCBwdC53cml0ZVVpbnQzMkxFKHYgKyBwIHwgMCwgaSwgMjgpLCBwdC53cml0ZVVpbnQzMkxFKFIgKyBiIHwgMCwgaSwgMzIpLCBwdC53cml0ZVVpbnQzMkxFKCQgKyB4IHwgMCwgaSwgMzYpLCBwdC53cml0ZVVpbnQzMkxFKHEgKyBPIHwgMCwgaSwgNDApLCBwdC53cml0ZVVpbnQzMkxFKG0gKyBfIHwgMCwgaSwgNDQpLCBwdC53cml0ZVVpbnQzMkxFKEUgKyBDIHwgMCwgaSwgNDgpLCBwdC53cml0ZVVpbnQzMkxFKEIgKyBGIHwgMCwgaSwgNTIpLCBwdC53cml0ZVVpbnQzMkxFKHogKyBLIHwgMCwgaSwgNTYpLCBwdC53cml0ZVVpbnQzMkxFKGogKyBJIHwgMCwgaSwgNjApO1xufVxuZnVuY3Rpb24gRGMoaSwgZSwgdCwgcywgcikge1xuICBpZiAociA9PT0gdm9pZCAwICYmIChyID0gMCksIGkubGVuZ3RoICE9PSAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFDaGE6IGtleSBzaXplIG11c3QgYmUgMzIgYnl0ZXNcIik7XG4gIGlmIChzLmxlbmd0aCA8IHQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYTogZGVzdGluYXRpb24gaXMgc2hvcnRlciB0aGFuIHNvdXJjZVwiKTtcbiAgdmFyIG4sIG87XG4gIGlmIChyID09PSAwKSB7XG4gICAgaWYgKGUubGVuZ3RoICE9PSA4ICYmIGUubGVuZ3RoICE9PSAxMilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYSBub25jZSBtdXN0IGJlIDggb3IgMTIgYnl0ZXNcIik7XG4gICAgbiA9IG5ldyBVaW50OEFycmF5KDE2KSwgbyA9IG4ubGVuZ3RoIC0gZS5sZW5ndGgsIG4uc2V0KGUsIG8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChlLmxlbmd0aCAhPT0gMTYpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFDaGEgbm9uY2Ugd2l0aCBjb3VudGVyIG11c3QgYmUgMTYgYnl0ZXNcIik7XG4gICAgbiA9IGUsIG8gPSByO1xuICB9XG4gIGZvciAodmFyIGMgPSBuZXcgVWludDhBcnJheSg2NCksIHUgPSAwOyB1IDwgdC5sZW5ndGg7IHUgKz0gNjQpIHtcbiAgICBwZihjLCBuLCBpKTtcbiAgICBmb3IgKHZhciBkID0gdTsgZCA8IHUgKyA2NCAmJiBkIDwgdC5sZW5ndGg7IGQrKylcbiAgICAgIHNbZF0gPSB0W2RdIF4gY1tkIC0gdV07XG4gICAgeWYobiwgMCwgbyk7XG4gIH1cbiAgcmV0dXJuIEtyLndpcGUoYyksIHIgPT09IDAgJiYgS3Iud2lwZShuKSwgcztcbn1cbmhyLnN0cmVhbVhPUiA9IERjO1xuZnVuY3Rpb24gZ2YoaSwgZSwgdCwgcykge1xuICByZXR1cm4gcyA9PT0gdm9pZCAwICYmIChzID0gMCksIEtyLndpcGUodCksIERjKGksIGUsIHQsIHQsIHMpO1xufVxuaHIuc3RyZWFtID0gZ2Y7XG5mdW5jdGlvbiB5ZihpLCBlLCB0KSB7XG4gIGZvciAodmFyIHMgPSAxOyB0LS07IClcbiAgICBzID0gcyArIChpW2VdICYgMjU1KSB8IDAsIGlbZV0gPSBzICYgMjU1LCBzID4+Pj0gOCwgZSsrO1xuICBpZiAocyA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhQ2hhOiBjb3VudGVyIG92ZXJmbG93XCIpO1xufVxudmFyIHhjID0ge30sIGRpID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmZ1bmN0aW9uIG1mKGksIGUsIHQpIHtcbiAgcmV0dXJuIH4oaSAtIDEpICYgZSB8IGkgLSAxICYgdDtcbn1cbmRpLnNlbGVjdCA9IG1mO1xuZnVuY3Rpb24gYmYoaSwgZSkge1xuICByZXR1cm4gKGkgfCAwKSAtIChlIHwgMCkgLSAxID4+PiAzMSAmIDE7XG59XG5kaS5sZXNzT3JFcXVhbCA9IGJmO1xuZnVuY3Rpb24gT2MoaSwgZSkge1xuICBpZiAoaS5sZW5ndGggIT09IGUubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBmb3IgKHZhciB0ID0gMCwgcyA9IDA7IHMgPCBpLmxlbmd0aDsgcysrKVxuICAgIHQgfD0gaVtzXSBeIGVbc107XG4gIHJldHVybiAxICYgdCAtIDEgPj4+IDg7XG59XG5kaS5jb21wYXJlID0gT2M7XG5mdW5jdGlvbiB3ZihpLCBlKSB7XG4gIHJldHVybiBpLmxlbmd0aCA9PT0gMCB8fCBlLmxlbmd0aCA9PT0gMCA/ICExIDogT2MoaSwgZSkgIT09IDA7XG59XG5kaS5lcXVhbCA9IHdmO1xuKGZ1bmN0aW9uKGkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgdmFyIGUgPSBkaSwgdCA9IFB0O1xuICBpLkRJR0VTVF9MRU5HVEggPSAxNjtcbiAgdmFyIHMgPSAoXG4gICAgLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gbyhjKSB7XG4gICAgICAgIHRoaXMuZGlnZXN0TGVuZ3RoID0gaS5ESUdFU1RfTEVOR1RILCB0aGlzLl9idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNiksIHRoaXMuX3IgPSBuZXcgVWludDE2QXJyYXkoMTApLCB0aGlzLl9oID0gbmV3IFVpbnQxNkFycmF5KDEwKSwgdGhpcy5fcGFkID0gbmV3IFVpbnQxNkFycmF5KDgpLCB0aGlzLl9sZWZ0b3ZlciA9IDAsIHRoaXMuX2ZpbiA9IDAsIHRoaXMuX2ZpbmlzaGVkID0gITE7XG4gICAgICAgIHZhciB1ID0gY1swXSB8IGNbMV0gPDwgODtcbiAgICAgICAgdGhpcy5fclswXSA9IHUgJiA4MTkxO1xuICAgICAgICB2YXIgZCA9IGNbMl0gfCBjWzNdIDw8IDg7XG4gICAgICAgIHRoaXMuX3JbMV0gPSAodSA+Pj4gMTMgfCBkIDw8IDMpICYgODE5MTtcbiAgICAgICAgdmFyIHAgPSBjWzRdIHwgY1s1XSA8PCA4O1xuICAgICAgICB0aGlzLl9yWzJdID0gKGQgPj4+IDEwIHwgcCA8PCA2KSAmIDc5Mzk7XG4gICAgICAgIHZhciBiID0gY1s2XSB8IGNbN10gPDwgODtcbiAgICAgICAgdGhpcy5fclszXSA9IChwID4+PiA3IHwgYiA8PCA5KSAmIDgxOTE7XG4gICAgICAgIHZhciB4ID0gY1s4XSB8IGNbOV0gPDwgODtcbiAgICAgICAgdGhpcy5fcls0XSA9IChiID4+PiA0IHwgeCA8PCAxMikgJiAyNTUsIHRoaXMuX3JbNV0gPSB4ID4+PiAxICYgODE5MDtcbiAgICAgICAgdmFyIE8gPSBjWzEwXSB8IGNbMTFdIDw8IDg7XG4gICAgICAgIHRoaXMuX3JbNl0gPSAoeCA+Pj4gMTQgfCBPIDw8IDIpICYgODE5MTtcbiAgICAgICAgdmFyIF8gPSBjWzEyXSB8IGNbMTNdIDw8IDg7XG4gICAgICAgIHRoaXMuX3JbN10gPSAoTyA+Pj4gMTEgfCBfIDw8IDUpICYgODA2NTtcbiAgICAgICAgdmFyIEMgPSBjWzE0XSB8IGNbMTVdIDw8IDg7XG4gICAgICAgIHRoaXMuX3JbOF0gPSAoXyA+Pj4gOCB8IEMgPDwgOCkgJiA4MTkxLCB0aGlzLl9yWzldID0gQyA+Pj4gNSAmIDEyNywgdGhpcy5fcGFkWzBdID0gY1sxNl0gfCBjWzE3XSA8PCA4LCB0aGlzLl9wYWRbMV0gPSBjWzE4XSB8IGNbMTldIDw8IDgsIHRoaXMuX3BhZFsyXSA9IGNbMjBdIHwgY1syMV0gPDwgOCwgdGhpcy5fcGFkWzNdID0gY1syMl0gfCBjWzIzXSA8PCA4LCB0aGlzLl9wYWRbNF0gPSBjWzI0XSB8IGNbMjVdIDw8IDgsIHRoaXMuX3BhZFs1XSA9IGNbMjZdIHwgY1syN10gPDwgOCwgdGhpcy5fcGFkWzZdID0gY1syOF0gfCBjWzI5XSA8PCA4LCB0aGlzLl9wYWRbN10gPSBjWzMwXSB8IGNbMzFdIDw8IDg7XG4gICAgICB9XG4gICAgICByZXR1cm4gby5wcm90b3R5cGUuX2Jsb2NrcyA9IGZ1bmN0aW9uKGMsIHUsIGQpIHtcbiAgICAgICAgZm9yICh2YXIgcCA9IHRoaXMuX2ZpbiA/IDAgOiAyMDQ4LCBiID0gdGhpcy5faFswXSwgeCA9IHRoaXMuX2hbMV0sIE8gPSB0aGlzLl9oWzJdLCBfID0gdGhpcy5faFszXSwgQyA9IHRoaXMuX2hbNF0sIEYgPSB0aGlzLl9oWzVdLCBLID0gdGhpcy5faFs2XSwgSSA9IHRoaXMuX2hbN10sIEQgPSB0aGlzLl9oWzhdLCB5ID0gdGhpcy5faFs5XSwgdyA9IHRoaXMuX3JbMF0sIGYgPSB0aGlzLl9yWzFdLCBhID0gdGhpcy5fclsyXSwgbCA9IHRoaXMuX3JbM10sIEwgPSB0aGlzLl9yWzRdLCB2ID0gdGhpcy5fcls1XSwgUiA9IHRoaXMuX3JbNl0sICQgPSB0aGlzLl9yWzddLCBxID0gdGhpcy5fcls4XSwgbSA9IHRoaXMuX3JbOV07IGQgPj0gMTY7ICkge1xuICAgICAgICAgIHZhciBFID0gY1t1ICsgMF0gfCBjW3UgKyAxXSA8PCA4O1xuICAgICAgICAgIGIgKz0gRSAmIDgxOTE7XG4gICAgICAgICAgdmFyIEIgPSBjW3UgKyAyXSB8IGNbdSArIDNdIDw8IDg7XG4gICAgICAgICAgeCArPSAoRSA+Pj4gMTMgfCBCIDw8IDMpICYgODE5MTtcbiAgICAgICAgICB2YXIgeiA9IGNbdSArIDRdIHwgY1t1ICsgNV0gPDwgODtcbiAgICAgICAgICBPICs9IChCID4+PiAxMCB8IHogPDwgNikgJiA4MTkxO1xuICAgICAgICAgIHZhciBqID0gY1t1ICsgNl0gfCBjW3UgKyA3XSA8PCA4O1xuICAgICAgICAgIF8gKz0gKHogPj4+IDcgfCBqIDw8IDkpICYgODE5MTtcbiAgICAgICAgICB2YXIgVSA9IGNbdSArIDhdIHwgY1t1ICsgOV0gPDwgODtcbiAgICAgICAgICBDICs9IChqID4+PiA0IHwgVSA8PCAxMikgJiA4MTkxLCBGICs9IFUgPj4+IDEgJiA4MTkxO1xuICAgICAgICAgIHZhciBNID0gY1t1ICsgMTBdIHwgY1t1ICsgMTFdIDw8IDg7XG4gICAgICAgICAgSyArPSAoVSA+Pj4gMTQgfCBNIDw8IDIpICYgODE5MTtcbiAgICAgICAgICB2YXIgSCA9IGNbdSArIDEyXSB8IGNbdSArIDEzXSA8PCA4O1xuICAgICAgICAgIEkgKz0gKE0gPj4+IDExIHwgSCA8PCA1KSAmIDgxOTE7XG4gICAgICAgICAgdmFyIHRlID0gY1t1ICsgMTRdIHwgY1t1ICsgMTVdIDw8IDg7XG4gICAgICAgICAgRCArPSAoSCA+Pj4gOCB8IHRlIDw8IDgpICYgODE5MSwgeSArPSB0ZSA+Pj4gNSB8IHA7XG4gICAgICAgICAgdmFyIEcgPSAwLCBpZSA9IEc7XG4gICAgICAgICAgaWUgKz0gYiAqIHcsIGllICs9IHggKiAoNSAqIG0pLCBpZSArPSBPICogKDUgKiBxKSwgaWUgKz0gXyAqICg1ICogJCksIGllICs9IEMgKiAoNSAqIFIpLCBHID0gaWUgPj4+IDEzLCBpZSAmPSA4MTkxLCBpZSArPSBGICogKDUgKiB2KSwgaWUgKz0gSyAqICg1ICogTCksIGllICs9IEkgKiAoNSAqIGwpLCBpZSArPSBEICogKDUgKiBhKSwgaWUgKz0geSAqICg1ICogZiksIEcgKz0gaWUgPj4+IDEzLCBpZSAmPSA4MTkxO1xuICAgICAgICAgIHZhciBRID0gRztcbiAgICAgICAgICBRICs9IGIgKiBmLCBRICs9IHggKiB3LCBRICs9IE8gKiAoNSAqIG0pLCBRICs9IF8gKiAoNSAqIHEpLCBRICs9IEMgKiAoNSAqICQpLCBHID0gUSA+Pj4gMTMsIFEgJj0gODE5MSwgUSArPSBGICogKDUgKiBSKSwgUSArPSBLICogKDUgKiB2KSwgUSArPSBJICogKDUgKiBMKSwgUSArPSBEICogKDUgKiBsKSwgUSArPSB5ICogKDUgKiBhKSwgRyArPSBRID4+PiAxMywgUSAmPSA4MTkxO1xuICAgICAgICAgIHZhciBzZSA9IEc7XG4gICAgICAgICAgc2UgKz0gYiAqIGEsIHNlICs9IHggKiBmLCBzZSArPSBPICogdywgc2UgKz0gXyAqICg1ICogbSksIHNlICs9IEMgKiAoNSAqIHEpLCBHID0gc2UgPj4+IDEzLCBzZSAmPSA4MTkxLCBzZSArPSBGICogKDUgKiAkKSwgc2UgKz0gSyAqICg1ICogUiksIHNlICs9IEkgKiAoNSAqIHYpLCBzZSArPSBEICogKDUgKiBMKSwgc2UgKz0geSAqICg1ICogbCksIEcgKz0gc2UgPj4+IDEzLCBzZSAmPSA4MTkxO1xuICAgICAgICAgIHZhciBUID0gRztcbiAgICAgICAgICBUICs9IGIgKiBsLCBUICs9IHggKiBhLCBUICs9IE8gKiBmLCBUICs9IF8gKiB3LCBUICs9IEMgKiAoNSAqIG0pLCBHID0gVCA+Pj4gMTMsIFQgJj0gODE5MSwgVCArPSBGICogKDUgKiBxKSwgVCArPSBLICogKDUgKiAkKSwgVCArPSBJICogKDUgKiBSKSwgVCArPSBEICogKDUgKiB2KSwgVCArPSB5ICogKDUgKiBMKSwgRyArPSBUID4+PiAxMywgVCAmPSA4MTkxO1xuICAgICAgICAgIHZhciBBID0gRztcbiAgICAgICAgICBBICs9IGIgKiBMLCBBICs9IHggKiBsLCBBICs9IE8gKiBhLCBBICs9IF8gKiBmLCBBICs9IEMgKiB3LCBHID0gQSA+Pj4gMTMsIEEgJj0gODE5MSwgQSArPSBGICogKDUgKiBtKSwgQSArPSBLICogKDUgKiBxKSwgQSArPSBJICogKDUgKiAkKSwgQSArPSBEICogKDUgKiBSKSwgQSArPSB5ICogKDUgKiB2KSwgRyArPSBBID4+PiAxMywgQSAmPSA4MTkxO1xuICAgICAgICAgIHZhciBOID0gRztcbiAgICAgICAgICBOICs9IGIgKiB2LCBOICs9IHggKiBMLCBOICs9IE8gKiBsLCBOICs9IF8gKiBhLCBOICs9IEMgKiBmLCBHID0gTiA+Pj4gMTMsIE4gJj0gODE5MSwgTiArPSBGICogdywgTiArPSBLICogKDUgKiBtKSwgTiArPSBJICogKDUgKiBxKSwgTiArPSBEICogKDUgKiAkKSwgTiArPSB5ICogKDUgKiBSKSwgRyArPSBOID4+PiAxMywgTiAmPSA4MTkxO1xuICAgICAgICAgIHZhciBoID0gRztcbiAgICAgICAgICBoICs9IGIgKiBSLCBoICs9IHggKiB2LCBoICs9IE8gKiBMLCBoICs9IF8gKiBsLCBoICs9IEMgKiBhLCBHID0gaCA+Pj4gMTMsIGggJj0gODE5MSwgaCArPSBGICogZiwgaCArPSBLICogdywgaCArPSBJICogKDUgKiBtKSwgaCArPSBEICogKDUgKiBxKSwgaCArPSB5ICogKDUgKiAkKSwgRyArPSBoID4+PiAxMywgaCAmPSA4MTkxO1xuICAgICAgICAgIHZhciBTID0gRztcbiAgICAgICAgICBTICs9IGIgKiAkLCBTICs9IHggKiBSLCBTICs9IE8gKiB2LCBTICs9IF8gKiBMLCBTICs9IEMgKiBsLCBHID0gUyA+Pj4gMTMsIFMgJj0gODE5MSwgUyArPSBGICogYSwgUyArPSBLICogZiwgUyArPSBJICogdywgUyArPSBEICogKDUgKiBtKSwgUyArPSB5ICogKDUgKiBxKSwgRyArPSBTID4+PiAxMywgUyAmPSA4MTkxO1xuICAgICAgICAgIHZhciBXID0gRztcbiAgICAgICAgICBXICs9IGIgKiBxLCBXICs9IHggKiAkLCBXICs9IE8gKiBSLCBXICs9IF8gKiB2LCBXICs9IEMgKiBMLCBHID0gVyA+Pj4gMTMsIFcgJj0gODE5MSwgVyArPSBGICogbCwgVyArPSBLICogYSwgVyArPSBJICogZiwgVyArPSBEICogdywgVyArPSB5ICogKDUgKiBtKSwgRyArPSBXID4+PiAxMywgVyAmPSA4MTkxO1xuICAgICAgICAgIHZhciBYID0gRztcbiAgICAgICAgICBYICs9IGIgKiBtLCBYICs9IHggKiBxLCBYICs9IE8gKiAkLCBYICs9IF8gKiBSLCBYICs9IEMgKiB2LCBHID0gWCA+Pj4gMTMsIFggJj0gODE5MSwgWCArPSBGICogTCwgWCArPSBLICogbCwgWCArPSBJICogYSwgWCArPSBEICogZiwgWCArPSB5ICogdywgRyArPSBYID4+PiAxMywgWCAmPSA4MTkxLCBHID0gKEcgPDwgMikgKyBHIHwgMCwgRyA9IEcgKyBpZSB8IDAsIGllID0gRyAmIDgxOTEsIEcgPSBHID4+PiAxMywgUSArPSBHLCBiID0gaWUsIHggPSBRLCBPID0gc2UsIF8gPSBULCBDID0gQSwgRiA9IE4sIEsgPSBoLCBJID0gUywgRCA9IFcsIHkgPSBYLCB1ICs9IDE2LCBkIC09IDE2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hbMF0gPSBiLCB0aGlzLl9oWzFdID0geCwgdGhpcy5faFsyXSA9IE8sIHRoaXMuX2hbM10gPSBfLCB0aGlzLl9oWzRdID0gQywgdGhpcy5faFs1XSA9IEYsIHRoaXMuX2hbNl0gPSBLLCB0aGlzLl9oWzddID0gSSwgdGhpcy5faFs4XSA9IEQsIHRoaXMuX2hbOV0gPSB5O1xuICAgICAgfSwgby5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oYywgdSkge1xuICAgICAgICB1ID09PSB2b2lkIDAgJiYgKHUgPSAwKTtcbiAgICAgICAgdmFyIGQgPSBuZXcgVWludDE2QXJyYXkoMTApLCBwLCBiLCB4LCBPO1xuICAgICAgICBpZiAodGhpcy5fbGVmdG92ZXIpIHtcbiAgICAgICAgICBmb3IgKE8gPSB0aGlzLl9sZWZ0b3ZlciwgdGhpcy5fYnVmZmVyW08rK10gPSAxOyBPIDwgMTY7IE8rKylcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlcltPXSA9IDA7XG4gICAgICAgICAgdGhpcy5fZmluID0gMSwgdGhpcy5fYmxvY2tzKHRoaXMuX2J1ZmZlciwgMCwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAocCA9IHRoaXMuX2hbMV0gPj4+IDEzLCB0aGlzLl9oWzFdICY9IDgxOTEsIE8gPSAyOyBPIDwgMTA7IE8rKylcbiAgICAgICAgICB0aGlzLl9oW09dICs9IHAsIHAgPSB0aGlzLl9oW09dID4+PiAxMywgdGhpcy5faFtPXSAmPSA4MTkxO1xuICAgICAgICBmb3IgKHRoaXMuX2hbMF0gKz0gcCAqIDUsIHAgPSB0aGlzLl9oWzBdID4+PiAxMywgdGhpcy5faFswXSAmPSA4MTkxLCB0aGlzLl9oWzFdICs9IHAsIHAgPSB0aGlzLl9oWzFdID4+PiAxMywgdGhpcy5faFsxXSAmPSA4MTkxLCB0aGlzLl9oWzJdICs9IHAsIGRbMF0gPSB0aGlzLl9oWzBdICsgNSwgcCA9IGRbMF0gPj4+IDEzLCBkWzBdICY9IDgxOTEsIE8gPSAxOyBPIDwgMTA7IE8rKylcbiAgICAgICAgICBkW09dID0gdGhpcy5faFtPXSArIHAsIHAgPSBkW09dID4+PiAxMywgZFtPXSAmPSA4MTkxO1xuICAgICAgICBmb3IgKGRbOV0gLT0gODE5MiwgYiA9IChwIF4gMSkgLSAxLCBPID0gMDsgTyA8IDEwOyBPKyspXG4gICAgICAgICAgZFtPXSAmPSBiO1xuICAgICAgICBmb3IgKGIgPSB+YiwgTyA9IDA7IE8gPCAxMDsgTysrKVxuICAgICAgICAgIHRoaXMuX2hbT10gPSB0aGlzLl9oW09dICYgYiB8IGRbT107XG4gICAgICAgIGZvciAodGhpcy5faFswXSA9ICh0aGlzLl9oWzBdIHwgdGhpcy5faFsxXSA8PCAxMykgJiA2NTUzNSwgdGhpcy5faFsxXSA9ICh0aGlzLl9oWzFdID4+PiAzIHwgdGhpcy5faFsyXSA8PCAxMCkgJiA2NTUzNSwgdGhpcy5faFsyXSA9ICh0aGlzLl9oWzJdID4+PiA2IHwgdGhpcy5faFszXSA8PCA3KSAmIDY1NTM1LCB0aGlzLl9oWzNdID0gKHRoaXMuX2hbM10gPj4+IDkgfCB0aGlzLl9oWzRdIDw8IDQpICYgNjU1MzUsIHRoaXMuX2hbNF0gPSAodGhpcy5faFs0XSA+Pj4gMTIgfCB0aGlzLl9oWzVdIDw8IDEgfCB0aGlzLl9oWzZdIDw8IDE0KSAmIDY1NTM1LCB0aGlzLl9oWzVdID0gKHRoaXMuX2hbNl0gPj4+IDIgfCB0aGlzLl9oWzddIDw8IDExKSAmIDY1NTM1LCB0aGlzLl9oWzZdID0gKHRoaXMuX2hbN10gPj4+IDUgfCB0aGlzLl9oWzhdIDw8IDgpICYgNjU1MzUsIHRoaXMuX2hbN10gPSAodGhpcy5faFs4XSA+Pj4gOCB8IHRoaXMuX2hbOV0gPDwgNSkgJiA2NTUzNSwgeCA9IHRoaXMuX2hbMF0gKyB0aGlzLl9wYWRbMF0sIHRoaXMuX2hbMF0gPSB4ICYgNjU1MzUsIE8gPSAxOyBPIDwgODsgTysrKVxuICAgICAgICAgIHggPSAodGhpcy5faFtPXSArIHRoaXMuX3BhZFtPXSB8IDApICsgKHggPj4+IDE2KSB8IDAsIHRoaXMuX2hbT10gPSB4ICYgNjU1MzU7XG4gICAgICAgIHJldHVybiBjW3UgKyAwXSA9IHRoaXMuX2hbMF0gPj4+IDAsIGNbdSArIDFdID0gdGhpcy5faFswXSA+Pj4gOCwgY1t1ICsgMl0gPSB0aGlzLl9oWzFdID4+PiAwLCBjW3UgKyAzXSA9IHRoaXMuX2hbMV0gPj4+IDgsIGNbdSArIDRdID0gdGhpcy5faFsyXSA+Pj4gMCwgY1t1ICsgNV0gPSB0aGlzLl9oWzJdID4+PiA4LCBjW3UgKyA2XSA9IHRoaXMuX2hbM10gPj4+IDAsIGNbdSArIDddID0gdGhpcy5faFszXSA+Pj4gOCwgY1t1ICsgOF0gPSB0aGlzLl9oWzRdID4+PiAwLCBjW3UgKyA5XSA9IHRoaXMuX2hbNF0gPj4+IDgsIGNbdSArIDEwXSA9IHRoaXMuX2hbNV0gPj4+IDAsIGNbdSArIDExXSA9IHRoaXMuX2hbNV0gPj4+IDgsIGNbdSArIDEyXSA9IHRoaXMuX2hbNl0gPj4+IDAsIGNbdSArIDEzXSA9IHRoaXMuX2hbNl0gPj4+IDgsIGNbdSArIDE0XSA9IHRoaXMuX2hbN10gPj4+IDAsIGNbdSArIDE1XSA9IHRoaXMuX2hbN10gPj4+IDgsIHRoaXMuX2ZpbmlzaGVkID0gITAsIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciB1ID0gMCwgZCA9IGMubGVuZ3RoLCBwO1xuICAgICAgICBpZiAodGhpcy5fbGVmdG92ZXIpIHtcbiAgICAgICAgICBwID0gMTYgLSB0aGlzLl9sZWZ0b3ZlciwgcCA+IGQgJiYgKHAgPSBkKTtcbiAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IHA7IGIrKylcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclt0aGlzLl9sZWZ0b3ZlciArIGJdID0gY1t1ICsgYl07XG4gICAgICAgICAgaWYgKGQgLT0gcCwgdSArPSBwLCB0aGlzLl9sZWZ0b3ZlciArPSBwLCB0aGlzLl9sZWZ0b3ZlciA8IDE2KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgdGhpcy5fYmxvY2tzKHRoaXMuX2J1ZmZlciwgMCwgMTYpLCB0aGlzLl9sZWZ0b3ZlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQgPj0gMTYgJiYgKHAgPSBkIC0gZCAlIDE2LCB0aGlzLl9ibG9ja3MoYywgdSwgcCksIHUgKz0gcCwgZCAtPSBwKSwgZCkge1xuICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgZDsgYisrKVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyW3RoaXMuX2xlZnRvdmVyICsgYl0gPSBjW3UgKyBiXTtcbiAgICAgICAgICB0aGlzLl9sZWZ0b3ZlciArPSBkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9maW5pc2hlZClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5MTMwNSB3YXMgZmluaXNoZWRcIik7XG4gICAgICAgIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goYyksIGM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdC53aXBlKHRoaXMuX2J1ZmZlciksIHQud2lwZSh0aGlzLl9yKSwgdC53aXBlKHRoaXMuX2gpLCB0LndpcGUodGhpcy5fcGFkKSwgdGhpcy5fbGVmdG92ZXIgPSAwLCB0aGlzLl9maW4gPSAwLCB0aGlzLl9maW5pc2hlZCA9ICEwLCB0aGlzO1xuICAgICAgfSwgbztcbiAgICB9KClcbiAgKTtcbiAgaS5Qb2x5MTMwNSA9IHM7XG4gIGZ1bmN0aW9uIHIobywgYykge1xuICAgIHZhciB1ID0gbmV3IHMobyk7XG4gICAgdS51cGRhdGUoYyk7XG4gICAgdmFyIGQgPSB1LmRpZ2VzdCgpO1xuICAgIHJldHVybiB1LmNsZWFuKCksIGQ7XG4gIH1cbiAgaS5vbmVUaW1lQXV0aCA9IHI7XG4gIGZ1bmN0aW9uIG4obywgYykge1xuICAgIHJldHVybiBvLmxlbmd0aCAhPT0gaS5ESUdFU1RfTEVOR1RIIHx8IGMubGVuZ3RoICE9PSBpLkRJR0VTVF9MRU5HVEggPyAhMSA6IGUuZXF1YWwobywgYyk7XG4gIH1cbiAgaS5lcXVhbCA9IG47XG59KSh4Yyk7XG4oZnVuY3Rpb24oaSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICB2YXIgZSA9IGhyLCB0ID0geGMsIHMgPSBQdCwgciA9IG9lLCBuID0gZGk7XG4gIGkuS0VZX0xFTkdUSCA9IDMyLCBpLk5PTkNFX0xFTkdUSCA9IDEyLCBpLlRBR19MRU5HVEggPSAxNjtcbiAgdmFyIG8gPSBuZXcgVWludDhBcnJheSgxNiksIGMgPSAoXG4gICAgLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gdShkKSB7XG4gICAgICAgIGlmICh0aGlzLm5vbmNlTGVuZ3RoID0gaS5OT05DRV9MRU5HVEgsIHRoaXMudGFnTGVuZ3RoID0gaS5UQUdfTEVOR1RILCBkLmxlbmd0aCAhPT0gaS5LRVlfTEVOR1RIKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYTIwUG9seTEzMDUgbmVlZHMgMzItYnl0ZSBrZXlcIik7XG4gICAgICAgIHRoaXMuX2tleSA9IG5ldyBVaW50OEFycmF5KGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHUucHJvdG90eXBlLnNlYWwgPSBmdW5jdGlvbihkLCBwLCBiLCB4KSB7XG4gICAgICAgIGlmIChkLmxlbmd0aCA+IDE2KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYTIwUG9seTEzMDU6IGluY29ycmVjdCBub25jZSBsZW5ndGhcIik7XG4gICAgICAgIHZhciBPID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBPLnNldChkLCBPLmxlbmd0aCAtIGQubGVuZ3RoKTtcbiAgICAgICAgdmFyIF8gPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGUuc3RyZWFtKHRoaXMuX2tleSwgTywgXywgNCk7XG4gICAgICAgIHZhciBDID0gcC5sZW5ndGggKyB0aGlzLnRhZ0xlbmd0aCwgRjtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICBpZiAoeC5sZW5ndGggIT09IEMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFDaGEyMFBvbHkxMzA1OiBpbmNvcnJlY3QgZGVzdGluYXRpb24gbGVuZ3RoXCIpO1xuICAgICAgICAgIEYgPSB4O1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBGID0gbmV3IFVpbnQ4QXJyYXkoQyk7XG4gICAgICAgIHJldHVybiBlLnN0cmVhbVhPUih0aGlzLl9rZXksIE8sIHAsIEYsIDQpLCB0aGlzLl9hdXRoZW50aWNhdGUoRi5zdWJhcnJheShGLmxlbmd0aCAtIHRoaXMudGFnTGVuZ3RoLCBGLmxlbmd0aCksIF8sIEYuc3ViYXJyYXkoMCwgRi5sZW5ndGggLSB0aGlzLnRhZ0xlbmd0aCksIGIpLCBzLndpcGUoTyksIEY7XG4gICAgICB9LCB1LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oZCwgcCwgYiwgeCkge1xuICAgICAgICBpZiAoZC5sZW5ndGggPiAxNilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFDaGEyMFBvbHkxMzA1OiBpbmNvcnJlY3Qgbm9uY2UgbGVuZ3RoXCIpO1xuICAgICAgICBpZiAocC5sZW5ndGggPCB0aGlzLnRhZ0xlbmd0aClcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIE8gPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIE8uc2V0KGQsIE8ubGVuZ3RoIC0gZC5sZW5ndGgpO1xuICAgICAgICB2YXIgXyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgZS5zdHJlYW0odGhpcy5fa2V5LCBPLCBfLCA0KTtcbiAgICAgICAgdmFyIEMgPSBuZXcgVWludDhBcnJheSh0aGlzLnRhZ0xlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLl9hdXRoZW50aWNhdGUoQywgXywgcC5zdWJhcnJheSgwLCBwLmxlbmd0aCAtIHRoaXMudGFnTGVuZ3RoKSwgYiksICFuLmVxdWFsKEMsIHAuc3ViYXJyYXkocC5sZW5ndGggLSB0aGlzLnRhZ0xlbmd0aCwgcC5sZW5ndGgpKSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIEYgPSBwLmxlbmd0aCAtIHRoaXMudGFnTGVuZ3RoLCBLO1xuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIGlmICh4Lmxlbmd0aCAhPT0gRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYTIwUG9seTEzMDU6IGluY29ycmVjdCBkZXN0aW5hdGlvbiBsZW5ndGhcIik7XG4gICAgICAgICAgSyA9IHg7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIEsgPSBuZXcgVWludDhBcnJheShGKTtcbiAgICAgICAgcmV0dXJuIGUuc3RyZWFtWE9SKHRoaXMuX2tleSwgTywgcC5zdWJhcnJheSgwLCBwLmxlbmd0aCAtIHRoaXMudGFnTGVuZ3RoKSwgSywgNCksIHMud2lwZShPKSwgSztcbiAgICAgIH0sIHUucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzLndpcGUodGhpcy5fa2V5KSwgdGhpcztcbiAgICAgIH0sIHUucHJvdG90eXBlLl9hdXRoZW50aWNhdGUgPSBmdW5jdGlvbihkLCBwLCBiLCB4KSB7XG4gICAgICAgIHZhciBPID0gbmV3IHQuUG9seTEzMDUocCk7XG4gICAgICAgIHggJiYgKE8udXBkYXRlKHgpLCB4Lmxlbmd0aCAlIDE2ID4gMCAmJiBPLnVwZGF0ZShvLnN1YmFycmF5KHgubGVuZ3RoICUgMTYpKSksIE8udXBkYXRlKGIpLCBiLmxlbmd0aCAlIDE2ID4gMCAmJiBPLnVwZGF0ZShvLnN1YmFycmF5KGIubGVuZ3RoICUgMTYpKTtcbiAgICAgICAgdmFyIF8gPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgeCAmJiByLndyaXRlVWludDY0TEUoeC5sZW5ndGgsIF8pLCBPLnVwZGF0ZShfKSwgci53cml0ZVVpbnQ2NExFKGIubGVuZ3RoLCBfKSwgTy51cGRhdGUoXyk7XG4gICAgICAgIGZvciAodmFyIEMgPSBPLmRpZ2VzdCgpLCBGID0gMDsgRiA8IEMubGVuZ3RoOyBGKyspXG4gICAgICAgICAgZFtGXSA9IENbRl07XG4gICAgICAgIE8uY2xlYW4oKSwgcy53aXBlKEMpLCBzLndpcGUoXyk7XG4gICAgICB9LCB1O1xuICAgIH0oKVxuICApO1xuICBpLkNoYUNoYTIwUG9seTEzMDUgPSBjO1xufSkoZ3MpO1xudmFyIE5jID0ge30sIHlzID0ge30sIGNuID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY24sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmZ1bmN0aW9uIHZmKGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpLnNhdmVTdGF0ZSA8IFwidVwiICYmIHR5cGVvZiBpLnJlc3RvcmVTdGF0ZSA8IFwidVwiICYmIHR5cGVvZiBpLmNsZWFuU2F2ZWRTdGF0ZSA8IFwidVwiO1xufVxuY24uaXNTZXJpYWxpemFibGVIYXNoID0gdmY7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoeXMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBqdCA9IGNuLCBfZiA9IGRpLCBFZiA9IFB0LCBQYyA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBpKGUsIHQpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaGVkID0gITEsIHRoaXMuX2lubmVyID0gbmV3IGUoKSwgdGhpcy5fb3V0ZXIgPSBuZXcgZSgpLCB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMuX291dGVyLmJsb2NrU2l6ZSwgdGhpcy5kaWdlc3RMZW5ndGggPSB0aGlzLl9vdXRlci5kaWdlc3RMZW5ndGg7XG4gICAgICB2YXIgcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgICAgIHQubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUgPyB0aGlzLl9pbm5lci51cGRhdGUodCkuZmluaXNoKHMpLmNsZWFuKCkgOiBzLnNldCh0KTtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcy5sZW5ndGg7IHIrKylcbiAgICAgICAgc1tyXSBePSA1NDtcbiAgICAgIHRoaXMuX2lubmVyLnVwZGF0ZShzKTtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcy5sZW5ndGg7IHIrKylcbiAgICAgICAgc1tyXSBePSAxMDY7XG4gICAgICB0aGlzLl9vdXRlci51cGRhdGUocyksIGp0LmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikgJiYganQuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX291dGVyKSAmJiAodGhpcy5faW5uZXJLZXllZFN0YXRlID0gdGhpcy5faW5uZXIuc2F2ZVN0YXRlKCksIHRoaXMuX291dGVyS2V5ZWRTdGF0ZSA9IHRoaXMuX291dGVyLnNhdmVTdGF0ZSgpKSwgRWYud2lwZShzKTtcbiAgICB9XG4gICAgcmV0dXJuIGkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWp0LmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikgfHwgIWp0LmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9vdXRlcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImhtYWM6IGNhbid0IHJlc2V0KCkgYmVjYXVzZSBoYXNoIGRvZXNuJ3QgaW1wbGVtZW50IHJlc3RvcmVTdGF0ZSgpXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLnJlc3RvcmVTdGF0ZSh0aGlzLl9pbm5lcktleWVkU3RhdGUpLCB0aGlzLl9vdXRlci5yZXN0b3JlU3RhdGUodGhpcy5fb3V0ZXJLZXllZFN0YXRlKSwgdGhpcy5fZmluaXNoZWQgPSAhMSwgdGhpcztcbiAgICB9LCBpLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAganQuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSAmJiB0aGlzLl9pbm5lci5jbGVhblNhdmVkU3RhdGUodGhpcy5faW5uZXJLZXllZFN0YXRlKSwganQuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX291dGVyKSAmJiB0aGlzLl9vdXRlci5jbGVhblNhdmVkU3RhdGUodGhpcy5fb3V0ZXJLZXllZFN0YXRlKSwgdGhpcy5faW5uZXIuY2xlYW4oKSwgdGhpcy5fb3V0ZXIuY2xlYW4oKTtcbiAgICB9LCBpLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5uZXIudXBkYXRlKGUpLCB0aGlzO1xuICAgIH0sIGkucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maW5pc2hlZCA/ICh0aGlzLl9vdXRlci5maW5pc2goZSksIHRoaXMpIDogKHRoaXMuX2lubmVyLmZpbmlzaChlKSwgdGhpcy5fb3V0ZXIudXBkYXRlKGUuc3ViYXJyYXkoMCwgdGhpcy5kaWdlc3RMZW5ndGgpKS5maW5pc2goZSksIHRoaXMuX2ZpbmlzaGVkID0gITAsIHRoaXMpO1xuICAgIH0sIGkucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBuZXcgVWludDhBcnJheSh0aGlzLmRpZ2VzdExlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2goZSksIGU7XG4gICAgfSwgaS5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWp0LmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImhtYWM6IGNhbid0IHNhdmVTdGF0ZSgpIGJlY2F1c2UgaGFzaCBkb2Vzbid0IGltcGxlbWVudCBpdFwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9pbm5lci5zYXZlU3RhdGUoKTtcbiAgICB9LCBpLnByb3RvdHlwZS5yZXN0b3JlU3RhdGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIWp0LmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikgfHwgIWp0LmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9vdXRlcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImhtYWM6IGNhbid0IHJlc3RvcmVTdGF0ZSgpIGJlY2F1c2UgaGFzaCBkb2Vzbid0IGltcGxlbWVudCBpdFwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9pbm5lci5yZXN0b3JlU3RhdGUoZSksIHRoaXMuX291dGVyLnJlc3RvcmVTdGF0ZSh0aGlzLl9vdXRlcktleWVkU3RhdGUpLCB0aGlzLl9maW5pc2hlZCA9ICExLCB0aGlzO1xuICAgIH0sIGkucHJvdG90eXBlLmNsZWFuU2F2ZWRTdGF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghanQuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaG1hYzogY2FuJ3QgY2xlYW5TYXZlZFN0YXRlKCkgYmVjYXVzZSBoYXNoIGRvZXNuJ3QgaW1wbGVtZW50IGl0XCIpO1xuICAgICAgdGhpcy5faW5uZXIuY2xlYW5TYXZlZFN0YXRlKGUpO1xuICAgIH0sIGk7XG4gIH0oKVxuKTtcbnlzLkhNQUMgPSBQYztcbmZ1bmN0aW9uIFNmKGksIGUsIHQpIHtcbiAgdmFyIHMgPSBuZXcgUGMoaSwgZSk7XG4gIHMudXBkYXRlKHQpO1xuICB2YXIgciA9IHMuZGlnZXN0KCk7XG4gIHJldHVybiBzLmNsZWFuKCksIHI7XG59XG55cy5obWFjID0gU2Y7XG55cy5lcXVhbCA9IF9mLmVxdWFsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5jLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgdm8gPSB5cywgX28gPSBQdCwgSWYgPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaShlLCB0LCBzLCByKSB7XG4gICAgICBzID09PSB2b2lkIDAgJiYgKHMgPSBuZXcgVWludDhBcnJheSgwKSksIHRoaXMuX2NvdW50ZXIgPSBuZXcgVWludDhBcnJheSgxKSwgdGhpcy5faGFzaCA9IGUsIHRoaXMuX2luZm8gPSByO1xuICAgICAgdmFyIG4gPSB2by5obWFjKHRoaXMuX2hhc2gsIHMsIHQpO1xuICAgICAgdGhpcy5faG1hYyA9IG5ldyB2by5ITUFDKGUsIG4pLCB0aGlzLl9idWZmZXIgPSBuZXcgVWludDhBcnJheSh0aGlzLl9obWFjLmRpZ2VzdExlbmd0aCksIHRoaXMuX2J1ZnBvcyA9IHRoaXMuX2J1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBpLnByb3RvdHlwZS5fZmlsbEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY291bnRlclswXSsrO1xuICAgICAgdmFyIGUgPSB0aGlzLl9jb3VudGVyWzBdO1xuICAgICAgaWYgKGUgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImhrZGY6IGNhbm5vdCBleHBhbmQgbW9yZVwiKTtcbiAgICAgIHRoaXMuX2htYWMucmVzZXQoKSwgZSA+IDEgJiYgdGhpcy5faG1hYy51cGRhdGUodGhpcy5fYnVmZmVyKSwgdGhpcy5faW5mbyAmJiB0aGlzLl9obWFjLnVwZGF0ZSh0aGlzLl9pbmZvKSwgdGhpcy5faG1hYy51cGRhdGUodGhpcy5fY291bnRlciksIHRoaXMuX2htYWMuZmluaXNoKHRoaXMuX2J1ZmZlciksIHRoaXMuX2J1ZnBvcyA9IDA7XG4gICAgfSwgaS5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24oZSkge1xuICAgICAgZm9yICh2YXIgdCA9IG5ldyBVaW50OEFycmF5KGUpLCBzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspXG4gICAgICAgIHRoaXMuX2J1ZnBvcyA9PT0gdGhpcy5fYnVmZmVyLmxlbmd0aCAmJiB0aGlzLl9maWxsQnVmZmVyKCksIHRbc10gPSB0aGlzLl9idWZmZXJbdGhpcy5fYnVmcG9zKytdO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSwgaS5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2htYWMuY2xlYW4oKSwgX28ud2lwZSh0aGlzLl9idWZmZXIpLCBfby53aXBlKHRoaXMuX2NvdW50ZXIpLCB0aGlzLl9idWZwb3MgPSAwO1xuICAgIH0sIGk7XG4gIH0oKVxuKSwgUmMgPSBOYy5IS0RGID0gSWYsIFNpID0ge307XG4oZnVuY3Rpb24oaSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICB2YXIgZSA9IG9lLCB0ID0gUHQ7XG4gIGkuRElHRVNUX0xFTkdUSCA9IDMyLCBpLkJMT0NLX1NJWkUgPSA2NDtcbiAgdmFyIHMgPSAoXG4gICAgLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gYygpIHtcbiAgICAgICAgdGhpcy5kaWdlc3RMZW5ndGggPSBpLkRJR0VTVF9MRU5HVEgsIHRoaXMuYmxvY2tTaXplID0gaS5CTE9DS19TSVpFLCB0aGlzLl9zdGF0ZSA9IG5ldyBJbnQzMkFycmF5KDgpLCB0aGlzLl90ZW1wID0gbmV3IEludDMyQXJyYXkoNjQpLCB0aGlzLl9idWZmZXIgPSBuZXcgVWludDhBcnJheSgxMjgpLCB0aGlzLl9idWZmZXJMZW5ndGggPSAwLCB0aGlzLl9ieXRlc0hhc2hlZCA9IDAsIHRoaXMuX2ZpbmlzaGVkID0gITEsIHRoaXMucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjLnByb3RvdHlwZS5faW5pdFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlWzBdID0gMTc3OTAzMzcwMywgdGhpcy5fc3RhdGVbMV0gPSAzMTQ0MTM0Mjc3LCB0aGlzLl9zdGF0ZVsyXSA9IDEwMTM5MDQyNDIsIHRoaXMuX3N0YXRlWzNdID0gMjc3MzQ4MDc2MiwgdGhpcy5fc3RhdGVbNF0gPSAxMzU5ODkzMTE5LCB0aGlzLl9zdGF0ZVs1XSA9IDI2MDA4MjI5MjQsIHRoaXMuX3N0YXRlWzZdID0gNTI4NzM0NjM1LCB0aGlzLl9zdGF0ZVs3XSA9IDE1NDE0NTkyMjU7XG4gICAgICB9LCBjLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdFN0YXRlKCksIHRoaXMuX2J1ZmZlckxlbmd0aCA9IDAsIHRoaXMuX2J5dGVzSGFzaGVkID0gMCwgdGhpcy5fZmluaXNoZWQgPSAhMSwgdGhpcztcbiAgICAgIH0sIGMucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHQud2lwZSh0aGlzLl9idWZmZXIpLCB0LndpcGUodGhpcy5fdGVtcCksIHRoaXMucmVzZXQoKTtcbiAgICAgIH0sIGMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHUsIGQpIHtcbiAgICAgICAgaWYgKGQgPT09IHZvaWQgMCAmJiAoZCA9IHUubGVuZ3RoKSwgdGhpcy5fZmluaXNoZWQpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU0hBMjU2OiBjYW4ndCB1cGRhdGUgYmVjYXVzZSBoYXNoIHdhcyBmaW5pc2hlZC5cIik7XG4gICAgICAgIHZhciBwID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX2J5dGVzSGFzaGVkICs9IGQsIHRoaXMuX2J1ZmZlckxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKDsgdGhpcy5fYnVmZmVyTGVuZ3RoIDwgdGhpcy5ibG9ja1NpemUgJiYgZCA+IDA7IClcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclt0aGlzLl9idWZmZXJMZW5ndGgrK10gPSB1W3ArK10sIGQtLTtcbiAgICAgICAgICB0aGlzLl9idWZmZXJMZW5ndGggPT09IHRoaXMuYmxvY2tTaXplICYmIChuKHRoaXMuX3RlbXAsIHRoaXMuX3N0YXRlLCB0aGlzLl9idWZmZXIsIDAsIHRoaXMuYmxvY2tTaXplKSwgdGhpcy5fYnVmZmVyTGVuZ3RoID0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChkID49IHRoaXMuYmxvY2tTaXplICYmIChwID0gbih0aGlzLl90ZW1wLCB0aGlzLl9zdGF0ZSwgdSwgcCwgZCksIGQgJT0gdGhpcy5ibG9ja1NpemUpOyBkID4gMDsgKVxuICAgICAgICAgIHRoaXMuX2J1ZmZlclt0aGlzLl9idWZmZXJMZW5ndGgrK10gPSB1W3ArK10sIGQtLTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBjLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICB2YXIgZCA9IHRoaXMuX2J5dGVzSGFzaGVkLCBwID0gdGhpcy5fYnVmZmVyTGVuZ3RoLCBiID0gZCAvIDUzNjg3MDkxMiB8IDAsIHggPSBkIDw8IDMsIE8gPSBkICUgNjQgPCA1NiA/IDY0IDogMTI4O1xuICAgICAgICAgIHRoaXMuX2J1ZmZlcltwXSA9IDEyODtcbiAgICAgICAgICBmb3IgKHZhciBfID0gcCArIDE7IF8gPCBPIC0gODsgXysrKVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyW19dID0gMDtcbiAgICAgICAgICBlLndyaXRlVWludDMyQkUoYiwgdGhpcy5fYnVmZmVyLCBPIC0gOCksIGUud3JpdGVVaW50MzJCRSh4LCB0aGlzLl9idWZmZXIsIE8gLSA0KSwgbih0aGlzLl90ZW1wLCB0aGlzLl9zdGF0ZSwgdGhpcy5fYnVmZmVyLCAwLCBPKSwgdGhpcy5fZmluaXNoZWQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfID0gMDsgXyA8IHRoaXMuZGlnZXN0TGVuZ3RoIC8gNDsgXysrKVxuICAgICAgICAgIGUud3JpdGVVaW50MzJCRSh0aGlzLl9zdGF0ZVtfXSwgdSwgXyAqIDQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIGMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdSA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGlnZXN0TGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKHUpLCB1O1xuICAgICAgfSwgYy5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9maW5pc2hlZClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTSEEyNTY6IGNhbm5vdCBzYXZlIGZpbmlzaGVkIHN0YXRlXCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlOiBuZXcgSW50MzJBcnJheSh0aGlzLl9zdGF0ZSksXG4gICAgICAgICAgYnVmZmVyOiB0aGlzLl9idWZmZXJMZW5ndGggPiAwID8gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyKSA6IHZvaWQgMCxcbiAgICAgICAgICBidWZmZXJMZW5ndGg6IHRoaXMuX2J1ZmZlckxlbmd0aCxcbiAgICAgICAgICBieXRlc0hhc2hlZDogdGhpcy5fYnl0ZXNIYXNoZWRcbiAgICAgICAgfTtcbiAgICAgIH0sIGMucHJvdG90eXBlLnJlc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLnNldCh1LnN0YXRlKSwgdGhpcy5fYnVmZmVyTGVuZ3RoID0gdS5idWZmZXJMZW5ndGgsIHUuYnVmZmVyICYmIHRoaXMuX2J1ZmZlci5zZXQodS5idWZmZXIpLCB0aGlzLl9ieXRlc0hhc2hlZCA9IHUuYnl0ZXNIYXNoZWQsIHRoaXMuX2ZpbmlzaGVkID0gITEsIHRoaXM7XG4gICAgICB9LCBjLnByb3RvdHlwZS5jbGVhblNhdmVkU3RhdGUgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHQud2lwZSh1LnN0YXRlKSwgdS5idWZmZXIgJiYgdC53aXBlKHUuYnVmZmVyKSwgdS5idWZmZXJMZW5ndGggPSAwLCB1LmJ5dGVzSGFzaGVkID0gMDtcbiAgICAgIH0sIGM7XG4gICAgfSgpXG4gICk7XG4gIGkuU0hBMjU2ID0gcztcbiAgdmFyIHIgPSBuZXcgSW50MzJBcnJheShbXG4gICAgMTExNjM1MjQwOCxcbiAgICAxODk5NDQ3NDQxLFxuICAgIDMwNDkzMjM0NzEsXG4gICAgMzkyMTAwOTU3MyxcbiAgICA5NjE5ODcxNjMsXG4gICAgMTUwODk3MDk5MyxcbiAgICAyNDUzNjM1NzQ4LFxuICAgIDI4NzA3NjMyMjEsXG4gICAgMzYyNDM4MTA4MCxcbiAgICAzMTA1OTg0MDEsXG4gICAgNjA3MjI1Mjc4LFxuICAgIDE0MjY4ODE5ODcsXG4gICAgMTkyNTA3ODM4OCxcbiAgICAyMTYyMDc4MjA2LFxuICAgIDI2MTQ4ODgxMDMsXG4gICAgMzI0ODIyMjU4MCxcbiAgICAzODM1MzkwNDAxLFxuICAgIDQwMjIyMjQ3NzQsXG4gICAgMjY0MzQ3MDc4LFxuICAgIDYwNDgwNzYyOCxcbiAgICA3NzAyNTU5ODMsXG4gICAgMTI0OTE1MDEyMixcbiAgICAxNTU1MDgxNjkyLFxuICAgIDE5OTYwNjQ5ODYsXG4gICAgMjU1NDIyMDg4MixcbiAgICAyODIxODM0MzQ5LFxuICAgIDI5NTI5OTY4MDgsXG4gICAgMzIxMDMxMzY3MSxcbiAgICAzMzM2NTcxODkxLFxuICAgIDM1ODQ1Mjg3MTEsXG4gICAgMTEzOTI2OTkzLFxuICAgIDMzODI0MTg5NSxcbiAgICA2NjYzMDcyMDUsXG4gICAgNzczNTI5OTEyLFxuICAgIDEyOTQ3NTczNzIsXG4gICAgMTM5NjE4MjI5MSxcbiAgICAxNjk1MTgzNzAwLFxuICAgIDE5ODY2NjEwNTEsXG4gICAgMjE3NzAyNjM1MCxcbiAgICAyNDU2OTU2MDM3LFxuICAgIDI3MzA0ODU5MjEsXG4gICAgMjgyMDMwMjQxMSxcbiAgICAzMjU5NzMwODAwLFxuICAgIDMzNDU3NjQ3NzEsXG4gICAgMzUxNjA2NTgxNyxcbiAgICAzNjAwMzUyODA0LFxuICAgIDQwOTQ1NzE5MDksXG4gICAgMjc1NDIzMzQ0LFxuICAgIDQzMDIyNzczNCxcbiAgICA1MDY5NDg2MTYsXG4gICAgNjU5MDYwNTU2LFxuICAgIDg4Mzk5Nzg3NyxcbiAgICA5NTgxMzk1NzEsXG4gICAgMTMyMjgyMjIxOCxcbiAgICAxNTM3MDAyMDYzLFxuICAgIDE3NDc4NzM3NzksXG4gICAgMTk1NTU2MjIyMixcbiAgICAyMDI0MTA0ODE1LFxuICAgIDIyMjc3MzA0NTIsXG4gICAgMjM2MTg1MjQyNCxcbiAgICAyNDI4NDM2NDc0LFxuICAgIDI3NTY3MzQxODcsXG4gICAgMzIwNDAzMTQ3OSxcbiAgICAzMzI5MzI1Mjk4XG4gIF0pO1xuICBmdW5jdGlvbiBuKGMsIHUsIGQsIHAsIGIpIHtcbiAgICBmb3IgKDsgYiA+PSA2NDsgKSB7XG4gICAgICBmb3IgKHZhciB4ID0gdVswXSwgTyA9IHVbMV0sIF8gPSB1WzJdLCBDID0gdVszXSwgRiA9IHVbNF0sIEsgPSB1WzVdLCBJID0gdVs2XSwgRCA9IHVbN10sIHkgPSAwOyB5IDwgMTY7IHkrKykge1xuICAgICAgICB2YXIgdyA9IHAgKyB5ICogNDtcbiAgICAgICAgY1t5XSA9IGUucmVhZFVpbnQzMkJFKGQsIHcpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgeSA9IDE2OyB5IDwgNjQ7IHkrKykge1xuICAgICAgICB2YXIgZiA9IGNbeSAtIDJdLCBhID0gKGYgPj4+IDE3IHwgZiA8PCAzMiAtIDE3KSBeIChmID4+PiAxOSB8IGYgPDwgMzIgLSAxOSkgXiBmID4+PiAxMDtcbiAgICAgICAgZiA9IGNbeSAtIDE1XTtcbiAgICAgICAgdmFyIGwgPSAoZiA+Pj4gNyB8IGYgPDwgMzIgLSA3KSBeIChmID4+PiAxOCB8IGYgPDwgMzIgLSAxOCkgXiBmID4+PiAzO1xuICAgICAgICBjW3ldID0gKGEgKyBjW3kgLSA3XSB8IDApICsgKGwgKyBjW3kgLSAxNl0gfCAwKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNjQ7IHkrKykge1xuICAgICAgICB2YXIgYSA9ICgoKEYgPj4+IDYgfCBGIDw8IDI2KSBeIChGID4+PiAxMSB8IEYgPDwgMjEpIF4gKEYgPj4+IDI1IHwgRiA8PCA3KSkgKyAoRiAmIEsgXiB+RiAmIEkpIHwgMCkgKyAoRCArIChyW3ldICsgY1t5XSB8IDApIHwgMCkgfCAwLCBsID0gKCh4ID4+PiAyIHwgeCA8PCAzMiAtIDIpIF4gKHggPj4+IDEzIHwgeCA8PCAzMiAtIDEzKSBeICh4ID4+PiAyMiB8IHggPDwgMzIgLSAyMikpICsgKHggJiBPIF4geCAmIF8gXiBPICYgXykgfCAwO1xuICAgICAgICBEID0gSSwgSSA9IEssIEsgPSBGLCBGID0gQyArIGEgfCAwLCBDID0gXywgXyA9IE8sIE8gPSB4LCB4ID0gYSArIGwgfCAwO1xuICAgICAgfVxuICAgICAgdVswXSArPSB4LCB1WzFdICs9IE8sIHVbMl0gKz0gXywgdVszXSArPSBDLCB1WzRdICs9IEYsIHVbNV0gKz0gSywgdVs2XSArPSBJLCB1WzddICs9IEQsIHAgKz0gNjQsIGIgLT0gNjQ7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG4gIGZ1bmN0aW9uIG8oYykge1xuICAgIHZhciB1ID0gbmV3IHMoKTtcbiAgICB1LnVwZGF0ZShjKTtcbiAgICB2YXIgZCA9IHUuZGlnZXN0KCk7XG4gICAgcmV0dXJuIHUuY2xlYW4oKSwgZDtcbiAgfVxuICBpLmhhc2ggPSBvO1xufSkoU2kpO1xudmFyIG1zID0ge307XG4oZnVuY3Rpb24oaSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBpLnNoYXJlZEtleSA9IGkuZ2VuZXJhdGVLZXlQYWlyID0gaS5nZW5lcmF0ZUtleVBhaXJGcm9tU2VlZCA9IGkuc2NhbGFyTXVsdEJhc2UgPSBpLnNjYWxhck11bHQgPSBpLlNIQVJFRF9LRVlfTEVOR1RIID0gaS5TRUNSRVRfS0VZX0xFTkdUSCA9IGkuUFVCTElDX0tFWV9MRU5HVEggPSB2b2lkIDA7XG4gIGNvbnN0IGUgPSBsaSwgdCA9IFB0O1xuICBpLlBVQkxJQ19LRVlfTEVOR1RIID0gMzIsIGkuU0VDUkVUX0tFWV9MRU5HVEggPSAzMiwgaS5TSEFSRURfS0VZX0xFTkdUSCA9IDMyO1xuICBmdW5jdGlvbiBzKHkpIHtcbiAgICBjb25zdCB3ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgaWYgKHkpXG4gICAgICBmb3IgKGxldCBmID0gMDsgZiA8IHkubGVuZ3RoOyBmKyspXG4gICAgICAgIHdbZl0gPSB5W2ZdO1xuICAgIHJldHVybiB3O1xuICB9XG4gIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHJbMF0gPSA5O1xuICBjb25zdCBuID0gcyhbNTYxMjksIDFdKTtcbiAgZnVuY3Rpb24gbyh5KSB7XG4gICAgbGV0IHcgPSAxO1xuICAgIGZvciAobGV0IGYgPSAwOyBmIDwgMTY7IGYrKykge1xuICAgICAgbGV0IGEgPSB5W2ZdICsgdyArIDY1NTM1O1xuICAgICAgdyA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgeVtmXSA9IGEgLSB3ICogNjU1MzY7XG4gICAgfVxuICAgIHlbMF0gKz0gdyAtIDEgKyAzNyAqICh3IC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gYyh5LCB3LCBmKSB7XG4gICAgY29uc3QgYSA9IH4oZiAtIDEpO1xuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgMTY7IGwrKykge1xuICAgICAgY29uc3QgTCA9IGEgJiAoeVtsXSBeIHdbbF0pO1xuICAgICAgeVtsXSBePSBMLCB3W2xdIF49IEw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHUoeSwgdykge1xuICAgIGNvbnN0IGYgPSBzKCksIGEgPSBzKCk7XG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCAxNjsgbCsrKVxuICAgICAgYVtsXSA9IHdbbF07XG4gICAgbyhhKSwgbyhhKSwgbyhhKTtcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IDI7IGwrKykge1xuICAgICAgZlswXSA9IGFbMF0gLSA2NTUxNztcbiAgICAgIGZvciAobGV0IHYgPSAxOyB2IDwgMTU7IHYrKylcbiAgICAgICAgZlt2XSA9IGFbdl0gLSA2NTUzNSAtIChmW3YgLSAxXSA+PiAxNiAmIDEpLCBmW3YgLSAxXSAmPSA2NTUzNTtcbiAgICAgIGZbMTVdID0gYVsxNV0gLSAzMjc2NyAtIChmWzE0XSA+PiAxNiAmIDEpO1xuICAgICAgY29uc3QgTCA9IGZbMTVdID4+IDE2ICYgMTtcbiAgICAgIGZbMTRdICY9IDY1NTM1LCBjKGEsIGYsIDEgLSBMKTtcbiAgICB9XG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCAxNjsgbCsrKVxuICAgICAgeVsyICogbF0gPSBhW2xdICYgMjU1LCB5WzIgKiBsICsgMV0gPSBhW2xdID4+IDg7XG4gIH1cbiAgZnVuY3Rpb24gZCh5LCB3KSB7XG4gICAgZm9yIChsZXQgZiA9IDA7IGYgPCAxNjsgZisrKVxuICAgICAgeVtmXSA9IHdbMiAqIGZdICsgKHdbMiAqIGYgKyAxXSA8PCA4KTtcbiAgICB5WzE1XSAmPSAzMjc2NztcbiAgfVxuICBmdW5jdGlvbiBwKHksIHcsIGYpIHtcbiAgICBmb3IgKGxldCBhID0gMDsgYSA8IDE2OyBhKyspXG4gICAgICB5W2FdID0gd1thXSArIGZbYV07XG4gIH1cbiAgZnVuY3Rpb24gYih5LCB3LCBmKSB7XG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCAxNjsgYSsrKVxuICAgICAgeVthXSA9IHdbYV0gLSBmW2FdO1xuICB9XG4gIGZ1bmN0aW9uIHgoeSwgdywgZikge1xuICAgIGxldCBhLCBsLCBMID0gMCwgdiA9IDAsIFIgPSAwLCAkID0gMCwgcSA9IDAsIG0gPSAwLCBFID0gMCwgQiA9IDAsIHogPSAwLCBqID0gMCwgVSA9IDAsIE0gPSAwLCBIID0gMCwgdGUgPSAwLCBHID0gMCwgaWUgPSAwLCBRID0gMCwgc2UgPSAwLCBUID0gMCwgQSA9IDAsIE4gPSAwLCBoID0gMCwgUyA9IDAsIFcgPSAwLCBYID0gMCwgZmUgPSAwLCB2ZSA9IDAsIGdlID0gMCwgU2UgPSAwLCBNZSA9IDAsICRlID0gMCwgYmUgPSBmWzBdLCB5ZSA9IGZbMV0sIHBlID0gZlsyXSwgbGUgPSBmWzNdLCB1ZSA9IGZbNF0sIGhlID0gZls1XSwgY2UgPSBmWzZdLCByZSA9IGZbN10sIGRlID0gZls4XSwgbWUgPSBmWzldLCBuZSA9IGZbMTBdLCBfZSA9IGZbMTFdLCBFZSA9IGZbMTJdLCBEZSA9IGZbMTNdLCB4ZSA9IGZbMTRdLCBJZSA9IGZbMTVdO1xuICAgIGEgPSB3WzBdLCBMICs9IGEgKiBiZSwgdiArPSBhICogeWUsIFIgKz0gYSAqIHBlLCAkICs9IGEgKiBsZSwgcSArPSBhICogdWUsIG0gKz0gYSAqIGhlLCBFICs9IGEgKiBjZSwgQiArPSBhICogcmUsIHogKz0gYSAqIGRlLCBqICs9IGEgKiBtZSwgVSArPSBhICogbmUsIE0gKz0gYSAqIF9lLCBIICs9IGEgKiBFZSwgdGUgKz0gYSAqIERlLCBHICs9IGEgKiB4ZSwgaWUgKz0gYSAqIEllLCBhID0gd1sxXSwgdiArPSBhICogYmUsIFIgKz0gYSAqIHllLCAkICs9IGEgKiBwZSwgcSArPSBhICogbGUsIG0gKz0gYSAqIHVlLCBFICs9IGEgKiBoZSwgQiArPSBhICogY2UsIHogKz0gYSAqIHJlLCBqICs9IGEgKiBkZSwgVSArPSBhICogbWUsIE0gKz0gYSAqIG5lLCBIICs9IGEgKiBfZSwgdGUgKz0gYSAqIEVlLCBHICs9IGEgKiBEZSwgaWUgKz0gYSAqIHhlLCBRICs9IGEgKiBJZSwgYSA9IHdbMl0sIFIgKz0gYSAqIGJlLCAkICs9IGEgKiB5ZSwgcSArPSBhICogcGUsIG0gKz0gYSAqIGxlLCBFICs9IGEgKiB1ZSwgQiArPSBhICogaGUsIHogKz0gYSAqIGNlLCBqICs9IGEgKiByZSwgVSArPSBhICogZGUsIE0gKz0gYSAqIG1lLCBIICs9IGEgKiBuZSwgdGUgKz0gYSAqIF9lLCBHICs9IGEgKiBFZSwgaWUgKz0gYSAqIERlLCBRICs9IGEgKiB4ZSwgc2UgKz0gYSAqIEllLCBhID0gd1szXSwgJCArPSBhICogYmUsIHEgKz0gYSAqIHllLCBtICs9IGEgKiBwZSwgRSArPSBhICogbGUsIEIgKz0gYSAqIHVlLCB6ICs9IGEgKiBoZSwgaiArPSBhICogY2UsIFUgKz0gYSAqIHJlLCBNICs9IGEgKiBkZSwgSCArPSBhICogbWUsIHRlICs9IGEgKiBuZSwgRyArPSBhICogX2UsIGllICs9IGEgKiBFZSwgUSArPSBhICogRGUsIHNlICs9IGEgKiB4ZSwgVCArPSBhICogSWUsIGEgPSB3WzRdLCBxICs9IGEgKiBiZSwgbSArPSBhICogeWUsIEUgKz0gYSAqIHBlLCBCICs9IGEgKiBsZSwgeiArPSBhICogdWUsIGogKz0gYSAqIGhlLCBVICs9IGEgKiBjZSwgTSArPSBhICogcmUsIEggKz0gYSAqIGRlLCB0ZSArPSBhICogbWUsIEcgKz0gYSAqIG5lLCBpZSArPSBhICogX2UsIFEgKz0gYSAqIEVlLCBzZSArPSBhICogRGUsIFQgKz0gYSAqIHhlLCBBICs9IGEgKiBJZSwgYSA9IHdbNV0sIG0gKz0gYSAqIGJlLCBFICs9IGEgKiB5ZSwgQiArPSBhICogcGUsIHogKz0gYSAqIGxlLCBqICs9IGEgKiB1ZSwgVSArPSBhICogaGUsIE0gKz0gYSAqIGNlLCBIICs9IGEgKiByZSwgdGUgKz0gYSAqIGRlLCBHICs9IGEgKiBtZSwgaWUgKz0gYSAqIG5lLCBRICs9IGEgKiBfZSwgc2UgKz0gYSAqIEVlLCBUICs9IGEgKiBEZSwgQSArPSBhICogeGUsIE4gKz0gYSAqIEllLCBhID0gd1s2XSwgRSArPSBhICogYmUsIEIgKz0gYSAqIHllLCB6ICs9IGEgKiBwZSwgaiArPSBhICogbGUsIFUgKz0gYSAqIHVlLCBNICs9IGEgKiBoZSwgSCArPSBhICogY2UsIHRlICs9IGEgKiByZSwgRyArPSBhICogZGUsIGllICs9IGEgKiBtZSwgUSArPSBhICogbmUsIHNlICs9IGEgKiBfZSwgVCArPSBhICogRWUsIEEgKz0gYSAqIERlLCBOICs9IGEgKiB4ZSwgaCArPSBhICogSWUsIGEgPSB3WzddLCBCICs9IGEgKiBiZSwgeiArPSBhICogeWUsIGogKz0gYSAqIHBlLCBVICs9IGEgKiBsZSwgTSArPSBhICogdWUsIEggKz0gYSAqIGhlLCB0ZSArPSBhICogY2UsIEcgKz0gYSAqIHJlLCBpZSArPSBhICogZGUsIFEgKz0gYSAqIG1lLCBzZSArPSBhICogbmUsIFQgKz0gYSAqIF9lLCBBICs9IGEgKiBFZSwgTiArPSBhICogRGUsIGggKz0gYSAqIHhlLCBTICs9IGEgKiBJZSwgYSA9IHdbOF0sIHogKz0gYSAqIGJlLCBqICs9IGEgKiB5ZSwgVSArPSBhICogcGUsIE0gKz0gYSAqIGxlLCBIICs9IGEgKiB1ZSwgdGUgKz0gYSAqIGhlLCBHICs9IGEgKiBjZSwgaWUgKz0gYSAqIHJlLCBRICs9IGEgKiBkZSwgc2UgKz0gYSAqIG1lLCBUICs9IGEgKiBuZSwgQSArPSBhICogX2UsIE4gKz0gYSAqIEVlLCBoICs9IGEgKiBEZSwgUyArPSBhICogeGUsIFcgKz0gYSAqIEllLCBhID0gd1s5XSwgaiArPSBhICogYmUsIFUgKz0gYSAqIHllLCBNICs9IGEgKiBwZSwgSCArPSBhICogbGUsIHRlICs9IGEgKiB1ZSwgRyArPSBhICogaGUsIGllICs9IGEgKiBjZSwgUSArPSBhICogcmUsIHNlICs9IGEgKiBkZSwgVCArPSBhICogbWUsIEEgKz0gYSAqIG5lLCBOICs9IGEgKiBfZSwgaCArPSBhICogRWUsIFMgKz0gYSAqIERlLCBXICs9IGEgKiB4ZSwgWCArPSBhICogSWUsIGEgPSB3WzEwXSwgVSArPSBhICogYmUsIE0gKz0gYSAqIHllLCBIICs9IGEgKiBwZSwgdGUgKz0gYSAqIGxlLCBHICs9IGEgKiB1ZSwgaWUgKz0gYSAqIGhlLCBRICs9IGEgKiBjZSwgc2UgKz0gYSAqIHJlLCBUICs9IGEgKiBkZSwgQSArPSBhICogbWUsIE4gKz0gYSAqIG5lLCBoICs9IGEgKiBfZSwgUyArPSBhICogRWUsIFcgKz0gYSAqIERlLCBYICs9IGEgKiB4ZSwgZmUgKz0gYSAqIEllLCBhID0gd1sxMV0sIE0gKz0gYSAqIGJlLCBIICs9IGEgKiB5ZSwgdGUgKz0gYSAqIHBlLCBHICs9IGEgKiBsZSwgaWUgKz0gYSAqIHVlLCBRICs9IGEgKiBoZSwgc2UgKz0gYSAqIGNlLCBUICs9IGEgKiByZSwgQSArPSBhICogZGUsIE4gKz0gYSAqIG1lLCBoICs9IGEgKiBuZSwgUyArPSBhICogX2UsIFcgKz0gYSAqIEVlLCBYICs9IGEgKiBEZSwgZmUgKz0gYSAqIHhlLCB2ZSArPSBhICogSWUsIGEgPSB3WzEyXSwgSCArPSBhICogYmUsIHRlICs9IGEgKiB5ZSwgRyArPSBhICogcGUsIGllICs9IGEgKiBsZSwgUSArPSBhICogdWUsIHNlICs9IGEgKiBoZSwgVCArPSBhICogY2UsIEEgKz0gYSAqIHJlLCBOICs9IGEgKiBkZSwgaCArPSBhICogbWUsIFMgKz0gYSAqIG5lLCBXICs9IGEgKiBfZSwgWCArPSBhICogRWUsIGZlICs9IGEgKiBEZSwgdmUgKz0gYSAqIHhlLCBnZSArPSBhICogSWUsIGEgPSB3WzEzXSwgdGUgKz0gYSAqIGJlLCBHICs9IGEgKiB5ZSwgaWUgKz0gYSAqIHBlLCBRICs9IGEgKiBsZSwgc2UgKz0gYSAqIHVlLCBUICs9IGEgKiBoZSwgQSArPSBhICogY2UsIE4gKz0gYSAqIHJlLCBoICs9IGEgKiBkZSwgUyArPSBhICogbWUsIFcgKz0gYSAqIG5lLCBYICs9IGEgKiBfZSwgZmUgKz0gYSAqIEVlLCB2ZSArPSBhICogRGUsIGdlICs9IGEgKiB4ZSwgU2UgKz0gYSAqIEllLCBhID0gd1sxNF0sIEcgKz0gYSAqIGJlLCBpZSArPSBhICogeWUsIFEgKz0gYSAqIHBlLCBzZSArPSBhICogbGUsIFQgKz0gYSAqIHVlLCBBICs9IGEgKiBoZSwgTiArPSBhICogY2UsIGggKz0gYSAqIHJlLCBTICs9IGEgKiBkZSwgVyArPSBhICogbWUsIFggKz0gYSAqIG5lLCBmZSArPSBhICogX2UsIHZlICs9IGEgKiBFZSwgZ2UgKz0gYSAqIERlLCBTZSArPSBhICogeGUsIE1lICs9IGEgKiBJZSwgYSA9IHdbMTVdLCBpZSArPSBhICogYmUsIFEgKz0gYSAqIHllLCBzZSArPSBhICogcGUsIFQgKz0gYSAqIGxlLCBBICs9IGEgKiB1ZSwgTiArPSBhICogaGUsIGggKz0gYSAqIGNlLCBTICs9IGEgKiByZSwgVyArPSBhICogZGUsIFggKz0gYSAqIG1lLCBmZSArPSBhICogbmUsIHZlICs9IGEgKiBfZSwgZ2UgKz0gYSAqIEVlLCBTZSArPSBhICogRGUsIE1lICs9IGEgKiB4ZSwgJGUgKz0gYSAqIEllLCBMICs9IDM4ICogUSwgdiArPSAzOCAqIHNlLCBSICs9IDM4ICogVCwgJCArPSAzOCAqIEEsIHEgKz0gMzggKiBOLCBtICs9IDM4ICogaCwgRSArPSAzOCAqIFMsIEIgKz0gMzggKiBXLCB6ICs9IDM4ICogWCwgaiArPSAzOCAqIGZlLCBVICs9IDM4ICogdmUsIE0gKz0gMzggKiBnZSwgSCArPSAzOCAqIFNlLCB0ZSArPSAzOCAqIE1lLCBHICs9IDM4ICogJGUsIGwgPSAxLCBhID0gTCArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgTCA9IGEgLSBsICogNjU1MzYsIGEgPSB2ICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCB2ID0gYSAtIGwgKiA2NTUzNiwgYSA9IFIgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIFIgPSBhIC0gbCAqIDY1NTM2LCBhID0gJCArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgJCA9IGEgLSBsICogNjU1MzYsIGEgPSBxICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBxID0gYSAtIGwgKiA2NTUzNiwgYSA9IG0gKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIG0gPSBhIC0gbCAqIDY1NTM2LCBhID0gRSArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgRSA9IGEgLSBsICogNjU1MzYsIGEgPSBCICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBCID0gYSAtIGwgKiA2NTUzNiwgYSA9IHogKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIHogPSBhIC0gbCAqIDY1NTM2LCBhID0gaiArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgaiA9IGEgLSBsICogNjU1MzYsIGEgPSBVICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBVID0gYSAtIGwgKiA2NTUzNiwgYSA9IE0gKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIE0gPSBhIC0gbCAqIDY1NTM2LCBhID0gSCArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgSCA9IGEgLSBsICogNjU1MzYsIGEgPSB0ZSArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgdGUgPSBhIC0gbCAqIDY1NTM2LCBhID0gRyArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgRyA9IGEgLSBsICogNjU1MzYsIGEgPSBpZSArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgaWUgPSBhIC0gbCAqIDY1NTM2LCBMICs9IGwgLSAxICsgMzcgKiAobCAtIDEpLCBsID0gMSwgYSA9IEwgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIEwgPSBhIC0gbCAqIDY1NTM2LCBhID0gdiArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgdiA9IGEgLSBsICogNjU1MzYsIGEgPSBSICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBSID0gYSAtIGwgKiA2NTUzNiwgYSA9ICQgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksICQgPSBhIC0gbCAqIDY1NTM2LCBhID0gcSArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgcSA9IGEgLSBsICogNjU1MzYsIGEgPSBtICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBtID0gYSAtIGwgKiA2NTUzNiwgYSA9IEUgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIEUgPSBhIC0gbCAqIDY1NTM2LCBhID0gQiArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgQiA9IGEgLSBsICogNjU1MzYsIGEgPSB6ICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCB6ID0gYSAtIGwgKiA2NTUzNiwgYSA9IGogKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIGogPSBhIC0gbCAqIDY1NTM2LCBhID0gVSArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgVSA9IGEgLSBsICogNjU1MzYsIGEgPSBNICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBNID0gYSAtIGwgKiA2NTUzNiwgYSA9IEggKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIEggPSBhIC0gbCAqIDY1NTM2LCBhID0gdGUgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIHRlID0gYSAtIGwgKiA2NTUzNiwgYSA9IEcgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIEcgPSBhIC0gbCAqIDY1NTM2LCBhID0gaWUgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIGllID0gYSAtIGwgKiA2NTUzNiwgTCArPSBsIC0gMSArIDM3ICogKGwgLSAxKSwgeVswXSA9IEwsIHlbMV0gPSB2LCB5WzJdID0gUiwgeVszXSA9ICQsIHlbNF0gPSBxLCB5WzVdID0gbSwgeVs2XSA9IEUsIHlbN10gPSBCLCB5WzhdID0geiwgeVs5XSA9IGosIHlbMTBdID0gVSwgeVsxMV0gPSBNLCB5WzEyXSA9IEgsIHlbMTNdID0gdGUsIHlbMTRdID0gRywgeVsxNV0gPSBpZTtcbiAgfVxuICBmdW5jdGlvbiBPKHksIHcpIHtcbiAgICB4KHksIHcsIHcpO1xuICB9XG4gIGZ1bmN0aW9uIF8oeSwgdykge1xuICAgIGNvbnN0IGYgPSBzKCk7XG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCAxNjsgYSsrKVxuICAgICAgZlthXSA9IHdbYV07XG4gICAgZm9yIChsZXQgYSA9IDI1MzsgYSA+PSAwOyBhLS0pXG4gICAgICBPKGYsIGYpLCBhICE9PSAyICYmIGEgIT09IDQgJiYgeChmLCBmLCB3KTtcbiAgICBmb3IgKGxldCBhID0gMDsgYSA8IDE2OyBhKyspXG4gICAgICB5W2FdID0gZlthXTtcbiAgfVxuICBmdW5jdGlvbiBDKHksIHcpIHtcbiAgICBjb25zdCBmID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBhID0gbmV3IEZsb2F0NjRBcnJheSg4MCksIGwgPSBzKCksIEwgPSBzKCksIHYgPSBzKCksIFIgPSBzKCksICQgPSBzKCksIHEgPSBzKCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCAzMTsgeisrKVxuICAgICAgZlt6XSA9IHlbel07XG4gICAgZlszMV0gPSB5WzMxXSAmIDEyNyB8IDY0LCBmWzBdICY9IDI0OCwgZChhLCB3KTtcbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IDE2OyB6KyspXG4gICAgICBMW3pdID0gYVt6XTtcbiAgICBsWzBdID0gUlswXSA9IDE7XG4gICAgZm9yIChsZXQgeiA9IDI1NDsgeiA+PSAwOyAtLXopIHtcbiAgICAgIGNvbnN0IGogPSBmW3ogPj4+IDNdID4+PiAoeiAmIDcpICYgMTtcbiAgICAgIGMobCwgTCwgaiksIGModiwgUiwgaiksIHAoJCwgbCwgdiksIGIobCwgbCwgdiksIHAodiwgTCwgUiksIGIoTCwgTCwgUiksIE8oUiwgJCksIE8ocSwgbCksIHgobCwgdiwgbCksIHgodiwgTCwgJCksIHAoJCwgbCwgdiksIGIobCwgbCwgdiksIE8oTCwgbCksIGIodiwgUiwgcSksIHgobCwgdiwgbiksIHAobCwgbCwgUiksIHgodiwgdiwgbCksIHgobCwgUiwgcSksIHgoUiwgTCwgYSksIE8oTCwgJCksIGMobCwgTCwgaiksIGModiwgUiwgaik7XG4gICAgfVxuICAgIGZvciAobGV0IHogPSAwOyB6IDwgMTY7IHorKylcbiAgICAgIGFbeiArIDE2XSA9IGxbel0sIGFbeiArIDMyXSA9IHZbel0sIGFbeiArIDQ4XSA9IExbel0sIGFbeiArIDY0XSA9IFJbel07XG4gICAgY29uc3QgbSA9IGEuc3ViYXJyYXkoMzIpLCBFID0gYS5zdWJhcnJheSgxNik7XG4gICAgXyhtLCBtKSwgeChFLCBFLCBtKTtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHJldHVybiB1KEIsIEUpLCBCO1xuICB9XG4gIGkuc2NhbGFyTXVsdCA9IEM7XG4gIGZ1bmN0aW9uIEYoeSkge1xuICAgIHJldHVybiBDKHksIHIpO1xuICB9XG4gIGkuc2NhbGFyTXVsdEJhc2UgPSBGO1xuICBmdW5jdGlvbiBLKHkpIHtcbiAgICBpZiAoeS5sZW5ndGggIT09IGkuU0VDUkVUX0tFWV9MRU5HVEgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHgyNTUxOTogc2VlZCBtdXN0IGJlICR7aS5TRUNSRVRfS0VZX0xFTkdUSH0gYnl0ZXNgKTtcbiAgICBjb25zdCB3ID0gbmV3IFVpbnQ4QXJyYXkoeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YmxpY0tleTogRih3KSxcbiAgICAgIHNlY3JldEtleTogd1xuICAgIH07XG4gIH1cbiAgaS5nZW5lcmF0ZUtleVBhaXJGcm9tU2VlZCA9IEs7XG4gIGZ1bmN0aW9uIEkoeSkge1xuICAgIGNvbnN0IHcgPSAoMCwgZS5yYW5kb21CeXRlcykoMzIsIHkpLCBmID0gSyh3KTtcbiAgICByZXR1cm4gKDAsIHQud2lwZSkodyksIGY7XG4gIH1cbiAgaS5nZW5lcmF0ZUtleVBhaXIgPSBJO1xuICBmdW5jdGlvbiBEKHksIHcsIGYgPSAhMSkge1xuICAgIGlmICh5Lmxlbmd0aCAhPT0gaS5QVUJMSUNfS0VZX0xFTkdUSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlgyNTUxOTogaW5jb3JyZWN0IHNlY3JldCBrZXkgbGVuZ3RoXCIpO1xuICAgIGlmICh3Lmxlbmd0aCAhPT0gaS5QVUJMSUNfS0VZX0xFTkdUSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlgyNTUxOTogaW5jb3JyZWN0IHB1YmxpYyBrZXkgbGVuZ3RoXCIpO1xuICAgIGNvbnN0IGEgPSBDKHksIHcpO1xuICAgIGlmIChmKSB7XG4gICAgICBsZXQgbCA9IDA7XG4gICAgICBmb3IgKGxldCBMID0gMDsgTCA8IGEubGVuZ3RoOyBMKyspXG4gICAgICAgIGwgfD0gYVtMXTtcbiAgICAgIGlmIChsID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJYMjU1MTk6IGludmFsaWQgc2hhcmVkIGtleVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgaS5zaGFyZWRLZXkgPSBEO1xufSkobXMpO1xudmFyIEVvID0gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzLl9fc3ByZWFkQXJyYXkgfHwgZnVuY3Rpb24oaSwgZSwgdCkge1xuICBpZiAodCB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgIGZvciAodmFyIHMgPSAwLCByID0gZS5sZW5ndGgsIG47IHMgPCByOyBzKyspXG4gICAgICAobiB8fCAhKHMgaW4gZSkpICYmIChuIHx8IChuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSwgMCwgcykpLCBuW3NdID0gZVtzXSk7XG4gIHJldHVybiBpLmNvbmNhdChuIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUpKTtcbn0sIERmID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGkoZSwgdCwgcykge1xuICAgICAgdGhpcy5uYW1lID0gZSwgdGhpcy52ZXJzaW9uID0gdCwgdGhpcy5vcyA9IHMsIHRoaXMudHlwZSA9IFwiYnJvd3NlclwiO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfSgpXG4pLCB4ZiA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBpKGUpIHtcbiAgICAgIHRoaXMudmVyc2lvbiA9IGUsIHRoaXMudHlwZSA9IFwibm9kZVwiLCB0aGlzLm5hbWUgPSBcIm5vZGVcIiwgdGhpcy5vcyA9IHByb2Nlc3MucGxhdGZvcm07XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9KClcbiksIE9mID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGkoZSwgdCwgcywgcikge1xuICAgICAgdGhpcy5uYW1lID0gZSwgdGhpcy52ZXJzaW9uID0gdCwgdGhpcy5vcyA9IHMsIHRoaXMuYm90ID0gciwgdGhpcy50eXBlID0gXCJib3QtZGV2aWNlXCI7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9KClcbiksIE5mID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICB0aGlzLnR5cGUgPSBcImJvdFwiLCB0aGlzLmJvdCA9ICEwLCB0aGlzLm5hbWUgPSBcImJvdFwiLCB0aGlzLnZlcnNpb24gPSBudWxsLCB0aGlzLm9zID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0oKVxuKSwgUGYgPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgIHRoaXMudHlwZSA9IFwicmVhY3QtbmF0aXZlXCIsIHRoaXMubmFtZSA9IFwicmVhY3QtbmF0aXZlXCIsIHRoaXMudmVyc2lvbiA9IG51bGwsIHRoaXMub3MgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfSgpXG4pLCBSZiA9IC9hbGV4YXxib3R8Y3Jhd2woZXJ8aW5nKXxmYWNlYm9va2V4dGVybmFsaGl0fGZlZWRidXJuZXJ8Z29vZ2xlIHdlYiBwcmV2aWV3fG5hZ2lvc3xwb3N0cmFua3xwaW5nZG9tfHNsdXJwfHNwaWRlcnx5YWhvbyF8eWFuZGV4LywgQ2YgPSAvKG51aGt8Y3VybHxHb29nbGVib3R8WWFtbXlib3R8T3BlbmJvdHxTbHVycHxNU05Cb3R8QXNrXFwgSmVldmVzXFwvVGVvbWF8aWFfYXJjaGl2ZXIpLywgU28gPSAzLCBBZiA9IFtcbiAgW1wiYW9sXCIsIC9BT0xTaGllbGRcXC8oWzAtOVxcLl9dKykvXSxcbiAgW1wiZWRnZVwiLCAvRWRnZVxcLyhbMC05XFwuX10rKS9dLFxuICBbXCJlZGdlLWlvc1wiLCAvRWRnaU9TXFwvKFswLTlcXC5fXSspL10sXG4gIFtcInlhbmRleGJyb3dzZXJcIiwgL1lhQnJvd3NlclxcLyhbMC05XFwuX10rKS9dLFxuICBbXCJrYWthb3RhbGtcIiwgL0tBS0FPVEFMS1xccyhbMC05XFwuXSspL10sXG4gIFtcInNhbXN1bmdcIiwgL1NhbXN1bmdCcm93c2VyXFwvKFswLTlcXC5dKykvXSxcbiAgW1wic2lsa1wiLCAvXFxiU2lsa1xcLyhbMC05Ll8tXSspXFxiL10sXG4gIFtcIm1pdWlcIiwgL01pdWlCcm93c2VyXFwvKFswLTlcXC5dKykkL10sXG4gIFtcImJlYWtlclwiLCAvQmVha2VyQnJvd3NlclxcLyhbMC05XFwuXSspL10sXG4gIFtcImVkZ2UtY2hyb21pdW1cIiwgL0VkZ0E/XFwvKFswLTlcXC5dKykvXSxcbiAgW1xuICAgIFwiY2hyb21pdW0td2Vidmlld1wiLFxuICAgIC8oPyFDaHJvbS4qT1BSKXd2XFwpLipDaHJvbSg/OmV8aXVtKVxcLyhbMC05XFwuXSspKDo/XFxzfCQpL1xuICBdLFxuICBbXCJjaHJvbWVcIiwgLyg/IUNocm9tLipPUFIpQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICBbXCJwaGFudG9tanNcIiwgL1BoYW50b21KU1xcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sXG4gIFtcImNyaW9zXCIsIC9DcmlPU1xcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sXG4gIFtcImZpcmVmb3hcIiwgL0ZpcmVmb3hcXC8oWzAtOVxcLl0rKSg/Olxcc3wkKS9dLFxuICBbXCJmeGlvc1wiLCAvRnhpT1NcXC8oWzAtOVxcLl0rKS9dLFxuICBbXCJvcGVyYS1taW5pXCIsIC9PcGVyYSBNaW5pLipWZXJzaW9uXFwvKFswLTlcXC5dKykvXSxcbiAgW1wib3BlcmFcIiwgL09wZXJhXFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSxcbiAgW1wib3BlcmFcIiwgL09QUlxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sXG4gIFtcInBpZVwiLCAvXk1pY3Jvc29mdCBQb2NrZXQgSW50ZXJuZXQgRXhwbG9yZXJcXC8oXFxkK1xcLlxcZCspJC9dLFxuICBbXCJwaWVcIiwgL15Nb3ppbGxhXFwvXFxkXFwuXFxkK1xcc1xcKGNvbXBhdGlibGU7XFxzKD86TVNQP0lFfE1TSW50ZXJuZXQgRXhwbG9yZXIpIChcXGQrXFwuXFxkKyk7LipXaW5kb3dzIENFLipcXCkkL10sXG4gIFtcIm5ldGZyb250XCIsIC9eTW96aWxsYVxcL1xcZFxcLlxcZCsuKk5ldEZyb250XFwvKFxcZC5cXGQpL10sXG4gIFtcImllXCIsIC9UcmlkZW50XFwvN1xcLjAuKnJ2XFw6KFswLTlcXC5dKykuKlxcKS4qR2Vja28kL10sXG4gIFtcImllXCIsIC9NU0lFXFxzKFswLTlcXC5dKyk7LipUcmlkZW50XFwvWzQtN10uMC9dLFxuICBbXCJpZVwiLCAvTVNJRVxccyg3XFwuMCkvXSxcbiAgW1wiYmIxMFwiLCAvQkIxMDtcXHNUb3VjaC4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sXG4gIFtcImFuZHJvaWRcIiwgL0FuZHJvaWRcXHMoWzAtOVxcLl0rKS9dLFxuICBbXCJpb3NcIiwgL1ZlcnNpb25cXC8oWzAtOVxcLl9dKykuKk1vYmlsZS4qU2FmYXJpLiovXSxcbiAgW1wic2FmYXJpXCIsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipTYWZhcmkvXSxcbiAgW1wiZmFjZWJvb2tcIiwgL0ZCW0FTXVZcXC8oWzAtOVxcLl0rKS9dLFxuICBbXCJpbnN0YWdyYW1cIiwgL0luc3RhZ3JhbVxccyhbMC05XFwuXSspL10sXG4gIFtcImlvcy13ZWJ2aWV3XCIsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipNb2JpbGUvXSxcbiAgW1wiaW9zLXdlYnZpZXdcIiwgL0FwcGxlV2ViS2l0XFwvKFswLTlcXC5dKykuKkdlY2tvXFwpJC9dLFxuICBbXCJjdXJsXCIsIC9eY3VybFxcLyhbMC05XFwuXSspJC9dLFxuICBbXCJzZWFyY2hib3RcIiwgUmZdXG5dLCBJbyA9IFtcbiAgW1wiaU9TXCIsIC9pUChob25lfG9kfGFkKS9dLFxuICBbXCJBbmRyb2lkIE9TXCIsIC9BbmRyb2lkL10sXG4gIFtcIkJsYWNrQmVycnkgT1NcIiwgL0JsYWNrQmVycnl8QkIxMC9dLFxuICBbXCJXaW5kb3dzIE1vYmlsZVwiLCAvSUVNb2JpbGUvXSxcbiAgW1wiQW1hem9uIE9TXCIsIC9LaW5kbGUvXSxcbiAgW1wiV2luZG93cyAzLjExXCIsIC9XaW4xNi9dLFxuICBbXCJXaW5kb3dzIDk1XCIsIC8oV2luZG93cyA5NSl8KFdpbjk1KXwoV2luZG93c185NSkvXSxcbiAgW1wiV2luZG93cyA5OFwiLCAvKFdpbmRvd3MgOTgpfChXaW45OCkvXSxcbiAgW1wiV2luZG93cyAyMDAwXCIsIC8oV2luZG93cyBOVCA1LjApfChXaW5kb3dzIDIwMDApL10sXG4gIFtcIldpbmRvd3MgWFBcIiwgLyhXaW5kb3dzIE5UIDUuMSl8KFdpbmRvd3MgWFApL10sXG4gIFtcIldpbmRvd3MgU2VydmVyIDIwMDNcIiwgLyhXaW5kb3dzIE5UIDUuMikvXSxcbiAgW1wiV2luZG93cyBWaXN0YVwiLCAvKFdpbmRvd3MgTlQgNi4wKS9dLFxuICBbXCJXaW5kb3dzIDdcIiwgLyhXaW5kb3dzIE5UIDYuMSkvXSxcbiAgW1wiV2luZG93cyA4XCIsIC8oV2luZG93cyBOVCA2LjIpL10sXG4gIFtcIldpbmRvd3MgOC4xXCIsIC8oV2luZG93cyBOVCA2LjMpL10sXG4gIFtcIldpbmRvd3MgMTBcIiwgLyhXaW5kb3dzIE5UIDEwLjApL10sXG4gIFtcIldpbmRvd3MgTUVcIiwgL1dpbmRvd3MgTUUvXSxcbiAgW1wiV2luZG93cyBDRVwiLCAvV2luZG93cyBDRXxXaW5DRXxNaWNyb3NvZnQgUG9ja2V0IEludGVybmV0IEV4cGxvcmVyL10sXG4gIFtcIk9wZW4gQlNEXCIsIC9PcGVuQlNEL10sXG4gIFtcIlN1biBPU1wiLCAvU3VuT1MvXSxcbiAgW1wiQ2hyb21lIE9TXCIsIC9Dck9TL10sXG4gIFtcIkxpbnV4XCIsIC8oTGludXgpfChYMTEpL10sXG4gIFtcIk1hYyBPU1wiLCAvKE1hY19Qb3dlclBDKXwoTWFjaW50b3NoKS9dLFxuICBbXCJRTlhcIiwgL1FOWC9dLFxuICBbXCJCZU9TXCIsIC9CZU9TL10sXG4gIFtcIk9TLzJcIiwgL09TXFwvMi9dXG5dO1xuZnVuY3Rpb24gaG4oaSkge1xuICByZXR1cm4gaSA/IERvKGkpIDogdHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIgJiYgdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCIgPyBuZXcgUGYoKSA6IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiA/IERvKG5hdmlnYXRvci51c2VyQWdlbnQpIDogRmYoKTtcbn1cbmZ1bmN0aW9uIFRmKGkpIHtcbiAgcmV0dXJuIGkgIT09IFwiXCIgJiYgQWYucmVkdWNlKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgcyA9IHRbMF0sIHIgPSB0WzFdO1xuICAgIGlmIChlKVxuICAgICAgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSByLmV4ZWMoaSk7XG4gICAgcmV0dXJuICEhbiAmJiBbcywgbl07XG4gIH0sICExKTtcbn1cbmZ1bmN0aW9uIERvKGkpIHtcbiAgdmFyIGUgPSBUZihpKTtcbiAgaWYgKCFlKVxuICAgIHJldHVybiBudWxsO1xuICB2YXIgdCA9IGVbMF0sIHMgPSBlWzFdO1xuICBpZiAodCA9PT0gXCJzZWFyY2hib3RcIilcbiAgICByZXR1cm4gbmV3IE5mKCk7XG4gIHZhciByID0gc1sxXSAmJiBzWzFdLnNwbGl0KFwiLlwiKS5qb2luKFwiX1wiKS5zcGxpdChcIl9cIikuc2xpY2UoMCwgMyk7XG4gIHIgPyByLmxlbmd0aCA8IFNvICYmIChyID0gRW8oRW8oW10sIHIsICEwKSwgVWYoU28gLSByLmxlbmd0aCksICEwKSkgOiByID0gW107XG4gIHZhciBuID0gci5qb2luKFwiLlwiKSwgbyA9ICRmKGkpLCBjID0gQ2YuZXhlYyhpKTtcbiAgcmV0dXJuIGMgJiYgY1sxXSA/IG5ldyBPZih0LCBuLCBvLCBjWzFdKSA6IG5ldyBEZih0LCBuLCBvKTtcbn1cbmZ1bmN0aW9uICRmKGkpIHtcbiAgZm9yICh2YXIgZSA9IDAsIHQgPSBJby5sZW5ndGg7IGUgPCB0OyBlKyspIHtcbiAgICB2YXIgcyA9IElvW2VdLCByID0gc1swXSwgbiA9IHNbMV0sIG8gPSBuLmV4ZWMoaSk7XG4gICAgaWYgKG8pXG4gICAgICByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIEZmKCkge1xuICB2YXIgaSA9IHR5cGVvZiBwcm9jZXNzIDwgXCJ1XCIgJiYgcHJvY2Vzcy52ZXJzaW9uO1xuICByZXR1cm4gaSA/IG5ldyB4Zihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMSkpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIFVmKGkpIHtcbiAgZm9yICh2YXIgZSA9IFtdLCB0ID0gMDsgdCA8IGk7IHQrKylcbiAgICBlLnB1c2goXCIwXCIpO1xuICByZXR1cm4gZTtcbn1cbnZhciBQZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5QZS5nZXRMb2NhbFN0b3JhZ2UgPSBQZS5nZXRMb2NhbFN0b3JhZ2VPclRocm93ID0gUGUuZ2V0Q3J5cHRvID0gUGUuZ2V0Q3J5cHRvT3JUaHJvdyA9IGxuID0gUGUuZ2V0TG9jYXRpb24gPSBQZS5nZXRMb2NhdGlvbk9yVGhyb3cgPSBicyA9IFBlLmdldE5hdmlnYXRvciA9IFBlLmdldE5hdmlnYXRvck9yVGhyb3cgPSB1biA9IFBlLmdldERvY3VtZW50ID0gUGUuZ2V0RG9jdW1lbnRPclRocm93ID0gUGUuZ2V0RnJvbVdpbmRvd09yVGhyb3cgPSBQZS5nZXRGcm9tV2luZG93ID0gdm9pZCAwO1xuZnVuY3Rpb24gSWkoaSkge1xuICBsZXQgZTtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2Ygd2luZG93W2ldIDwgXCJ1XCIgJiYgKGUgPSB3aW5kb3dbaV0pLCBlO1xufVxuUGUuZ2V0RnJvbVdpbmRvdyA9IElpO1xuZnVuY3Rpb24gTGkoaSkge1xuICBjb25zdCBlID0gSWkoaSk7XG4gIGlmICghZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7aX0gaXMgbm90IGRlZmluZWQgaW4gV2luZG93YCk7XG4gIHJldHVybiBlO1xufVxuUGUuZ2V0RnJvbVdpbmRvd09yVGhyb3cgPSBMaTtcbmZ1bmN0aW9uIExmKCkge1xuICByZXR1cm4gTGkoXCJkb2N1bWVudFwiKTtcbn1cblBlLmdldERvY3VtZW50T3JUaHJvdyA9IExmO1xuZnVuY3Rpb24gTWYoKSB7XG4gIHJldHVybiBJaShcImRvY3VtZW50XCIpO1xufVxudmFyIHVuID0gUGUuZ2V0RG9jdW1lbnQgPSBNZjtcbmZ1bmN0aW9uIHFmKCkge1xuICByZXR1cm4gTGkoXCJuYXZpZ2F0b3JcIik7XG59XG5QZS5nZXROYXZpZ2F0b3JPclRocm93ID0gcWY7XG5mdW5jdGlvbiBqZigpIHtcbiAgcmV0dXJuIElpKFwibmF2aWdhdG9yXCIpO1xufVxudmFyIGJzID0gUGUuZ2V0TmF2aWdhdG9yID0gamY7XG5mdW5jdGlvbiB6ZigpIHtcbiAgcmV0dXJuIExpKFwibG9jYXRpb25cIik7XG59XG5QZS5nZXRMb2NhdGlvbk9yVGhyb3cgPSB6ZjtcbmZ1bmN0aW9uIEtmKCkge1xuICByZXR1cm4gSWkoXCJsb2NhdGlvblwiKTtcbn1cbnZhciBsbiA9IFBlLmdldExvY2F0aW9uID0gS2Y7XG5mdW5jdGlvbiBWZigpIHtcbiAgcmV0dXJuIExpKFwiY3J5cHRvXCIpO1xufVxuUGUuZ2V0Q3J5cHRvT3JUaHJvdyA9IFZmO1xuZnVuY3Rpb24gQmYoKSB7XG4gIHJldHVybiBJaShcImNyeXB0b1wiKTtcbn1cblBlLmdldENyeXB0byA9IEJmO1xuZnVuY3Rpb24ga2YoKSB7XG4gIHJldHVybiBMaShcImxvY2FsU3RvcmFnZVwiKTtcbn1cblBlLmdldExvY2FsU3RvcmFnZU9yVGhyb3cgPSBrZjtcbmZ1bmN0aW9uIEhmKCkge1xuICByZXR1cm4gSWkoXCJsb2NhbFN0b3JhZ2VcIik7XG59XG5QZS5nZXRMb2NhbFN0b3JhZ2UgPSBIZjtcbnZhciBkbiA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGRuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgZm4gPSBkbi5nZXRXaW5kb3dNZXRhZGF0YSA9IHZvaWQgMDtcbmNvbnN0IHhvID0gUGU7XG5mdW5jdGlvbiBHZigpIHtcbiAgbGV0IGksIGU7XG4gIHRyeSB7XG4gICAgaSA9IHhvLmdldERvY3VtZW50T3JUaHJvdygpLCBlID0geG8uZ2V0TG9jYXRpb25PclRocm93KCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgY29uc3QgYiA9IGkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpLCB4ID0gW107XG4gICAgZm9yIChsZXQgTyA9IDA7IE8gPCBiLmxlbmd0aDsgTysrKSB7XG4gICAgICBjb25zdCBfID0gYltPXSwgQyA9IF8uZ2V0QXR0cmlidXRlKFwicmVsXCIpO1xuICAgICAgaWYgKEMgJiYgQy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJpY29uXCIpID4gLTEpIHtcbiAgICAgICAgY29uc3QgRiA9IF8uZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgICAgaWYgKEYpXG4gICAgICAgICAgaWYgKEYudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiaHR0cHM6XCIpID09PSAtMSAmJiBGLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImh0dHA6XCIpID09PSAtMSAmJiBGLmluZGV4T2YoXCIvL1wiKSAhPT0gMCkge1xuICAgICAgICAgICAgbGV0IEsgPSBlLnByb3RvY29sICsgXCIvL1wiICsgZS5ob3N0O1xuICAgICAgICAgICAgaWYgKEYuaW5kZXhPZihcIi9cIikgPT09IDApXG4gICAgICAgICAgICAgIEsgKz0gRjtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBJID0gZS5wYXRobmFtZS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICAgIEkucG9wKCk7XG4gICAgICAgICAgICAgIGNvbnN0IEQgPSBJLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICBLICs9IEQgKyBcIi9cIiArIEY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4LnB1c2goSyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChGLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgSyA9IGUucHJvdG9jb2wgKyBGO1xuICAgICAgICAgICAgeC5wdXNoKEspO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgeC5wdXNoKEYpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfVxuICBmdW5jdGlvbiBzKC4uLmIpIHtcbiAgICBjb25zdCB4ID0gaS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm1ldGFcIik7XG4gICAgZm9yIChsZXQgTyA9IDA7IE8gPCB4Lmxlbmd0aDsgTysrKSB7XG4gICAgICBjb25zdCBfID0geFtPXSwgQyA9IFtcIml0ZW1wcm9wXCIsIFwicHJvcGVydHlcIiwgXCJuYW1lXCJdLm1hcCgoRikgPT4gXy5nZXRBdHRyaWJ1dGUoRikpLmZpbHRlcigoRikgPT4gRiA/IGIuaW5jbHVkZXMoRikgOiAhMSk7XG4gICAgICBpZiAoQy5sZW5ndGggJiYgQykge1xuICAgICAgICBjb25zdCBGID0gXy5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpO1xuICAgICAgICBpZiAoRilcbiAgICAgICAgICByZXR1cm4gRjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gcigpIHtcbiAgICBsZXQgYiA9IHMoXCJuYW1lXCIsIFwib2c6c2l0ZV9uYW1lXCIsIFwib2c6dGl0bGVcIiwgXCJ0d2l0dGVyOnRpdGxlXCIpO1xuICAgIHJldHVybiBiIHx8IChiID0gaS50aXRsZSksIGI7XG4gIH1cbiAgZnVuY3Rpb24gbigpIHtcbiAgICByZXR1cm4gcyhcImRlc2NyaXB0aW9uXCIsIFwib2c6ZGVzY3JpcHRpb25cIiwgXCJ0d2l0dGVyOmRlc2NyaXB0aW9uXCIsIFwia2V5d29yZHNcIik7XG4gIH1cbiAgY29uc3QgbyA9IHIoKSwgYyA9IG4oKSwgdSA9IGUub3JpZ2luLCBkID0gdCgpO1xuICByZXR1cm4ge1xuICAgIGRlc2NyaXB0aW9uOiBjLFxuICAgIHVybDogdSxcbiAgICBpY29uczogZCxcbiAgICBuYW1lOiBvXG4gIH07XG59XG5mbiA9IGRuLmdldFdpbmRvd01ldGFkYXRhID0gR2Y7XG52YXIgaWkgPSB7fSwgV2YgPSAoaSkgPT4gZW5jb2RlVVJJQ29tcG9uZW50KGkpLnJlcGxhY2UoL1shJygpKl0vZywgKGUpID0+IGAlJHtlLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9YCksIENjID0gXCIlW2EtZjAtOV17Mn1cIiwgT28gPSBuZXcgUmVnRXhwKFwiKFwiICsgQ2MgKyBcIil8KFteJV0rPylcIiwgXCJnaVwiKSwgTm8gPSBuZXcgUmVnRXhwKFwiKFwiICsgQ2MgKyBcIikrXCIsIFwiZ2lcIik7XG5mdW5jdGlvbiBWcihpLCBlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFtkZWNvZGVVUklDb21wb25lbnQoaS5qb2luKFwiXCIpKV07XG4gIH0gY2F0Y2gge1xuICB9XG4gIGlmIChpLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gaTtcbiAgZSA9IGUgfHwgMTtcbiAgdmFyIHQgPSBpLnNsaWNlKDAsIGUpLCBzID0gaS5zbGljZShlKTtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChbXSwgVnIodCksIFZyKHMpKTtcbn1cbmZ1bmN0aW9uIFlmKGkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGkpO1xuICB9IGNhdGNoIHtcbiAgICBmb3IgKHZhciBlID0gaS5tYXRjaChPbykgfHwgW10sIHQgPSAxOyB0IDwgZS5sZW5ndGg7IHQrKylcbiAgICAgIGkgPSBWcihlLCB0KS5qb2luKFwiXCIpLCBlID0gaS5tYXRjaChPbykgfHwgW107XG4gICAgcmV0dXJuIGk7XG4gIH1cbn1cbmZ1bmN0aW9uIEpmKGkpIHtcbiAgZm9yICh2YXIgZSA9IHtcbiAgICBcIiVGRSVGRlwiOiBcIu+/ve+/vVwiLFxuICAgIFwiJUZGJUZFXCI6IFwi77+977+9XCJcbiAgfSwgdCA9IE5vLmV4ZWMoaSk7IHQ7ICkge1xuICAgIHRyeSB7XG4gICAgICBlW3RbMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KHRbMF0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdmFyIHMgPSBZZih0WzBdKTtcbiAgICAgIHMgIT09IHRbMF0gJiYgKGVbdFswXV0gPSBzKTtcbiAgICB9XG4gICAgdCA9IE5vLmV4ZWMoaSk7XG4gIH1cbiAgZVtcIiVDMlwiXSA9IFwi77+9XCI7XG4gIGZvciAodmFyIHIgPSBPYmplY3Qua2V5cyhlKSwgbiA9IDA7IG4gPCByLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIG8gPSByW25dO1xuICAgIGkgPSBpLnJlcGxhY2UobmV3IFJlZ0V4cChvLCBcImdcIiksIGVbb10pO1xuICB9XG4gIHJldHVybiBpO1xufVxudmFyIFFmID0gZnVuY3Rpb24oaSkge1xuICBpZiAodHlwZW9mIGkgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYGVuY29kZWRVUklgIHRvIGJlIG9mIHR5cGUgYHN0cmluZ2AsIGdvdCBgXCIgKyB0eXBlb2YgaSArIFwiYFwiKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaSA9IGkucmVwbGFjZSgvXFwrL2csIFwiIFwiKSwgZGVjb2RlVVJJQ29tcG9uZW50KGkpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gSmYoaSk7XG4gIH1cbn0sIFhmID0gKGksIGUpID0+IHtcbiAgaWYgKCEodHlwZW9mIGkgPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgdGhlIGFyZ3VtZW50cyB0byBiZSBvZiB0eXBlIGBzdHJpbmdgXCIpO1xuICBpZiAoZSA9PT0gXCJcIilcbiAgICByZXR1cm4gW2ldO1xuICBjb25zdCB0ID0gaS5pbmRleE9mKGUpO1xuICByZXR1cm4gdCA9PT0gLTEgPyBbaV0gOiBbXG4gICAgaS5zbGljZSgwLCB0KSxcbiAgICBpLnNsaWNlKHQgKyBlLmxlbmd0aClcbiAgXTtcbn0sIFpmID0gZnVuY3Rpb24oaSwgZSkge1xuICBmb3IgKHZhciB0ID0ge30sIHMgPSBPYmplY3Qua2V5cyhpKSwgciA9IEFycmF5LmlzQXJyYXkoZSksIG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKykge1xuICAgIHZhciBvID0gc1tuXSwgYyA9IGlbb107XG4gICAgKHIgPyBlLmluZGV4T2YobykgIT09IC0xIDogZShvLCBjLCBpKSkgJiYgKHRbb10gPSBjKTtcbiAgfVxuICByZXR1cm4gdDtcbn07XG4oZnVuY3Rpb24oaSkge1xuICBjb25zdCBlID0gV2YsIHQgPSBRZiwgcyA9IFhmLCByID0gWmYsIG4gPSAoSSkgPT4gSSA9PSBudWxsLCBvID0gU3ltYm9sKFwiZW5jb2RlRnJhZ21lbnRJZGVudGlmaWVyXCIpO1xuICBmdW5jdGlvbiBjKEkpIHtcbiAgICBzd2l0Y2ggKEkuYXJyYXlGb3JtYXQpIHtcbiAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICByZXR1cm4gKEQpID0+ICh5LCB3KSA9PiB7XG4gICAgICAgICAgY29uc3QgZiA9IHkubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB3ID09PSB2b2lkIDAgfHwgSS5za2lwTnVsbCAmJiB3ID09PSBudWxsIHx8IEkuc2tpcEVtcHR5U3RyaW5nICYmIHcgPT09IFwiXCIgPyB5IDogdyA9PT0gbnVsbCA/IFsuLi55LCBbcChELCBJKSwgXCJbXCIsIGYsIFwiXVwiXS5qb2luKFwiXCIpXSA6IFtcbiAgICAgICAgICAgIC4uLnksXG4gICAgICAgICAgICBbcChELCBJKSwgXCJbXCIsIHAoZiwgSSksIFwiXT1cIiwgcCh3LCBJKV0uam9pbihcIlwiKVxuICAgICAgICAgIF07XG4gICAgICAgIH07XG4gICAgICBjYXNlIFwiYnJhY2tldFwiOlxuICAgICAgICByZXR1cm4gKEQpID0+ICh5LCB3KSA9PiB3ID09PSB2b2lkIDAgfHwgSS5za2lwTnVsbCAmJiB3ID09PSBudWxsIHx8IEkuc2tpcEVtcHR5U3RyaW5nICYmIHcgPT09IFwiXCIgPyB5IDogdyA9PT0gbnVsbCA/IFsuLi55LCBbcChELCBJKSwgXCJbXVwiXS5qb2luKFwiXCIpXSA6IFsuLi55LCBbcChELCBJKSwgXCJbXT1cIiwgcCh3LCBJKV0uam9pbihcIlwiKV07XG4gICAgICBjYXNlIFwiY29sb24tbGlzdC1zZXBhcmF0b3JcIjpcbiAgICAgICAgcmV0dXJuIChEKSA9PiAoeSwgdykgPT4gdyA9PT0gdm9pZCAwIHx8IEkuc2tpcE51bGwgJiYgdyA9PT0gbnVsbCB8fCBJLnNraXBFbXB0eVN0cmluZyAmJiB3ID09PSBcIlwiID8geSA6IHcgPT09IG51bGwgPyBbLi4ueSwgW3AoRCwgSSksIFwiOmxpc3Q9XCJdLmpvaW4oXCJcIildIDogWy4uLnksIFtwKEQsIEkpLCBcIjpsaXN0PVwiLCBwKHcsIEkpXS5qb2luKFwiXCIpXTtcbiAgICAgIGNhc2UgXCJjb21tYVwiOlxuICAgICAgY2FzZSBcInNlcGFyYXRvclwiOlxuICAgICAgY2FzZSBcImJyYWNrZXQtc2VwYXJhdG9yXCI6IHtcbiAgICAgICAgY29uc3QgRCA9IEkuYXJyYXlGb3JtYXQgPT09IFwiYnJhY2tldC1zZXBhcmF0b3JcIiA/IFwiW109XCIgOiBcIj1cIjtcbiAgICAgICAgcmV0dXJuICh5KSA9PiAodywgZikgPT4gZiA9PT0gdm9pZCAwIHx8IEkuc2tpcE51bGwgJiYgZiA9PT0gbnVsbCB8fCBJLnNraXBFbXB0eVN0cmluZyAmJiBmID09PSBcIlwiID8gdyA6IChmID0gZiA9PT0gbnVsbCA/IFwiXCIgOiBmLCB3Lmxlbmd0aCA9PT0gMCA/IFtbcCh5LCBJKSwgRCwgcChmLCBJKV0uam9pbihcIlwiKV0gOiBbW3csIHAoZiwgSSldLmpvaW4oSS5hcnJheUZvcm1hdFNlcGFyYXRvcildKTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoRCkgPT4gKHksIHcpID0+IHcgPT09IHZvaWQgMCB8fCBJLnNraXBOdWxsICYmIHcgPT09IG51bGwgfHwgSS5za2lwRW1wdHlTdHJpbmcgJiYgdyA9PT0gXCJcIiA/IHkgOiB3ID09PSBudWxsID8gWy4uLnksIHAoRCwgSSldIDogWy4uLnksIFtwKEQsIEkpLCBcIj1cIiwgcCh3LCBJKV0uam9pbihcIlwiKV07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHUoSSkge1xuICAgIGxldCBEO1xuICAgIHN3aXRjaCAoSS5hcnJheUZvcm1hdCkge1xuICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgIHJldHVybiAoeSwgdywgZikgPT4ge1xuICAgICAgICAgIGlmIChEID0gL1xcWyhcXGQqKVxcXSQvLmV4ZWMoeSksIHkgPSB5LnJlcGxhY2UoL1xcW1xcZCpcXF0kLywgXCJcIiksICFEKSB7XG4gICAgICAgICAgICBmW3ldID0gdztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZlt5XSA9PT0gdm9pZCAwICYmIChmW3ldID0ge30pLCBmW3ldW0RbMV1dID0gdztcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJicmFja2V0XCI6XG4gICAgICAgIHJldHVybiAoeSwgdywgZikgPT4ge1xuICAgICAgICAgIGlmIChEID0gLyhcXFtcXF0pJC8uZXhlYyh5KSwgeSA9IHkucmVwbGFjZSgvXFxbXFxdJC8sIFwiXCIpLCAhRCkge1xuICAgICAgICAgICAgZlt5XSA9IHc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmW3ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZbeV0gPSBbd107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZbeV0gPSBbXS5jb25jYXQoZlt5XSwgdyk7XG4gICAgICAgIH07XG4gICAgICBjYXNlIFwiY29sb24tbGlzdC1zZXBhcmF0b3JcIjpcbiAgICAgICAgcmV0dXJuICh5LCB3LCBmKSA9PiB7XG4gICAgICAgICAgaWYgKEQgPSAvKDpsaXN0KSQvLmV4ZWMoeSksIHkgPSB5LnJlcGxhY2UoLzpsaXN0JC8sIFwiXCIpLCAhRCkge1xuICAgICAgICAgICAgZlt5XSA9IHc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmW3ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZbeV0gPSBbd107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZbeV0gPSBbXS5jb25jYXQoZlt5XSwgdyk7XG4gICAgICAgIH07XG4gICAgICBjYXNlIFwiY29tbWFcIjpcbiAgICAgIGNhc2UgXCJzZXBhcmF0b3JcIjpcbiAgICAgICAgcmV0dXJuICh5LCB3LCBmKSA9PiB7XG4gICAgICAgICAgY29uc3QgYSA9IHR5cGVvZiB3ID09IFwic3RyaW5nXCIgJiYgdy5pbmNsdWRlcyhJLmFycmF5Rm9ybWF0U2VwYXJhdG9yKSwgbCA9IHR5cGVvZiB3ID09IFwic3RyaW5nXCIgJiYgIWEgJiYgYih3LCBJKS5pbmNsdWRlcyhJLmFycmF5Rm9ybWF0U2VwYXJhdG9yKTtcbiAgICAgICAgICB3ID0gbCA/IGIodywgSSkgOiB3O1xuICAgICAgICAgIGNvbnN0IEwgPSBhIHx8IGwgPyB3LnNwbGl0KEkuYXJyYXlGb3JtYXRTZXBhcmF0b3IpLm1hcCgodikgPT4gYih2LCBJKSkgOiB3ID09PSBudWxsID8gdyA6IGIodywgSSk7XG4gICAgICAgICAgZlt5XSA9IEw7XG4gICAgICAgIH07XG4gICAgICBjYXNlIFwiYnJhY2tldC1zZXBhcmF0b3JcIjpcbiAgICAgICAgcmV0dXJuICh5LCB3LCBmKSA9PiB7XG4gICAgICAgICAgY29uc3QgYSA9IC8oXFxbXFxdKSQvLnRlc3QoeSk7XG4gICAgICAgICAgaWYgKHkgPSB5LnJlcGxhY2UoL1xcW1xcXSQvLCBcIlwiKSwgIWEpIHtcbiAgICAgICAgICAgIGZbeV0gPSB3ICYmIGIodywgSSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGwgPSB3ID09PSBudWxsID8gW10gOiB3LnNwbGl0KEkuYXJyYXlGb3JtYXRTZXBhcmF0b3IpLm1hcCgoTCkgPT4gYihMLCBJKSk7XG4gICAgICAgICAgaWYgKGZbeV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZlt5XSA9IGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZbeV0gPSBbXS5jb25jYXQoZlt5XSwgbCk7XG4gICAgICAgIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKHksIHcsIGYpID0+IHtcbiAgICAgICAgICBpZiAoZlt5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmW3ldID0gdztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZlt5XSA9IFtdLmNvbmNhdChmW3ldLCB3KTtcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZChJKSB7XG4gICAgaWYgKHR5cGVvZiBJICE9IFwic3RyaW5nXCIgfHwgSS5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJyYXlGb3JtYXRTZXBhcmF0b3IgbXVzdCBiZSBzaW5nbGUgY2hhcmFjdGVyIHN0cmluZ1wiKTtcbiAgfVxuICBmdW5jdGlvbiBwKEksIEQpIHtcbiAgICByZXR1cm4gRC5lbmNvZGUgPyBELnN0cmljdCA/IGUoSSkgOiBlbmNvZGVVUklDb21wb25lbnQoSSkgOiBJO1xuICB9XG4gIGZ1bmN0aW9uIGIoSSwgRCkge1xuICAgIHJldHVybiBELmRlY29kZSA/IHQoSSkgOiBJO1xuICB9XG4gIGZ1bmN0aW9uIHgoSSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KEkpID8gSS5zb3J0KCkgOiB0eXBlb2YgSSA9PSBcIm9iamVjdFwiID8geChPYmplY3Qua2V5cyhJKSkuc29ydCgoRCwgeSkgPT4gTnVtYmVyKEQpIC0gTnVtYmVyKHkpKS5tYXAoKEQpID0+IElbRF0pIDogSTtcbiAgfVxuICBmdW5jdGlvbiBPKEkpIHtcbiAgICBjb25zdCBEID0gSS5pbmRleE9mKFwiI1wiKTtcbiAgICByZXR1cm4gRCAhPT0gLTEgJiYgKEkgPSBJLnNsaWNlKDAsIEQpKSwgSTtcbiAgfVxuICBmdW5jdGlvbiBfKEkpIHtcbiAgICBsZXQgRCA9IFwiXCI7XG4gICAgY29uc3QgeSA9IEkuaW5kZXhPZihcIiNcIik7XG4gICAgcmV0dXJuIHkgIT09IC0xICYmIChEID0gSS5zbGljZSh5KSksIEQ7XG4gIH1cbiAgZnVuY3Rpb24gQyhJKSB7XG4gICAgSSA9IE8oSSk7XG4gICAgY29uc3QgRCA9IEkuaW5kZXhPZihcIj9cIik7XG4gICAgcmV0dXJuIEQgPT09IC0xID8gXCJcIiA6IEkuc2xpY2UoRCArIDEpO1xuICB9XG4gIGZ1bmN0aW9uIEYoSSwgRCkge1xuICAgIHJldHVybiBELnBhcnNlTnVtYmVycyAmJiAhTnVtYmVyLmlzTmFOKE51bWJlcihJKSkgJiYgdHlwZW9mIEkgPT0gXCJzdHJpbmdcIiAmJiBJLnRyaW0oKSAhPT0gXCJcIiA/IEkgPSBOdW1iZXIoSSkgOiBELnBhcnNlQm9vbGVhbnMgJiYgSSAhPT0gbnVsbCAmJiAoSS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIiB8fCBJLnRvTG93ZXJDYXNlKCkgPT09IFwiZmFsc2VcIikgJiYgKEkgPSBJLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiKSwgSTtcbiAgfVxuICBmdW5jdGlvbiBLKEksIEQpIHtcbiAgICBEID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBkZWNvZGU6ICEwLFxuICAgICAgc29ydDogITAsXG4gICAgICBhcnJheUZvcm1hdDogXCJub25lXCIsXG4gICAgICBhcnJheUZvcm1hdFNlcGFyYXRvcjogXCIsXCIsXG4gICAgICBwYXJzZU51bWJlcnM6ICExLFxuICAgICAgcGFyc2VCb29sZWFuczogITFcbiAgICB9LCBEKSwgZChELmFycmF5Rm9ybWF0U2VwYXJhdG9yKTtcbiAgICBjb25zdCB5ID0gdShEKSwgdyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmICh0eXBlb2YgSSAhPSBcInN0cmluZ1wiIHx8IChJID0gSS50cmltKCkucmVwbGFjZSgvXls/IyZdLywgXCJcIiksICFJKSlcbiAgICAgIHJldHVybiB3O1xuICAgIGZvciAoY29uc3QgZiBvZiBJLnNwbGl0KFwiJlwiKSkge1xuICAgICAgaWYgKGYgPT09IFwiXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbGV0IFthLCBsXSA9IHMoRC5kZWNvZGUgPyBmLnJlcGxhY2UoL1xcKy9nLCBcIiBcIikgOiBmLCBcIj1cIik7XG4gICAgICBsID0gbCA9PT0gdm9pZCAwID8gbnVsbCA6IFtcImNvbW1hXCIsIFwic2VwYXJhdG9yXCIsIFwiYnJhY2tldC1zZXBhcmF0b3JcIl0uaW5jbHVkZXMoRC5hcnJheUZvcm1hdCkgPyBsIDogYihsLCBEKSwgeShiKGEsIEQpLCBsLCB3KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmIG9mIE9iamVjdC5rZXlzKHcpKSB7XG4gICAgICBjb25zdCBhID0gd1tmXTtcbiAgICAgIGlmICh0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGwpXG4gICAgICAgIGZvciAoY29uc3QgbCBvZiBPYmplY3Qua2V5cyhhKSlcbiAgICAgICAgICBhW2xdID0gRihhW2xdLCBEKTtcbiAgICAgIGVsc2VcbiAgICAgICAgd1tmXSA9IEYoYSwgRCk7XG4gICAgfVxuICAgIHJldHVybiBELnNvcnQgPT09ICExID8gdyA6IChELnNvcnQgPT09ICEwID8gT2JqZWN0LmtleXModykuc29ydCgpIDogT2JqZWN0LmtleXModykuc29ydChELnNvcnQpKS5yZWR1Y2UoKGYsIGEpID0+IHtcbiAgICAgIGNvbnN0IGwgPSB3W2FdO1xuICAgICAgcmV0dXJuIGwgJiYgdHlwZW9mIGwgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShsKSA/IGZbYV0gPSB4KGwpIDogZlthXSA9IGwsIGY7XG4gICAgfSwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIGkuZXh0cmFjdCA9IEMsIGkucGFyc2UgPSBLLCBpLnN0cmluZ2lmeSA9IChJLCBEKSA9PiB7XG4gICAgaWYgKCFJKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgRCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZW5jb2RlOiAhMCxcbiAgICAgIHN0cmljdDogITAsXG4gICAgICBhcnJheUZvcm1hdDogXCJub25lXCIsXG4gICAgICBhcnJheUZvcm1hdFNlcGFyYXRvcjogXCIsXCJcbiAgICB9LCBEKSwgZChELmFycmF5Rm9ybWF0U2VwYXJhdG9yKTtcbiAgICBjb25zdCB5ID0gKGwpID0+IEQuc2tpcE51bGwgJiYgbihJW2xdKSB8fCBELnNraXBFbXB0eVN0cmluZyAmJiBJW2xdID09PSBcIlwiLCB3ID0gYyhEKSwgZiA9IHt9O1xuICAgIGZvciAoY29uc3QgbCBvZiBPYmplY3Qua2V5cyhJKSlcbiAgICAgIHkobCkgfHwgKGZbbF0gPSBJW2xdKTtcbiAgICBjb25zdCBhID0gT2JqZWN0LmtleXMoZik7XG4gICAgcmV0dXJuIEQuc29ydCAhPT0gITEgJiYgYS5zb3J0KEQuc29ydCksIGEubWFwKChsKSA9PiB7XG4gICAgICBjb25zdCBMID0gSVtsXTtcbiAgICAgIHJldHVybiBMID09PSB2b2lkIDAgPyBcIlwiIDogTCA9PT0gbnVsbCA/IHAobCwgRCkgOiBBcnJheS5pc0FycmF5KEwpID8gTC5sZW5ndGggPT09IDAgJiYgRC5hcnJheUZvcm1hdCA9PT0gXCJicmFja2V0LXNlcGFyYXRvclwiID8gcChsLCBEKSArIFwiW11cIiA6IEwucmVkdWNlKHcobCksIFtdKS5qb2luKFwiJlwiKSA6IHAobCwgRCkgKyBcIj1cIiArIHAoTCwgRCk7XG4gICAgfSkuZmlsdGVyKChsKSA9PiBsLmxlbmd0aCA+IDApLmpvaW4oXCImXCIpO1xuICB9LCBpLnBhcnNlVXJsID0gKEksIEQpID0+IHtcbiAgICBEID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBkZWNvZGU6ICEwXG4gICAgfSwgRCk7XG4gICAgY29uc3QgW3ksIHddID0gcyhJLCBcIiNcIik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIHVybDogeS5zcGxpdChcIj9cIilbMF0gfHwgXCJcIixcbiAgICAgICAgcXVlcnk6IEsoQyhJKSwgRClcbiAgICAgIH0sXG4gICAgICBEICYmIEQucGFyc2VGcmFnbWVudElkZW50aWZpZXIgJiYgdyA/IHsgZnJhZ21lbnRJZGVudGlmaWVyOiBiKHcsIEQpIH0gOiB7fVxuICAgICk7XG4gIH0sIGkuc3RyaW5naWZ5VXJsID0gKEksIEQpID0+IHtcbiAgICBEID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBlbmNvZGU6ICEwLFxuICAgICAgc3RyaWN0OiAhMCxcbiAgICAgIFtvXTogITBcbiAgICB9LCBEKTtcbiAgICBjb25zdCB5ID0gTyhJLnVybCkuc3BsaXQoXCI/XCIpWzBdIHx8IFwiXCIsIHcgPSBpLmV4dHJhY3QoSS51cmwpLCBmID0gaS5wYXJzZSh3LCB7IHNvcnQ6ICExIH0pLCBhID0gT2JqZWN0LmFzc2lnbihmLCBJLnF1ZXJ5KTtcbiAgICBsZXQgbCA9IGkuc3RyaW5naWZ5KGEsIEQpO1xuICAgIGwgJiYgKGwgPSBgPyR7bH1gKTtcbiAgICBsZXQgTCA9IF8oSS51cmwpO1xuICAgIHJldHVybiBJLmZyYWdtZW50SWRlbnRpZmllciAmJiAoTCA9IGAjJHtEW29dID8gcChJLmZyYWdtZW50SWRlbnRpZmllciwgRCkgOiBJLmZyYWdtZW50SWRlbnRpZmllcn1gKSwgYCR7eX0ke2x9JHtMfWA7XG4gIH0sIGkucGljayA9IChJLCBELCB5KSA9PiB7XG4gICAgeSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgcGFyc2VGcmFnbWVudElkZW50aWZpZXI6ICEwLFxuICAgICAgW29dOiAhMVxuICAgIH0sIHkpO1xuICAgIGNvbnN0IHsgdXJsOiB3LCBxdWVyeTogZiwgZnJhZ21lbnRJZGVudGlmaWVyOiBhIH0gPSBpLnBhcnNlVXJsKEksIHkpO1xuICAgIHJldHVybiBpLnN0cmluZ2lmeVVybCh7XG4gICAgICB1cmw6IHcsXG4gICAgICBxdWVyeTogcihmLCBEKSxcbiAgICAgIGZyYWdtZW50SWRlbnRpZmllcjogYVxuICAgIH0sIHkpO1xuICB9LCBpLmV4Y2x1ZGUgPSAoSSwgRCwgeSkgPT4ge1xuICAgIGNvbnN0IHcgPSBBcnJheS5pc0FycmF5KEQpID8gKGYpID0+ICFELmluY2x1ZGVzKGYpIDogKGYsIGEpID0+ICFEKGYsIGEpO1xuICAgIHJldHVybiBpLnBpY2soSSwgdywgeSk7XG4gIH07XG59KShpaSk7XG5jb25zdCBBYyA9IHtcbiAgd2FrdToge1xuICAgIHB1Ymxpc2g6IFwid2FrdV9wdWJsaXNoXCIsXG4gICAgYmF0Y2hQdWJsaXNoOiBcIndha3VfYmF0Y2hQdWJsaXNoXCIsXG4gICAgc3Vic2NyaWJlOiBcIndha3Vfc3Vic2NyaWJlXCIsXG4gICAgYmF0Y2hTdWJzY3JpYmU6IFwid2FrdV9iYXRjaFN1YnNjcmliZVwiLFxuICAgIHN1YnNjcmlwdGlvbjogXCJ3YWt1X3N1YnNjcmlwdGlvblwiLFxuICAgIHVuc3Vic2NyaWJlOiBcIndha3VfdW5zdWJzY3JpYmVcIixcbiAgICBiYXRjaFVuc3Vic2NyaWJlOiBcIndha3VfYmF0Y2hVbnN1YnNjcmliZVwiXG4gIH0sXG4gIGlybjoge1xuICAgIHB1Ymxpc2g6IFwiaXJuX3B1Ymxpc2hcIixcbiAgICBiYXRjaFB1Ymxpc2g6IFwiaXJuX2JhdGNoUHVibGlzaFwiLFxuICAgIHN1YnNjcmliZTogXCJpcm5fc3Vic2NyaWJlXCIsXG4gICAgYmF0Y2hTdWJzY3JpYmU6IFwiaXJuX2JhdGNoU3Vic2NyaWJlXCIsXG4gICAgc3Vic2NyaXB0aW9uOiBcImlybl9zdWJzY3JpcHRpb25cIixcbiAgICB1bnN1YnNjcmliZTogXCJpcm5fdW5zdWJzY3JpYmVcIixcbiAgICBiYXRjaFVuc3Vic2NyaWJlOiBcImlybl9iYXRjaFVuc3Vic2NyaWJlXCJcbiAgfSxcbiAgaXJpZGl1bToge1xuICAgIHB1Ymxpc2g6IFwiaXJpZGl1bV9wdWJsaXNoXCIsXG4gICAgYmF0Y2hQdWJsaXNoOiBcImlyaWRpdW1fYmF0Y2hQdWJsaXNoXCIsXG4gICAgc3Vic2NyaWJlOiBcImlyaWRpdW1fc3Vic2NyaWJlXCIsXG4gICAgYmF0Y2hTdWJzY3JpYmU6IFwiaXJpZGl1bV9iYXRjaFN1YnNjcmliZVwiLFxuICAgIHN1YnNjcmlwdGlvbjogXCJpcmlkaXVtX3N1YnNjcmlwdGlvblwiLFxuICAgIHVuc3Vic2NyaWJlOiBcImlyaWRpdW1fdW5zdWJzY3JpYmVcIixcbiAgICBiYXRjaFVuc3Vic2NyaWJlOiBcImlyaWRpdW1fYmF0Y2hVbnN1YnNjcmliZVwiXG4gIH1cbn07XG5mdW5jdGlvbiBUYyhpLCBlKSB7XG4gIHJldHVybiBpLmluY2x1ZGVzKFwiOlwiKSA/IFtpXSA6IGUuY2hhaW5zIHx8IFtdO1xufVxuY29uc3QgJGMgPSBcImJhc2UxMFwiLCB2dCA9IFwiYmFzZTE2XCIsIEJyID0gXCJiYXNlNjRwYWRcIiwgcG4gPSBcInV0ZjhcIiwgRmMgPSAwLCBEaSA9IDEsIGVwID0gMCwgUG8gPSAxLCBrciA9IDEyLCBnbiA9IDMyO1xuZnVuY3Rpb24gdHAoKSB7XG4gIGNvbnN0IGkgPSBtcy5nZW5lcmF0ZUtleVBhaXIoKTtcbiAgcmV0dXJuIHsgcHJpdmF0ZUtleTogTmUoaS5zZWNyZXRLZXksIHZ0KSwgcHVibGljS2V5OiBOZShpLnB1YmxpY0tleSwgdnQpIH07XG59XG5mdW5jdGlvbiBIcigpIHtcbiAgY29uc3QgaSA9IGxpLnJhbmRvbUJ5dGVzKGduKTtcbiAgcmV0dXJuIE5lKGksIHZ0KTtcbn1cbmZ1bmN0aW9uIGlwKGksIGUpIHtcbiAgY29uc3QgdCA9IG1zLnNoYXJlZEtleShDZShpLCB2dCksIENlKGUsIHZ0KSwgITApLCBzID0gbmV3IFJjKFNpLlNIQTI1NiwgdCkuZXhwYW5kKGduKTtcbiAgcmV0dXJuIE5lKHMsIHZ0KTtcbn1cbmZ1bmN0aW9uIHNwKGkpIHtcbiAgY29uc3QgZSA9IFNpLmhhc2goQ2UoaSwgdnQpKTtcbiAgcmV0dXJuIE5lKGUsIHZ0KTtcbn1cbmZ1bmN0aW9uIEZpKGkpIHtcbiAgY29uc3QgZSA9IFNpLmhhc2goQ2UoaSwgcG4pKTtcbiAgcmV0dXJuIE5lKGUsIHZ0KTtcbn1cbmZ1bmN0aW9uIHJwKGkpIHtcbiAgcmV0dXJuIENlKGAke2l9YCwgJGMpO1xufVxuZnVuY3Rpb24gd3MoaSkge1xuICByZXR1cm4gTnVtYmVyKE5lKGksICRjKSk7XG59XG5mdW5jdGlvbiBucChpKSB7XG4gIGNvbnN0IGUgPSBycCh0eXBlb2YgaS50eXBlIDwgXCJ1XCIgPyBpLnR5cGUgOiBGYyk7XG4gIGlmICh3cyhlKSA9PT0gRGkgJiYgdHlwZW9mIGkuc2VuZGVyUHVibGljS2V5ID4gXCJ1XCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzZW5kZXIgcHVibGljIGtleSBmb3IgdHlwZSAxIGVudmVsb3BlXCIpO1xuICBjb25zdCB0ID0gdHlwZW9mIGkuc2VuZGVyUHVibGljS2V5IDwgXCJ1XCIgPyBDZShpLnNlbmRlclB1YmxpY0tleSwgdnQpIDogdm9pZCAwLCBzID0gdHlwZW9mIGkuaXYgPCBcInVcIiA/IENlKGkuaXYsIHZ0KSA6IGxpLnJhbmRvbUJ5dGVzKGtyKSwgciA9IG5ldyBncy5DaGFDaGEyMFBvbHkxMzA1KENlKGkuc3ltS2V5LCB2dCkpLnNlYWwocywgQ2UoaS5tZXNzYWdlLCBwbikpO1xuICByZXR1cm4gYXAoeyB0eXBlOiBlLCBzZWFsZWQ6IHIsIGl2OiBzLCBzZW5kZXJQdWJsaWNLZXk6IHQgfSk7XG59XG5mdW5jdGlvbiBvcChpKSB7XG4gIGNvbnN0IGUgPSBuZXcgZ3MuQ2hhQ2hhMjBQb2x5MTMwNShDZShpLnN5bUtleSwgdnQpKSwgeyBzZWFsZWQ6IHQsIGl2OiBzIH0gPSBZcyhpLmVuY29kZWQpLCByID0gZS5vcGVuKHMsIHQpO1xuICBpZiAociA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjcnlwdFwiKTtcbiAgcmV0dXJuIE5lKHIsIHBuKTtcbn1cbmZ1bmN0aW9uIGFwKGkpIHtcbiAgaWYgKHdzKGkudHlwZSkgPT09IERpKSB7XG4gICAgaWYgKHR5cGVvZiBpLnNlbmRlclB1YmxpY0tleSA+IFwidVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzZW5kZXIgcHVibGljIGtleSBmb3IgdHlwZSAxIGVudmVsb3BlXCIpO1xuICAgIHJldHVybiBOZShscyhbaS50eXBlLCBpLnNlbmRlclB1YmxpY0tleSwgaS5pdiwgaS5zZWFsZWRdKSwgQnIpO1xuICB9XG4gIHJldHVybiBOZShscyhbaS50eXBlLCBpLml2LCBpLnNlYWxlZF0pLCBCcik7XG59XG5mdW5jdGlvbiBZcyhpKSB7XG4gIGNvbnN0IGUgPSBDZShpLCBCciksIHQgPSBlLnNsaWNlKGVwLCBQbyksIHMgPSBQbztcbiAgaWYgKHdzKHQpID09PSBEaSkge1xuICAgIGNvbnN0IGMgPSBzICsgZ24sIHUgPSBjICsga3IsIGQgPSBlLnNsaWNlKHMsIGMpLCBwID0gZS5zbGljZShjLCB1KSwgYiA9IGUuc2xpY2UodSk7XG4gICAgcmV0dXJuIHsgdHlwZTogdCwgc2VhbGVkOiBiLCBpdjogcCwgc2VuZGVyUHVibGljS2V5OiBkIH07XG4gIH1cbiAgY29uc3QgciA9IHMgKyBrciwgbiA9IGUuc2xpY2UocywgciksIG8gPSBlLnNsaWNlKHIpO1xuICByZXR1cm4geyB0eXBlOiB0LCBzZWFsZWQ6IG8sIGl2OiBuIH07XG59XG5mdW5jdGlvbiBjcChpLCBlKSB7XG4gIGNvbnN0IHQgPSBZcyhpKTtcbiAgcmV0dXJuIFVjKHsgdHlwZTogd3ModC50eXBlKSwgc2VuZGVyUHVibGljS2V5OiB0eXBlb2YgdC5zZW5kZXJQdWJsaWNLZXkgPCBcInVcIiA/IE5lKHQuc2VuZGVyUHVibGljS2V5LCB2dCkgOiB2b2lkIDAsIHJlY2VpdmVyUHVibGljS2V5OiBlPy5yZWNlaXZlclB1YmxpY0tleSB9KTtcbn1cbmZ1bmN0aW9uIFVjKGkpIHtcbiAgY29uc3QgZSA9IGk/LnR5cGUgfHwgRmM7XG4gIGlmIChlID09PSBEaSkge1xuICAgIGlmICh0eXBlb2YgaT8uc2VuZGVyUHVibGljS2V5ID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNlbmRlciBwdWJsaWMga2V5XCIpO1xuICAgIGlmICh0eXBlb2YgaT8ucmVjZWl2ZXJQdWJsaWNLZXkgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgcmVjZWl2ZXIgcHVibGljIGtleVwiKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBlLCBzZW5kZXJQdWJsaWNLZXk6IGk/LnNlbmRlclB1YmxpY0tleSwgcmVjZWl2ZXJQdWJsaWNLZXk6IGk/LnJlY2VpdmVyUHVibGljS2V5IH07XG59XG5mdW5jdGlvbiBSbyhpKSB7XG4gIHJldHVybiBpLnR5cGUgPT09IERpICYmIHR5cGVvZiBpLnNlbmRlclB1YmxpY0tleSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpLnJlY2VpdmVyUHVibGljS2V5ID09IFwic3RyaW5nXCI7XG59XG52YXIgaHAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIENvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgdXAgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBscCA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIEFvID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IGhwKGksIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW2VdID0gdCwgVG8gPSAoaSwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgdXAuY2FsbChlLCB0KSAmJiBBbyhpLCB0LCBlW3RdKTtcbiAgaWYgKENvKVxuICAgIGZvciAodmFyIHQgb2YgQ28oZSkpXG4gICAgICBscC5jYWxsKGUsIHQpICYmIEFvKGksIHQsIGVbdF0pO1xuICByZXR1cm4gaTtcbn07XG5jb25zdCBkcCA9IFwiUmVhY3ROYXRpdmVcIiwgT3QgPSB7IHJlYWN0TmF0aXZlOiBcInJlYWN0LW5hdGl2ZVwiLCBub2RlOiBcIm5vZGVcIiwgYnJvd3NlcjogXCJicm93c2VyXCIsIHVua25vd246IFwidW5rbm93blwiIH0sIGZwID0gXCJqc1wiO1xuZnVuY3Rpb24geW4oKSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyA8IFwidVwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zIDwgXCJ1XCIgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA8IFwidVwiO1xufVxuZnVuY3Rpb24gdXIoKSB7XG4gIHJldHVybiAhdW4oKSAmJiAhIWJzKCkgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IGRwO1xufVxuZnVuY3Rpb24gdnMoKSB7XG4gIHJldHVybiAheW4oKSAmJiAhIWJzKCk7XG59XG5mdW5jdGlvbiBfcygpIHtcbiAgcmV0dXJuIHVyKCkgPyBPdC5yZWFjdE5hdGl2ZSA6IHluKCkgPyBPdC5ub2RlIDogdnMoKSA/IE90LmJyb3dzZXIgOiBPdC51bmtub3duO1xufVxuZnVuY3Rpb24gcHAoaSwgZSkge1xuICBsZXQgdCA9IGlpLnBhcnNlKGkpO1xuICByZXR1cm4gdCA9IFRvKFRvKHt9LCB0KSwgZSksIGkgPSBpaS5zdHJpbmdpZnkodCksIGk7XG59XG5mdW5jdGlvbiBncCgpIHtcbiAgcmV0dXJuIGZuKCkgfHwgeyBuYW1lOiBcIlwiLCBkZXNjcmlwdGlvbjogXCJcIiwgdXJsOiBcIlwiLCBpY29uczogW1wiXCJdIH07XG59XG5mdW5jdGlvbiB5cCgpIHtcbiAgaWYgKF9zKCkgPT09IE90LnJlYWN0TmF0aXZlICYmIHR5cGVvZiBnbG9iYWwgPCBcInVcIiAmJiB0eXBlb2YgKGdsb2JhbCA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsLlBsYXRmb3JtKSA8IFwidVwiKSB7XG4gICAgY29uc3QgeyBPUzogdCwgVmVyc2lvbjogcyB9ID0gZ2xvYmFsLlBsYXRmb3JtO1xuICAgIHJldHVybiBbdCwgc10uam9pbihcIi1cIik7XG4gIH1cbiAgY29uc3QgaSA9IGhuKCk7XG4gIGlmIChpID09PSBudWxsKVxuICAgIHJldHVybiBcInVua25vd25cIjtcbiAgY29uc3QgZSA9IGkub3MgPyBpLm9zLnJlcGxhY2UoXCIgXCIsIFwiXCIpLnRvTG93ZXJDYXNlKCkgOiBcInVua25vd25cIjtcbiAgcmV0dXJuIGkudHlwZSA9PT0gXCJicm93c2VyXCIgPyBbZSwgaS5uYW1lLCBpLnZlcnNpb25dLmpvaW4oXCItXCIpIDogW2UsIGkudmVyc2lvbl0uam9pbihcIi1cIik7XG59XG5mdW5jdGlvbiBtcCgpIHtcbiAgdmFyIGk7XG4gIGNvbnN0IGUgPSBfcygpO1xuICByZXR1cm4gZSA9PT0gT3QuYnJvd3NlciA/IFtlLCAoKGkgPSBsbigpKSA9PSBudWxsID8gdm9pZCAwIDogaS5ob3N0KSB8fCBcInVua25vd25cIl0uam9pbihcIjpcIikgOiBlO1xufVxuZnVuY3Rpb24gYnAoaSwgZSwgdCkge1xuICBjb25zdCBzID0geXAoKSwgciA9IG1wKCk7XG4gIHJldHVybiBbW2ksIGVdLmpvaW4oXCItXCIpLCBbZnAsIHRdLmpvaW4oXCItXCIpLCBzLCByXS5qb2luKFwiL1wiKTtcbn1cbmZ1bmN0aW9uIHdwKHsgcHJvdG9jb2w6IGksIHZlcnNpb246IGUsIHJlbGF5VXJsOiB0LCBzZGtWZXJzaW9uOiBzLCBhdXRoOiByLCBwcm9qZWN0SWQ6IG4sIHVzZU9uQ2xvc2VFdmVudDogbyB9KSB7XG4gIGNvbnN0IGMgPSB0LnNwbGl0KFwiP1wiKSwgdSA9IGJwKGksIGUsIHMpLCBkID0geyBhdXRoOiByLCB1YTogdSwgcHJvamVjdElkOiBuLCB1c2VPbkNsb3NlRXZlbnQ6IG8gfHwgdm9pZCAwIH0sIHAgPSBwcChjWzFdIHx8IFwiXCIsIGQpO1xuICByZXR1cm4gY1swXSArIFwiP1wiICsgcDtcbn1cbmZ1bmN0aW9uIF9pKGksIGUpIHtcbiAgcmV0dXJuIGkuZmlsdGVyKCh0KSA9PiBlLmluY2x1ZGVzKHQpKS5sZW5ndGggPT09IGkubGVuZ3RoO1xufVxuZnVuY3Rpb24gTGMoaSkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGkuZW50cmllcygpKTtcbn1cbmZ1bmN0aW9uIE1jKGkpIHtcbiAgcmV0dXJuIG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoaSkpO1xufVxuZnVuY3Rpb24gQWkoaSA9IFYuRklWRV9NSU5VVEVTLCBlKSB7XG4gIGNvbnN0IHQgPSBWLnRvTWlsaXNlY29uZHMoaSB8fCBWLkZJVkVfTUlOVVRFUyk7XG4gIGxldCBzLCByLCBuO1xuICByZXR1cm4geyByZXNvbHZlOiAobykgPT4ge1xuICAgIG4gJiYgcyAmJiAoY2xlYXJUaW1lb3V0KG4pLCBzKG8pKTtcbiAgfSwgcmVqZWN0OiAobykgPT4ge1xuICAgIG4gJiYgciAmJiAoY2xlYXJUaW1lb3V0KG4pLCByKG8pKTtcbiAgfSwgZG9uZTogKCkgPT4gbmV3IFByb21pc2UoKG8sIGMpID0+IHtcbiAgICBuID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjKG5ldyBFcnJvcihlKSk7XG4gICAgfSwgdCksIHMgPSBvLCByID0gYztcbiAgfSkgfTtcbn1cbmZ1bmN0aW9uIGRzKGksIGUsIHQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChzLCByKSA9PiB7XG4gICAgY29uc3QgbiA9IHNldFRpbWVvdXQoKCkgPT4gcihuZXcgRXJyb3IodCkpLCBlKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbyA9IGF3YWl0IGk7XG4gICAgICBzKG8pO1xuICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgIHIobyk7XG4gICAgfVxuICAgIGNsZWFyVGltZW91dChuKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBxYyhpLCBlKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiICYmIGUuc3RhcnRzV2l0aChgJHtpfTpgKSlcbiAgICByZXR1cm4gZTtcbiAgaWYgKGkudG9Mb3dlckNhc2UoKSA9PT0gXCJ0b3BpY1wiKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIG11c3QgYmUgXCJzdHJpbmdcIiBmb3IgZXhwaXJlciB0YXJnZXQgdHlwZTogdG9waWMnKTtcbiAgICByZXR1cm4gYHRvcGljOiR7ZX1gO1xuICB9IGVsc2UgaWYgKGkudG9Mb3dlckNhc2UoKSA9PT0gXCJpZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwibnVtYmVyXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIG11c3QgYmUgXCJudW1iZXJcIiBmb3IgZXhwaXJlciB0YXJnZXQgdHlwZTogaWQnKTtcbiAgICByZXR1cm4gYGlkOiR7ZX1gO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBleHBpcmVyIHRhcmdldCB0eXBlOiAke2l9YCk7XG59XG5mdW5jdGlvbiB2cChpKSB7XG4gIHJldHVybiBxYyhcInRvcGljXCIsIGkpO1xufVxuZnVuY3Rpb24gX3AoaSkge1xuICByZXR1cm4gcWMoXCJpZFwiLCBpKTtcbn1cbmZ1bmN0aW9uIGpjKGkpIHtcbiAgY29uc3QgW2UsIHRdID0gaS5zcGxpdChcIjpcIiksIHMgPSB7IGlkOiB2b2lkIDAsIHRvcGljOiB2b2lkIDAgfTtcbiAgaWYgKGUgPT09IFwidG9waWNcIiAmJiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKVxuICAgIHMudG9waWMgPSB0O1xuICBlbHNlIGlmIChlID09PSBcImlkXCIgJiYgTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodCkpKVxuICAgIHMuaWQgPSBOdW1iZXIodCk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGFyZ2V0LCBleHBlY3RlZCBpZDpudW1iZXIgb3IgdG9waWM6c3RyaW5nLCBnb3QgJHtlfToke3R9YCk7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gTXQoaSwgZSkge1xuICByZXR1cm4gVi5mcm9tTWlsaXNlY29uZHMoKGUgfHwgRGF0ZS5ub3coKSkgKyBWLnRvTWlsaXNlY29uZHMoaSkpO1xufVxuZnVuY3Rpb24gYWkoaSkge1xuICByZXR1cm4gRGF0ZS5ub3coKSA+PSBWLnRvTWlsaXNlY29uZHMoaSk7XG59XG5mdW5jdGlvbiBCZShpLCBlKSB7XG4gIHJldHVybiBgJHtpfSR7ZSA/IGA6JHtlfWAgOiBcIlwifWA7XG59XG5hc3luYyBmdW5jdGlvbiBFcCh7IGlkOiBpLCB0b3BpYzogZSwgd2NEZWVwTGluazogdCB9KSB7XG4gIHRyeSB7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCByID0gKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKHQpIDogdCk/LmhyZWY7XG4gICAgaWYgKHR5cGVvZiByICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm47XG4gICAgci5lbmRzV2l0aChcIi9cIikgJiYgKHIgPSByLnNsaWNlKDAsIC0xKSk7XG4gICAgY29uc3QgbiA9IGAke3J9L3djP3JlcXVlc3RJZD0ke2l9JnNlc3Npb25Ub3BpYz0ke2V9YCwgbyA9IF9zKCk7XG4gICAgbyA9PT0gT3QuYnJvd3NlciA/IG4uc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpID8gd2luZG93Lm9wZW4obiwgXCJfYmxhbmtcIiwgXCJub3JlZmVycmVyIG5vb3BlbmVyXCIpIDogd2luZG93Lm9wZW4obiwgXCJfc2VsZlwiLCBcIm5vcmVmZXJyZXIgbm9vcGVuZXJcIikgOiBvID09PSBPdC5yZWFjdE5hdGl2ZSAmJiB0eXBlb2YgKGdsb2JhbCA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsLkxpbmtpbmcpIDwgXCJ1XCIgJiYgYXdhaXQgZ2xvYmFsLkxpbmtpbmcub3BlblVSTChuKTtcbiAgfSBjYXRjaCAocykge1xuICAgIGNvbnNvbGUuZXJyb3Iocyk7XG4gIH1cbn1cbmNvbnN0IFNwID0gXCJpcm5cIjtcbmZ1bmN0aW9uIEdyKGkpIHtcbiAgcmV0dXJuIGk/LnJlbGF5IHx8IHsgcHJvdG9jb2w6IFNwIH07XG59XG5mdW5jdGlvbiBqcyhpKSB7XG4gIGNvbnN0IGUgPSBBY1tpXTtcbiAgaWYgKHR5cGVvZiBlID4gXCJ1XCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBSZWxheSBQcm90b2NvbCBub3Qgc3VwcG9ydGVkOiAke2l9YCk7XG4gIHJldHVybiBlO1xufVxudmFyIElwID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCAkbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIERwID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgeHAgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBGbyA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBJcChpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQsIE9wID0gKGksIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIERwLmNhbGwoZSwgdCkgJiYgRm8oaSwgdCwgZVt0XSk7XG4gIGlmICgkbylcbiAgICBmb3IgKHZhciB0IG9mICRvKGUpKVxuICAgICAgeHAuY2FsbChlLCB0KSAmJiBGbyhpLCB0LCBlW3RdKTtcbiAgcmV0dXJuIGk7XG59O1xuZnVuY3Rpb24gTnAoaSwgZSA9IFwiLVwiKSB7XG4gIGNvbnN0IHQgPSB7fSwgcyA9IFwicmVsYXlcIiArIGU7XG4gIHJldHVybiBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgaWYgKHIuc3RhcnRzV2l0aChzKSkge1xuICAgICAgY29uc3QgbiA9IHIucmVwbGFjZShzLCBcIlwiKSwgbyA9IGlbcl07XG4gICAgICB0W25dID0gbztcbiAgICB9XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gUHAoaSkge1xuICBjb25zdCBlID0gaS5pbmRleE9mKFwiOlwiKSwgdCA9IGkuaW5kZXhPZihcIj9cIikgIT09IC0xID8gaS5pbmRleE9mKFwiP1wiKSA6IHZvaWQgMCwgcyA9IGkuc3Vic3RyaW5nKDAsIGUpLCByID0gaS5zdWJzdHJpbmcoZSArIDEsIHQpLnNwbGl0KFwiQFwiKSwgbiA9IHR5cGVvZiB0IDwgXCJ1XCIgPyBpLnN1YnN0cmluZyh0KSA6IFwiXCIsIG8gPSBpaS5wYXJzZShuKTtcbiAgcmV0dXJuIHsgcHJvdG9jb2w6IHMsIHRvcGljOiBScChyWzBdKSwgdmVyc2lvbjogcGFyc2VJbnQoclsxXSwgMTApLCBzeW1LZXk6IG8uc3ltS2V5LCByZWxheTogTnAobykgfTtcbn1cbmZ1bmN0aW9uIFJwKGkpIHtcbiAgcmV0dXJuIGkuc3RhcnRzV2l0aChcIi8vXCIpID8gaS5zdWJzdHJpbmcoMikgOiBpO1xufVxuZnVuY3Rpb24gQ3AoaSwgZSA9IFwiLVwiKSB7XG4gIGNvbnN0IHQgPSBcInJlbGF5XCIsIHMgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHIpID0+IHtcbiAgICBjb25zdCBuID0gdCArIGUgKyByO1xuICAgIGlbcl0gJiYgKHNbbl0gPSBpW3JdKTtcbiAgfSksIHM7XG59XG5mdW5jdGlvbiBBcChpKSB7XG4gIHJldHVybiBgJHtpLnByb3RvY29sfToke2kudG9waWN9QCR7aS52ZXJzaW9ufT9gICsgaWkuc3RyaW5naWZ5KE9wKHsgc3ltS2V5OiBpLnN5bUtleSB9LCBDcChpLnJlbGF5KSkpO1xufVxuZnVuY3Rpb24gTWkoaSkge1xuICBjb25zdCBlID0gW107XG4gIHJldHVybiBpLmZvckVhY2goKHQpID0+IHtcbiAgICBjb25zdCBbcywgcl0gPSB0LnNwbGl0KFwiOlwiKTtcbiAgICBlLnB1c2goYCR7c306JHtyfWApO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIFRwKGkpIHtcbiAgY29uc3QgZSA9IFtdO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgZS5wdXNoKC4uLk1pKHQuYWNjb3VudHMpKTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiAkcChpLCBlKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaSkuZm9yRWFjaCgocykgPT4ge1xuICAgIE1pKHMuYWNjb3VudHMpLmluY2x1ZGVzKGUpICYmIHQucHVzaCguLi5zLm1ldGhvZHMpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIEZwKGksIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgTWkocy5hY2NvdW50cykuaW5jbHVkZXMoZSkgJiYgdC5wdXNoKC4uLnMuZXZlbnRzKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBVcChpLCBlKSB7XG4gIGNvbnN0IHQgPSB6cyhpLCBlKTtcbiAgaWYgKHQpXG4gICAgdGhyb3cgbmV3IEVycm9yKHQubWVzc2FnZSk7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChjb25zdCBbciwgbl0gb2YgT2JqZWN0LmVudHJpZXMoaSkpXG4gICAgc1tyXSA9IHsgbWV0aG9kczogbi5tZXRob2RzLCBldmVudHM6IG4uZXZlbnRzLCBjaGFpbnM6IG4uYWNjb3VudHMubWFwKChvKSA9PiBgJHtvLnNwbGl0KFwiOlwiKVswXX06JHtvLnNwbGl0KFwiOlwiKVsxXX1gKSB9O1xuICByZXR1cm4gcztcbn1cbmNvbnN0IExwID0geyBJTlZBTElEX01FVEhPRDogeyBtZXNzYWdlOiBcIkludmFsaWQgbWV0aG9kLlwiLCBjb2RlOiAxMDAxIH0sIElOVkFMSURfRVZFTlQ6IHsgbWVzc2FnZTogXCJJbnZhbGlkIGV2ZW50LlwiLCBjb2RlOiAxMDAyIH0sIElOVkFMSURfVVBEQVRFX1JFUVVFU1Q6IHsgbWVzc2FnZTogXCJJbnZhbGlkIHVwZGF0ZSByZXF1ZXN0LlwiLCBjb2RlOiAxMDAzIH0sIElOVkFMSURfRVhURU5EX1JFUVVFU1Q6IHsgbWVzc2FnZTogXCJJbnZhbGlkIGV4dGVuZCByZXF1ZXN0LlwiLCBjb2RlOiAxMDA0IH0sIElOVkFMSURfU0VTU0lPTl9TRVRUTEVfUkVRVUVTVDogeyBtZXNzYWdlOiBcIkludmFsaWQgc2Vzc2lvbiBzZXR0bGUgcmVxdWVzdC5cIiwgY29kZTogMTAwNSB9LCBVTkFVVEhPUklaRURfTUVUSE9EOiB7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkIG1ldGhvZC5cIiwgY29kZTogMzAwMSB9LCBVTkFVVEhPUklaRURfRVZFTlQ6IHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWQgZXZlbnQuXCIsIGNvZGU6IDMwMDIgfSwgVU5BVVRIT1JJWkVEX1VQREFURV9SRVFVRVNUOiB7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkIHVwZGF0ZSByZXF1ZXN0LlwiLCBjb2RlOiAzMDAzIH0sIFVOQVVUSE9SSVpFRF9FWFRFTkRfUkVRVUVTVDogeyBtZXNzYWdlOiBcIlVuYXV0aG9yaXplZCBleHRlbmQgcmVxdWVzdC5cIiwgY29kZTogMzAwNCB9LCBVU0VSX1JFSkVDVEVEOiB7IG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZC5cIiwgY29kZTogNWUzIH0sIFVTRVJfUkVKRUNURURfQ0hBSU5TOiB7IG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZCBjaGFpbnMuXCIsIGNvZGU6IDUwMDEgfSwgVVNFUl9SRUpFQ1RFRF9NRVRIT0RTOiB7IG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZCBtZXRob2RzLlwiLCBjb2RlOiA1MDAyIH0sIFVTRVJfUkVKRUNURURfRVZFTlRTOiB7IG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZCBldmVudHMuXCIsIGNvZGU6IDUwMDMgfSwgVU5TVVBQT1JURURfQ0hBSU5TOiB7IG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgY2hhaW5zLlwiLCBjb2RlOiA1MTAwIH0sIFVOU1VQUE9SVEVEX01FVEhPRFM6IHsgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBtZXRob2RzLlwiLCBjb2RlOiA1MTAxIH0sIFVOU1VQUE9SVEVEX0VWRU5UUzogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIGV2ZW50cy5cIiwgY29kZTogNTEwMiB9LCBVTlNVUFBPUlRFRF9BQ0NPVU5UUzogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIGFjY291bnRzLlwiLCBjb2RlOiA1MTAzIH0sIFVOU1VQUE9SVEVEX05BTUVTUEFDRV9LRVk6IHsgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBuYW1lc3BhY2Uga2V5LlwiLCBjb2RlOiA1MTA0IH0sIFVTRVJfRElTQ09OTkVDVEVEOiB7IG1lc3NhZ2U6IFwiVXNlciBkaXNjb25uZWN0ZWQuXCIsIGNvZGU6IDZlMyB9LCBTRVNTSU9OX1NFVFRMRU1FTlRfRkFJTEVEOiB7IG1lc3NhZ2U6IFwiU2Vzc2lvbiBzZXR0bGVtZW50IGZhaWxlZC5cIiwgY29kZTogN2UzIH0sIFdDX01FVEhPRF9VTlNVUFBPUlRFRDogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIHdjXyBtZXRob2QuXCIsIGNvZGU6IDEwMDAxIH0gfSwgTXAgPSB7IE5PVF9JTklUSUFMSVpFRDogeyBtZXNzYWdlOiBcIk5vdCBpbml0aWFsaXplZC5cIiwgY29kZTogMSB9LCBOT19NQVRDSElOR19LRVk6IHsgbWVzc2FnZTogXCJObyBtYXRjaGluZyBrZXkuXCIsIGNvZGU6IDIgfSwgUkVTVE9SRV9XSUxMX09WRVJSSURFOiB7IG1lc3NhZ2U6IFwiUmVzdG9yZSB3aWxsIG92ZXJyaWRlLlwiLCBjb2RlOiAzIH0sIFJFU1VCU0NSSUJFRDogeyBtZXNzYWdlOiBcIlJlc3Vic2NyaWJlZC5cIiwgY29kZTogNCB9LCBNSVNTSU5HX09SX0lOVkFMSUQ6IHsgbWVzc2FnZTogXCJNaXNzaW5nIG9yIGludmFsaWQuXCIsIGNvZGU6IDUgfSwgRVhQSVJFRDogeyBtZXNzYWdlOiBcIkV4cGlyZWQuXCIsIGNvZGU6IDYgfSwgVU5LTk9XTl9UWVBFOiB7IG1lc3NhZ2U6IFwiVW5rbm93biB0eXBlLlwiLCBjb2RlOiA3IH0sIE1JU01BVENIRURfVE9QSUM6IHsgbWVzc2FnZTogXCJNaXNtYXRjaGVkIHRvcGljLlwiLCBjb2RlOiA4IH0sIE5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVM6IHsgbWVzc2FnZTogXCJOb24gY29uZm9ybWluZyBuYW1lc3BhY2VzLlwiLCBjb2RlOiA5IH0gfTtcbmZ1bmN0aW9uIFkoaSwgZSkge1xuICBjb25zdCB7IG1lc3NhZ2U6IHQsIGNvZGU6IHMgfSA9IE1wW2ldO1xuICByZXR1cm4geyBtZXNzYWdlOiBlID8gYCR7dH0gJHtlfWAgOiB0LCBjb2RlOiBzIH07XG59XG5mdW5jdGlvbiBudChpLCBlKSB7XG4gIGNvbnN0IHsgbWVzc2FnZTogdCwgY29kZTogcyB9ID0gTHBbaV07XG4gIHJldHVybiB7IG1lc3NhZ2U6IGUgPyBgJHt0fSAke2V9YCA6IHQsIGNvZGU6IHMgfTtcbn1cbmZ1bmN0aW9uIEVzKGksIGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaSkgPyB0eXBlb2YgZSA8IFwidVwiICYmIGkubGVuZ3RoID8gaS5ldmVyeShlKSA6ICEwIDogITE7XG59XG5mdW5jdGlvbiBjcyhpKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaSkgPT09IE9iamVjdC5wcm90b3R5cGUgJiYgT2JqZWN0LmtleXMoaSkubGVuZ3RoO1xufVxuZnVuY3Rpb24gYnQoaSkge1xuICByZXR1cm4gdHlwZW9mIGkgPiBcInVcIjtcbn1cbmZ1bmN0aW9uIG90KGksIGUpIHtcbiAgcmV0dXJuIGUgJiYgYnQoaSkgPyAhMCA6IHR5cGVvZiBpID09IFwic3RyaW5nXCIgJiYgISFpLnRyaW0oKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBtbihpLCBlKSB7XG4gIHJldHVybiBlICYmIGJ0KGkpID8gITAgOiB0eXBlb2YgaSA9PSBcIm51bWJlclwiICYmICFpc05hTihpKTtcbn1cbmZ1bmN0aW9uIHFwKGksIGUpIHtcbiAgY29uc3QgeyByZXF1aXJlZE5hbWVzcGFjZXM6IHQgfSA9IGUsIHMgPSBPYmplY3Qua2V5cyhpLm5hbWVzcGFjZXMpLCByID0gT2JqZWN0LmtleXModCk7XG4gIGxldCBuID0gITA7XG4gIHJldHVybiBfaShyLCBzKSA/IChzLmZvckVhY2goKG8pID0+IHtcbiAgICBjb25zdCB7IGFjY291bnRzOiBjLCBtZXRob2RzOiB1LCBldmVudHM6IGQgfSA9IGkubmFtZXNwYWNlc1tvXSwgcCA9IE1pKGMpLCBiID0gdFtvXTtcbiAgICAoIV9pKFRjKG8sIGIpLCBwKSB8fCAhX2koYi5tZXRob2RzLCB1KSB8fCAhX2koYi5ldmVudHMsIGQpKSAmJiAobiA9ICExKTtcbiAgfSksIG4pIDogITE7XG59XG5mdW5jdGlvbiBKcyhpKSB7XG4gIHJldHVybiBvdChpLCAhMSkgJiYgaS5pbmNsdWRlcyhcIjpcIikgPyBpLnNwbGl0KFwiOlwiKS5sZW5ndGggPT09IDIgOiAhMTtcbn1cbmZ1bmN0aW9uIGpwKGkpIHtcbiAgaWYgKG90KGksICExKSAmJiBpLmluY2x1ZGVzKFwiOlwiKSkge1xuICAgIGNvbnN0IGUgPSBpLnNwbGl0KFwiOlwiKTtcbiAgICBpZiAoZS5sZW5ndGggPT09IDMpIHtcbiAgICAgIGNvbnN0IHQgPSBlWzBdICsgXCI6XCIgKyBlWzFdO1xuICAgICAgcmV0dXJuICEhZVsyXSAmJiBKcyh0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24genAoaSkge1xuICBpZiAob3QoaSwgITEpKVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG5ldyBVUkwoaSkgPCBcInVcIjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIEtwKGkpIHtcbiAgdmFyIGU7XG4gIHJldHVybiAoZSA9IGk/LnByb3Bvc2VyKSA9PSBudWxsID8gdm9pZCAwIDogZS5wdWJsaWNLZXk7XG59XG5mdW5jdGlvbiBWcChpKSB7XG4gIHJldHVybiBpPy50b3BpYztcbn1cbmZ1bmN0aW9uIEJwKGksIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICByZXR1cm4gb3QoaT8ucHVibGljS2V5LCAhMSkgfHwgKHQgPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGAke2V9IGNvbnRyb2xsZXIgcHVibGljIGtleSBzaG91bGQgYmUgYSBzdHJpbmdgKSksIHQ7XG59XG5mdW5jdGlvbiBVbyhpKSB7XG4gIGxldCBlID0gITA7XG4gIHJldHVybiBFcyhpKSA/IGkubGVuZ3RoICYmIChlID0gaS5ldmVyeSgodCkgPT4gb3QodCwgITEpKSkgOiBlID0gITEsIGU7XG59XG5mdW5jdGlvbiBrcChpLCBlLCB0KSB7XG4gIGxldCBzID0gbnVsbDtcbiAgcmV0dXJuIEVzKGUpICYmIGUubGVuZ3RoID8gZS5mb3JFYWNoKChyKSA9PiB7XG4gICAgcyB8fCBKcyhyKSB8fCAocyA9IG50KFwiVU5TVVBQT1JURURfQ0hBSU5TXCIsIGAke3R9LCBjaGFpbiAke3J9IHNob3VsZCBiZSBhIHN0cmluZyBhbmQgY29uZm9ybSB0byBcIm5hbWVzcGFjZTpjaGFpbklkXCIgZm9ybWF0YCkpO1xuICB9KSA6IEpzKGkpIHx8IChzID0gbnQoXCJVTlNVUFBPUlRFRF9DSEFJTlNcIiwgYCR7dH0sIGNoYWlucyBtdXN0IGJlIGRlZmluZWQgYXMgXCJuYW1lc3BhY2U6Y2hhaW5JZFwiIGUuZy4gXCJlaXAxNTU6MVwiOiB7Li4ufSBpbiB0aGUgbmFtZXNwYWNlIGtleSBPUiBhcyBhbiBhcnJheSBvZiBDQUlQLTIgY2hhaW5JZHMgZS5nLiBlaXAxNTU6IHsgY2hhaW5zOiBbXCJlaXAxNTU6MVwiLCBcImVpcDE1NTo1XCJdIH1gKSksIHM7XG59XG5mdW5jdGlvbiBIcChpLCBlLCB0KSB7XG4gIGxldCBzID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGkpLmZvckVhY2goKFtyLCBuXSkgPT4ge1xuICAgIGlmIChzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBrcChyLCBUYyhyLCBuKSwgYCR7ZX0gJHt0fWApO1xuICAgIG8gJiYgKHMgPSBvKTtcbiAgfSksIHM7XG59XG5mdW5jdGlvbiBHcChpLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgcmV0dXJuIEVzKGkpID8gaS5mb3JFYWNoKChzKSA9PiB7XG4gICAgdCB8fCBqcChzKSB8fCAodCA9IG50KFwiVU5TVVBQT1JURURfQUNDT1VOVFNcIiwgYCR7ZX0sIGFjY291bnQgJHtzfSBzaG91bGQgYmUgYSBzdHJpbmcgYW5kIGNvbmZvcm0gdG8gXCJuYW1lc3BhY2U6Y2hhaW5JZDphZGRyZXNzXCIgZm9ybWF0YCkpO1xuICB9KSA6IHQgPSBudChcIlVOU1VQUE9SVEVEX0FDQ09VTlRTXCIsIGAke2V9LCBhY2NvdW50cyBzaG91bGQgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBjb25mb3JtaW5nIHRvIFwibmFtZXNwYWNlOmNoYWluSWQ6YWRkcmVzc1wiIGZvcm1hdGApLCB0O1xufVxuZnVuY3Rpb24gV3AoaSwgZSkge1xuICBsZXQgdCA9IG51bGw7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGkpLmZvckVhY2goKHMpID0+IHtcbiAgICBpZiAodClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gR3Aocz8uYWNjb3VudHMsIGAke2V9IG5hbWVzcGFjZWApO1xuICAgIHIgJiYgKHQgPSByKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBZcChpLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgcmV0dXJuIFVvKGk/Lm1ldGhvZHMpID8gVW8oaT8uZXZlbnRzKSB8fCAodCA9IG50KFwiVU5TVVBQT1JURURfRVZFTlRTXCIsIGAke2V9LCBldmVudHMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgZW1wdHkgYXJyYXkgZm9yIG5vIGV2ZW50c2ApKSA6IHQgPSBudChcIlVOU1VQUE9SVEVEX01FVEhPRFNcIiwgYCR7ZX0sIG1ldGhvZHMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgZW1wdHkgYXJyYXkgZm9yIG5vIG1ldGhvZHNgKSwgdDtcbn1cbmZ1bmN0aW9uIHpjKGksIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgaWYgKHQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IFlwKHMsIGAke2V9LCBuYW1lc3BhY2VgKTtcbiAgICByICYmICh0ID0gcik7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gSnAoaSwgZSwgdCkge1xuICBsZXQgcyA9IG51bGw7XG4gIGlmIChpICYmIGNzKGkpKSB7XG4gICAgY29uc3QgciA9IHpjKGksIGUpO1xuICAgIHIgJiYgKHMgPSByKTtcbiAgICBjb25zdCBuID0gSHAoaSwgZSwgdCk7XG4gICAgbiAmJiAocyA9IG4pO1xuICB9IGVsc2VcbiAgICBzID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgJHtlfSwgJHt0fSBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggZGF0YWApO1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHpzKGksIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICBpZiAoaSAmJiBjcyhpKSkge1xuICAgIGNvbnN0IHMgPSB6YyhpLCBlKTtcbiAgICBzICYmICh0ID0gcyk7XG4gICAgY29uc3QgciA9IFdwKGksIGUpO1xuICAgIHIgJiYgKHQgPSByKTtcbiAgfSBlbHNlXG4gICAgdCA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYCR7ZX0sIG5hbWVzcGFjZXMgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGRhdGFgKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBLYyhpKSB7XG4gIHJldHVybiBvdChpLnByb3RvY29sLCAhMCk7XG59XG5mdW5jdGlvbiBRcChpLCBlKSB7XG4gIGxldCB0ID0gITE7XG4gIHJldHVybiBlICYmICFpID8gdCA9ICEwIDogaSAmJiBFcyhpKSAmJiBpLmxlbmd0aCAmJiBpLmZvckVhY2goKHMpID0+IHtcbiAgICB0ID0gS2Mocyk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gWHAoaSkge1xuICByZXR1cm4gdHlwZW9mIGkgPT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIFN0KGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpIDwgXCJ1XCIgJiYgdHlwZW9mIGkgIT09IG51bGw7XG59XG5mdW5jdGlvbiBacChpKSB7XG4gIHJldHVybiAhKCFpIHx8IHR5cGVvZiBpICE9IFwib2JqZWN0XCIgfHwgIWkuY29kZSB8fCAhbW4oaS5jb2RlLCAhMSkgfHwgIWkubWVzc2FnZSB8fCAhb3QoaS5tZXNzYWdlLCAhMSkpO1xufVxuZnVuY3Rpb24gZWcoaSkge1xuICByZXR1cm4gIShidChpKSB8fCAhb3QoaS5tZXRob2QsICExKSk7XG59XG5mdW5jdGlvbiB0ZyhpKSB7XG4gIHJldHVybiAhKGJ0KGkpIHx8IGJ0KGkucmVzdWx0KSAmJiBidChpLmVycm9yKSB8fCAhbW4oaS5pZCwgITEpIHx8ICFvdChpLmpzb25ycGMsICExKSk7XG59XG5mdW5jdGlvbiBpZyhpKSB7XG4gIHJldHVybiAhKGJ0KGkpIHx8ICFvdChpLm5hbWUsICExKSk7XG59XG5mdW5jdGlvbiBMbyhpLCBlKSB7XG4gIHJldHVybiAhKCFKcyhlKSB8fCAhVHAoaSkuaW5jbHVkZXMoZSkpO1xufVxuZnVuY3Rpb24gc2coaSwgZSwgdCkge1xuICByZXR1cm4gb3QodCwgITEpID8gJHAoaSwgZSkuaW5jbHVkZXModCkgOiAhMTtcbn1cbmZ1bmN0aW9uIHJnKGksIGUsIHQpIHtcbiAgcmV0dXJuIG90KHQsICExKSA/IEZwKGksIGUpLmluY2x1ZGVzKHQpIDogITE7XG59XG5mdW5jdGlvbiBNbyhpLCBlLCB0KSB7XG4gIGxldCBzID0gbnVsbDtcbiAgY29uc3QgciA9IG5nKGkpLCBuID0gb2coZSksIG8gPSBPYmplY3Qua2V5cyhyKSwgYyA9IE9iamVjdC5rZXlzKG4pLCB1ID0gcW8oT2JqZWN0LmtleXMoaSkpLCBkID0gcW8oT2JqZWN0LmtleXMoZSkpLCBwID0gdS5maWx0ZXIoKGIpID0+ICFkLmluY2x1ZGVzKGIpKTtcbiAgcmV0dXJuIHAubGVuZ3RoICYmIChzID0gWShcIk5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVNcIiwgYCR7dH0gbmFtZXNwYWNlcyBrZXlzIGRvbid0IHNhdGlzZnkgcmVxdWlyZWROYW1lc3BhY2VzLlxuICAgICAgUmVxdWlyZWQ6ICR7cC50b1N0cmluZygpfVxuICAgICAgUmVjZWl2ZWQ6ICR7T2JqZWN0LmtleXMoZSkudG9TdHJpbmcoKX1gKSksIF9pKG8sIGMpIHx8IChzID0gWShcIk5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVNcIiwgYCR7dH0gbmFtZXNwYWNlcyBjaGFpbnMgZG9uJ3Qgc2F0aXNmeSByZXF1aXJlZCBuYW1lc3BhY2VzLlxuICAgICAgUmVxdWlyZWQ6ICR7by50b1N0cmluZygpfVxuICAgICAgQXBwcm92ZWQ6ICR7Yy50b1N0cmluZygpfWApKSwgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoYikgPT4ge1xuICAgIGlmICghYi5pbmNsdWRlcyhcIjpcIikgfHwgcylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4ID0gTWkoZVtiXS5hY2NvdW50cyk7XG4gICAgeC5pbmNsdWRlcyhiKSB8fCAocyA9IFkoXCJOT05fQ09ORk9STUlOR19OQU1FU1BBQ0VTXCIsIGAke3R9IG5hbWVzcGFjZXMgYWNjb3VudHMgZG9uJ3Qgc2F0aXNmeSBuYW1lc3BhY2UgYWNjb3VudHMgZm9yICR7Yn1cbiAgICAgICAgUmVxdWlyZWQ6ICR7Yn1cbiAgICAgICAgQXBwcm92ZWQ6ICR7eC50b1N0cmluZygpfWApKTtcbiAgfSksIG8uZm9yRWFjaCgoYikgPT4ge1xuICAgIHMgfHwgKF9pKHJbYl0ubWV0aG9kcywgbltiXS5tZXRob2RzKSA/IF9pKHJbYl0uZXZlbnRzLCBuW2JdLmV2ZW50cykgfHwgKHMgPSBZKFwiTk9OX0NPTkZPUk1JTkdfTkFNRVNQQUNFU1wiLCBgJHt0fSBuYW1lc3BhY2VzIGV2ZW50cyBkb24ndCBzYXRpc2Z5IG5hbWVzcGFjZSBldmVudHMgZm9yICR7Yn1gKSkgOiBzID0gWShcIk5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVNcIiwgYCR7dH0gbmFtZXNwYWNlcyBtZXRob2RzIGRvbid0IHNhdGlzZnkgbmFtZXNwYWNlIG1ldGhvZHMgZm9yICR7Yn1gKSk7XG4gIH0pLCBzO1xufVxuZnVuY3Rpb24gbmcoaSkge1xuICBjb25zdCBlID0ge307XG4gIHJldHVybiBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgdmFyIHM7XG4gICAgdC5pbmNsdWRlcyhcIjpcIikgPyBlW3RdID0gaVt0XSA6IChzID0gaVt0XS5jaGFpbnMpID09IG51bGwgfHwgcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBlW3JdID0geyBtZXRob2RzOiBpW3RdLm1ldGhvZHMsIGV2ZW50czogaVt0XS5ldmVudHMgfTtcbiAgICB9KTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBxbyhpKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChpLm1hcCgoZSkgPT4gZS5pbmNsdWRlcyhcIjpcIikgPyBlLnNwbGl0KFwiOlwiKVswXSA6IGUpKV07XG59XG5mdW5jdGlvbiBvZyhpKSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHQpID0+IHtcbiAgICB0LmluY2x1ZGVzKFwiOlwiKSA/IGVbdF0gPSBpW3RdIDogTWkoaVt0XS5hY2NvdW50cyk/LmZvckVhY2goKHIpID0+IHtcbiAgICAgIGVbcl0gPSB7IGFjY291bnRzOiBpW3RdLmFjY291bnRzLmZpbHRlcigobikgPT4gbi5pbmNsdWRlcyhgJHtyfTpgKSksIG1ldGhvZHM6IGlbdF0ubWV0aG9kcywgZXZlbnRzOiBpW3RdLmV2ZW50cyB9O1xuICAgIH0pO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIGFnKGksIGUpIHtcbiAgcmV0dXJuIG1uKGksICExKSAmJiBpIDw9IGUubWF4ICYmIGkgPj0gZS5taW47XG59XG5mdW5jdGlvbiBqbygpIHtcbiAgY29uc3QgaSA9IF9zKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgIHN3aXRjaCAoaSkge1xuICAgICAgY2FzZSBPdC5icm93c2VyOlxuICAgICAgICBlKGNnKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgT3QucmVhY3ROYXRpdmU6XG4gICAgICAgIGUoaGcoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBPdC5ub2RlOlxuICAgICAgICBlKHVnKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGUoITApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjZygpIHtcbiAgcmV0dXJuIHZzKCkgJiYgbmF2aWdhdG9yPy5vbkxpbmU7XG59XG5hc3luYyBmdW5jdGlvbiBoZygpIHtcbiAgcmV0dXJuIHVyKCkgJiYgdHlwZW9mIGdsb2JhbCA8IFwidVwiICYmIGdsb2JhbCAhPSBudWxsICYmIGdsb2JhbC5OZXRJbmZvID8gKGF3YWl0IChnbG9iYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbC5OZXRJbmZvLmZldGNoKCkpKT8uaXNDb25uZWN0ZWQgOiAhMDtcbn1cbmZ1bmN0aW9uIHVnKCkge1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBsZyhpKSB7XG4gIHN3aXRjaCAoX3MoKSkge1xuICAgIGNhc2UgT3QuYnJvd3NlcjpcbiAgICAgIGRnKGkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBPdC5yZWFjdE5hdGl2ZTpcbiAgICAgIGZnKGkpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIGRnKGkpIHtcbiAgdnMoKSAmJiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgKCkgPT4gaSghMCkpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgKCkgPT4gaSghMSkpKTtcbn1cbmZ1bmN0aW9uIGZnKGkpIHtcbiAgdXIoKSAmJiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgJiYgZ2xvYmFsICE9IG51bGwgJiYgZ2xvYmFsLk5ldEluZm8gJiYgZ2xvYmFsPy5OZXRJbmZvLmFkZEV2ZW50TGlzdGVuZXIoKGUpID0+IGkoZT8uaXNDb25uZWN0ZWQpKTtcbn1cbmNvbnN0IHhyID0ge307XG5sZXQgJHMgPSBjbGFzcyB7XG4gIHN0YXRpYyBnZXQoZSkge1xuICAgIHJldHVybiB4cltlXTtcbiAgfVxuICBzdGF0aWMgc2V0KGUsIHQpIHtcbiAgICB4cltlXSA9IHQ7XG4gIH1cbiAgc3RhdGljIGRlbGV0ZShlKSB7XG4gICAgZGVsZXRlIHhyW2VdO1xuICB9XG59O1xuY29uc3QgcGcgPSBcIlBBUlNFX0VSUk9SXCIsIGdnID0gXCJJTlZBTElEX1JFUVVFU1RcIiwgeWcgPSBcIk1FVEhPRF9OT1RfRk9VTkRcIiwgbWcgPSBcIklOVkFMSURfUEFSQU1TXCIsIFZjID0gXCJJTlRFUk5BTF9FUlJPUlwiLCBibiA9IFwiU0VSVkVSX0VSUk9SXCIsIGJnID0gWy0zMjcwMCwgLTMyNjAwLCAtMzI2MDEsIC0zMjYwMiwgLTMyNjAzXSwgaHMgPSB7XG4gIFtwZ106IHsgY29kZTogLTMyNzAwLCBtZXNzYWdlOiBcIlBhcnNlIGVycm9yXCIgfSxcbiAgW2dnXTogeyBjb2RlOiAtMzI2MDAsIG1lc3NhZ2U6IFwiSW52YWxpZCBSZXF1ZXN0XCIgfSxcbiAgW3lnXTogeyBjb2RlOiAtMzI2MDEsIG1lc3NhZ2U6IFwiTWV0aG9kIG5vdCBmb3VuZFwiIH0sXG4gIFttZ106IHsgY29kZTogLTMyNjAyLCBtZXNzYWdlOiBcIkludmFsaWQgcGFyYW1zXCIgfSxcbiAgW1ZjXTogeyBjb2RlOiAtMzI2MDMsIG1lc3NhZ2U6IFwiSW50ZXJuYWwgZXJyb3JcIiB9LFxuICBbYm5dOiB7IGNvZGU6IC0zMmUzLCBtZXNzYWdlOiBcIlNlcnZlciBlcnJvclwiIH1cbn0sIEJjID0gYm47XG5mdW5jdGlvbiB3ZyhpKSB7XG4gIHJldHVybiBiZy5pbmNsdWRlcyhpKTtcbn1cbmZ1bmN0aW9uIHpvKGkpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhzKS5pbmNsdWRlcyhpKSA/IGhzW2ldIDogaHNbQmNdO1xufVxuZnVuY3Rpb24gdmcoaSkge1xuICBjb25zdCBlID0gT2JqZWN0LnZhbHVlcyhocykuZmluZCgodCkgPT4gdC5jb2RlID09PSBpKTtcbiAgcmV0dXJuIGUgfHwgaHNbQmNdO1xufVxuZnVuY3Rpb24gX2coaSwgZSwgdCkge1xuICByZXR1cm4gaS5tZXNzYWdlLmluY2x1ZGVzKFwiZ2V0YWRkcmluZm8gRU5PVEZPVU5EXCIpIHx8IGkubWVzc2FnZS5pbmNsdWRlcyhcImNvbm5lY3QgRUNPTk5SRUZVU0VEXCIpID8gbmV3IEVycm9yKGBVbmF2YWlsYWJsZSAke3R9IFJQQyB1cmwgYXQgJHtlfWApIDogaTtcbn1cbnZhciBrYyA9IHt9LCBRdCA9IHt9LCBLbztcbmZ1bmN0aW9uIEVnKCkge1xuICBpZiAoS28pXG4gICAgcmV0dXJuIFF0O1xuICBLbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBRdC5pc0Jyb3dzZXJDcnlwdG9BdmFpbGFibGUgPSBRdC5nZXRTdWJ0bGVDcnlwdG8gPSBRdC5nZXRCcm93ZXJDcnlwdG8gPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIGkoKSB7XG4gICAgcmV0dXJuIChtdCA9PT0gbnVsbCB8fCBtdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXQuY3J5cHRvKSB8fCAobXQgPT09IG51bGwgfHwgbXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG10Lm1zQ3J5cHRvKSB8fCB7fTtcbiAgfVxuICBRdC5nZXRCcm93ZXJDcnlwdG8gPSBpO1xuICBmdW5jdGlvbiBlKCkge1xuICAgIGNvbnN0IHMgPSBpKCk7XG4gICAgcmV0dXJuIHMuc3VidGxlIHx8IHMud2Via2l0U3VidGxlO1xuICB9XG4gIFF0LmdldFN1YnRsZUNyeXB0byA9IGU7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgcmV0dXJuICEhaSgpICYmICEhZSgpO1xuICB9XG4gIHJldHVybiBRdC5pc0Jyb3dzZXJDcnlwdG9BdmFpbGFibGUgPSB0LCBRdDtcbn1cbnZhciBYdCA9IHt9LCBWbztcbmZ1bmN0aW9uIFNnKCkge1xuICBpZiAoVm8pXG4gICAgcmV0dXJuIFh0O1xuICBWbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBYdC5pc0Jyb3dzZXIgPSBYdC5pc05vZGUgPSBYdC5pc1JlYWN0TmF0aXZlID0gdm9pZCAwO1xuICBmdW5jdGlvbiBpKCkge1xuICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgPiBcInVcIiAmJiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcbiAgfVxuICBYdC5pc1JlYWN0TmF0aXZlID0gaTtcbiAgZnVuY3Rpb24gZSgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA8IFwidVwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgPCBcInVcIjtcbiAgfVxuICBYdC5pc05vZGUgPSBlO1xuICBmdW5jdGlvbiB0KCkge1xuICAgIHJldHVybiAhaSgpICYmICFlKCk7XG4gIH1cbiAgcmV0dXJuIFh0LmlzQnJvd3NlciA9IHQsIFh0O1xufVxuKGZ1bmN0aW9uKGkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgY29uc3QgZSA9IEZ0O1xuICBlLl9fZXhwb3J0U3RhcihFZygpLCBpKSwgZS5fX2V4cG9ydFN0YXIoU2coKSwgaSk7XG59KShrYyk7XG5mdW5jdGlvbiB3bihpID0gMykge1xuICBjb25zdCBlID0gRGF0ZS5ub3coKSAqIE1hdGgucG93KDEwLCBpKSwgdCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDEwLCBpKSk7XG4gIHJldHVybiBlICsgdDtcbn1cbmZ1bmN0aW9uIHZuKGkgPSA2KSB7XG4gIHJldHVybiBCaWdJbnQod24oaSkpO1xufVxuZnVuY3Rpb24gdGkoaSwgZSwgdCkge1xuICByZXR1cm4ge1xuICAgIGlkOiB0IHx8IHduKCksXG4gICAganNvbnJwYzogXCIyLjBcIixcbiAgICBtZXRob2Q6IGksXG4gICAgcGFyYW1zOiBlXG4gIH07XG59XG5mdW5jdGlvbiB4aShpLCBlKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGksXG4gICAganNvbnJwYzogXCIyLjBcIixcbiAgICByZXN1bHQ6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHFpKGksIGUsIHQpIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogaSxcbiAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgIGVycm9yOiBJZyhlLCB0KVxuICB9O1xufVxuZnVuY3Rpb24gSWcoaSwgZSkge1xuICByZXR1cm4gdHlwZW9mIGkgPiBcInVcIiA/IHpvKFZjKSA6ICh0eXBlb2YgaSA9PSBcInN0cmluZ1wiICYmIChpID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB6byhibikpLCB7IG1lc3NhZ2U6IGkgfSkpLCB0eXBlb2YgZSA8IFwidVwiICYmIChpLmRhdGEgPSBlKSwgd2coaS5jb2RlKSAmJiAoaSA9IHZnKGkuY29kZSkpLCBpKTtcbn1cbmNsYXNzIEhjIHtcbn1cbmNsYXNzIERnIGV4dGVuZHMgSGMge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuY2xhc3MgeGcgZXh0ZW5kcyBIYyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbn1cbmNsYXNzIE9nIGV4dGVuZHMgeGcge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuY29uc3QgTmcgPSBcIl53c3M/OlwiO1xuZnVuY3Rpb24gUGcoaSkge1xuICBjb25zdCBlID0gaS5tYXRjaChuZXcgUmVnRXhwKC9eXFx3KzovLCBcImdpXCIpKTtcbiAgaWYgKCEoIWUgfHwgIWUubGVuZ3RoKSlcbiAgICByZXR1cm4gZVswXTtcbn1cbmZ1bmN0aW9uIFJnKGksIGUpIHtcbiAgY29uc3QgdCA9IFBnKGkpO1xuICByZXR1cm4gdHlwZW9mIHQgPiBcInVcIiA/ICExIDogbmV3IFJlZ0V4cChlKS50ZXN0KHQpO1xufVxuZnVuY3Rpb24gQm8oaSkge1xuICByZXR1cm4gUmcoaSwgTmcpO1xufVxuZnVuY3Rpb24gQ2coaSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIndzcz86Ly9sb2NhbGhvc3QoOmR7Miw1fSk/XCIpLnRlc3QoaSk7XG59XG5mdW5jdGlvbiBHYyhpKSB7XG4gIHJldHVybiB0eXBlb2YgaSA9PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBpICYmIFwianNvbnJwY1wiIGluIGkgJiYgaS5qc29ucnBjID09PSBcIjIuMFwiO1xufVxuZnVuY3Rpb24gamkoaSkge1xuICByZXR1cm4gR2MoaSkgJiYgXCJtZXRob2RcIiBpbiBpO1xufVxuZnVuY3Rpb24gT2koaSkge1xuICByZXR1cm4gR2MoaSkgJiYgKGh0KGkpIHx8IEdlKGkpKTtcbn1cbmZ1bmN0aW9uIGh0KGkpIHtcbiAgcmV0dXJuIFwicmVzdWx0XCIgaW4gaTtcbn1cbmZ1bmN0aW9uIEdlKGkpIHtcbiAgcmV0dXJuIFwiZXJyb3JcIiBpbiBpO1xufVxuY2xhc3MgX24gZXh0ZW5kcyBPZyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKSwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMuaGFzUmVnaXN0ZXJlZEV2ZW50TGlzdGVuZXJzID0gITEsIHRoaXMuY29ubmVjdGlvbiA9IHRoaXMuc2V0Q29ubmVjdGlvbihlKSwgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3RlZCAmJiB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGUgPSB0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICBhd2FpdCB0aGlzLm9wZW4oZSk7XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICBhd2FpdCB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKGUsIHQpO1xuICB9XG4gIG9uY2UoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uY2UoZSwgdCk7XG4gIH1cbiAgb2ZmKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vZmYoZSwgdCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGUsIHQpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdHJpY3QodGkoZS5tZXRob2QsIGUucGFyYW1zIHx8IFtdLCBlLmlkIHx8IHZuKCkudG9TdHJpbmcoKSksIHQpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3RTdHJpY3QoZSwgdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocywgcikgPT4ge1xuICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGVkKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMub3BlbigpO1xuICAgICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgICAgcihuKTtcbiAgICAgICAgfVxuICAgICAgdGhpcy5ldmVudHMub24oYCR7ZS5pZH1gLCAobikgPT4ge1xuICAgICAgICBHZShuKSA/IHIobi5lcnJvcikgOiBzKG4ucmVzdWx0KTtcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmQoZSwgdCk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHIobik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0Q29ubmVjdGlvbihlID0gdGhpcy5jb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgb25QYXlsb2FkKGUpIHtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KFwicGF5bG9hZFwiLCBlKSwgT2koZSkgPyB0aGlzLmV2ZW50cy5lbWl0KGAke2UuaWR9YCwgZSkgOiB0aGlzLmV2ZW50cy5lbWl0KFwibWVzc2FnZVwiLCB7XG4gICAgICB0eXBlOiBlLm1ldGhvZCxcbiAgICAgIGRhdGE6IGUucGFyYW1zXG4gICAgfSk7XG4gIH1cbiAgb25DbG9zZShlKSB7XG4gICAgZSAmJiBlLmNvZGUgPT09IDNlMyAmJiB0aGlzLmV2ZW50cy5lbWl0KFwiZXJyb3JcIiwgbmV3IEVycm9yKGBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQgYWJub3JtYWxseSB3aXRoIGNvZGU6ICR7ZS5jb2RlfSAke2UucmVhc29uID8gYCgke2UucmVhc29ufSlgIDogXCJcIn1gKSksIHRoaXMuZXZlbnRzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICB9XG4gIGFzeW5jIG9wZW4oZSA9IHRoaXMuY29ubmVjdGlvbikge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9PT0gZSAmJiB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGVkIHx8ICh0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGVkICYmIHRoaXMuY2xvc2UoKSwgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAoYXdhaXQgdGhpcy5jb25uZWN0aW9uLm9wZW4oZSksIGUgPSB0aGlzLmNvbm5lY3Rpb24pLCB0aGlzLmNvbm5lY3Rpb24gPSB0aGlzLnNldENvbm5lY3Rpb24oZSksIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5vcGVuKCksIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLmV2ZW50cy5lbWl0KFwiY29ubmVjdFwiKSk7XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmhhc1JlZ2lzdGVyZWRFdmVudExpc3RlbmVycyB8fCAodGhpcy5jb25uZWN0aW9uLm9uKFwicGF5bG9hZFwiLCAoZSkgPT4gdGhpcy5vblBheWxvYWQoZSkpLCB0aGlzLmNvbm5lY3Rpb24ub24oXCJjbG9zZVwiLCAoZSkgPT4gdGhpcy5vbkNsb3NlKGUpKSwgdGhpcy5jb25uZWN0aW9uLm9uKFwiZXJyb3JcIiwgKGUpID0+IHRoaXMuZXZlbnRzLmVtaXQoXCJlcnJvclwiLCBlKSksIHRoaXMuY29ubmVjdGlvbi5vbihcInJlZ2lzdGVyX2Vycm9yXCIsIChlKSA9PiB0aGlzLm9uQ2xvc2UoKSksIHRoaXMuaGFzUmVnaXN0ZXJlZEV2ZW50TGlzdGVuZXJzID0gITApO1xuICB9XG59XG5jb25zdCBBZyA9ICgpID0+IHR5cGVvZiBXZWJTb2NrZXQgPCBcInVcIiA/IFdlYlNvY2tldCA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiAmJiB0eXBlb2YgZ2xvYmFsLldlYlNvY2tldCA8IFwidVwiID8gZ2xvYmFsLldlYlNvY2tldCA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2Ygd2luZG93LldlYlNvY2tldCA8IFwidVwiID8gd2luZG93LldlYlNvY2tldCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgJiYgdHlwZW9mIHNlbGYuV2ViU29ja2V0IDwgXCJ1XCIgPyBzZWxmLldlYlNvY2tldCA6IHJlcXVpcmUoXCJ3c1wiKSwgVGcgPSAoKSA9PiB0eXBlb2YgV2ViU29ja2V0IDwgXCJ1XCIgfHwgdHlwZW9mIGdsb2JhbCA8IFwidVwiICYmIHR5cGVvZiBnbG9iYWwuV2ViU29ja2V0IDwgXCJ1XCIgfHwgdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHR5cGVvZiB3aW5kb3cuV2ViU29ja2V0IDwgXCJ1XCIgfHwgdHlwZW9mIHNlbGYgPCBcInVcIiAmJiB0eXBlb2Ygc2VsZi5XZWJTb2NrZXQgPCBcInVcIiwga28gPSAoaSkgPT4gaS5zcGxpdChcIj9cIilbMF0sIEhvID0gMTAsICRnID0gQWcoKTtcbmNsYXNzIFdjIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGlmICh0aGlzLnVybCA9IGUsIHRoaXMuZXZlbnRzID0gbmV3IFdlLkV2ZW50RW1pdHRlcigpLCB0aGlzLnJlZ2lzdGVyaW5nID0gITEsICFCbyhlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZWQgVVJMIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggV2ViU29ja2V0IGNvbm5lY3Rpb246ICR7ZX1gKTtcbiAgICB0aGlzLnVybCA9IGU7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuc29ja2V0IDwgXCJ1XCI7XG4gIH1cbiAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJpbmc7XG4gIH1cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKGUsIHQpO1xuICB9XG4gIG9uY2UoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uY2UoZSwgdCk7XG4gIH1cbiAgb2ZmKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vZmYoZSwgdCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGUsIHQpO1xuICB9XG4gIGFzeW5jIG9wZW4oZSA9IHRoaXMudXJsKSB7XG4gICAgYXdhaXQgdGhpcy5yZWdpc3RlcihlKTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGUsIHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zb2NrZXQgPiBcInVcIikge1xuICAgICAgICB0KG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gYWxyZWFkeSBjbG9zZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5vbmNsb3NlID0gKHMpID0+IHtcbiAgICAgICAgdGhpcy5vbkNsb3NlKHMpLCBlKCk7XG4gICAgICB9LCB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNlbmQoZSwgdCkge1xuICAgIHR5cGVvZiB0aGlzLnNvY2tldCA+IFwidVwiICYmICh0aGlzLnNvY2tldCA9IGF3YWl0IHRoaXMucmVnaXN0ZXIoKSk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQocnIoZSkpO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIHRoaXMub25FcnJvcihlLmlkLCBzKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXIoZSA9IHRoaXMudXJsKSB7XG4gICAgaWYgKCFCbyhlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZWQgVVJMIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggV2ViU29ja2V0IGNvbm5lY3Rpb246ICR7ZX1gKTtcbiAgICBpZiAodGhpcy5yZWdpc3RlcmluZykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuZXZlbnRzLmdldE1heExpc3RlbmVycygpO1xuICAgICAgcmV0dXJuICh0aGlzLmV2ZW50cy5saXN0ZW5lckNvdW50KFwicmVnaXN0ZXJfZXJyb3JcIikgPj0gdCB8fCB0aGlzLmV2ZW50cy5saXN0ZW5lckNvdW50KFwib3BlblwiKSA+PSB0KSAmJiB0aGlzLmV2ZW50cy5zZXRNYXhMaXN0ZW5lcnModCArIDEpLCBuZXcgUHJvbWlzZSgocywgcikgPT4ge1xuICAgICAgICB0aGlzLmV2ZW50cy5vbmNlKFwicmVnaXN0ZXJfZXJyb3JcIiwgKG4pID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TWF4TGlzdGVuZXJzKCksIHIobik7XG4gICAgICAgIH0pLCB0aGlzLmV2ZW50cy5vbmNlKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucmVzZXRNYXhMaXN0ZW5lcnMoKSwgdHlwZW9mIHRoaXMuc29ja2V0ID4gXCJ1XCIpXG4gICAgICAgICAgICByZXR1cm4gcihuZXcgRXJyb3IoXCJXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBtaXNzaW5nIG9yIGludmFsaWRcIikpO1xuICAgICAgICAgIHModGhpcy5zb2NrZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51cmwgPSBlLCB0aGlzLnJlZ2lzdGVyaW5nID0gITAsIG5ldyBQcm9taXNlKCh0LCBzKSA9PiB7XG4gICAgICBjb25zdCByID0ga2MuaXNSZWFjdE5hdGl2ZSgpID8gdm9pZCAwIDogeyByZWplY3RVbmF1dGhvcml6ZWQ6ICFDZyhlKSB9LCBuID0gbmV3ICRnKGUsIFtdLCByKTtcbiAgICAgIFRnKCkgPyBuLm9uZXJyb3IgPSAobykgPT4ge1xuICAgICAgICBjb25zdCBjID0gbztcbiAgICAgICAgcyh0aGlzLmVtaXRFcnJvcihjLmVycm9yKSk7XG4gICAgICB9IDogbi5vbihcImVycm9yXCIsIChvKSA9PiB7XG4gICAgICAgIHModGhpcy5lbWl0RXJyb3IobykpO1xuICAgICAgfSksIG4ub25vcGVuID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9uT3BlbihuKSwgdChuKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgb25PcGVuKGUpIHtcbiAgICBlLm9ubWVzc2FnZSA9ICh0KSA9PiB0aGlzLm9uUGF5bG9hZCh0KSwgZS5vbmNsb3NlID0gKHQpID0+IHRoaXMub25DbG9zZSh0KSwgdGhpcy5zb2NrZXQgPSBlLCB0aGlzLnJlZ2lzdGVyaW5nID0gITEsIHRoaXMuZXZlbnRzLmVtaXQoXCJvcGVuXCIpO1xuICB9XG4gIG9uQ2xvc2UoZSkge1xuICAgIHRoaXMuc29ja2V0ID0gdm9pZCAwLCB0aGlzLnJlZ2lzdGVyaW5nID0gITEsIHRoaXMuZXZlbnRzLmVtaXQoXCJjbG9zZVwiLCBlKTtcbiAgfVxuICBvblBheWxvYWQoZSkge1xuICAgIGlmICh0eXBlb2YgZS5kYXRhID4gXCJ1XCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHR5cGVvZiBlLmRhdGEgPT0gXCJzdHJpbmdcIiA/IHJuKGUuZGF0YSkgOiBlLmRhdGE7XG4gICAgdGhpcy5ldmVudHMuZW1pdChcInBheWxvYWRcIiwgdCk7XG4gIH1cbiAgb25FcnJvcihlLCB0KSB7XG4gICAgY29uc3QgcyA9IHRoaXMucGFyc2VFcnJvcih0KSwgciA9IHMubWVzc2FnZSB8fCBzLnRvU3RyaW5nKCksIG4gPSBxaShlLCByKTtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KFwicGF5bG9hZFwiLCBuKTtcbiAgfVxuICBwYXJzZUVycm9yKGUsIHQgPSB0aGlzLnVybCkge1xuICAgIHJldHVybiBfZyhlLCBrbyh0KSwgXCJXU1wiKTtcbiAgfVxuICByZXNldE1heExpc3RlbmVycygpIHtcbiAgICB0aGlzLmV2ZW50cy5nZXRNYXhMaXN0ZW5lcnMoKSA+IEhvICYmIHRoaXMuZXZlbnRzLnNldE1heExpc3RlbmVycyhIbyk7XG4gIH1cbiAgZW1pdEVycm9yKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5wYXJzZUVycm9yKG5ldyBFcnJvcihlPy5tZXNzYWdlIHx8IGBXZWJTb2NrZXQgY29ubmVjdGlvbiBmYWlsZWQgZm9yIGhvc3Q6ICR7a28odGhpcy51cmwpfWApKTtcbiAgICByZXR1cm4gdGhpcy5ldmVudHMuZW1pdChcInJlZ2lzdGVyX2Vycm9yXCIsIHQpLCB0O1xuICB9XG59XG52YXIgUXMgPSB7IGV4cG9ydHM6IHt9IH07XG5Rcy5leHBvcnRzO1xuKGZ1bmN0aW9uKGksIGUpIHtcbiAgdmFyIHQgPSAyMDAsIHMgPSBcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIiwgciA9IDEsIG4gPSAyLCBvID0gOTAwNzE5OTI1NDc0MDk5MSwgYyA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIHUgPSBcIltvYmplY3QgQXJyYXldXCIsIGQgPSBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIiwgcCA9IFwiW29iamVjdCBCb29sZWFuXVwiLCBiID0gXCJbb2JqZWN0IERhdGVdXCIsIHggPSBcIltvYmplY3QgRXJyb3JdXCIsIE8gPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsIF8gPSBcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIsIEMgPSBcIltvYmplY3QgTWFwXVwiLCBGID0gXCJbb2JqZWN0IE51bWJlcl1cIiwgSyA9IFwiW29iamVjdCBOdWxsXVwiLCBJID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgRCA9IFwiW29iamVjdCBQcm9taXNlXVwiLCB5ID0gXCJbb2JqZWN0IFByb3h5XVwiLCB3ID0gXCJbb2JqZWN0IFJlZ0V4cF1cIiwgZiA9IFwiW29iamVjdCBTZXRdXCIsIGEgPSBcIltvYmplY3QgU3RyaW5nXVwiLCBsID0gXCJbb2JqZWN0IFN5bWJvbF1cIiwgTCA9IFwiW29iamVjdCBVbmRlZmluZWRdXCIsIHYgPSBcIltvYmplY3QgV2Vha01hcF1cIiwgUiA9IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiwgJCA9IFwiW29iamVjdCBEYXRhVmlld11cIiwgcSA9IFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCIsIG0gPSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiLCBFID0gXCJbb2JqZWN0IEludDhBcnJheV1cIiwgQiA9IFwiW29iamVjdCBJbnQxNkFycmF5XVwiLCB6ID0gXCJbb2JqZWN0IEludDMyQXJyYXldXCIsIGogPSBcIltvYmplY3QgVWludDhBcnJheV1cIiwgVSA9IFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIiwgTSA9IFwiW29iamVjdCBVaW50MTZBcnJheV1cIiwgSCA9IFwiW29iamVjdCBVaW50MzJBcnJheV1cIiwgdGUgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csIEcgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvLCBpZSA9IC9eKD86MHxbMS05XVxcZCopJC8sIFEgPSB7fTtcbiAgUVtxXSA9IFFbbV0gPSBRW0VdID0gUVtCXSA9IFFbel0gPSBRW2pdID0gUVtVXSA9IFFbTV0gPSBRW0hdID0gITAsIFFbY10gPSBRW3VdID0gUVtSXSA9IFFbcF0gPSBRWyRdID0gUVtiXSA9IFFbeF0gPSBRW09dID0gUVtDXSA9IFFbRl0gPSBRW0ldID0gUVt3XSA9IFFbZl0gPSBRW2FdID0gUVt2XSA9ICExO1xuICB2YXIgc2UgPSB0eXBlb2YgbXQgPT0gXCJvYmplY3RcIiAmJiBtdCAmJiBtdC5PYmplY3QgPT09IE9iamVjdCAmJiBtdCwgVCA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGYsIEEgPSBzZSB8fCBUIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSwgTiA9IGUgJiYgIWUubm9kZVR5cGUgJiYgZSwgaCA9IE4gJiYgITAgJiYgaSAmJiAhaS5ub2RlVHlwZSAmJiBpLCBTID0gaCAmJiBoLmV4cG9ydHMgPT09IE4sIFcgPSBTICYmIHNlLnByb2Nlc3MsIFggPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFcgJiYgVy5iaW5kaW5nICYmIFcuYmluZGluZyhcInV0aWxcIik7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9KCksIGZlID0gWCAmJiBYLmlzVHlwZWRBcnJheTtcbiAgZnVuY3Rpb24gdmUoZywgUCkge1xuICAgIGZvciAodmFyIGsgPSAtMSwgWiA9IGcgPT0gbnVsbCA/IDAgOiBnLmxlbmd0aCwgUmUgPSAwLCBhZSA9IFtdOyArK2sgPCBaOyApIHtcbiAgICAgIHZhciBMZSA9IGdba107XG4gICAgICBQKExlLCBrLCBnKSAmJiAoYWVbUmUrK10gPSBMZSk7XG4gICAgfVxuICAgIHJldHVybiBhZTtcbiAgfVxuICBmdW5jdGlvbiBnZShnLCBQKSB7XG4gICAgZm9yICh2YXIgayA9IC0xLCBaID0gUC5sZW5ndGgsIFJlID0gZy5sZW5ndGg7ICsrayA8IFo7IClcbiAgICAgIGdbUmUgKyBrXSA9IFBba107XG4gICAgcmV0dXJuIGc7XG4gIH1cbiAgZnVuY3Rpb24gU2UoZywgUCkge1xuICAgIGZvciAodmFyIGsgPSAtMSwgWiA9IGcgPT0gbnVsbCA/IDAgOiBnLmxlbmd0aDsgKytrIDwgWjsgKVxuICAgICAgaWYgKFAoZ1trXSwgaywgZykpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gTWUoZywgUCkge1xuICAgIGZvciAodmFyIGsgPSAtMSwgWiA9IEFycmF5KGcpOyArK2sgPCBnOyApXG4gICAgICBaW2tdID0gUChrKTtcbiAgICByZXR1cm4gWjtcbiAgfVxuICBmdW5jdGlvbiAkZShnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKFApIHtcbiAgICAgIHJldHVybiBnKFApO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYmUoZywgUCkge1xuICAgIHJldHVybiBnLmhhcyhQKTtcbiAgfVxuICBmdW5jdGlvbiB5ZShnLCBQKSB7XG4gICAgcmV0dXJuIGc/LltQXTtcbiAgfVxuICBmdW5jdGlvbiBwZShnKSB7XG4gICAgdmFyIFAgPSAtMSwgayA9IEFycmF5KGcuc2l6ZSk7XG4gICAgcmV0dXJuIGcuZm9yRWFjaChmdW5jdGlvbihaLCBSZSkge1xuICAgICAga1srK1BdID0gW1JlLCBaXTtcbiAgICB9KSwgaztcbiAgfVxuICBmdW5jdGlvbiBsZShnLCBQKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGspIHtcbiAgICAgIHJldHVybiBnKFAoaykpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdWUoZykge1xuICAgIHZhciBQID0gLTEsIGsgPSBBcnJheShnLnNpemUpO1xuICAgIHJldHVybiBnLmZvckVhY2goZnVuY3Rpb24oWikge1xuICAgICAga1srK1BdID0gWjtcbiAgICB9KSwgaztcbiAgfVxuICB2YXIgaGUgPSBBcnJheS5wcm90b3R5cGUsIGNlID0gRnVuY3Rpb24ucHJvdG90eXBlLCByZSA9IE9iamVjdC5wcm90b3R5cGUsIGRlID0gQVtcIl9fY29yZS1qc19zaGFyZWRfX1wiXSwgbWUgPSBjZS50b1N0cmluZywgbmUgPSByZS5oYXNPd25Qcm9wZXJ0eSwgX2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZyA9IC9bXi5dKyQvLmV4ZWMoZGUgJiYgZGUua2V5cyAmJiBkZS5rZXlzLklFX1BST1RPIHx8IFwiXCIpO1xuICAgIHJldHVybiBnID8gXCJTeW1ib2woc3JjKV8xLlwiICsgZyA6IFwiXCI7XG4gIH0oKSwgRWUgPSByZS50b1N0cmluZywgRGUgPSBSZWdFeHAoXG4gICAgXCJeXCIgKyBtZS5jYWxsKG5lKS5yZXBsYWNlKHRlLCBcIlxcXFwkJlwiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCBcIiQxLio/XCIpICsgXCIkXCJcbiAgKSwgeGUgPSBTID8gQS5CdWZmZXIgOiB2b2lkIDAsIEllID0gQS5TeW1ib2wsIFV0ID0gQS5VaW50OEFycmF5LCBxdCA9IHJlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBzaSA9IGhlLnNwbGljZSwgRHQgPSBJZSA/IEllLnRvU3RyaW5nVGFnIDogdm9pZCAwLCBmaSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIEtpID0geGUgPyB4ZS5pc0J1ZmZlciA6IHZvaWQgMCwgT3MgPSBsZShPYmplY3Qua2V5cywgT2JqZWN0KSwgcWUgPSBQaShBLCBcIkRhdGFWaWV3XCIpLCBGZSA9IFBpKEEsIFwiTWFwXCIpLCBqZSA9IFBpKEEsIFwiUHJvbWlzZVwiKSwgemUgPSBQaShBLCBcIlNldFwiKSwgS2UgPSBQaShBLCBcIldlYWtNYXBcIiksIFVlID0gUGkoT2JqZWN0LCBcImNyZWF0ZVwiKSwgUWUgPSBnaShxZSksIFhlID0gZ2koRmUpLCBaZSA9IGdpKGplKSwgZXQgPSBnaSh6ZSksIHR0ID0gZ2koS2UpLCBZZSA9IEllID8gSWUucHJvdG90eXBlIDogdm9pZCAwLCBWZSA9IFllID8gWWUudmFsdWVPZiA6IHZvaWQgMDtcbiAgZnVuY3Rpb24gQWUoZykge1xuICAgIHZhciBQID0gLTEsIGsgPSBnID09IG51bGwgPyAwIDogZy5sZW5ndGg7XG4gICAgZm9yICh0aGlzLmNsZWFyKCk7ICsrUCA8IGs7ICkge1xuICAgICAgdmFyIFogPSBnW1BdO1xuICAgICAgdGhpcy5zZXQoWlswXSwgWlsxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGl0KCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBVZSA/IFVlKG51bGwpIDoge30sIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gc3QoZykge1xuICAgIHZhciBQID0gdGhpcy5oYXMoZykgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19bZ107XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSAtPSBQID8gMSA6IDAsIFA7XG4gIH1cbiAgZnVuY3Rpb24ga2goZykge1xuICAgIHZhciBQID0gdGhpcy5fX2RhdGFfXztcbiAgICBpZiAoVWUpIHtcbiAgICAgIHZhciBrID0gUFtnXTtcbiAgICAgIHJldHVybiBrID09PSBzID8gdm9pZCAwIDogaztcbiAgICB9XG4gICAgcmV0dXJuIG5lLmNhbGwoUCwgZykgPyBQW2ddIDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIEhoKGcpIHtcbiAgICB2YXIgUCA9IHRoaXMuX19kYXRhX187XG4gICAgcmV0dXJuIFVlID8gUFtnXSAhPT0gdm9pZCAwIDogbmUuY2FsbChQLCBnKTtcbiAgfVxuICBmdW5jdGlvbiBHaChnLCBQKSB7XG4gICAgdmFyIGsgPSB0aGlzLl9fZGF0YV9fO1xuICAgIHJldHVybiB0aGlzLnNpemUgKz0gdGhpcy5oYXMoZykgPyAwIDogMSwga1tnXSA9IFVlICYmIFAgPT09IHZvaWQgMCA/IHMgOiBQLCB0aGlzO1xuICB9XG4gIEFlLnByb3RvdHlwZS5jbGVhciA9IGl0LCBBZS5wcm90b3R5cGUuZGVsZXRlID0gc3QsIEFlLnByb3RvdHlwZS5nZXQgPSBraCwgQWUucHJvdG90eXBlLmhhcyA9IEhoLCBBZS5wcm90b3R5cGUuc2V0ID0gR2g7XG4gIGZ1bmN0aW9uIFl0KGcpIHtcbiAgICB2YXIgUCA9IC0xLCBrID0gZyA9PSBudWxsID8gMCA6IGcubGVuZ3RoO1xuICAgIGZvciAodGhpcy5jbGVhcigpOyArK1AgPCBrOyApIHtcbiAgICAgIHZhciBaID0gZ1tQXTtcbiAgICAgIHRoaXMuc2V0KFpbMF0sIFpbMV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBXaCgpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gW10sIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gWWgoZykge1xuICAgIHZhciBQID0gdGhpcy5fX2RhdGFfXywgayA9IFBzKFAsIGcpO1xuICAgIGlmIChrIDwgMClcbiAgICAgIHJldHVybiAhMTtcbiAgICB2YXIgWiA9IFAubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gayA9PSBaID8gUC5wb3AoKSA6IHNpLmNhbGwoUCwgaywgMSksIC0tdGhpcy5zaXplLCAhMDtcbiAgfVxuICBmdW5jdGlvbiBKaChnKSB7XG4gICAgdmFyIFAgPSB0aGlzLl9fZGF0YV9fLCBrID0gUHMoUCwgZyk7XG4gICAgcmV0dXJuIGsgPCAwID8gdm9pZCAwIDogUFtrXVsxXTtcbiAgfVxuICBmdW5jdGlvbiBRaChnKSB7XG4gICAgcmV0dXJuIFBzKHRoaXMuX19kYXRhX18sIGcpID4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gWGgoZywgUCkge1xuICAgIHZhciBrID0gdGhpcy5fX2RhdGFfXywgWiA9IFBzKGssIGcpO1xuICAgIHJldHVybiBaIDwgMCA/ICgrK3RoaXMuc2l6ZSwgay5wdXNoKFtnLCBQXSkpIDoga1taXVsxXSA9IFAsIHRoaXM7XG4gIH1cbiAgWXQucHJvdG90eXBlLmNsZWFyID0gV2gsIFl0LnByb3RvdHlwZS5kZWxldGUgPSBZaCwgWXQucHJvdG90eXBlLmdldCA9IEpoLCBZdC5wcm90b3R5cGUuaGFzID0gUWgsIFl0LnByb3RvdHlwZS5zZXQgPSBYaDtcbiAgZnVuY3Rpb24gcGkoZykge1xuICAgIHZhciBQID0gLTEsIGsgPSBnID09IG51bGwgPyAwIDogZy5sZW5ndGg7XG4gICAgZm9yICh0aGlzLmNsZWFyKCk7ICsrUCA8IGs7ICkge1xuICAgICAgdmFyIFogPSBnW1BdO1xuICAgICAgdGhpcy5zZXQoWlswXSwgWlsxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFpoKCkge1xuICAgIHRoaXMuc2l6ZSA9IDAsIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICBoYXNoOiBuZXcgQWUoKSxcbiAgICAgIG1hcDogbmV3IChGZSB8fCBZdCkoKSxcbiAgICAgIHN0cmluZzogbmV3IEFlKClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGV1KGcpIHtcbiAgICB2YXIgUCA9IFJzKHRoaXMsIGcpLmRlbGV0ZShnKTtcbiAgICByZXR1cm4gdGhpcy5zaXplIC09IFAgPyAxIDogMCwgUDtcbiAgfVxuICBmdW5jdGlvbiB0dShnKSB7XG4gICAgcmV0dXJuIFJzKHRoaXMsIGcpLmdldChnKTtcbiAgfVxuICBmdW5jdGlvbiBpdShnKSB7XG4gICAgcmV0dXJuIFJzKHRoaXMsIGcpLmhhcyhnKTtcbiAgfVxuICBmdW5jdGlvbiBzdShnLCBQKSB7XG4gICAgdmFyIGsgPSBScyh0aGlzLCBnKSwgWiA9IGsuc2l6ZTtcbiAgICByZXR1cm4gay5zZXQoZywgUCksIHRoaXMuc2l6ZSArPSBrLnNpemUgPT0gWiA/IDAgOiAxLCB0aGlzO1xuICB9XG4gIHBpLnByb3RvdHlwZS5jbGVhciA9IFpoLCBwaS5wcm90b3R5cGUuZGVsZXRlID0gZXUsIHBpLnByb3RvdHlwZS5nZXQgPSB0dSwgcGkucHJvdG90eXBlLmhhcyA9IGl1LCBwaS5wcm90b3R5cGUuc2V0ID0gc3U7XG4gIGZ1bmN0aW9uIE5zKGcpIHtcbiAgICB2YXIgUCA9IC0xLCBrID0gZyA9PSBudWxsID8gMCA6IGcubGVuZ3RoO1xuICAgIGZvciAodGhpcy5fX2RhdGFfXyA9IG5ldyBwaSgpOyArK1AgPCBrOyApXG4gICAgICB0aGlzLmFkZChnW1BdKTtcbiAgfVxuICBmdW5jdGlvbiBydShnKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhX18uc2V0KGcsIHMpLCB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIG51KGcpIHtcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoZyk7XG4gIH1cbiAgTnMucHJvdG90eXBlLmFkZCA9IE5zLnByb3RvdHlwZS5wdXNoID0gcnUsIE5zLnByb3RvdHlwZS5oYXMgPSBudTtcbiAgZnVuY3Rpb24gcmkoZykge1xuICAgIHZhciBQID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBZdChnKTtcbiAgICB0aGlzLnNpemUgPSBQLnNpemU7XG4gIH1cbiAgZnVuY3Rpb24gb3UoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBZdCgpLCB0aGlzLnNpemUgPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGF1KGcpIHtcbiAgICB2YXIgUCA9IHRoaXMuX19kYXRhX18sIGsgPSBQLmRlbGV0ZShnKTtcbiAgICByZXR1cm4gdGhpcy5zaXplID0gUC5zaXplLCBrO1xuICB9XG4gIGZ1bmN0aW9uIGN1KGcpIHtcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoZyk7XG4gIH1cbiAgZnVuY3Rpb24gaHUoZykge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhnKTtcbiAgfVxuICBmdW5jdGlvbiB1dShnLCBQKSB7XG4gICAgdmFyIGsgPSB0aGlzLl9fZGF0YV9fO1xuICAgIGlmIChrIGluc3RhbmNlb2YgWXQpIHtcbiAgICAgIHZhciBaID0gay5fX2RhdGFfXztcbiAgICAgIGlmICghRmUgfHwgWi5sZW5ndGggPCB0IC0gMSlcbiAgICAgICAgcmV0dXJuIFoucHVzaChbZywgUF0pLCB0aGlzLnNpemUgPSArK2suc2l6ZSwgdGhpcztcbiAgICAgIGsgPSB0aGlzLl9fZGF0YV9fID0gbmV3IHBpKFopO1xuICAgIH1cbiAgICByZXR1cm4gay5zZXQoZywgUCksIHRoaXMuc2l6ZSA9IGsuc2l6ZSwgdGhpcztcbiAgfVxuICByaS5wcm90b3R5cGUuY2xlYXIgPSBvdSwgcmkucHJvdG90eXBlLmRlbGV0ZSA9IGF1LCByaS5wcm90b3R5cGUuZ2V0ID0gY3UsIHJpLnByb3RvdHlwZS5oYXMgPSBodSwgcmkucHJvdG90eXBlLnNldCA9IHV1O1xuICBmdW5jdGlvbiBsdShnLCBQKSB7XG4gICAgdmFyIGsgPSBDcyhnKSwgWiA9ICFrICYmIHh1KGcpLCBSZSA9ICFrICYmICFaICYmIGdyKGcpLCBhZSA9ICFrICYmICFaICYmICFSZSAmJiBLbihnKSwgTGUgPSBrIHx8IFogfHwgUmUgfHwgYWUsIHJ0ID0gTGUgPyBNZShnLmxlbmd0aCwgU3RyaW5nKSA6IFtdLCBjdCA9IHJ0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBUZSBpbiBnKVxuICAgICAgKFAgfHwgbmUuY2FsbChnLCBUZSkpICYmICEoTGUgJiYgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgKFRlID09IFwibGVuZ3RoXCIgfHwgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICBSZSAmJiAoVGUgPT0gXCJvZmZzZXRcIiB8fCBUZSA9PSBcInBhcmVudFwiKSB8fCAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICBhZSAmJiAoVGUgPT0gXCJidWZmZXJcIiB8fCBUZSA9PSBcImJ5dGVMZW5ndGhcIiB8fCBUZSA9PSBcImJ5dGVPZmZzZXRcIikgfHwgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgX3UoVGUsIGN0KSkpICYmIHJ0LnB1c2goVGUpO1xuICAgIHJldHVybiBydDtcbiAgfVxuICBmdW5jdGlvbiBQcyhnLCBQKSB7XG4gICAgZm9yICh2YXIgayA9IGcubGVuZ3RoOyBrLS07IClcbiAgICAgIGlmIChNbihnW2tdWzBdLCBQKSlcbiAgICAgICAgcmV0dXJuIGs7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGZ1bmN0aW9uIGR1KGcsIFAsIGspIHtcbiAgICB2YXIgWiA9IFAoZyk7XG4gICAgcmV0dXJuIENzKGcpID8gWiA6IGdlKFosIGsoZykpO1xuICB9XG4gIGZ1bmN0aW9uIFZpKGcpIHtcbiAgICByZXR1cm4gZyA9PSBudWxsID8gZyA9PT0gdm9pZCAwID8gTCA6IEsgOiBEdCAmJiBEdCBpbiBPYmplY3QoZykgPyB3dShnKSA6IER1KGcpO1xuICB9XG4gIGZ1bmN0aW9uICRuKGcpIHtcbiAgICByZXR1cm4gQmkoZykgJiYgVmkoZykgPT0gYztcbiAgfVxuICBmdW5jdGlvbiBGbihnLCBQLCBrLCBaLCBSZSkge1xuICAgIHJldHVybiBnID09PSBQID8gITAgOiBnID09IG51bGwgfHwgUCA9PSBudWxsIHx8ICFCaShnKSAmJiAhQmkoUCkgPyBnICE9PSBnICYmIFAgIT09IFAgOiBmdShnLCBQLCBrLCBaLCBGbiwgUmUpO1xuICB9XG4gIGZ1bmN0aW9uIGZ1KGcsIFAsIGssIFosIFJlLCBhZSkge1xuICAgIHZhciBMZSA9IENzKGcpLCBydCA9IENzKFApLCBjdCA9IExlID8gdSA6IG5pKGcpLCBUZSA9IHJ0ID8gdSA6IG5pKFApO1xuICAgIGN0ID0gY3QgPT0gYyA/IEkgOiBjdCwgVGUgPSBUZSA9PSBjID8gSSA6IFRlO1xuICAgIHZhciB4dCA9IGN0ID09IEksIEx0ID0gVGUgPT0gSSwgZnQgPSBjdCA9PSBUZTtcbiAgICBpZiAoZnQgJiYgZ3IoZykpIHtcbiAgICAgIGlmICghZ3IoUCkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIExlID0gITAsIHh0ID0gITE7XG4gICAgfVxuICAgIGlmIChmdCAmJiAheHQpXG4gICAgICByZXR1cm4gYWUgfHwgKGFlID0gbmV3IHJpKCkpLCBMZSB8fCBLbihnKSA/IFVuKGcsIFAsIGssIFosIFJlLCBhZSkgOiBtdShnLCBQLCBjdCwgaywgWiwgUmUsIGFlKTtcbiAgICBpZiAoIShrICYgcikpIHtcbiAgICAgIHZhciBSdCA9IHh0ICYmIG5lLmNhbGwoZywgXCJfX3dyYXBwZWRfX1wiKSwgQ3QgPSBMdCAmJiBuZS5jYWxsKFAsIFwiX193cmFwcGVkX19cIik7XG4gICAgICBpZiAoUnQgfHwgQ3QpIHtcbiAgICAgICAgdmFyIG9pID0gUnQgPyBnLnZhbHVlKCkgOiBnLCBKdCA9IEN0ID8gUC52YWx1ZSgpIDogUDtcbiAgICAgICAgcmV0dXJuIGFlIHx8IChhZSA9IG5ldyByaSgpKSwgUmUob2ksIEp0LCBrLCBaLCBhZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdCA/IChhZSB8fCAoYWUgPSBuZXcgcmkoKSksIGJ1KGcsIFAsIGssIFosIFJlLCBhZSkpIDogITE7XG4gIH1cbiAgZnVuY3Rpb24gcHUoZykge1xuICAgIGlmICghem4oZykgfHwgU3UoZykpXG4gICAgICByZXR1cm4gITE7XG4gICAgdmFyIFAgPSBxbihnKSA/IERlIDogRztcbiAgICByZXR1cm4gUC50ZXN0KGdpKGcpKTtcbiAgfVxuICBmdW5jdGlvbiBndShnKSB7XG4gICAgcmV0dXJuIEJpKGcpICYmIGpuKGcubGVuZ3RoKSAmJiAhIVFbVmkoZyldO1xuICB9XG4gIGZ1bmN0aW9uIHl1KGcpIHtcbiAgICBpZiAoIUl1KGcpKVxuICAgICAgcmV0dXJuIE9zKGcpO1xuICAgIHZhciBQID0gW107XG4gICAgZm9yICh2YXIgayBpbiBPYmplY3QoZykpXG4gICAgICBuZS5jYWxsKGcsIGspICYmIGsgIT0gXCJjb25zdHJ1Y3RvclwiICYmIFAucHVzaChrKTtcbiAgICByZXR1cm4gUDtcbiAgfVxuICBmdW5jdGlvbiBVbihnLCBQLCBrLCBaLCBSZSwgYWUpIHtcbiAgICB2YXIgTGUgPSBrICYgciwgcnQgPSBnLmxlbmd0aCwgY3QgPSBQLmxlbmd0aDtcbiAgICBpZiAocnQgIT0gY3QgJiYgIShMZSAmJiBjdCA+IHJ0KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICB2YXIgVGUgPSBhZS5nZXQoZyk7XG4gICAgaWYgKFRlICYmIGFlLmdldChQKSlcbiAgICAgIHJldHVybiBUZSA9PSBQO1xuICAgIHZhciB4dCA9IC0xLCBMdCA9ICEwLCBmdCA9IGsgJiBuID8gbmV3IE5zKCkgOiB2b2lkIDA7XG4gICAgZm9yIChhZS5zZXQoZywgUCksIGFlLnNldChQLCBnKTsgKyt4dCA8IHJ0OyApIHtcbiAgICAgIHZhciBSdCA9IGdbeHRdLCBDdCA9IFBbeHRdO1xuICAgICAgaWYgKFopXG4gICAgICAgIHZhciBvaSA9IExlID8gWihDdCwgUnQsIHh0LCBQLCBnLCBhZSkgOiBaKFJ0LCBDdCwgeHQsIGcsIFAsIGFlKTtcbiAgICAgIGlmIChvaSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChvaSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgTHQgPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZnQpIHtcbiAgICAgICAgaWYgKCFTZShQLCBmdW5jdGlvbihKdCwgeWkpIHtcbiAgICAgICAgICBpZiAoIWJlKGZ0LCB5aSkgJiYgKFJ0ID09PSBKdCB8fCBSZShSdCwgSnQsIGssIFosIGFlKSkpXG4gICAgICAgICAgICByZXR1cm4gZnQucHVzaCh5aSk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgTHQgPSAhMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghKFJ0ID09PSBDdCB8fCBSZShSdCwgQ3QsIGssIFosIGFlKSkpIHtcbiAgICAgICAgTHQgPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhZS5kZWxldGUoZyksIGFlLmRlbGV0ZShQKSwgTHQ7XG4gIH1cbiAgZnVuY3Rpb24gbXUoZywgUCwgaywgWiwgUmUsIGFlLCBMZSkge1xuICAgIHN3aXRjaCAoaykge1xuICAgICAgY2FzZSAkOlxuICAgICAgICBpZiAoZy5ieXRlTGVuZ3RoICE9IFAuYnl0ZUxlbmd0aCB8fCBnLmJ5dGVPZmZzZXQgIT0gUC5ieXRlT2Zmc2V0KVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgZyA9IGcuYnVmZmVyLCBQID0gUC5idWZmZXI7XG4gICAgICBjYXNlIFI6XG4gICAgICAgIHJldHVybiAhKGcuYnl0ZUxlbmd0aCAhPSBQLmJ5dGVMZW5ndGggfHwgIWFlKG5ldyBVdChnKSwgbmV3IFV0KFApKSk7XG4gICAgICBjYXNlIHA6XG4gICAgICBjYXNlIGI6XG4gICAgICBjYXNlIEY6XG4gICAgICAgIHJldHVybiBNbigrZywgK1ApO1xuICAgICAgY2FzZSB4OlxuICAgICAgICByZXR1cm4gZy5uYW1lID09IFAubmFtZSAmJiBnLm1lc3NhZ2UgPT0gUC5tZXNzYWdlO1xuICAgICAgY2FzZSB3OlxuICAgICAgY2FzZSBhOlxuICAgICAgICByZXR1cm4gZyA9PSBQICsgXCJcIjtcbiAgICAgIGNhc2UgQzpcbiAgICAgICAgdmFyIHJ0ID0gcGU7XG4gICAgICBjYXNlIGY6XG4gICAgICAgIHZhciBjdCA9IFogJiByO1xuICAgICAgICBpZiAocnQgfHwgKHJ0ID0gdWUpLCBnLnNpemUgIT0gUC5zaXplICYmICFjdClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIHZhciBUZSA9IExlLmdldChnKTtcbiAgICAgICAgaWYgKFRlKVxuICAgICAgICAgIHJldHVybiBUZSA9PSBQO1xuICAgICAgICBaIHw9IG4sIExlLnNldChnLCBQKTtcbiAgICAgICAgdmFyIHh0ID0gVW4ocnQoZyksIHJ0KFApLCBaLCBSZSwgYWUsIExlKTtcbiAgICAgICAgcmV0dXJuIExlLmRlbGV0ZShnKSwgeHQ7XG4gICAgICBjYXNlIGw6XG4gICAgICAgIGlmIChWZSlcbiAgICAgICAgICByZXR1cm4gVmUuY2FsbChnKSA9PSBWZS5jYWxsKFApO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gYnUoZywgUCwgaywgWiwgUmUsIGFlKSB7XG4gICAgdmFyIExlID0gayAmIHIsIHJ0ID0gTG4oZyksIGN0ID0gcnQubGVuZ3RoLCBUZSA9IExuKFApLCB4dCA9IFRlLmxlbmd0aDtcbiAgICBpZiAoY3QgIT0geHQgJiYgIUxlKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAodmFyIEx0ID0gY3Q7IEx0LS07ICkge1xuICAgICAgdmFyIGZ0ID0gcnRbTHRdO1xuICAgICAgaWYgKCEoTGUgPyBmdCBpbiBQIDogbmUuY2FsbChQLCBmdCkpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHZhciBSdCA9IGFlLmdldChnKTtcbiAgICBpZiAoUnQgJiYgYWUuZ2V0KFApKVxuICAgICAgcmV0dXJuIFJ0ID09IFA7XG4gICAgdmFyIEN0ID0gITA7XG4gICAgYWUuc2V0KGcsIFApLCBhZS5zZXQoUCwgZyk7XG4gICAgZm9yICh2YXIgb2kgPSBMZTsgKytMdCA8IGN0OyApIHtcbiAgICAgIGZ0ID0gcnRbTHRdO1xuICAgICAgdmFyIEp0ID0gZ1tmdF0sIHlpID0gUFtmdF07XG4gICAgICBpZiAoWilcbiAgICAgICAgdmFyIFZuID0gTGUgPyBaKHlpLCBKdCwgZnQsIFAsIGcsIGFlKSA6IFooSnQsIHlpLCBmdCwgZywgUCwgYWUpO1xuICAgICAgaWYgKCEoVm4gPT09IHZvaWQgMCA/IEp0ID09PSB5aSB8fCBSZShKdCwgeWksIGssIFosIGFlKSA6IFZuKSkge1xuICAgICAgICBDdCA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9pIHx8IChvaSA9IGZ0ID09IFwiY29uc3RydWN0b3JcIik7XG4gICAgfVxuICAgIGlmIChDdCAmJiAhb2kpIHtcbiAgICAgIHZhciBBcyA9IGcuY29uc3RydWN0b3IsIFRzID0gUC5jb25zdHJ1Y3RvcjtcbiAgICAgIEFzICE9IFRzICYmIFwiY29uc3RydWN0b3JcIiBpbiBnICYmIFwiY29uc3RydWN0b3JcIiBpbiBQICYmICEodHlwZW9mIEFzID09IFwiZnVuY3Rpb25cIiAmJiBBcyBpbnN0YW5jZW9mIEFzICYmIHR5cGVvZiBUcyA9PSBcImZ1bmN0aW9uXCIgJiYgVHMgaW5zdGFuY2VvZiBUcykgJiYgKEN0ID0gITEpO1xuICAgIH1cbiAgICByZXR1cm4gYWUuZGVsZXRlKGcpLCBhZS5kZWxldGUoUCksIEN0O1xuICB9XG4gIGZ1bmN0aW9uIExuKGcpIHtcbiAgICByZXR1cm4gZHUoZywgUHUsIHZ1KTtcbiAgfVxuICBmdW5jdGlvbiBScyhnLCBQKSB7XG4gICAgdmFyIGsgPSBnLl9fZGF0YV9fO1xuICAgIHJldHVybiBFdShQKSA/IGtbdHlwZW9mIFAgPT0gXCJzdHJpbmdcIiA/IFwic3RyaW5nXCIgOiBcImhhc2hcIl0gOiBrLm1hcDtcbiAgfVxuICBmdW5jdGlvbiBQaShnLCBQKSB7XG4gICAgdmFyIGsgPSB5ZShnLCBQKTtcbiAgICByZXR1cm4gcHUoaykgPyBrIDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHd1KGcpIHtcbiAgICB2YXIgUCA9IG5lLmNhbGwoZywgRHQpLCBrID0gZ1tEdF07XG4gICAgdHJ5IHtcbiAgICAgIGdbRHRdID0gdm9pZCAwO1xuICAgICAgdmFyIFogPSAhMDtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgdmFyIFJlID0gRWUuY2FsbChnKTtcbiAgICByZXR1cm4gWiAmJiAoUCA/IGdbRHRdID0gayA6IGRlbGV0ZSBnW0R0XSksIFJlO1xuICB9XG4gIHZhciB2dSA9IGZpID8gZnVuY3Rpb24oZykge1xuICAgIHJldHVybiBnID09IG51bGwgPyBbXSA6IChnID0gT2JqZWN0KGcpLCB2ZShmaShnKSwgZnVuY3Rpb24oUCkge1xuICAgICAgcmV0dXJuIHF0LmNhbGwoZywgUCk7XG4gICAgfSkpO1xuICB9IDogUnUsIG5pID0gVmk7XG4gIChxZSAmJiBuaShuZXcgcWUobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gJCB8fCBGZSAmJiBuaShuZXcgRmUoKSkgIT0gQyB8fCBqZSAmJiBuaShqZS5yZXNvbHZlKCkpICE9IEQgfHwgemUgJiYgbmkobmV3IHplKCkpICE9IGYgfHwgS2UgJiYgbmkobmV3IEtlKCkpICE9IHYpICYmIChuaSA9IGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgUCA9IFZpKGcpLCBrID0gUCA9PSBJID8gZy5jb25zdHJ1Y3RvciA6IHZvaWQgMCwgWiA9IGsgPyBnaShrKSA6IFwiXCI7XG4gICAgaWYgKFopXG4gICAgICBzd2l0Y2ggKFopIHtcbiAgICAgICAgY2FzZSBRZTpcbiAgICAgICAgICByZXR1cm4gJDtcbiAgICAgICAgY2FzZSBYZTpcbiAgICAgICAgICByZXR1cm4gQztcbiAgICAgICAgY2FzZSBaZTpcbiAgICAgICAgICByZXR1cm4gRDtcbiAgICAgICAgY2FzZSBldDpcbiAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgY2FzZSB0dDpcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICByZXR1cm4gUDtcbiAgfSk7XG4gIGZ1bmN0aW9uIF91KGcsIFApIHtcbiAgICByZXR1cm4gUCA9IFAgPz8gbywgISFQICYmICh0eXBlb2YgZyA9PSBcIm51bWJlclwiIHx8IGllLnRlc3QoZykpICYmIGcgPiAtMSAmJiBnICUgMSA9PSAwICYmIGcgPCBQO1xuICB9XG4gIGZ1bmN0aW9uIEV1KGcpIHtcbiAgICB2YXIgUCA9IHR5cGVvZiBnO1xuICAgIHJldHVybiBQID09IFwic3RyaW5nXCIgfHwgUCA9PSBcIm51bWJlclwiIHx8IFAgPT0gXCJzeW1ib2xcIiB8fCBQID09IFwiYm9vbGVhblwiID8gZyAhPT0gXCJfX3Byb3RvX19cIiA6IGcgPT09IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gU3UoZykge1xuICAgIHJldHVybiAhIV9lICYmIF9lIGluIGc7XG4gIH1cbiAgZnVuY3Rpb24gSXUoZykge1xuICAgIHZhciBQID0gZyAmJiBnLmNvbnN0cnVjdG9yLCBrID0gdHlwZW9mIFAgPT0gXCJmdW5jdGlvblwiICYmIFAucHJvdG90eXBlIHx8IHJlO1xuICAgIHJldHVybiBnID09PSBrO1xuICB9XG4gIGZ1bmN0aW9uIER1KGcpIHtcbiAgICByZXR1cm4gRWUuY2FsbChnKTtcbiAgfVxuICBmdW5jdGlvbiBnaShnKSB7XG4gICAgaWYgKGcgIT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1lLmNhbGwoZyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBnICsgXCJcIjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBNbihnLCBQKSB7XG4gICAgcmV0dXJuIGcgPT09IFAgfHwgZyAhPT0gZyAmJiBQICE9PSBQO1xuICB9XG4gIHZhciB4dSA9ICRuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmd1bWVudHM7XG4gIH0oKSkgPyAkbiA6IGZ1bmN0aW9uKGcpIHtcbiAgICByZXR1cm4gQmkoZykgJiYgbmUuY2FsbChnLCBcImNhbGxlZVwiKSAmJiAhcXQuY2FsbChnLCBcImNhbGxlZVwiKTtcbiAgfSwgQ3MgPSBBcnJheS5pc0FycmF5O1xuICBmdW5jdGlvbiBPdShnKSB7XG4gICAgcmV0dXJuIGcgIT0gbnVsbCAmJiBqbihnLmxlbmd0aCkgJiYgIXFuKGcpO1xuICB9XG4gIHZhciBnciA9IEtpIHx8IEN1O1xuICBmdW5jdGlvbiBOdShnLCBQKSB7XG4gICAgcmV0dXJuIEZuKGcsIFApO1xuICB9XG4gIGZ1bmN0aW9uIHFuKGcpIHtcbiAgICBpZiAoIXpuKGcpKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBQID0gVmkoZyk7XG4gICAgcmV0dXJuIFAgPT0gTyB8fCBQID09IF8gfHwgUCA9PSBkIHx8IFAgPT0geTtcbiAgfVxuICBmdW5jdGlvbiBqbihnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBnID09IFwibnVtYmVyXCIgJiYgZyA+IC0xICYmIGcgJSAxID09IDAgJiYgZyA8PSBvO1xuICB9XG4gIGZ1bmN0aW9uIHpuKGcpIHtcbiAgICB2YXIgUCA9IHR5cGVvZiBnO1xuICAgIHJldHVybiBnICE9IG51bGwgJiYgKFAgPT0gXCJvYmplY3RcIiB8fCBQID09IFwiZnVuY3Rpb25cIik7XG4gIH1cbiAgZnVuY3Rpb24gQmkoZykge1xuICAgIHJldHVybiBnICE9IG51bGwgJiYgdHlwZW9mIGcgPT0gXCJvYmplY3RcIjtcbiAgfVxuICB2YXIgS24gPSBmZSA/ICRlKGZlKSA6IGd1O1xuICBmdW5jdGlvbiBQdShnKSB7XG4gICAgcmV0dXJuIE91KGcpID8gbHUoZykgOiB5dShnKTtcbiAgfVxuICBmdW5jdGlvbiBSdSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZnVuY3Rpb24gQ3UoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGkuZXhwb3J0cyA9IE51O1xufSkoUXMsIFFzLmV4cG9ydHMpO1xudmFyIEZnID0gUXMuZXhwb3J0cztcbmNvbnN0IFljID0gLyogQF9fUFVSRV9fICovIEdhKEZnKTtcbmZ1bmN0aW9uIFVnKGksIGUpIHtcbiAgaWYgKGkubGVuZ3RoID49IDI1NSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWxwaGFiZXQgdG9vIGxvbmdcIik7XG4gIGZvciAodmFyIHQgPSBuZXcgVWludDhBcnJheSgyNTYpLCBzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspXG4gICAgdFtzXSA9IDI1NTtcbiAgZm9yICh2YXIgciA9IDA7IHIgPCBpLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIG4gPSBpLmNoYXJBdChyKSwgbyA9IG4uY2hhckNvZGVBdCgwKTtcbiAgICBpZiAodFtvXSAhPT0gMjU1KVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuICsgXCIgaXMgYW1iaWd1b3VzXCIpO1xuICAgIHRbb10gPSByO1xuICB9XG4gIHZhciBjID0gaS5sZW5ndGgsIHUgPSBpLmNoYXJBdCgwKSwgZCA9IE1hdGgubG9nKGMpIC8gTWF0aC5sb2coMjU2KSwgcCA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhjKTtcbiAgZnVuY3Rpb24gYihfKSB7XG4gICAgaWYgKF8gaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoXykgPyBfID0gbmV3IFVpbnQ4QXJyYXkoXy5idWZmZXIsIF8uYnl0ZU9mZnNldCwgXy5ieXRlTGVuZ3RoKSA6IEFycmF5LmlzQXJyYXkoXykgJiYgKF8gPSBVaW50OEFycmF5LmZyb20oXykpKSwgIShfIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheVwiKTtcbiAgICBpZiAoXy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBmb3IgKHZhciBDID0gMCwgRiA9IDAsIEsgPSAwLCBJID0gXy5sZW5ndGg7IEsgIT09IEkgJiYgX1tLXSA9PT0gMDsgKVxuICAgICAgSysrLCBDKys7XG4gICAgZm9yICh2YXIgRCA9IChJIC0gSykgKiBwICsgMSA+Pj4gMCwgeSA9IG5ldyBVaW50OEFycmF5KEQpOyBLICE9PSBJOyApIHtcbiAgICAgIGZvciAodmFyIHcgPSBfW0tdLCBmID0gMCwgYSA9IEQgLSAxOyAodyAhPT0gMCB8fCBmIDwgRikgJiYgYSAhPT0gLTE7IGEtLSwgZisrKVxuICAgICAgICB3ICs9IDI1NiAqIHlbYV0gPj4+IDAsIHlbYV0gPSB3ICUgYyA+Pj4gMCwgdyA9IHcgLyBjID4+PiAwO1xuICAgICAgaWYgKHcgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi16ZXJvIGNhcnJ5XCIpO1xuICAgICAgRiA9IGYsIEsrKztcbiAgICB9XG4gICAgZm9yICh2YXIgbCA9IEQgLSBGOyBsICE9PSBEICYmIHlbbF0gPT09IDA7IClcbiAgICAgIGwrKztcbiAgICBmb3IgKHZhciBMID0gdS5yZXBlYXQoQyk7IGwgPCBEOyArK2wpXG4gICAgICBMICs9IGkuY2hhckF0KHlbbF0pO1xuICAgIHJldHVybiBMO1xuICB9XG4gIGZ1bmN0aW9uIHgoXykge1xuICAgIGlmICh0eXBlb2YgXyAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKTtcbiAgICBpZiAoXy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB2YXIgQyA9IDA7XG4gICAgaWYgKF9bQ10gIT09IFwiIFwiKSB7XG4gICAgICBmb3IgKHZhciBGID0gMCwgSyA9IDA7IF9bQ10gPT09IHU7IClcbiAgICAgICAgRisrLCBDKys7XG4gICAgICBmb3IgKHZhciBJID0gKF8ubGVuZ3RoIC0gQykgKiBkICsgMSA+Pj4gMCwgRCA9IG5ldyBVaW50OEFycmF5KEkpOyBfW0NdOyApIHtcbiAgICAgICAgdmFyIHkgPSB0W18uY2hhckNvZGVBdChDKV07XG4gICAgICAgIGlmICh5ID09PSAyNTUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciB3ID0gMCwgZiA9IEkgLSAxOyAoeSAhPT0gMCB8fCB3IDwgSykgJiYgZiAhPT0gLTE7IGYtLSwgdysrKVxuICAgICAgICAgIHkgKz0gYyAqIERbZl0gPj4+IDAsIERbZl0gPSB5ICUgMjU2ID4+PiAwLCB5ID0geSAvIDI1NiA+Pj4gMDtcbiAgICAgICAgaWYgKHkgIT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLXplcm8gY2FycnlcIik7XG4gICAgICAgIEsgPSB3LCBDKys7XG4gICAgICB9XG4gICAgICBpZiAoX1tDXSAhPT0gXCIgXCIpIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IEkgLSBLOyBhICE9PSBJICYmIERbYV0gPT09IDA7IClcbiAgICAgICAgICBhKys7XG4gICAgICAgIGZvciAodmFyIGwgPSBuZXcgVWludDhBcnJheShGICsgKEkgLSBhKSksIEwgPSBGOyBhICE9PSBJOyApXG4gICAgICAgICAgbFtMKytdID0gRFthKytdO1xuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gTyhfKSB7XG4gICAgdmFyIEMgPSB4KF8pO1xuICAgIGlmIChDKVxuICAgICAgcmV0dXJuIEM7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb24tJHtlfSBjaGFyYWN0ZXJgKTtcbiAgfVxuICByZXR1cm4geyBlbmNvZGU6IGIsIGRlY29kZVVuc2FmZTogeCwgZGVjb2RlOiBPIH07XG59XG52YXIgTGcgPSBVZywgTWcgPSBMZztcbmNvbnN0IEpjID0gKGkpID0+IHtcbiAgaWYgKGkgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGkuY29uc3RydWN0b3IubmFtZSA9PT0gXCJVaW50OEFycmF5XCIpXG4gICAgcmV0dXJuIGk7XG4gIGlmIChpIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGkpO1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGkpKVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShpLmJ1ZmZlciwgaS5ieXRlT2Zmc2V0LCBpLmJ5dGVMZW5ndGgpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGVcIik7XG59LCBxZyA9IChpKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaSksIGpnID0gKGkpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShpKTtcbmxldCB6ZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcykge1xuICAgIHRoaXMubmFtZSA9IGUsIHRoaXMucHJlZml4ID0gdCwgdGhpcy5iYXNlRW5jb2RlID0gcztcbiAgfVxuICBlbmNvZGUoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgIHJldHVybiBgJHt0aGlzLnByZWZpeH0ke3RoaXMuYmFzZUVuY29kZShlKX1gO1xuICAgIHRocm93IEVycm9yKFwiVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlXCIpO1xuICB9XG59LCBLZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcykge1xuICAgIGlmICh0aGlzLm5hbWUgPSBlLCB0aGlzLnByZWZpeCA9IHQsIHQuY29kZVBvaW50QXQoMCkgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJlZml4IGNoYXJhY3RlclwiKTtcbiAgICB0aGlzLnByZWZpeENvZGVQb2ludCA9IHQuY29kZVBvaW50QXQoMCksIHRoaXMuYmFzZURlY29kZSA9IHM7XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGUuY29kZVBvaW50QXQoMCkgIT09IHRoaXMucHJlZml4Q29kZVBvaW50KVxuICAgICAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkoZSl9LCAke3RoaXMubmFtZX0gZGVjb2RlciBvbmx5IHN1cHBvcnRzIGlucHV0cyBwcmVmaXhlZCB3aXRoICR7dGhpcy5wcmVmaXh9YCk7XG4gICAgICByZXR1cm4gdGhpcy5iYXNlRGVjb2RlKGUuc2xpY2UodGhpcy5wcmVmaXgubGVuZ3RoKSk7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBFcnJvcihcIkNhbiBvbmx5IG11bHRpYmFzZSBkZWNvZGUgc3RyaW5nc1wiKTtcbiAgfVxuICBvcihlKSB7XG4gICAgcmV0dXJuIFFjKHRoaXMsIGUpO1xuICB9XG59LCBWZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuZGVjb2RlcnMgPSBlO1xuICB9XG4gIG9yKGUpIHtcbiAgICByZXR1cm4gUWModGhpcywgZSk7XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICBjb25zdCB0ID0gZVswXSwgcyA9IHRoaXMuZGVjb2RlcnNbdF07XG4gICAgaWYgKHMpXG4gICAgICByZXR1cm4gcy5kZWNvZGUoZSk7XG4gICAgdGhyb3cgUmFuZ2VFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkoZSl9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7T2JqZWN0LmtleXModGhpcy5kZWNvZGVycyl9IGFyZSBzdXBwb3J0ZWRgKTtcbiAgfVxufTtcbmNvbnN0IFFjID0gKGksIGUpID0+IG5ldyBWZyh7IC4uLmkuZGVjb2RlcnMgfHwgeyBbaS5wcmVmaXhdOiBpIH0sIC4uLmUuZGVjb2RlcnMgfHwgeyBbZS5wcmVmaXhdOiBlIH0gfSk7XG5sZXQgQmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMsIHIpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnByZWZpeCA9IHQsIHRoaXMuYmFzZUVuY29kZSA9IHMsIHRoaXMuYmFzZURlY29kZSA9IHIsIHRoaXMuZW5jb2RlciA9IG5ldyB6ZyhlLCB0LCBzKSwgdGhpcy5kZWNvZGVyID0gbmV3IEtnKGUsIHQsIHIpO1xuICB9XG4gIGVuY29kZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoZSk7XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyLmRlY29kZShlKTtcbiAgfVxufTtcbmNvbnN0IGxyID0gKHsgbmFtZTogaSwgcHJlZml4OiBlLCBlbmNvZGU6IHQsIGRlY29kZTogcyB9KSA9PiBuZXcgQmcoaSwgZSwgdCwgcyksIFNzID0gKHsgcHJlZml4OiBpLCBuYW1lOiBlLCBhbHBoYWJldDogdCB9KSA9PiB7XG4gIGNvbnN0IHsgZW5jb2RlOiBzLCBkZWNvZGU6IHIgfSA9IE1nKHQsIGUpO1xuICByZXR1cm4gbHIoeyBwcmVmaXg6IGksIG5hbWU6IGUsIGVuY29kZTogcywgZGVjb2RlOiAobikgPT4gSmMocihuKSkgfSk7XG59LCBrZyA9IChpLCBlLCB0LCBzKSA9PiB7XG4gIGNvbnN0IHIgPSB7fTtcbiAgZm9yIChsZXQgcCA9IDA7IHAgPCBlLmxlbmd0aDsgKytwKVxuICAgIHJbZVtwXV0gPSBwO1xuICBsZXQgbiA9IGkubGVuZ3RoO1xuICBmb3IgKDsgaVtuIC0gMV0gPT09IFwiPVwiOyApXG4gICAgLS1uO1xuICBjb25zdCBvID0gbmV3IFVpbnQ4QXJyYXkobiAqIHQgLyA4IHwgMCk7XG4gIGxldCBjID0gMCwgdSA9IDAsIGQgPSAwO1xuICBmb3IgKGxldCBwID0gMDsgcCA8IG47ICsrcCkge1xuICAgIGNvbnN0IGIgPSByW2lbcF1dO1xuICAgIGlmIChiID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE5vbi0ke3N9IGNoYXJhY3RlcmApO1xuICAgIHUgPSB1IDw8IHQgfCBiLCBjICs9IHQsIGMgPj0gOCAmJiAoYyAtPSA4LCBvW2QrK10gPSAyNTUgJiB1ID4+IGMpO1xuICB9XG4gIGlmIChjID49IHQgfHwgMjU1ICYgdSA8PCA4IC0gYylcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBkYXRhXCIpO1xuICByZXR1cm4gbztcbn0sIEhnID0gKGksIGUsIHQpID0+IHtcbiAgY29uc3QgcyA9IGVbZS5sZW5ndGggLSAxXSA9PT0gXCI9XCIsIHIgPSAoMSA8PCB0KSAtIDE7XG4gIGxldCBuID0gXCJcIiwgbyA9IDAsIGMgPSAwO1xuICBmb3IgKGxldCB1ID0gMDsgdSA8IGkubGVuZ3RoOyArK3UpXG4gICAgZm9yIChjID0gYyA8PCA4IHwgaVt1XSwgbyArPSA4OyBvID4gdDsgKVxuICAgICAgbyAtPSB0LCBuICs9IGVbciAmIGMgPj4gb107XG4gIGlmIChvICYmIChuICs9IGVbciAmIGMgPDwgdCAtIG9dKSwgcylcbiAgICBmb3IgKDsgbi5sZW5ndGggKiB0ICYgNzsgKVxuICAgICAgbiArPSBcIj1cIjtcbiAgcmV0dXJuIG47XG59LCBsdCA9ICh7IG5hbWU6IGksIHByZWZpeDogZSwgYml0c1BlckNoYXI6IHQsIGFscGhhYmV0OiBzIH0pID0+IGxyKHsgcHJlZml4OiBlLCBuYW1lOiBpLCBlbmNvZGUocikge1xuICByZXR1cm4gSGcociwgcywgdCk7XG59LCBkZWNvZGUocikge1xuICByZXR1cm4ga2cociwgcywgdCwgaSk7XG59IH0pLCBHZyA9IGxyKHsgcHJlZml4OiBcIlxcMFwiLCBuYW1lOiBcImlkZW50aXR5XCIsIGVuY29kZTogKGkpID0+IGpnKGkpLCBkZWNvZGU6IChpKSA9PiBxZyhpKSB9KTtcbnZhciBXZyA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGlkZW50aXR5OiBHZyB9KTtcbmNvbnN0IFlnID0gbHQoeyBwcmVmaXg6IFwiMFwiLCBuYW1lOiBcImJhc2UyXCIsIGFscGhhYmV0OiBcIjAxXCIsIGJpdHNQZXJDaGFyOiAxIH0pO1xudmFyIEpnID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTI6IFlnIH0pO1xuY29uc3QgUWcgPSBsdCh7IHByZWZpeDogXCI3XCIsIG5hbWU6IFwiYmFzZThcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1NjdcIiwgYml0c1BlckNoYXI6IDMgfSk7XG52YXIgWGcgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlODogUWcgfSk7XG5jb25zdCBaZyA9IFNzKHsgcHJlZml4OiBcIjlcIiwgbmFtZTogXCJiYXNlMTBcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OVwiIH0pO1xudmFyIGV5ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTEwOiBaZyB9KTtcbmNvbnN0IHR5ID0gbHQoeyBwcmVmaXg6IFwiZlwiLCBuYW1lOiBcImJhc2UxNlwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmXCIsIGJpdHNQZXJDaGFyOiA0IH0pLCBpeSA9IGx0KHsgcHJlZml4OiBcIkZcIiwgbmFtZTogXCJiYXNlMTZ1cHBlclwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGXCIsIGJpdHNQZXJDaGFyOiA0IH0pO1xudmFyIHN5ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTE2OiB0eSwgYmFzZTE2dXBwZXI6IGl5IH0pO1xuY29uc3QgcnkgPSBsdCh7IHByZWZpeDogXCJiXCIsIG5hbWU6IFwiYmFzZTMyXCIsIGFscGhhYmV0OiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBueSA9IGx0KHsgcHJlZml4OiBcIkJcIiwgbmFtZTogXCJiYXNlMzJ1cHBlclwiLCBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiLCBiaXRzUGVyQ2hhcjogNSB9KSwgb3kgPSBsdCh7IHByZWZpeDogXCJjXCIsIG5hbWU6IFwiYmFzZTMycGFkXCIsIGFscGhhYmV0OiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PVwiLCBiaXRzUGVyQ2hhcjogNSB9KSwgYXkgPSBsdCh7IHByZWZpeDogXCJDXCIsIG5hbWU6IFwiYmFzZTMycGFkdXBwZXJcIiwgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBjeSA9IGx0KHsgcHJlZml4OiBcInZcIiwgbmFtZTogXCJiYXNlMzJoZXhcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZcIiwgYml0c1BlckNoYXI6IDUgfSksIGh5ID0gbHQoeyBwcmVmaXg6IFwiVlwiLCBuYW1lOiBcImJhc2UzMmhleHVwcGVyXCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWXCIsIGJpdHNQZXJDaGFyOiA1IH0pLCB1eSA9IGx0KHsgcHJlZml4OiBcInRcIiwgbmFtZTogXCJiYXNlMzJoZXhwYWRcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXY9XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBseSA9IGx0KHsgcHJlZml4OiBcIlRcIiwgbmFtZTogXCJiYXNlMzJoZXhwYWR1cHBlclwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVj1cIiwgYml0c1BlckNoYXI6IDUgfSksIGR5ID0gbHQoeyBwcmVmaXg6IFwiaFwiLCBuYW1lOiBcImJhc2UzMnpcIiwgYWxwaGFiZXQ6IFwieWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjlcIiwgYml0c1BlckNoYXI6IDUgfSk7XG52YXIgZnkgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMzI6IHJ5LCBiYXNlMzJ1cHBlcjogbnksIGJhc2UzMnBhZDogb3ksIGJhc2UzMnBhZHVwcGVyOiBheSwgYmFzZTMyaGV4OiBjeSwgYmFzZTMyaGV4dXBwZXI6IGh5LCBiYXNlMzJoZXhwYWQ6IHV5LCBiYXNlMzJoZXhwYWR1cHBlcjogbHksIGJhc2UzMno6IGR5IH0pO1xuY29uc3QgcHkgPSBTcyh7IHByZWZpeDogXCJrXCIsIG5hbWU6IFwiYmFzZTM2XCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiIH0pLCBneSA9IFNzKHsgcHJlZml4OiBcIktcIiwgbmFtZTogXCJiYXNlMzZ1cHBlclwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIiB9KTtcbnZhciB5eSA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2UzNjogcHksIGJhc2UzNnVwcGVyOiBneSB9KTtcbmNvbnN0IG15ID0gU3MoeyBuYW1lOiBcImJhc2U1OGJ0Y1wiLCBwcmVmaXg6IFwielwiLCBhbHBoYWJldDogXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCIgfSksIGJ5ID0gU3MoeyBuYW1lOiBcImJhc2U1OGZsaWNrclwiLCBwcmVmaXg6IFwiWlwiLCBhbHBoYWJldDogXCIxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaXCIgfSk7XG52YXIgd3kgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlNThidGM6IG15LCBiYXNlNThmbGlja3I6IGJ5IH0pO1xuY29uc3QgdnkgPSBsdCh7IHByZWZpeDogXCJtXCIsIG5hbWU6IFwiYmFzZTY0XCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIiwgYml0c1BlckNoYXI6IDYgfSksIF95ID0gbHQoeyBwcmVmaXg6IFwiTVwiLCBuYW1lOiBcImJhc2U2NHBhZFwiLCBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLCBiaXRzUGVyQ2hhcjogNiB9KSwgRXkgPSBsdCh7IHByZWZpeDogXCJ1XCIsIG5hbWU6IFwiYmFzZTY0dXJsXCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV9cIiwgYml0c1BlckNoYXI6IDYgfSksIFN5ID0gbHQoeyBwcmVmaXg6IFwiVVwiLCBuYW1lOiBcImJhc2U2NHVybHBhZFwiLCBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPVwiLCBiaXRzUGVyQ2hhcjogNiB9KTtcbnZhciBJeSA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2U2NDogdnksIGJhc2U2NHBhZDogX3ksIGJhc2U2NHVybDogRXksIGJhc2U2NHVybHBhZDogU3kgfSk7XG5jb25zdCBYYyA9IEFycmF5LmZyb20oXCLwn5qA8J+qkOKYhPCfm7Dwn4yM8J+MkfCfjJLwn4yT8J+MlPCfjJXwn4yW8J+Ml/CfjJjwn4yN8J+Mj/CfjI7wn5CJ4piA8J+Su/CflqXwn5K+8J+Sv/CfmILinaTwn5iN8J+ko/CfmIrwn5mP8J+SlfCfmK3wn5iY8J+RjfCfmIXwn5GP8J+YgfCflKXwn6Ww8J+SlPCfkpbwn5KZ8J+YovCfpJTwn5iG8J+ZhPCfkqrwn5iJ4pi68J+RjPCfpJfwn5Kc8J+YlPCfmI7wn5iH8J+MufCfpKbwn46J8J+SnuKcjOKcqPCfpLfwn5ix8J+YjPCfjLjwn5mM8J+Yi/Cfkpfwn5Ka8J+Yj/Cfkpvwn5mC8J+Sk/CfpKnwn5iE8J+YgPCflqTwn5iD8J+Sr/CfmYjwn5GH8J+OtvCfmJLwn6St4p2j8J+YnPCfkovwn5GA8J+YqvCfmJHwn5Kl8J+Zi/CfmJ7wn5ip8J+YofCfpKrwn5GK8J+ls/CfmKXwn6Sk8J+RifCfkoPwn5iz4pyL8J+YmvCfmJ3wn5i08J+Mn/CfmKzwn5mD8J+NgPCfjLfwn5i78J+Yk+KtkOKchfCfpbrwn4yI8J+YiPCfpJjwn5Km4pyU8J+Yo/Cfj4Pwn5KQ4pi58J+OivCfkpjwn5ig4pid8J+YlfCfjLrwn46C8J+Mu/CfmJDwn5aV8J+SnfCfmYrwn5i58J+Xo/Cfkqvwn5KA8J+RkfCfjrXwn6Se8J+Ym/CflLTwn5ik8J+MvPCfmKvimr3wn6SZ4piV8J+PhvCfpKvwn5GI8J+YrvCfmYbwn4278J+Ng/CfkLbwn5KB8J+YsvCfjL/wn6eh8J+OgeKaofCfjJ7wn46I4p2M4pyK8J+Ri/CfmLDwn6So8J+YtvCfpJ3wn5q28J+SsPCfjZPwn5Ki8J+kn/CfmYHwn5qo8J+SqPCfpKzinIjwn46A8J+NuvCfpJPwn5iZ8J+Sn/CfjLHwn5iW8J+RtvCfpbTilrbinqHinZPwn5KO8J+SuOKsh/CfmKjwn4ya8J+mi/CfmLfwn5W64pqg8J+ZhfCfmJ/wn5i18J+RjvCfpLLwn6Sg8J+kp/Cfk4zwn5S18J+ShfCfp5Dwn5C+8J+NkvCfmJfwn6SR8J+MivCfpK/wn5C34piO8J+Sp/CfmK/wn5KG8J+RhvCfjqTwn5mH8J+NkeKdhPCfjLTwn5Kj8J+QuPCfkozwn5ON8J+lgPCfpKLwn5GF8J+SofCfkqnwn5GQ8J+TuPCfkbvwn6SQ8J+krvCfjrzwn6W18J+aqfCfjY7wn42K8J+RvPCfko3wn5Oj8J+lglwiKSwgRHkgPSBYYy5yZWR1Y2UoKGksIGUsIHQpID0+IChpW3RdID0gZSwgaSksIFtdKSwgeHkgPSBYYy5yZWR1Y2UoKGksIGUsIHQpID0+IChpW2UuY29kZVBvaW50QXQoMCldID0gdCwgaSksIFtdKTtcbmZ1bmN0aW9uIE95KGkpIHtcbiAgcmV0dXJuIGkucmVkdWNlKChlLCB0KSA9PiAoZSArPSBEeVt0XSwgZSksIFwiXCIpO1xufVxuZnVuY3Rpb24gTnkoaSkge1xuICBjb25zdCBlID0gW107XG4gIGZvciAoY29uc3QgdCBvZiBpKSB7XG4gICAgY29uc3QgcyA9IHh5W3QuY29kZVBvaW50QXQoMCldO1xuICAgIGlmIChzID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi1iYXNlMjU2ZW1vamkgY2hhcmFjdGVyOiAke3R9YCk7XG4gICAgZS5wdXNoKHMpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShlKTtcbn1cbmNvbnN0IFB5ID0gbHIoeyBwcmVmaXg6IFwi8J+agFwiLCBuYW1lOiBcImJhc2UyNTZlbW9qaVwiLCBlbmNvZGU6IE95LCBkZWNvZGU6IE55IH0pO1xudmFyIFJ5ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTI1NmVtb2ppOiBQeSB9KSwgQ3kgPSBaYywgR28gPSAxMjgsIEF5ID0gMTI3LCBUeSA9IH5BeSwgJHkgPSBNYXRoLnBvdygyLCAzMSk7XG5mdW5jdGlvbiBaYyhpLCBlLCB0KSB7XG4gIGUgPSBlIHx8IFtdLCB0ID0gdCB8fCAwO1xuICBmb3IgKHZhciBzID0gdDsgaSA+PSAkeTsgKVxuICAgIGVbdCsrXSA9IGkgJiAyNTUgfCBHbywgaSAvPSAxMjg7XG4gIGZvciAoOyBpICYgVHk7IClcbiAgICBlW3QrK10gPSBpICYgMjU1IHwgR28sIGkgPj4+PSA3O1xuICByZXR1cm4gZVt0XSA9IGkgfCAwLCBaYy5ieXRlcyA9IHQgLSBzICsgMSwgZTtcbn1cbnZhciBGeSA9IFdyLCBVeSA9IDEyOCwgV28gPSAxMjc7XG5mdW5jdGlvbiBXcihpLCBzKSB7XG4gIHZhciB0ID0gMCwgcyA9IHMgfHwgMCwgciA9IDAsIG4gPSBzLCBvLCBjID0gaS5sZW5ndGg7XG4gIGRvIHtcbiAgICBpZiAobiA+PSBjKVxuICAgICAgdGhyb3cgV3IuYnl0ZXMgPSAwLCBuZXcgUmFuZ2VFcnJvcihcIkNvdWxkIG5vdCBkZWNvZGUgdmFyaW50XCIpO1xuICAgIG8gPSBpW24rK10sIHQgKz0gciA8IDI4ID8gKG8gJiBXbykgPDwgciA6IChvICYgV28pICogTWF0aC5wb3coMiwgciksIHIgKz0gNztcbiAgfSB3aGlsZSAobyA+PSBVeSk7XG4gIHJldHVybiBXci5ieXRlcyA9IG4gLSBzLCB0O1xufVxudmFyIEx5ID0gTWF0aC5wb3coMiwgNyksIE15ID0gTWF0aC5wb3coMiwgMTQpLCBxeSA9IE1hdGgucG93KDIsIDIxKSwgankgPSBNYXRoLnBvdygyLCAyOCksIHp5ID0gTWF0aC5wb3coMiwgMzUpLCBLeSA9IE1hdGgucG93KDIsIDQyKSwgVnkgPSBNYXRoLnBvdygyLCA0OSksIEJ5ID0gTWF0aC5wb3coMiwgNTYpLCBreSA9IE1hdGgucG93KDIsIDYzKSwgSHkgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiBpIDwgTHkgPyAxIDogaSA8IE15ID8gMiA6IGkgPCBxeSA/IDMgOiBpIDwgankgPyA0IDogaSA8IHp5ID8gNSA6IGkgPCBLeSA/IDYgOiBpIDwgVnkgPyA3IDogaSA8IEJ5ID8gOCA6IGkgPCBreSA/IDkgOiAxMDtcbn0sIEd5ID0geyBlbmNvZGU6IEN5LCBkZWNvZGU6IEZ5LCBlbmNvZGluZ0xlbmd0aDogSHkgfSwgZWggPSBHeTtcbmNvbnN0IFlvID0gKGksIGUsIHQgPSAwKSA9PiAoZWguZW5jb2RlKGksIGUsIHQpLCBlKSwgSm8gPSAoaSkgPT4gZWguZW5jb2RpbmdMZW5ndGgoaSksIFlyID0gKGksIGUpID0+IHtcbiAgY29uc3QgdCA9IGUuYnl0ZUxlbmd0aCwgcyA9IEpvKGkpLCByID0gcyArIEpvKHQpLCBuID0gbmV3IFVpbnQ4QXJyYXkociArIHQpO1xuICByZXR1cm4gWW8oaSwgbiwgMCksIFlvKHQsIG4sIHMpLCBuLnNldChlLCByKSwgbmV3IFd5KGksIHQsIGUsIG4pO1xufTtcbmxldCBXeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcywgcikge1xuICAgIHRoaXMuY29kZSA9IGUsIHRoaXMuc2l6ZSA9IHQsIHRoaXMuZGlnZXN0ID0gcywgdGhpcy5ieXRlcyA9IHI7XG4gIH1cbn07XG5jb25zdCB0aCA9ICh7IG5hbWU6IGksIGNvZGU6IGUsIGVuY29kZTogdCB9KSA9PiBuZXcgWXkoaSwgZSwgdCk7XG5sZXQgWXkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLmNvZGUgPSB0LCB0aGlzLmVuY29kZSA9IHM7XG4gIH1cbiAgZGlnZXN0KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmVuY29kZShlKTtcbiAgICAgIHJldHVybiB0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IFlyKHRoaXMuY29kZSwgdCkgOiB0LnRoZW4oKHMpID0+IFlyKHRoaXMuY29kZSwgcykpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGVcIik7XG4gIH1cbn07XG5jb25zdCBpaCA9IChpKSA9PiBhc3luYyAoZSkgPT4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoaSwgZSkpLCBKeSA9IHRoKHsgbmFtZTogXCJzaGEyLTI1NlwiLCBjb2RlOiAxOCwgZW5jb2RlOiBpaChcIlNIQS0yNTZcIikgfSksIFF5ID0gdGgoeyBuYW1lOiBcInNoYTItNTEyXCIsIGNvZGU6IDE5LCBlbmNvZGU6IGloKFwiU0hBLTUxMlwiKSB9KTtcbnZhciBYeSA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIHNoYTI1NjogSnksIHNoYTUxMjogUXkgfSk7XG5jb25zdCBzaCA9IDAsIFp5ID0gXCJpZGVudGl0eVwiLCByaCA9IEpjLCBlMSA9IChpKSA9PiBZcihzaCwgcmgoaSkpLCB0MSA9IHsgY29kZTogc2gsIG5hbWU6IFp5LCBlbmNvZGU6IHJoLCBkaWdlc3Q6IGUxIH07XG52YXIgaTEgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBpZGVudGl0eTogdDEgfSk7XG5uZXcgVGV4dEVuY29kZXIoKSwgbmV3IFRleHREZWNvZGVyKCk7XG5jb25zdCBRbyA9IHsgLi4uV2csIC4uLkpnLCAuLi5YZywgLi4uZXksIC4uLnN5LCAuLi5meSwgLi4ueXksIC4uLnd5LCAuLi5JeSwgLi4uUnkgfTtcbih7IC4uLlh5LCAuLi5pMSB9KTtcbmZ1bmN0aW9uIG5oKGkpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgPyBuZXcgVWludDhBcnJheShpLmJ1ZmZlciwgaS5ieXRlT2Zmc2V0LCBpLmJ5dGVMZW5ndGgpIDogaTtcbn1cbmZ1bmN0aW9uIHMxKGkgPSAwKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jVW5zYWZlICE9IG51bGwgPyBuaChnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZShpKSkgOiBuZXcgVWludDhBcnJheShpKTtcbn1cbmZ1bmN0aW9uIG9oKGksIGUsIHQsIHMpIHtcbiAgcmV0dXJuIHsgbmFtZTogaSwgcHJlZml4OiBlLCBlbmNvZGVyOiB7IG5hbWU6IGksIHByZWZpeDogZSwgZW5jb2RlOiB0IH0sIGRlY29kZXI6IHsgZGVjb2RlOiBzIH0gfTtcbn1cbmNvbnN0IFhvID0gb2goXCJ1dGY4XCIsIFwidVwiLCAoaSkgPT4gXCJ1XCIgKyBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpLmRlY29kZShpKSwgKGkpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpLnN1YnN0cmluZygxKSkpLCBPciA9IG9oKFwiYXNjaWlcIiwgXCJhXCIsIChpKSA9PiB7XG4gIGxldCBlID0gXCJhXCI7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgaS5sZW5ndGg7IHQrKylcbiAgICBlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoaVt0XSk7XG4gIHJldHVybiBlO1xufSwgKGkpID0+IHtcbiAgaSA9IGkuc3Vic3RyaW5nKDEpO1xuICBjb25zdCBlID0gczEoaS5sZW5ndGgpO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IGkubGVuZ3RoOyB0KyspXG4gICAgZVt0XSA9IGkuY2hhckNvZGVBdCh0KTtcbiAgcmV0dXJuIGU7XG59KSwgcjEgPSB7IHV0Zjg6IFhvLCBcInV0Zi04XCI6IFhvLCBoZXg6IFFvLmJhc2UxNiwgbGF0aW4xOiBPciwgYXNjaWk6IE9yLCBiaW5hcnk6IE9yLCAuLi5RbyB9O1xuZnVuY3Rpb24gbjEoaSwgZSA9IFwidXRmOFwiKSB7XG4gIGNvbnN0IHQgPSByMVtlXTtcbiAgaWYgKCF0KVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZW5jb2RpbmcgXCIke2V9XCJgKTtcbiAgcmV0dXJuIChlID09PSBcInV0ZjhcIiB8fCBlID09PSBcInV0Zi04XCIpICYmIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbSAhPSBudWxsID8gbmgoZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShpLCBcInV0Zi04XCIpKSA6IHQuZGVjb2Rlci5kZWNvZGUoYCR7dC5wcmVmaXh9JHtpfWApO1xufVxuY29uc3QgYWggPSBcIndjXCIsIG8xID0gMiwgRW4gPSBcImNvcmVcIiwgaGkgPSBgJHthaH1AMjoke0VufTpgLCBhMSA9IHsgbmFtZTogRW4sIGxvZ2dlcjogXCJlcnJvclwiIH0sIGMxID0geyBkYXRhYmFzZTogXCI6bWVtb3J5OlwiIH0sIGgxID0gXCJjcnlwdG9cIiwgWm8gPSBcImNsaWVudF9lZDI1NTE5X3NlZWRcIiwgdTEgPSBWLk9ORV9EQVksIGwxID0gXCJrZXljaGFpblwiLCBkMSA9IFwiMC4zXCIsIGYxID0gXCJtZXNzYWdlc1wiLCBwMSA9IFwiMC4zXCIsIGcxID0gVi5TSVhfSE9VUlMsIHkxID0gXCJwdWJsaXNoZXJcIiwgY2ggPSBcImlyblwiLCBtMSA9IFwiZXJyb3JcIiwgaGggPSBcIndzczovL3JlbGF5LndhbGxldGNvbm5lY3QuY29tXCIsIGVhID0gXCJ3c3M6Ly9yZWxheS53YWxsZXRjb25uZWN0Lm9yZ1wiLCBiMSA9IFwicmVsYXllclwiLCBndCA9IHsgbWVzc2FnZTogXCJyZWxheWVyX21lc3NhZ2VcIiwgbWVzc2FnZV9hY2s6IFwicmVsYXllcl9tZXNzYWdlX2Fja1wiLCBjb25uZWN0OiBcInJlbGF5ZXJfY29ubmVjdFwiLCBkaXNjb25uZWN0OiBcInJlbGF5ZXJfZGlzY29ubmVjdFwiLCBlcnJvcjogXCJyZWxheWVyX2Vycm9yXCIsIGNvbm5lY3Rpb25fc3RhbGxlZDogXCJyZWxheWVyX2Nvbm5lY3Rpb25fc3RhbGxlZFwiLCB0cmFuc3BvcnRfY2xvc2VkOiBcInJlbGF5ZXJfdHJhbnNwb3J0X2Nsb3NlZFwiLCBwdWJsaXNoOiBcInJlbGF5ZXJfcHVibGlzaFwiIH0sIHcxID0gXCJfc3Vic2NyaXB0aW9uXCIsIFp0ID0geyBwYXlsb2FkOiBcInBheWxvYWRcIiwgY29ubmVjdDogXCJjb25uZWN0XCIsIGRpc2Nvbm5lY3Q6IFwiZGlzY29ubmVjdFwiLCBlcnJvcjogXCJlcnJvclwiIH0sIHYxID0gVi5PTkVfU0VDT05ELCBfMSA9IFwiMi4xMC4xXCIsIEUxID0gMWU0LCBTMSA9IFwiMC4zXCIsIEkxID0gXCJXQUxMRVRDT05ORUNUX0NMSUVOVF9JRFwiLCBWdCA9IHsgY3JlYXRlZDogXCJzdWJzY3JpcHRpb25fY3JlYXRlZFwiLCBkZWxldGVkOiBcInN1YnNjcmlwdGlvbl9kZWxldGVkXCIsIGV4cGlyZWQ6IFwic3Vic2NyaXB0aW9uX2V4cGlyZWRcIiwgZGlzYWJsZWQ6IFwic3Vic2NyaXB0aW9uX2Rpc2FibGVkXCIsIHN5bmM6IFwic3Vic2NyaXB0aW9uX3N5bmNcIiwgcmVzdWJzY3JpYmVkOiBcInN1YnNjcmlwdGlvbl9yZXN1YnNjcmliZWRcIiB9LCBEMSA9IFwic3Vic2NyaXB0aW9uXCIsIHgxID0gXCIwLjNcIiwgTzEgPSBWLkZJVkVfU0VDT05EUyAqIDFlMywgTjEgPSBcInBhaXJpbmdcIiwgUDEgPSBcIjAuM1wiLCBYaSA9IHsgd2NfcGFpcmluZ0RlbGV0ZTogeyByZXE6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMWUzIH0sIHJlczogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMDAxIH0gfSwgd2NfcGFpcmluZ1Bpbmc6IHsgcmVxOiB7IHR0bDogVi5USElSVFlfU0VDT05EUywgcHJvbXB0OiAhMSwgdGFnOiAxMDAyIH0sIHJlczogeyB0dGw6IFYuVEhJUlRZX1NFQ09ORFMsIHByb21wdDogITEsIHRhZzogMTAwMyB9IH0sIHVucmVnaXN0ZXJlZF9tZXRob2Q6IHsgcmVxOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDAgfSwgcmVzOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDAgfSB9IH0sIG9zID0geyBjcmVhdGU6IFwicGFpcmluZ19jcmVhdGVcIiwgZXhwaXJlOiBcInBhaXJpbmdfZXhwaXJlXCIsIGRlbGV0ZTogXCJwYWlyaW5nX2RlbGV0ZVwiLCBwaW5nOiBcInBhaXJpbmdfcGluZ1wiIH0sIHp0ID0geyBjcmVhdGVkOiBcImhpc3RvcnlfY3JlYXRlZFwiLCB1cGRhdGVkOiBcImhpc3RvcnlfdXBkYXRlZFwiLCBkZWxldGVkOiBcImhpc3RvcnlfZGVsZXRlZFwiLCBzeW5jOiBcImhpc3Rvcnlfc3luY1wiIH0sIFIxID0gXCJoaXN0b3J5XCIsIEMxID0gXCIwLjNcIiwgQTEgPSBcImV4cGlyZXJcIiwgVHQgPSB7IGNyZWF0ZWQ6IFwiZXhwaXJlcl9jcmVhdGVkXCIsIGRlbGV0ZWQ6IFwiZXhwaXJlcl9kZWxldGVkXCIsIGV4cGlyZWQ6IFwiZXhwaXJlcl9leHBpcmVkXCIsIHN5bmM6IFwiZXhwaXJlcl9zeW5jXCIgfSwgVDEgPSBcIjAuM1wiLCBOciA9IFwidmVyaWZ5LWFwaVwiLCBLcyA9IFwiaHR0cHM6Ly92ZXJpZnkud2FsbGV0Y29ubmVjdC5jb21cIiwgdGEgPSBcImh0dHBzOi8vdmVyaWZ5LndhbGxldGNvbm5lY3Qub3JnXCI7XG5sZXQgJDEgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMua2V5Y2hhaW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLm5hbWUgPSBsMSwgdGhpcy52ZXJzaW9uID0gZDEsIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zdG9yYWdlUHJlZml4ID0gaGksIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICBjb25zdCBzID0gYXdhaXQgdGhpcy5nZXRLZXlDaGFpbigpO1xuICAgICAgICB0eXBlb2YgcyA8IFwidVwiICYmICh0aGlzLmtleWNoYWluID0gcyksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMDtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmhhcyA9IChzKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMua2V5Y2hhaW4uaGFzKHMpKSwgdGhpcy5zZXQgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMua2V5Y2hhaW4uc2V0KHMsIHIpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9LCB0aGlzLmdldCA9IChzKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmtleWNoYWluLmdldChzKTtcbiAgICAgIGlmICh0eXBlb2YgciA+IFwidVwiKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gWShcIk5PX01BVENISU5HX0tFWVwiLCBgJHt0aGlzLm5hbWV9OiAke3N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0sIHRoaXMuZGVsID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmtleWNoYWluLmRlbGV0ZShzKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSBlZS5nZW5lcmF0ZUNoaWxkTG9nZ2VyKHQsIHRoaXMubmFtZSk7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBzdG9yYWdlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcmVmaXggKyB0aGlzLnZlcnNpb24gKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgYXN5bmMgc2V0S2V5Q2hhaW4oZSkge1xuICAgIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBMYyhlKSk7XG4gIH1cbiAgYXN5bmMgZ2V0S2V5Q2hhaW4oKSB7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICByZXR1cm4gdHlwZW9mIGUgPCBcInVcIiA/IE1jKGUpIDogdm9pZCAwO1xuICB9XG4gIGFzeW5jIHBlcnNpc3QoKSB7XG4gICAgYXdhaXQgdGhpcy5zZXRLZXlDaGFpbih0aGlzLmtleWNoYWluKTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBZKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG59LCBGMSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcykge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5uYW1lID0gaDEsIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAoYXdhaXQgdGhpcy5rZXljaGFpbi5pbml0KCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCk7XG4gICAgfSwgdGhpcy5oYXNLZXlzID0gKHIpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5rZXljaGFpbi5oYXMocikpLCB0aGlzLmdldENsaWVudElkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5nZXRDbGllbnRTZWVkKCksIG4gPSBXcyhyKTtcbiAgICAgIHJldHVybiBhbihuLnB1YmxpY0tleSk7XG4gICAgfSwgdGhpcy5nZW5lcmF0ZUtleVBhaXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHIgPSB0cCgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0UHJpdmF0ZUtleShyLnB1YmxpY0tleSwgci5wcml2YXRlS2V5KTtcbiAgICB9LCB0aGlzLnNpZ25KV1QgPSBhc3luYyAocikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5nZXRDbGllbnRTZWVkKCksIG8gPSBXcyhuKSwgYyA9IEhyKCk7XG4gICAgICByZXR1cm4gYXdhaXQgSWMoYywgciwgdTEsIG8pO1xuICAgIH0sIHRoaXMuZ2VuZXJhdGVTaGFyZWRLZXkgPSAociwgbiwgbykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBjID0gdGhpcy5nZXRQcml2YXRlS2V5KHIpLCB1ID0gaXAoYywgbik7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTeW1LZXkodSwgbyk7XG4gICAgfSwgdGhpcy5zZXRTeW1LZXkgPSBhc3luYyAociwgbikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBvID0gbiB8fCBzcChyKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmtleWNoYWluLnNldChvLCByKSwgbztcbiAgICB9LCB0aGlzLmRlbGV0ZUtleVBhaXIgPSBhc3luYyAocikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMua2V5Y2hhaW4uZGVsKHIpO1xuICAgIH0sIHRoaXMuZGVsZXRlU3ltS2V5ID0gYXN5bmMgKHIpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmtleWNoYWluLmRlbChyKTtcbiAgICB9LCB0aGlzLmVuY29kZSA9IGFzeW5jIChyLCBuLCBvKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IGMgPSBVYyhvKSwgdSA9IHJyKG4pO1xuICAgICAgaWYgKFJvKGMpKSB7XG4gICAgICAgIGNvbnN0IHggPSBjLnNlbmRlclB1YmxpY0tleSwgTyA9IGMucmVjZWl2ZXJQdWJsaWNLZXk7XG4gICAgICAgIHIgPSBhd2FpdCB0aGlzLmdlbmVyYXRlU2hhcmVkS2V5KHgsIE8pO1xuICAgICAgfVxuICAgICAgY29uc3QgZCA9IHRoaXMuZ2V0U3ltS2V5KHIpLCB7IHR5cGU6IHAsIHNlbmRlclB1YmxpY0tleTogYiB9ID0gYztcbiAgICAgIHJldHVybiBucCh7IHR5cGU6IHAsIHN5bUtleTogZCwgbWVzc2FnZTogdSwgc2VuZGVyUHVibGljS2V5OiBiIH0pO1xuICAgIH0sIHRoaXMuZGVjb2RlID0gYXN5bmMgKHIsIG4sIG8pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgYyA9IGNwKG4sIG8pO1xuICAgICAgaWYgKFJvKGMpKSB7XG4gICAgICAgIGNvbnN0IHUgPSBjLnJlY2VpdmVyUHVibGljS2V5LCBkID0gYy5zZW5kZXJQdWJsaWNLZXk7XG4gICAgICAgIHIgPSBhd2FpdCB0aGlzLmdlbmVyYXRlU2hhcmVkS2V5KHUsIGQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdSA9IHRoaXMuZ2V0U3ltS2V5KHIpLCBkID0gb3AoeyBzeW1LZXk6IHUsIGVuY29kZWQ6IG4gfSk7XG4gICAgICAgIHJldHVybiBybihkKTtcbiAgICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBkZWNvZGUgbWVzc2FnZSBmcm9tIHRvcGljOiAnJHtyfScsIGNsaWVudElkOiAnJHthd2FpdCB0aGlzLmdldENsaWVudElkKCl9J2ApLCB0aGlzLmxvZ2dlci5lcnJvcih1KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmdldFBheWxvYWRUeXBlID0gKHIpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBZcyhyKTtcbiAgICAgIHJldHVybiB3cyhuLnR5cGUpO1xuICAgIH0sIHRoaXMuZ2V0UGF5bG9hZFNlbmRlclB1YmxpY0tleSA9IChyKSA9PiB7XG4gICAgICBjb25zdCBuID0gWXMocik7XG4gICAgICByZXR1cm4gbi5zZW5kZXJQdWJsaWNLZXkgPyBOZShuLnNlbmRlclB1YmxpY0tleSwgdnQpIDogdm9pZCAwO1xuICAgIH0sIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLmtleWNoYWluID0gcyB8fCBuZXcgJDEodGhpcy5jb3JlLCB0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGFzeW5jIHNldFByaXZhdGVLZXkoZSwgdCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmtleWNoYWluLnNldChlLCB0KSwgZTtcbiAgfVxuICBnZXRQcml2YXRlS2V5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5rZXljaGFpbi5nZXQoZSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xpZW50U2VlZCgpIHtcbiAgICBsZXQgZSA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIGUgPSB0aGlzLmtleWNoYWluLmdldChabyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBlID0gSHIoKSwgYXdhaXQgdGhpcy5rZXljaGFpbi5zZXQoWm8sIGUpO1xuICAgIH1cbiAgICByZXR1cm4gbjEoZSwgXCJiYXNlMTZcIik7XG4gIH1cbiAgZ2V0U3ltS2V5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5rZXljaGFpbi5nZXQoZSk7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gWShcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxufSwgVTEgPSBjbGFzcyBleHRlbmRzIGdsIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmxvZ2dlciA9IGUsIHRoaXMuY29yZSA9IHQsIHRoaXMubWVzc2FnZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLm5hbWUgPSBmMSwgdGhpcy52ZXJzaW9uID0gcDEsIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zdG9yYWdlUHJlZml4ID0gaGksIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHMgPSBhd2FpdCB0aGlzLmdldFJlbGF5ZXJNZXNzYWdlcygpO1xuICAgICAgICAgIHR5cGVvZiBzIDwgXCJ1XCIgJiYgKHRoaXMubWVzc2FnZXMgPSBzKSwgdGhpcy5sb2dnZXIuZGVidWcoYFN1Y2Nlc3NmdWxseSBSZXN0b3JlZCByZWNvcmRzIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicmVzdG9yZVwiLCBzaXplOiB0aGlzLm1lc3NhZ2VzLnNpemUgfSk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmFpbGVkIHRvIFJlc3RvcmUgcmVjb3JkcyBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLmVycm9yKHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMuc2V0ID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgbiA9IEZpKHIpO1xuICAgICAgbGV0IG8gPSB0aGlzLm1lc3NhZ2VzLmdldChzKTtcbiAgICAgIHJldHVybiB0eXBlb2YgbyA+IFwidVwiICYmIChvID0ge30pLCB0eXBlb2Ygb1tuXSA8IFwidVwiIHx8IChvW25dID0gciwgdGhpcy5tZXNzYWdlcy5zZXQocywgbyksIGF3YWl0IHRoaXMucGVyc2lzdCgpKSwgbjtcbiAgICB9LCB0aGlzLmdldCA9IChzKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGxldCByID0gdGhpcy5tZXNzYWdlcy5nZXQocyk7XG4gICAgICByZXR1cm4gdHlwZW9mIHIgPiBcInVcIiAmJiAociA9IHt9KSwgcjtcbiAgICB9LCB0aGlzLmhhcyA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmdldChzKSwgbyA9IEZpKHIpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBuW29dIDwgXCJ1XCI7XG4gICAgfSwgdGhpcy5kZWwgPSBhc3luYyAocykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubWVzc2FnZXMuZGVsZXRlKHMpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9LCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIoZSwgdGhpcy5uYW1lKSwgdGhpcy5jb3JlID0gdDtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIFwiLy9cIiArIHRoaXMubmFtZTtcbiAgfVxuICBhc3luYyBzZXRSZWxheWVyTWVzc2FnZXMoZSkge1xuICAgIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBMYyhlKSk7XG4gIH1cbiAgYXN5bmMgZ2V0UmVsYXllck1lc3NhZ2VzKCkge1xuICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgcmV0dXJuIHR5cGVvZiBlIDwgXCJ1XCIgPyBNYyhlKSA6IHZvaWQgMDtcbiAgfVxuICBhc3luYyBwZXJzaXN0KCkge1xuICAgIGF3YWl0IHRoaXMuc2V0UmVsYXllck1lc3NhZ2VzKHRoaXMubWVzc2FnZXMpO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IFkoXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn0sIEwxID0gY2xhc3MgZXh0ZW5kcyB5bCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5uYW1lID0geTEsIHRoaXMucXVldWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnB1Ymxpc2hUaW1lb3V0ID0gVi50b01pbGlzZWNvbmRzKFYuVEVOX1NFQ09ORFMpLCB0aGlzLm5lZWRzVHJhbnNwb3J0UmVzdGFydCA9ICExLCB0aGlzLnB1Ymxpc2ggPSBhc3luYyAocywgciwgbikgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlB1Ymxpc2hpbmcgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicHVibGlzaFwiLCBwYXJhbXM6IHsgdG9waWM6IHMsIG1lc3NhZ2U6IHIsIG9wdHM6IG4gfSB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGMgPSBuPy50dGwgfHwgZzEsIHUgPSBHcihuKSwgZCA9IG4/LnByb21wdCB8fCAhMSwgcCA9IG4/LnRhZyB8fCAwLCBiID0gbj8uaWQgfHwgdm4oKS50b1N0cmluZygpLCB4ID0geyB0b3BpYzogcywgbWVzc2FnZTogciwgb3B0czogeyB0dGw6IGMsIHJlbGF5OiB1LCBwcm9tcHQ6IGQsIHRhZzogcCwgaWQ6IGIgfSB9LCBPID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnF1ZXVlLnNldChiLCB4KSwgdGhpcy5wdWJsaXNoVGltZW91dCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgYXdhaXQgZHModGhpcy5ycGNQdWJsaXNoKHMsIHIsIGMsIHUsIGQsIHAsIGIpLCB0aGlzLnB1Ymxpc2hUaW1lb3V0LCBcIkZhaWxlZCB0byBwdWJsaXNoIHBheWxvYWQsIHBsZWFzZSB0cnkgYWdhaW4uXCIpLCB0aGlzLnJlbW92ZVJlcXVlc3RGcm9tUXVldWUoYiksIHRoaXMucmVsYXllci5ldmVudHMuZW1pdChndC5wdWJsaXNoLCB4KTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIGlmICh0aGlzLmxvZ2dlci5kZWJ1ZyhcIlB1Ymxpc2hpbmcgUGF5bG9hZCBzdGFsbGVkXCIpLCB0aGlzLm5lZWRzVHJhbnNwb3J0UmVzdGFydCA9ICEwLCAobyA9IG4/LmludGVybmFsKSAhPSBudWxsICYmIG8udGhyb3dPbkZhaWxlZFB1Ymxpc2gpXG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJlbW92ZVJlcXVlc3RGcm9tUXVldWUoYiksIF87XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChPKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN1Y2Nlc3NmdWxseSBQdWJsaXNoZWQgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicHVibGlzaFwiLCBwYXJhbXM6IHsgdG9waWM6IHMsIG1lc3NhZ2U6IHIsIG9wdHM6IG4gfSB9KTtcbiAgICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZGVidWcoXCJGYWlsZWQgdG8gUHVibGlzaCBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci5lcnJvcihjKSwgYztcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uKHMsIHIpO1xuICAgIH0sIHRoaXMub25jZSA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbmNlKHMsIHIpO1xuICAgIH0sIHRoaXMub2ZmID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9mZihzLCByKTtcbiAgICB9LCB0aGlzLnJlbW92ZUxpc3RlbmVyID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHMsIHIpO1xuICAgIH0sIHRoaXMucmVsYXllciA9IGUsIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgcnBjUHVibGlzaChlLCB0LCBzLCByLCBuLCBvLCBjKSB7XG4gICAgdmFyIHUsIGQsIHAsIGI7XG4gICAgY29uc3QgeCA9IHsgbWV0aG9kOiBqcyhyLnByb3RvY29sKS5wdWJsaXNoLCBwYXJhbXM6IHsgdG9waWM6IGUsIG1lc3NhZ2U6IHQsIHR0bDogcywgcHJvbXB0OiBuLCB0YWc6IG8gfSwgaWQ6IGMgfTtcbiAgICByZXR1cm4gYnQoKHUgPSB4LnBhcmFtcykgPT0gbnVsbCA/IHZvaWQgMCA6IHUucHJvbXB0KSAmJiAoKGQgPSB4LnBhcmFtcykgPT0gbnVsbCB8fCBkZWxldGUgZC5wcm9tcHQpLCBidCgocCA9IHgucGFyYW1zKSA9PSBudWxsID8gdm9pZCAwIDogcC50YWcpICYmICgoYiA9IHgucGFyYW1zKSA9PSBudWxsIHx8IGRlbGV0ZSBiLnRhZyksIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1lc3NhZ2VcIiwgZGlyZWN0aW9uOiBcIm91dGdvaW5nXCIsIHJlcXVlc3Q6IHggfSksIHRoaXMucmVsYXllci5yZXF1ZXN0KHgpO1xuICB9XG4gIHJlbW92ZVJlcXVlc3RGcm9tUXVldWUoZSkge1xuICAgIHRoaXMucXVldWUuZGVsZXRlKGUpO1xuICB9XG4gIGNoZWNrUXVldWUoKSB7XG4gICAgdGhpcy5xdWV1ZS5mb3JFYWNoKGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiB0LCBtZXNzYWdlOiBzLCBvcHRzOiByIH0gPSBlO1xuICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoKHQsIHMsIHIpO1xuICAgIH0pO1xuICB9XG4gIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5yZWxheWVyLmNvcmUuaGVhcnRiZWF0Lm9uKFd0LkhFQVJUQkVBVF9FVkVOVFMucHVsc2UsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLm5lZWRzVHJhbnNwb3J0UmVzdGFydCkge1xuICAgICAgICB0aGlzLm5lZWRzVHJhbnNwb3J0UmVzdGFydCA9ICExLCB0aGlzLnJlbGF5ZXIuZXZlbnRzLmVtaXQoZ3QuY29ubmVjdGlvbl9zdGFsbGVkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja1F1ZXVlKCk7XG4gICAgfSksIHRoaXMucmVsYXllci5vbihndC5tZXNzYWdlX2FjaywgKGUpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlUmVxdWVzdEZyb21RdWV1ZShlLmlkLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xuICB9XG59LCBNMSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnNldCA9IChlLCB0KSA9PiB7XG4gICAgICBjb25zdCBzID0gdGhpcy5nZXQoZSk7XG4gICAgICB0aGlzLmV4aXN0cyhlLCB0KSB8fCB0aGlzLm1hcC5zZXQoZSwgWy4uLnMsIHRdKTtcbiAgICB9LCB0aGlzLmdldCA9IChlKSA9PiB0aGlzLm1hcC5nZXQoZSkgfHwgW10sIHRoaXMuZXhpc3RzID0gKGUsIHQpID0+IHRoaXMuZ2V0KGUpLmluY2x1ZGVzKHQpLCB0aGlzLmRlbGV0ZSA9IChlLCB0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHQgPiBcInVcIikge1xuICAgICAgICB0aGlzLm1hcC5kZWxldGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5tYXAuaGFzKGUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBzID0gdGhpcy5nZXQoZSk7XG4gICAgICBpZiAoIXRoaXMuZXhpc3RzKGUsIHQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gcy5maWx0ZXIoKG4pID0+IG4gIT09IHQpO1xuICAgICAgaWYgKCFyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm1hcC5kZWxldGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwLnNldChlLCByKTtcbiAgICB9LCB0aGlzLmNsZWFyID0gKCkgPT4ge1xuICAgICAgdGhpcy5tYXAuY2xlYXIoKTtcbiAgICB9O1xuICB9XG4gIGdldCB0b3BpY3MoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAua2V5cygpKTtcbiAgfVxufTtcbnZhciBxMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgajEgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgejEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgaWEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBLMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIFYxID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgc2EgPSAoaSwgZSwgdCkgPT4gZSBpbiBpID8gcTEoaSwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGlbZV0gPSB0LCBaaSA9IChpLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICBLMS5jYWxsKGUsIHQpICYmIHNhKGksIHQsIGVbdF0pO1xuICBpZiAoaWEpXG4gICAgZm9yICh2YXIgdCBvZiBpYShlKSlcbiAgICAgIFYxLmNhbGwoZSwgdCkgJiYgc2EoaSwgdCwgZVt0XSk7XG4gIHJldHVybiBpO1xufSwgUHIgPSAoaSwgZSkgPT4gajEoaSwgejEoZSkpO1xubGV0IEIxID0gY2xhc3MgZXh0ZW5kcyB3bCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnRvcGljTWFwID0gbmV3IE0xKCksIHRoaXMuZXZlbnRzID0gbmV3IFdlLkV2ZW50RW1pdHRlcigpLCB0aGlzLm5hbWUgPSBEMSwgdGhpcy52ZXJzaW9uID0geDEsIHRoaXMucGVuZGluZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9uV2F0Y2hMYWJlbCA9IFwicGVuZGluZ19zdWJfd2F0Y2hfbGFiZWxcIiwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwgPSAyMCwgdGhpcy5zdG9yYWdlUHJlZml4ID0gaGksIHRoaXMuc3Vic2NyaWJlVGltZW91dCA9IDFlNCwgdGhpcy5yZXN0YXJ0SW5Qcm9ncmVzcyA9ICExLCB0aGlzLmJhdGNoU3Vic2NyaWJlVG9waWNzTGltaXQgPSA1MDAsIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIiksIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLmNsaWVudElkID0gYXdhaXQgdGhpcy5yZWxheWVyLmNvcmUuY3J5cHRvLmdldENsaWVudElkKCkpO1xuICAgIH0sIHRoaXMuc3Vic2NyaWJlID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRvQ29tcGxldGUoKSwgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3Vic2NyaWJpbmcgVG9waWNcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInN1YnNjcmliZVwiLCBwYXJhbXM6IHsgdG9waWM6IHMsIG9wdHM6IHIgfSB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG4gPSBHcihyKSwgbyA9IHsgdG9waWM6IHMsIHJlbGF5OiBuIH07XG4gICAgICAgIHRoaXMucGVuZGluZy5zZXQocywgbyk7XG4gICAgICAgIGNvbnN0IGMgPSBhd2FpdCB0aGlzLnJwY1N1YnNjcmliZShzLCBuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25TdWJzY3JpYmUoYywgbyksIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3VjY2Vzc2Z1bGx5IFN1YnNjcmliZWQgVG9waWNcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInN1YnNjcmliZVwiLCBwYXJhbXM6IHsgdG9waWM6IHMsIG9wdHM6IHIgfSB9KSwgYztcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZGVidWcoXCJGYWlsZWQgdG8gU3Vic2NyaWJlIFRvcGljXCIpLCB0aGlzLmxvZ2dlci5lcnJvcihuKSwgbjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnVuc3Vic2NyaWJlID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRvQ29tcGxldGUoKSwgdGhpcy5pc0luaXRpYWxpemVkKCksIHR5cGVvZiByPy5pZCA8IFwidVwiID8gYXdhaXQgdGhpcy51bnN1YnNjcmliZUJ5SWQocywgci5pZCwgcikgOiBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlQnlUb3BpYyhzLCByKTtcbiAgICB9LCB0aGlzLmlzU3Vic2NyaWJlZCA9IGFzeW5jIChzKSA9PiB0aGlzLnRvcGljcy5pbmNsdWRlcyhzKSA/ICEwIDogYXdhaXQgbmV3IFByb21pc2UoKHIsIG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSBuZXcgVi5XYXRjaCgpO1xuICAgICAgby5zdGFydCh0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25XYXRjaExhYmVsKTtcbiAgICAgIGNvbnN0IGMgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICF0aGlzLnBlbmRpbmcuaGFzKHMpICYmIHRoaXMudG9waWNzLmluY2x1ZGVzKHMpICYmIChjbGVhckludGVydmFsKGMpLCBvLnN0b3AodGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9uV2F0Y2hMYWJlbCksIHIoITApKSwgby5lbGFwc2VkKHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbldhdGNoTGFiZWwpID49IE8xICYmIChjbGVhckludGVydmFsKGMpLCBvLnN0b3AodGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9uV2F0Y2hMYWJlbCksIG4obmV3IEVycm9yKFwiU3Vic2NyaXB0aW9uIHJlc29sdXRpb24gdGltZW91dFwiKSkpO1xuICAgICAgfSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgIH0pLmNhdGNoKCgpID0+ICExKSwgdGhpcy5vbiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbihzLCByKTtcbiAgICB9LCB0aGlzLm9uY2UgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub25jZShzLCByKTtcbiAgICB9LCB0aGlzLm9mZiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vZmYocywgcik7XG4gICAgfSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihzLCByKTtcbiAgICB9LCB0aGlzLnJlc3RhcnQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLnJlc3RhcnRJblByb2dyZXNzID0gITAsIGF3YWl0IHRoaXMucmVzdG9yZSgpLCBhd2FpdCB0aGlzLnJlc2V0KCksIHRoaXMucmVzdGFydEluUHJvZ3Jlc3MgPSAhMTtcbiAgICB9LCB0aGlzLnJlbGF5ZXIgPSBlLCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy5jbGllbnRJZCA9IFwiXCI7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBzdG9yYWdlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcmVmaXggKyB0aGlzLnZlcnNpb24gKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zLnNpemU7XG4gIH1cbiAgZ2V0IGlkcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN1YnNjcmlwdGlvbnMua2V5cygpKTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKSk7XG4gIH1cbiAgZ2V0IHRvcGljcygpIHtcbiAgICByZXR1cm4gdGhpcy50b3BpY01hcC50b3BpY3M7XG4gIH1cbiAgaGFzU3Vic2NyaXB0aW9uKGUsIHQpIHtcbiAgICBsZXQgcyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBzID0gdGhpcy5nZXRTdWJzY3JpcHRpb24oZSkudG9waWMgPT09IHQ7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG4gIG9uRW5hYmxlKCkge1xuICAgIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMDtcbiAgfVxuICBvbkRpc2FibGUoKSB7XG4gICAgdGhpcy5jYWNoZWQgPSB0aGlzLnZhbHVlcywgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCksIHRoaXMudG9waWNNYXAuY2xlYXIoKTtcbiAgfVxuICBhc3luYyB1bnN1YnNjcmliZUJ5VG9waWMoZSwgdCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnRvcGljTWFwLmdldChlKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChzLm1hcChhc3luYyAocikgPT4gYXdhaXQgdGhpcy51bnN1YnNjcmliZUJ5SWQoZSwgciwgdCkpKTtcbiAgfVxuICBhc3luYyB1bnN1YnNjcmliZUJ5SWQoZSwgdCwgcykge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiVW5zdWJzY3JpYmluZyBUb3BpY1wiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwidW5zdWJzY3JpYmVcIiwgcGFyYW1zOiB7IHRvcGljOiBlLCBpZDogdCwgb3B0czogcyB9IH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByID0gR3Iocyk7XG4gICAgICBhd2FpdCB0aGlzLnJwY1Vuc3Vic2NyaWJlKGUsIHQsIHIpO1xuICAgICAgY29uc3QgbiA9IG50KFwiVVNFUl9ESVNDT05ORUNURURcIiwgYCR7dGhpcy5uYW1lfSwgJHtlfWApO1xuICAgICAgYXdhaXQgdGhpcy5vblVuc3Vic2NyaWJlKGUsIHQsIG4pLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN1Y2Nlc3NmdWxseSBVbnN1YnNjcmliZWQgVG9waWNcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInVuc3Vic2NyaWJlXCIsIHBhcmFtczogeyB0b3BpYzogZSwgaWQ6IHQsIG9wdHM6IHMgfSB9KTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICB0aHJvdyB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkZhaWxlZCB0byBVbnN1YnNjcmliZSBUb3BpY1wiKSwgdGhpcy5sb2dnZXIuZXJyb3IociksIHI7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJwY1N1YnNjcmliZShlLCB0KSB7XG4gICAgY29uc3QgcyA9IHsgbWV0aG9kOiBqcyh0LnByb3RvY29sKS5zdWJzY3JpYmUsIHBhcmFtczogeyB0b3BpYzogZSB9IH07XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJPdXRnb2luZyBSZWxheSBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwicGF5bG9hZFwiLCBkaXJlY3Rpb246IFwib3V0Z29pbmdcIiwgcmVxdWVzdDogcyB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYXdhaXQgZHModGhpcy5yZWxheWVyLnJlcXVlc3QocyksIHRoaXMuc3Vic2NyaWJlVGltZW91dCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIk91dGdvaW5nIFJlbGF5IFN1YnNjcmliZSBQYXlsb2FkIHN0YWxsZWRcIiksIHRoaXMucmVsYXllci5ldmVudHMuZW1pdChndC5jb25uZWN0aW9uX3N0YWxsZWQpO1xuICAgIH1cbiAgICByZXR1cm4gRmkoZSArIHRoaXMuY2xpZW50SWQpO1xuICB9XG4gIGFzeW5jIHJwY0JhdGNoU3Vic2NyaWJlKGUpIHtcbiAgICBpZiAoIWUubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBlWzBdLnJlbGF5LCBzID0geyBtZXRob2Q6IGpzKHQucHJvdG9jb2wpLmJhdGNoU3Vic2NyaWJlLCBwYXJhbXM6IHsgdG9waWNzOiBlLm1hcCgocikgPT4gci50b3BpYykgfSB9O1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcInBheWxvYWRcIiwgZGlyZWN0aW9uOiBcIm91dGdvaW5nXCIsIHJlcXVlc3Q6IHMgfSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhd2FpdCBkcyh0aGlzLnJlbGF5ZXIucmVxdWVzdChzKSwgdGhpcy5zdWJzY3JpYmVUaW1lb3V0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgUGF5bG9hZCBzdGFsbGVkXCIpLCB0aGlzLnJlbGF5ZXIuZXZlbnRzLmVtaXQoZ3QuY29ubmVjdGlvbl9zdGFsbGVkKTtcbiAgICB9XG4gIH1cbiAgcnBjVW5zdWJzY3JpYmUoZSwgdCwgcykge1xuICAgIGNvbnN0IHIgPSB7IG1ldGhvZDoganMocy5wcm90b2NvbCkudW5zdWJzY3JpYmUsIHBhcmFtczogeyB0b3BpYzogZSwgaWQ6IHQgfSB9O1xuICAgIHJldHVybiB0aGlzLmxvZ2dlci5kZWJ1ZyhcIk91dGdvaW5nIFJlbGF5IFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJwYXlsb2FkXCIsIGRpcmVjdGlvbjogXCJvdXRnb2luZ1wiLCByZXF1ZXN0OiByIH0pLCB0aGlzLnJlbGF5ZXIucmVxdWVzdChyKTtcbiAgfVxuICBvblN1YnNjcmliZShlLCB0KSB7XG4gICAgdGhpcy5zZXRTdWJzY3JpcHRpb24oZSwgUHIoWmkoe30sIHQpLCB7IGlkOiBlIH0pKSwgdGhpcy5wZW5kaW5nLmRlbGV0ZSh0LnRvcGljKTtcbiAgfVxuICBvbkJhdGNoU3Vic2NyaWJlKGUpIHtcbiAgICBlLmxlbmd0aCAmJiBlLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHRoaXMuc2V0U3Vic2NyaXB0aW9uKHQuaWQsIFppKHt9LCB0KSksIHRoaXMucGVuZGluZy5kZWxldGUodC50b3BpYyk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgb25VbnN1YnNjcmliZShlLCB0LCBzKSB7XG4gICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKHQpLCB0aGlzLmhhc1N1YnNjcmlwdGlvbih0LCBlKSAmJiB0aGlzLmRlbGV0ZVN1YnNjcmlwdGlvbih0LCBzKSwgYXdhaXQgdGhpcy5yZWxheWVyLm1lc3NhZ2VzLmRlbChlKTtcbiAgfVxuICBhc3luYyBzZXRSZWxheWVyU3Vic2NyaXB0aW9ucyhlKSB7XG4gICAgYXdhaXQgdGhpcy5yZWxheWVyLmNvcmUuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgZSk7XG4gIH1cbiAgYXN5bmMgZ2V0UmVsYXllclN1YnNjcmlwdGlvbnMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVsYXllci5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG4gIHNldFN1YnNjcmlwdGlvbihlLCB0KSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmhhcyhlKSB8fCAodGhpcy5sb2dnZXIuZGVidWcoXCJTZXR0aW5nIHN1YnNjcmlwdGlvblwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic2V0U3Vic2NyaXB0aW9uXCIsIGlkOiBlLCBzdWJzY3JpcHRpb246IHQgfSksIHRoaXMuYWRkU3Vic2NyaXB0aW9uKGUsIHQpKTtcbiAgfVxuICBhZGRTdWJzY3JpcHRpb24oZSwgdCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoZSwgWmkoe30sIHQpKSwgdGhpcy50b3BpY01hcC5zZXQodC50b3BpYywgZSksIHRoaXMuZXZlbnRzLmVtaXQoVnQuY3JlYXRlZCwgdCk7XG4gIH1cbiAgZ2V0U3Vic2NyaXB0aW9uKGUpIHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgc3Vic2NyaXB0aW9uXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJnZXRTdWJzY3JpcHRpb25cIiwgaWQ6IGUgfSk7XG4gICAgY29uc3QgdCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQoZSk7XG4gICAgaWYgKCF0KSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHMgfSA9IFkoXCJOT19NQVRDSElOR19LRVlcIiwgYCR7dGhpcy5uYW1lfTogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHMpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBkZWxldGVTdWJzY3JpcHRpb24oZSwgdCkge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiRGVsZXRpbmcgc3Vic2NyaXB0aW9uXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJkZWxldGVTdWJzY3JpcHRpb25cIiwgaWQ6IGUsIHJlYXNvbjogdCB9KTtcbiAgICBjb25zdCBzID0gdGhpcy5nZXRTdWJzY3JpcHRpb24oZSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShlKSwgdGhpcy50b3BpY01hcC5kZWxldGUocy50b3BpYywgZSksIHRoaXMuZXZlbnRzLmVtaXQoVnQuZGVsZXRlZCwgUHIoWmkoe30sIHMpLCB7IHJlYXNvbjogdCB9KSk7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldFJlbGF5ZXJTdWJzY3JpcHRpb25zKHRoaXMudmFsdWVzKSwgdGhpcy5ldmVudHMuZW1pdChWdC5zeW5jKTtcbiAgfVxuICBhc3luYyByZXNldCgpIHtcbiAgICBpZiAodGhpcy5jYWNoZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlID0gTWF0aC5jZWlsKHRoaXMuY2FjaGVkLmxlbmd0aCAvIHRoaXMuYmF0Y2hTdWJzY3JpYmVUb3BpY3NMaW1pdCk7XG4gICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGU7IHQrKykge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5jYWNoZWQuc3BsaWNlKDAsIHRoaXMuYmF0Y2hTdWJzY3JpYmVUb3BpY3NMaW1pdCk7XG4gICAgICAgIGF3YWl0IHRoaXMuYmF0Y2hTdWJzY3JpYmUocyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzLmVtaXQoVnQucmVzdWJzY3JpYmVkKTtcbiAgfVxuICBhc3luYyByZXN0b3JlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5nZXRSZWxheWVyU3Vic2NyaXB0aW9ucygpO1xuICAgICAgaWYgKHR5cGVvZiBlID4gXCJ1XCIgfHwgIWUubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zLnNpemUpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiUkVTVE9SRV9XSUxMX09WRVJSSURFXCIsIHRoaXMubmFtZSk7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHQpLCB0aGlzLmxvZ2dlci5lcnJvcihgJHt0aGlzLm5hbWV9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMudmFsdWVzKX1gKSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIHN1YnNjcmlwdGlvbnMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJyZXN0b3JlXCIsIHN1YnNjcmlwdGlvbnM6IHRoaXMudmFsdWVzIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gUmVzdG9yZSBzdWJzY3JpcHRpb25zIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGJhdGNoU3Vic2NyaWJlKGUpIHtcbiAgICBpZiAoIWUubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBhd2FpdCB0aGlzLnJwY0JhdGNoU3Vic2NyaWJlKGUpO1xuICAgIEVzKHQpICYmIHRoaXMub25CYXRjaFN1YnNjcmliZSh0Lm1hcCgocywgcikgPT4gUHIoWmkoe30sIGVbcl0pLCB7IGlkOiBzIH0pKSk7XG4gIH1cbiAgYXN5bmMgb25Db25uZWN0KCkge1xuICAgIHRoaXMucmVzdGFydEluUHJvZ3Jlc3MgfHwgKGF3YWl0IHRoaXMucmVzdGFydCgpLCB0aGlzLm9uRW5hYmxlKCkpO1xuICB9XG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm9uRGlzYWJsZSgpO1xuICB9XG4gIGFzeW5jIGNoZWNrUGVuZGluZygpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQgfHwgdGhpcy5yZWxheWVyLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHRoaXMucGVuZGluZy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBlLnB1c2godCk7XG4gICAgfSksIGF3YWl0IHRoaXMuYmF0Y2hTdWJzY3JpYmUoZSk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLnJlbGF5ZXIuY29yZS5oZWFydGJlYXQub24oV3QuSEVBUlRCRUFUX0VWRU5UUy5wdWxzZSwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5jaGVja1BlbmRpbmcoKTtcbiAgICB9KSwgdGhpcy5yZWxheWVyLm9uKGd0LmNvbm5lY3QsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMub25Db25uZWN0KCk7XG4gICAgfSksIHRoaXMucmVsYXllci5vbihndC5kaXNjb25uZWN0LCAoKSA9PiB7XG4gICAgICB0aGlzLm9uRGlzY29ubmVjdCgpO1xuICAgIH0pLCB0aGlzLmV2ZW50cy5vbihWdC5jcmVhdGVkLCBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IFZ0LmNyZWF0ZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgZGF0YTogZSB9KSwgYXdhaXQgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSksIHRoaXMuZXZlbnRzLm9uKFZ0LmRlbGV0ZWQsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gVnQuZGVsZXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCBkYXRhOiBlIH0pLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBZKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlc3RhcnRUb0NvbXBsZXRlKCkge1xuICAgIHRoaXMucmVzdGFydEluUHJvZ3Jlc3MgJiYgYXdhaXQgbmV3IFByb21pc2UoKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHRoaXMucmVzdGFydEluUHJvZ3Jlc3MgfHwgKGNsZWFySW50ZXJ2YWwodCksIGUoKSk7XG4gICAgICB9LCB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgazEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHJhID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgSDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBHMSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIG5hID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IGsxKGksIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW2VdID0gdCwgVzEgPSAoaSwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgSDEuY2FsbChlLCB0KSAmJiBuYShpLCB0LCBlW3RdKTtcbiAgaWYgKHJhKVxuICAgIGZvciAodmFyIHQgb2YgcmEoZSkpXG4gICAgICBHMS5jYWxsKGUsIHQpICYmIG5hKGksIHQsIGVbdF0pO1xuICByZXR1cm4gaTtcbn07XG5sZXQgWTEgPSBjbGFzcyBleHRlbmRzIG1sIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLnByb3RvY29sID0gXCJ3Y1wiLCB0aGlzLnZlcnNpb24gPSAyLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5uYW1lID0gYjEsIHRoaXMudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZCA9ICExLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuY29ubmVjdGlvbkF0dGVtcHRJblByb2dyZXNzID0gITEsIHRoaXMuY29ubmVjdGlvblN0YXR1c1BvbGxpbmdJbnRlcnZhbCA9IDIwLCB0aGlzLnN0YWxlQ29ubmVjdGlvbkVycm9ycyA9IFtcInNvY2tldCBoYW5nIHVwXCIsIFwic29ja2V0IHN0YWxsZWRcIl0sIHRoaXMuaGFzRXhwZXJpZW5jZWROZXR3b3JrRGlzcnVwdGlvbiA9ICExLCB0aGlzLnJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJQdWJsaXNoaW5nIFJlcXVlc3QgUGF5bG9hZFwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRvRXN0YWJsaXNoQ29ubmVjdGlvbigpLCBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3QodCk7XG4gICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmRlYnVnKFwiRmFpbGVkIHRvIFB1Ymxpc2ggUmVxdWVzdFwiKSwgdGhpcy5sb2dnZXIuZXJyb3IocyksIHM7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblBheWxvYWRIYW5kbGVyID0gKHQpID0+IHtcbiAgICAgIHRoaXMub25Qcm92aWRlclBheWxvYWQodCk7XG4gICAgfSwgdGhpcy5vbkNvbm5lY3RIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5ldmVudHMuZW1pdChndC5jb25uZWN0KTtcbiAgICB9LCB0aGlzLm9uRGlzY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9uUHJvdmlkZXJEaXNjb25uZWN0KCk7XG4gICAgfSwgdGhpcy5vblByb3ZpZGVyRXJyb3JIYW5kbGVyID0gKHQpID0+IHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKHQpLCB0aGlzLmV2ZW50cy5lbWl0KGd0LmVycm9yLCB0KSwgdGhpcy5sb2dnZXIuaW5mbyhcIkZhdGFsIHNvY2tldCBlcnJvciByZWNlaXZlZCwgY2xvc2luZyB0cmFuc3BvcnRcIiksIHRoaXMudHJhbnNwb3J0Q2xvc2UoKTtcbiAgICB9LCB0aGlzLnJlZ2lzdGVyUHJvdmlkZXJMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICB0aGlzLnByb3ZpZGVyLm9uKFp0LnBheWxvYWQsIHRoaXMub25QYXlsb2FkSGFuZGxlciksIHRoaXMucHJvdmlkZXIub24oWnQuY29ubmVjdCwgdGhpcy5vbkNvbm5lY3RIYW5kbGVyKSwgdGhpcy5wcm92aWRlci5vbihadC5kaXNjb25uZWN0LCB0aGlzLm9uRGlzY29ubmVjdEhhbmRsZXIpLCB0aGlzLnByb3ZpZGVyLm9uKFp0LmVycm9yLCB0aGlzLm9uUHJvdmlkZXJFcnJvckhhbmRsZXIpO1xuICAgIH0sIHRoaXMuY29yZSA9IGUuY29yZSwgdGhpcy5sb2dnZXIgPSB0eXBlb2YgZS5sb2dnZXIgPCBcInVcIiAmJiB0eXBlb2YgZS5sb2dnZXIgIT0gXCJzdHJpbmdcIiA/IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIoZS5sb2dnZXIsIHRoaXMubmFtZSkgOiBlZS5waW5vKGVlLmdldERlZmF1bHRMb2dnZXJPcHRpb25zKHsgbGV2ZWw6IGUubG9nZ2VyIHx8IG0xIH0pKSwgdGhpcy5tZXNzYWdlcyA9IG5ldyBVMSh0aGlzLmxvZ2dlciwgZS5jb3JlKSwgdGhpcy5zdWJzY3JpYmVyID0gbmV3IEIxKHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy5wdWJsaXNoZXIgPSBuZXcgTDEodGhpcywgdGhpcy5sb2dnZXIpLCB0aGlzLnJlbGF5VXJsID0gZT8ucmVsYXlVcmwgfHwgaGgsIHRoaXMucHJvamVjdElkID0gZS5wcm9qZWN0SWQsIHRoaXMucHJvdmlkZXIgPSB7fTtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIiksIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCBhd2FpdCB0aGlzLmNyZWF0ZVByb3ZpZGVyKCksIGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLm1lc3NhZ2VzLmluaXQoKSwgdGhpcy5zdWJzY3JpYmVyLmluaXQoKV0pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydE9wZW4oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oYENvbm5lY3Rpb24gdmlhICR7dGhpcy5yZWxheVVybH0gZmFpbGVkLCBhdHRlbXB0aW5nIHRvIGNvbm5lY3QgdmlhIGZhaWxvdmVyIGRvbWFpbiAke2VhfS4uLmApLCBhd2FpdCB0aGlzLnJlc3RhcnRUcmFuc3BvcnQoZWEpO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemVkID0gITAsIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5zdWJzY3JpYmVyLnRvcGljcy5sZW5ndGggPT09IDAgJiYgKHRoaXMubG9nZ2VyLmluZm8oXCJObyB0b3BpY3Mgc3Vic2NyaWJlZCB0byBhZnRlciBpbml0LCBjbG9zaW5nIHRyYW5zcG9ydFwiKSwgYXdhaXQgdGhpcy50cmFuc3BvcnRDbG9zZSgpLCB0aGlzLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQgPSAhMSk7XG4gICAgfSwgRTEpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmNvbm5lY3Rpb24uY29ubmVjdGVkO1xuICB9XG4gIGdldCBjb25uZWN0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmNvbm5lY3Rpb24uY29ubmVjdGluZztcbiAgfVxuICBhc3luYyBwdWJsaXNoKGUsIHQsIHMpIHtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5wdWJsaXNoZXIucHVibGlzaChlLCB0LCBzKSwgYXdhaXQgdGhpcy5yZWNvcmRNZXNzYWdlRXZlbnQoeyB0b3BpYzogZSwgbWVzc2FnZTogdCwgcHVibGlzaGVkQXQ6IERhdGUubm93KCkgfSk7XG4gIH1cbiAgYXN5bmMgc3Vic2NyaWJlKGUsIHQpIHtcbiAgICB2YXIgcztcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICBsZXQgciA9ICgocyA9IHRoaXMuc3Vic2NyaWJlci50b3BpY01hcC5nZXQoZSkpID09IG51bGwgPyB2b2lkIDAgOiBzWzBdKSB8fCBcIlwiO1xuICAgIHJldHVybiByIHx8IChhd2FpdCBQcm9taXNlLmFsbChbbmV3IFByb21pc2UoKG4pID0+IHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlci5vbmNlKFZ0LmNyZWF0ZWQsIChvKSA9PiB7XG4gICAgICAgIG8udG9waWMgPT09IGUgJiYgbigpO1xuICAgICAgfSk7XG4gICAgfSksIG5ldyBQcm9taXNlKGFzeW5jIChuKSA9PiB7XG4gICAgICByID0gYXdhaXQgdGhpcy5zdWJzY3JpYmVyLnN1YnNjcmliZShlLCB0KSwgbigpO1xuICAgIH0pXSksIHIpO1xuICB9XG4gIGFzeW5jIHVuc3Vic2NyaWJlKGUsIHQpIHtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5zdWJzY3JpYmVyLnVuc3Vic2NyaWJlKGUsIHQpO1xuICB9XG4gIG9uKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vbihlLCB0KTtcbiAgfVxuICBvbmNlKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vbmNlKGUsIHQpO1xuICB9XG4gIG9mZihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMub2ZmKGUsIHQpO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVyKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihlLCB0KTtcbiAgfVxuICBhc3luYyB0cmFuc3BvcnRDbG9zZSgpIHtcbiAgICB0aGlzLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQgPSAhMCwgdGhpcy5oYXNFeHBlcmllbmNlZE5ldHdvcmtEaXNydXB0aW9uICYmIHRoaXMuY29ubmVjdGVkID8gYXdhaXQgZHModGhpcy5wcm92aWRlci5kaXNjb25uZWN0KCksIDFlMywgXCJwcm92aWRlci5kaXNjb25uZWN0KClcIikuY2F0Y2goKCkgPT4gdGhpcy5vblByb3ZpZGVyRGlzY29ubmVjdCgpKSA6IHRoaXMuY29ubmVjdGVkICYmIGF3YWl0IHRoaXMucHJvdmlkZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGFzeW5jIHRyYW5zcG9ydE9wZW4oZSkge1xuICAgIGlmICh0aGlzLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQgPSAhMSwgYXdhaXQgdGhpcy5jb25maXJtT25saW5lU3RhdGVPclRocm93KCksICF0aGlzLmNvbm5lY3Rpb25BdHRlbXB0SW5Qcm9ncmVzcykge1xuICAgICAgZSAmJiBlICE9PSB0aGlzLnJlbGF5VXJsICYmICh0aGlzLnJlbGF5VXJsID0gZSwgYXdhaXQgdGhpcy50cmFuc3BvcnRDbG9zZSgpLCBhd2FpdCB0aGlzLmNyZWF0ZVByb3ZpZGVyKCkpLCB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0SW5Qcm9ncmVzcyA9ICEwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW25ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKVxuICAgICAgICAgICAgcmV0dXJuIHQoKTtcbiAgICAgICAgICB0aGlzLnN1YnNjcmliZXIub25jZShWdC5yZXN1YnNjcmliZWQsICgpID0+IHtcbiAgICAgICAgICAgIHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIG5ldyBQcm9taXNlKGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGRzKHRoaXMucHJvdmlkZXIuY29ubmVjdCgpLCAxZTQsIGBTb2NrZXQgc3RhbGxlZCB3aGVuIHRyeWluZyB0byBjb25uZWN0IHRvICR7dGhpcy5yZWxheVVybH1gKTtcbiAgICAgICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgICAgICBzKHIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0KCk7XG4gICAgICAgIH0pXSk7XG4gICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKHQpO1xuICAgICAgICBjb25zdCBzID0gdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGlvblN0YWxsZWQocy5tZXNzYWdlKSlcbiAgICAgICAgICB0aHJvdyB0O1xuICAgICAgICB0aGlzLnByb3ZpZGVyLmV2ZW50cy5lbWl0KFp0LmRpc2Nvbm5lY3QpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQXR0ZW1wdEluUHJvZ3Jlc3MgPSAhMSwgdGhpcy5oYXNFeHBlcmllbmNlZE5ldHdvcmtEaXNydXB0aW9uID0gITE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlc3RhcnRUcmFuc3BvcnQoZSkge1xuICAgIGF3YWl0IHRoaXMuY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpLCAhdGhpcy5jb25uZWN0aW9uQXR0ZW1wdEluUHJvZ3Jlc3MgJiYgKHRoaXMucmVsYXlVcmwgPSBlIHx8IHRoaXMucmVsYXlVcmwsIGF3YWl0IHRoaXMudHJhbnNwb3J0Q2xvc2UoKSwgYXdhaXQgdGhpcy5jcmVhdGVQcm92aWRlcigpLCBhd2FpdCB0aGlzLnRyYW5zcG9ydE9wZW4oKSk7XG4gIH1cbiAgYXN5bmMgY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpIHtcbiAgICBpZiAoIWF3YWl0IGpvKCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBpbnRlcm5ldCBjb25uZWN0aW9uIGRldGVjdGVkLiBQbGVhc2UgcmVzdGFydCB5b3VyIG5ldHdvcmsgYW5kIHRyeSBhZ2Fpbi5cIik7XG4gIH1cbiAgaXNDb25uZWN0aW9uU3RhbGxlZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhbGVDb25uZWN0aW9uRXJyb3JzLnNvbWUoKHQpID0+IGUuaW5jbHVkZXModCkpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVByb3ZpZGVyKCkge1xuICAgIHRoaXMucHJvdmlkZXIuY29ubmVjdGlvbiAmJiB0aGlzLnVucmVnaXN0ZXJQcm92aWRlckxpc3RlbmVycygpO1xuICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLnNpZ25KV1QodGhpcy5yZWxheVVybCk7XG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBfbihuZXcgV2Mod3AoeyBzZGtWZXJzaW9uOiBfMSwgcHJvdG9jb2w6IHRoaXMucHJvdG9jb2wsIHZlcnNpb246IHRoaXMudmVyc2lvbiwgcmVsYXlVcmw6IHRoaXMucmVsYXlVcmwsIHByb2plY3RJZDogdGhpcy5wcm9qZWN0SWQsIGF1dGg6IGUsIHVzZU9uQ2xvc2VFdmVudDogITAgfSkpKSwgdGhpcy5yZWdpc3RlclByb3ZpZGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgYXN5bmMgcmVjb3JkTWVzc2FnZUV2ZW50KGUpIHtcbiAgICBjb25zdCB7IHRvcGljOiB0LCBtZXNzYWdlOiBzIH0gPSBlO1xuICAgIGF3YWl0IHRoaXMubWVzc2FnZXMuc2V0KHQsIHMpO1xuICB9XG4gIGFzeW5jIHNob3VsZElnbm9yZU1lc3NhZ2VFdmVudChlKSB7XG4gICAgY29uc3QgeyB0b3BpYzogdCwgbWVzc2FnZTogcyB9ID0gZTtcbiAgICBpZiAoIXMgfHwgcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5sb2dnZXIuZGVidWcoYElnbm9yaW5nIGludmFsaWQvZW1wdHkgbWVzc2FnZTogJHtzfWApLCAhMDtcbiAgICBpZiAoIWF3YWl0IHRoaXMuc3Vic2NyaWJlci5pc1N1YnNjcmliZWQodCkpXG4gICAgICByZXR1cm4gdGhpcy5sb2dnZXIuZGVidWcoYElnbm9yaW5nIG1lc3NhZ2UgZm9yIG5vbi1zdWJzY3JpYmVkIHRvcGljICR7dH1gKSwgITA7XG4gICAgY29uc3QgciA9IHRoaXMubWVzc2FnZXMuaGFzKHQsIHMpO1xuICAgIHJldHVybiByICYmIHRoaXMubG9nZ2VyLmRlYnVnKGBJZ25vcmluZyBkdXBsaWNhdGUgbWVzc2FnZTogJHtzfWApLCByO1xuICB9XG4gIGFzeW5jIG9uUHJvdmlkZXJQYXlsb2FkKGUpIHtcbiAgICBpZiAodGhpcy5sb2dnZXIuZGVidWcoXCJJbmNvbWluZyBSZWxheSBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwicGF5bG9hZFwiLCBkaXJlY3Rpb246IFwiaW5jb21pbmdcIiwgcGF5bG9hZDogZSB9KSwgamkoZSkpIHtcbiAgICAgIGlmICghZS5tZXRob2QuZW5kc1dpdGgodzEpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB0ID0gZS5wYXJhbXMsIHsgdG9waWM6IHMsIG1lc3NhZ2U6IHIsIHB1Ymxpc2hlZEF0OiBuIH0gPSB0LmRhdGEsIG8gPSB7IHRvcGljOiBzLCBtZXNzYWdlOiByLCBwdWJsaXNoZWRBdDogbiB9O1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJFbWl0dGluZyBSZWxheWVyIFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKFcxKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdC5pZCB9LCBvKSksIHRoaXMuZXZlbnRzLmVtaXQodC5pZCwgbyksIGF3YWl0IHRoaXMuYWNrbm93bGVkZ2VQYXlsb2FkKGUpLCBhd2FpdCB0aGlzLm9uTWVzc2FnZUV2ZW50KG8pO1xuICAgIH0gZWxzZVxuICAgICAgT2koZSkgJiYgdGhpcy5ldmVudHMuZW1pdChndC5tZXNzYWdlX2FjaywgZSk7XG4gIH1cbiAgYXN5bmMgb25NZXNzYWdlRXZlbnQoZSkge1xuICAgIGF3YWl0IHRoaXMuc2hvdWxkSWdub3JlTWVzc2FnZUV2ZW50KGUpIHx8ICh0aGlzLmV2ZW50cy5lbWl0KGd0Lm1lc3NhZ2UsIGUpLCBhd2FpdCB0aGlzLnJlY29yZE1lc3NhZ2VFdmVudChlKSk7XG4gIH1cbiAgYXN5bmMgYWNrbm93bGVkZ2VQYXlsb2FkKGUpIHtcbiAgICBjb25zdCB0ID0geGkoZS5pZCwgITApO1xuICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuY29ubmVjdGlvbi5zZW5kKHQpO1xuICB9XG4gIHVucmVnaXN0ZXJQcm92aWRlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLnByb3ZpZGVyLm9mZihadC5wYXlsb2FkLCB0aGlzLm9uUGF5bG9hZEhhbmRsZXIpLCB0aGlzLnByb3ZpZGVyLm9mZihadC5jb25uZWN0LCB0aGlzLm9uQ29ubmVjdEhhbmRsZXIpLCB0aGlzLnByb3ZpZGVyLm9mZihadC5kaXNjb25uZWN0LCB0aGlzLm9uRGlzY29ubmVjdEhhbmRsZXIpLCB0aGlzLnByb3ZpZGVyLm9mZihadC5lcnJvciwgdGhpcy5vblByb3ZpZGVyRXJyb3JIYW5kbGVyKTtcbiAgfVxuICBhc3luYyByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKGd0LmNvbm5lY3Rpb25fc3RhbGxlZCwgKCkgPT4ge1xuICAgICAgdGhpcy5yZXN0YXJ0VHJhbnNwb3J0KCkuY2F0Y2goKHQpID0+IHRoaXMubG9nZ2VyLmVycm9yKHQpKTtcbiAgICB9KTtcbiAgICBsZXQgZSA9IGF3YWl0IGpvKCk7XG4gICAgbGcoYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgJiYgZSAhPT0gdCAmJiAoZSA9IHQsIHQgPyBhd2FpdCB0aGlzLnJlc3RhcnRUcmFuc3BvcnQoKS5jYXRjaCgocykgPT4gdGhpcy5sb2dnZXIuZXJyb3IocykpIDogKHRoaXMuaGFzRXhwZXJpZW5jZWROZXR3b3JrRGlzcnVwdGlvbiA9ICEwLCBhd2FpdCB0aGlzLnRyYW5zcG9ydENsb3NlKCkuY2F0Y2goKHMpID0+IHRoaXMubG9nZ2VyLmVycm9yKHMpKSkpO1xuICAgIH0pO1xuICB9XG4gIG9uUHJvdmlkZXJEaXNjb25uZWN0KCkge1xuICAgIHRoaXMuZXZlbnRzLmVtaXQoZ3QuZGlzY29ubmVjdCksIHRoaXMuYXR0ZW1wdFRvUmVjb25uZWN0KCk7XG4gIH1cbiAgYXR0ZW1wdFRvUmVjb25uZWN0KCkge1xuICAgIHRoaXMudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZCB8fCAodGhpcy5sb2dnZXIuaW5mbyhcImF0dGVtcHRUb1JlY29ubmVjdCBjYWxsZWQuIENvbm5lY3RpbmcuLi5cIiksIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VHJhbnNwb3J0KCkuY2F0Y2goKGUpID0+IHRoaXMubG9nZ2VyLmVycm9yKGUpKTtcbiAgICB9LCBWLnRvTWlsaXNlY29uZHModjEpKSk7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gWShcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBhc3luYyB0b0VzdGFibGlzaENvbm5lY3Rpb24oKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMuY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpLCAhdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25BdHRlbXB0SW5Qcm9ncmVzcylcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkICYmIChjbGVhckludGVydmFsKHQpLCBlKCkpO1xuICAgICAgICAgIH0sIHRoaXMuY29ubmVjdGlvblN0YXR1c1BvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG59O1xudmFyIEoxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBvYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIFExID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgWDEgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBhYSA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBKMShpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQsIGNhID0gKGksIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIFExLmNhbGwoZSwgdCkgJiYgYWEoaSwgdCwgZVt0XSk7XG4gIGlmIChvYSlcbiAgICBmb3IgKHZhciB0IG9mIG9hKGUpKVxuICAgICAgWDEuY2FsbChlLCB0KSAmJiBhYShpLCB0LCBlW3RdKTtcbiAgcmV0dXJuIGk7XG59O1xubGV0IGRyID0gY2xhc3MgZXh0ZW5kcyBibCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMsIHIgPSBoaSwgbiA9IHZvaWQgMCkge1xuICAgIHN1cGVyKGUsIHQsIHMsIHIpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMubmFtZSA9IHMsIHRoaXMubWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy52ZXJzaW9uID0gUzEsIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zdG9yYWdlUHJlZml4ID0gaGksIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIiksIGF3YWl0IHRoaXMucmVzdG9yZSgpLCB0aGlzLmNhY2hlZC5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIHRoaXMuZ2V0S2V5ICYmIG8gIT09IG51bGwgJiYgIWJ0KG8pID8gdGhpcy5tYXAuc2V0KHRoaXMuZ2V0S2V5KG8pLCBvKSA6IEtwKG8pID8gdGhpcy5tYXAuc2V0KG8uaWQsIG8pIDogVnAobykgJiYgdGhpcy5tYXAuc2V0KG8udG9waWMsIG8pO1xuICAgICAgfSksIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCk7XG4gICAgfSwgdGhpcy5zZXQgPSBhc3luYyAobywgYykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubWFwLmhhcyhvKSA/IGF3YWl0IHRoaXMudXBkYXRlKG8sIGMpIDogKHRoaXMubG9nZ2VyLmRlYnVnKFwiU2V0dGluZyB2YWx1ZVwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic2V0XCIsIGtleTogbywgdmFsdWU6IGMgfSksIHRoaXMubWFwLnNldChvLCBjKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCkpO1xuICAgIH0sIHRoaXMuZ2V0ID0gKG8pID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJHZXR0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJnZXRcIiwga2V5OiBvIH0pLCB0aGlzLmdldERhdGEobykpLCB0aGlzLmdldEFsbCA9IChvKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIG8gPyB0aGlzLnZhbHVlcy5maWx0ZXIoKGMpID0+IE9iamVjdC5rZXlzKG8pLmV2ZXJ5KCh1KSA9PiBZYyhjW3VdLCBvW3VdKSkpIDogdGhpcy52YWx1ZXMpLCB0aGlzLnVwZGF0ZSA9IGFzeW5jIChvLCBjKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJVcGRhdGluZyB2YWx1ZVwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwidXBkYXRlXCIsIGtleTogbywgdXBkYXRlOiBjIH0pO1xuICAgICAgY29uc3QgdSA9IGNhKGNhKHt9LCB0aGlzLmdldERhdGEobykpLCBjKTtcbiAgICAgIHRoaXMubWFwLnNldChvLCB1KSwgYXdhaXQgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSwgdGhpcy5kZWxldGUgPSBhc3luYyAobywgYykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubWFwLmhhcyhvKSAmJiAodGhpcy5sb2dnZXIuZGVidWcoXCJEZWxldGluZyB2YWx1ZVwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwiZGVsZXRlXCIsIGtleTogbywgcmVhc29uOiBjIH0pLCB0aGlzLm1hcC5kZWxldGUobyksIGF3YWl0IHRoaXMucGVyc2lzdCgpKTtcbiAgICB9LCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy5zdG9yYWdlUHJlZml4ID0gciwgdGhpcy5nZXRLZXkgPSBuO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgXCIvL1wiICsgdGhpcy5uYW1lO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLnNpemU7XG4gIH1cbiAgZ2V0IGtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAua2V5cygpKTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWFwLnZhbHVlcygpKTtcbiAgfVxuICBhc3luYyBzZXREYXRhU3RvcmUoZSkge1xuICAgIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBlKTtcbiAgfVxuICBhc3luYyBnZXREYXRhU3RvcmUoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgfVxuICBnZXREYXRhKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5tYXAuZ2V0KGUpO1xuICAgIGlmICghdCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBzIH0gPSBZKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGAke3RoaXMubmFtZX06ICR7ZX1gKTtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHMpLCBuZXcgRXJyb3Iocyk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIGFzeW5jIHBlcnNpc3QoKSB7XG4gICAgYXdhaXQgdGhpcy5zZXREYXRhU3RvcmUodGhpcy52YWx1ZXMpO1xuICB9XG4gIGFzeW5jIHJlc3RvcmUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmdldERhdGFTdG9yZSgpO1xuICAgICAgaWYgKHR5cGVvZiBlID4gXCJ1XCIgfHwgIWUubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5tYXAuc2l6ZSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJSRVNUT1JFX1dJTExfT1ZFUlJJREVcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3IodCksIG5ldyBFcnJvcih0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGVkID0gZSwgdGhpcy5sb2dnZXIuZGVidWcoYFN1Y2Nlc3NmdWxseSBSZXN0b3JlZCB2YWx1ZSBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInJlc3RvcmVcIiwgdmFsdWU6IHRoaXMudmFsdWVzIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gUmVzdG9yZSB2YWx1ZSBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBZKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG59LCBaMSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5uYW1lID0gTjEsIHRoaXMudmVyc2lvbiA9IFAxLCB0aGlzLmV2ZW50cyA9IG5ldyBpcigpLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuc3RvcmFnZVByZWZpeCA9IGhpLCB0aGlzLmlnbm9yZWRQYXlsb2FkVHlwZXMgPSBbRGldLCB0aGlzLnJlZ2lzdGVyZWRNZXRob2RzID0gW10sIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKGF3YWl0IHRoaXMucGFpcmluZ3MuaW5pdCgpLCBhd2FpdCB0aGlzLmNsZWFudXAoKSwgdGhpcy5yZWdpc3RlclJlbGF5ZXJFdmVudHMoKSwgdGhpcy5yZWdpc3RlckV4cGlyZXJFdmVudHMoKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwLCB0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpKTtcbiAgICB9LCB0aGlzLnJlZ2lzdGVyID0gKHsgbWV0aG9kczogcyB9KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5yZWdpc3RlcmVkTWV0aG9kcyA9IFsuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4udGhpcy5yZWdpc3RlcmVkTWV0aG9kcywgLi4uc10pXTtcbiAgICB9LCB0aGlzLmNyZWF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgcyA9IEhyKCksIHIgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLnNldFN5bUtleShzKSwgbiA9IE10KFYuRklWRV9NSU5VVEVTKSwgbyA9IHsgcHJvdG9jb2w6IGNoIH0sIGMgPSB7IHRvcGljOiByLCBleHBpcnk6IG4sIHJlbGF5OiBvLCBhY3RpdmU6ICExIH0sIHUgPSBBcCh7IHByb3RvY29sOiB0aGlzLmNvcmUucHJvdG9jb2wsIHZlcnNpb246IHRoaXMuY29yZS52ZXJzaW9uLCB0b3BpYzogciwgc3ltS2V5OiBzLCByZWxheTogbyB9KTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBhaXJpbmdzLnNldChyLCBjKSwgYXdhaXQgdGhpcy5jb3JlLnJlbGF5ZXIuc3Vic2NyaWJlKHIpLCB0aGlzLmNvcmUuZXhwaXJlci5zZXQociwgbiksIHsgdG9waWM6IHIsIHVyaTogdSB9O1xuICAgIH0sIHRoaXMucGFpciA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5pc1ZhbGlkUGFpcihzKTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHIsIHN5bUtleTogbiwgcmVsYXk6IG8gfSA9IFBwKHMudXJpKTtcbiAgICAgIGxldCBjO1xuICAgICAgaWYgKHRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhyKSAmJiAoYyA9IHRoaXMucGFpcmluZ3MuZ2V0KHIpLCBjLmFjdGl2ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFpcmluZyBhbHJlYWR5IGV4aXN0czogJHtyfS4gUGxlYXNlIHRyeSBhZ2FpbiB3aXRoIGEgbmV3IGNvbm5lY3Rpb24gVVJJLmApO1xuICAgICAgdGhpcy5jb3JlLmNyeXB0by5rZXljaGFpbi5oYXMocikgfHwgKGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uc2V0U3ltS2V5KG4sIHIpLCBhd2FpdCB0aGlzLmNvcmUucmVsYXllci5zdWJzY3JpYmUociwgeyByZWxheTogbyB9KSk7XG4gICAgICBjb25zdCB1ID0gTXQoVi5GSVZFX01JTlVURVMpLCBkID0geyB0b3BpYzogciwgcmVsYXk6IG8sIGV4cGlyeTogdSwgYWN0aXZlOiAhMSB9O1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGFpcmluZ3Muc2V0KHIsIGQpLCB0aGlzLmNvcmUuZXhwaXJlci5zZXQociwgdSksIHMuYWN0aXZhdGVQYWlyaW5nICYmIGF3YWl0IHRoaXMuYWN0aXZhdGUoeyB0b3BpYzogciB9KSwgdGhpcy5ldmVudHMuZW1pdChvcy5jcmVhdGUsIGQpLCBkO1xuICAgIH0sIHRoaXMuYWN0aXZhdGUgPSBhc3luYyAoeyB0b3BpYzogcyB9KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHIgPSBNdChWLlRISVJUWV9EQVlTKTtcbiAgICAgIGF3YWl0IHRoaXMucGFpcmluZ3MudXBkYXRlKHMsIHsgYWN0aXZlOiAhMCwgZXhwaXJ5OiByIH0pLCB0aGlzLmNvcmUuZXhwaXJlci5zZXQocywgcik7XG4gICAgfSwgdGhpcy5waW5nID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRQaW5nKHMpO1xuICAgICAgY29uc3QgeyB0b3BpYzogciB9ID0gcztcbiAgICAgIGlmICh0aGlzLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMocikpIHtcbiAgICAgICAgY29uc3QgbiA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QociwgXCJ3Y19wYWlyaW5nUGluZ1wiLCB7fSksIHsgZG9uZTogbywgcmVzb2x2ZTogYywgcmVqZWN0OiB1IH0gPSBBaSgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbmNlKEJlKFwicGFpcmluZ19waW5nXCIsIG4pLCAoeyBlcnJvcjogZCB9KSA9PiB7XG4gICAgICAgICAgZCA/IHUoZCkgOiBjKCk7XG4gICAgICAgIH0pLCBhd2FpdCBvKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy51cGRhdGVFeHBpcnkgPSBhc3luYyAoeyB0b3BpYzogcywgZXhwaXJ5OiByIH0pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLnBhaXJpbmdzLnVwZGF0ZShzLCB7IGV4cGlyeTogciB9KTtcbiAgICB9LCB0aGlzLnVwZGF0ZU1ldGFkYXRhID0gYXN5bmMgKHsgdG9waWM6IHMsIG1ldGFkYXRhOiByIH0pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLnBhaXJpbmdzLnVwZGF0ZShzLCB7IHBlZXJNZXRhZGF0YTogciB9KTtcbiAgICB9LCB0aGlzLmdldFBhaXJpbmdzID0gKCkgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLnBhaXJpbmdzLnZhbHVlcyksIHRoaXMuZGlzY29ubmVjdCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkRGlzY29ubmVjdChzKTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHIgfSA9IHM7XG4gICAgICB0aGlzLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMocikgJiYgKGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QociwgXCJ3Y19wYWlyaW5nRGVsZXRlXCIsIG50KFwiVVNFUl9ESVNDT05ORUNURURcIikpLCBhd2FpdCB0aGlzLmRlbGV0ZVBhaXJpbmcocikpO1xuICAgIH0sIHRoaXMuc2VuZFJlcXVlc3QgPSBhc3luYyAocywgciwgbikgPT4ge1xuICAgICAgY29uc3QgbyA9IHRpKHIsIG4pLCBjID0gYXdhaXQgdGhpcy5jb3JlLmNyeXB0by5lbmNvZGUocywgbyksIHUgPSBYaVtyXS5yZXE7XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLmhpc3Rvcnkuc2V0KHMsIG8pLCB0aGlzLmNvcmUucmVsYXllci5wdWJsaXNoKHMsIGMsIHUpLCBvLmlkO1xuICAgIH0sIHRoaXMuc2VuZFJlc3VsdCA9IGFzeW5jIChzLCByLCBuKSA9PiB7XG4gICAgICBjb25zdCBvID0geGkocywgbiksIGMgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLmVuY29kZShyLCBvKSwgdSA9IGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LmdldChyLCBzKSwgZCA9IFhpW3UucmVxdWVzdC5tZXRob2RdLnJlcztcbiAgICAgIGF3YWl0IHRoaXMuY29yZS5yZWxheWVyLnB1Ymxpc2gociwgYywgZCksIGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LnJlc29sdmUobyk7XG4gICAgfSwgdGhpcy5zZW5kRXJyb3IgPSBhc3luYyAocywgciwgbikgPT4ge1xuICAgICAgY29uc3QgbyA9IHFpKHMsIG4pLCBjID0gYXdhaXQgdGhpcy5jb3JlLmNyeXB0by5lbmNvZGUociwgbyksIHUgPSBhd2FpdCB0aGlzLmNvcmUuaGlzdG9yeS5nZXQociwgcyksIGQgPSBYaVt1LnJlcXVlc3QubWV0aG9kXSA/IFhpW3UucmVxdWVzdC5tZXRob2RdLnJlcyA6IFhpLnVucmVnaXN0ZXJlZF9tZXRob2QucmVzO1xuICAgICAgYXdhaXQgdGhpcy5jb3JlLnJlbGF5ZXIucHVibGlzaChyLCBjLCBkKSwgYXdhaXQgdGhpcy5jb3JlLmhpc3RvcnkucmVzb2x2ZShvKTtcbiAgICB9LCB0aGlzLmRlbGV0ZVBhaXJpbmcgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5jb3JlLnJlbGF5ZXIudW5zdWJzY3JpYmUocyksIGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLnBhaXJpbmdzLmRlbGV0ZShzLCBudChcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgdGhpcy5jb3JlLmNyeXB0by5kZWxldGVTeW1LZXkocyksIHIgPyBQcm9taXNlLnJlc29sdmUoKSA6IHRoaXMuY29yZS5leHBpcmVyLmRlbChzKV0pO1xuICAgIH0sIHRoaXMuY2xlYW51cCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnBhaXJpbmdzLmdldEFsbCgpLmZpbHRlcigocikgPT4gYWkoci5leHBpcnkpKTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHMubWFwKChyKSA9PiB0aGlzLmRlbGV0ZVBhaXJpbmcoci50b3BpYykpKTtcbiAgICB9LCB0aGlzLm9uUmVsYXlFdmVudFJlcXVlc3QgPSAocykgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogciwgcGF5bG9hZDogbiB9ID0gcztcbiAgICAgIHN3aXRjaCAobi5tZXRob2QpIHtcbiAgICAgICAgY2FzZSBcIndjX3BhaXJpbmdQaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25QYWlyaW5nUGluZ1JlcXVlc3Qociwgbik7XG4gICAgICAgIGNhc2UgXCJ3Y19wYWlyaW5nRGVsZXRlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25QYWlyaW5nRGVsZXRlUmVxdWVzdChyLCBuKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblVua25vd25ScGNNZXRob2RSZXF1ZXN0KHIsIG4pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25SZWxheUV2ZW50UmVzcG9uc2UgPSBhc3luYyAocykgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogciwgcGF5bG9hZDogbiB9ID0gcywgbyA9IChhd2FpdCB0aGlzLmNvcmUuaGlzdG9yeS5nZXQociwgbi5pZCkpLnJlcXVlc3QubWV0aG9kO1xuICAgICAgc3dpdGNoIChvKSB7XG4gICAgICAgIGNhc2UgXCJ3Y19wYWlyaW5nUGluZ1wiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uUGFpcmluZ1BpbmdSZXNwb25zZShyLCBuKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblVua25vd25ScGNNZXRob2RSZXNwb25zZShvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uUGFpcmluZ1BpbmdSZXF1ZXN0ID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IG4gfSA9IHI7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRQaW5nKHsgdG9waWM6IHMgfSksIGF3YWl0IHRoaXMuc2VuZFJlc3VsdChuLCBzLCAhMCksIHRoaXMuZXZlbnRzLmVtaXQob3MucGluZywgeyBpZDogbiwgdG9waWM6IHMgfSk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHMsIG8pLCB0aGlzLmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uUGFpcmluZ1BpbmdSZXNwb25zZSA9IChzLCByKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBuIH0gPSByO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGh0KHIpID8gdGhpcy5ldmVudHMuZW1pdChCZShcInBhaXJpbmdfcGluZ1wiLCBuKSwge30pIDogR2UocikgJiYgdGhpcy5ldmVudHMuZW1pdChCZShcInBhaXJpbmdfcGluZ1wiLCBuKSwgeyBlcnJvcjogci5lcnJvciB9KTtcbiAgICAgIH0sIDUwMCk7XG4gICAgfSwgdGhpcy5vblBhaXJpbmdEZWxldGVSZXF1ZXN0ID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IG4gfSA9IHI7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWREaXNjb25uZWN0KHsgdG9waWM6IHMgfSksIGF3YWl0IHRoaXMuZGVsZXRlUGFpcmluZyhzKSwgdGhpcy5ldmVudHMuZW1pdChvcy5kZWxldGUsIHsgaWQ6IG4sIHRvcGljOiBzIH0pO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihuLCBzLCBvKSwgdGhpcy5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblVua25vd25ScGNNZXRob2RSZXF1ZXN0ID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IG4sIG1ldGhvZDogbyB9ID0gcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRNZXRob2RzLmluY2x1ZGVzKG8pKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYyA9IG50KFwiV0NfTUVUSE9EX1VOU1VQUE9SVEVEXCIsIG8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihuLCBzLCBjKSwgdGhpcy5sb2dnZXIuZXJyb3IoYyk7XG4gICAgICB9IGNhdGNoIChjKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHMsIGMpLCB0aGlzLmxvZ2dlci5lcnJvcihjKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uVW5rbm93blJwY01ldGhvZFJlc3BvbnNlID0gKHMpID0+IHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZE1ldGhvZHMuaW5jbHVkZXMocykgfHwgdGhpcy5sb2dnZXIuZXJyb3IobnQoXCJXQ19NRVRIT0RfVU5TVVBQT1JURURcIiwgcykpO1xuICAgIH0sIHRoaXMuaXNWYWxpZFBhaXIgPSAocykgPT4ge1xuICAgICAgaWYgKCFTdChzKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHBhaXIoKSBwYXJhbXM6ICR7c31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHIpO1xuICAgICAgfVxuICAgICAgaWYgKCF6cChzLnVyaSkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwYWlyKCkgdXJpOiAke3MudXJpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkUGluZyA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBpZiAoIVN0KHMpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcGluZygpIHBhcmFtczogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiByIH0gPSBzO1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkUGFpcmluZ1RvcGljKHIpO1xuICAgIH0sIHRoaXMuaXNWYWxpZERpc2Nvbm5lY3QgPSBhc3luYyAocykgPT4ge1xuICAgICAgaWYgKCFTdChzKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGRpc2Nvbm5lY3QoKSBwYXJhbXM6ICR7c31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogciB9ID0gcztcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFBhaXJpbmdUb3BpYyhyKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRQYWlyaW5nVG9waWMgPSBhc3luYyAocykgPT4ge1xuICAgICAgaWYgKCFvdChzLCAhMSkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwYWlyaW5nIHRvcGljIHNob3VsZCBiZSBhIHN0cmluZzogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhzKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IFkoXCJOT19NQVRDSElOR19LRVlcIiwgYHBhaXJpbmcgdG9waWMgZG9lc24ndCBleGlzdDogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgICBpZiAoYWkodGhpcy5wYWlyaW5ncy5nZXQocykuZXhwaXJ5KSkge1xuICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZVBhaXJpbmcocyk7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gWShcIkVYUElSRURcIiwgYHBhaXJpbmcgdG9waWM6ICR7c31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHIpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLnBhaXJpbmdzID0gbmV3IGRyKHRoaXMuY29yZSwgdGhpcy5sb2dnZXIsIHRoaXMubmFtZSwgdGhpcy5zdG9yYWdlUHJlZml4KTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gWShcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlclJlbGF5ZXJFdmVudHMoKSB7XG4gICAgdGhpcy5jb3JlLnJlbGF5ZXIub24oZ3QubWVzc2FnZSwgYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHQsIG1lc3NhZ2U6IHMgfSA9IGU7XG4gICAgICBpZiAoIXRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyh0KSB8fCB0aGlzLmlnbm9yZWRQYXlsb2FkVHlwZXMuaW5jbHVkZXModGhpcy5jb3JlLmNyeXB0by5nZXRQYXlsb2FkVHlwZShzKSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLmRlY29kZSh0LCBzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGppKHIpID8gKHRoaXMuY29yZS5oaXN0b3J5LnNldCh0LCByKSwgdGhpcy5vblJlbGF5RXZlbnRSZXF1ZXN0KHsgdG9waWM6IHQsIHBheWxvYWQ6IHIgfSkpIDogT2kocikgJiYgKGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LnJlc29sdmUociksIGF3YWl0IHRoaXMub25SZWxheUV2ZW50UmVzcG9uc2UoeyB0b3BpYzogdCwgcGF5bG9hZDogciB9KSwgdGhpcy5jb3JlLmhpc3RvcnkuZGVsZXRlKHQsIHIuaWQpKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3Iobik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJFeHBpcmVyRXZlbnRzKCkge1xuICAgIHRoaXMuY29yZS5leHBpcmVyLm9uKFR0LmV4cGlyZWQsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiB0IH0gPSBqYyhlLnRhcmdldCk7XG4gICAgICB0ICYmIHRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyh0KSAmJiAoYXdhaXQgdGhpcy5kZWxldGVQYWlyaW5nKHQsICEwKSwgdGhpcy5ldmVudHMuZW1pdChvcy5leHBpcmUsIHsgdG9waWM6IHQgfSkpO1xuICAgIH0pO1xuICB9XG59LCBlbSA9IGNsYXNzIGV4dGVuZHMgcGwge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5yZWNvcmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMubmFtZSA9IFIxLCB0aGlzLnZlcnNpb24gPSBDMSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSBoaSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAodGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSwgYXdhaXQgdGhpcy5yZXN0b3JlKCksIHRoaXMuY2FjaGVkLmZvckVhY2goKHMpID0+IHRoaXMucmVjb3Jkcy5zZXQocy5pZCwgcykpLCB0aGlzLmNhY2hlZCA9IFtdLCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwKTtcbiAgICB9LCB0aGlzLnNldCA9IChzLCByLCBuKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubG9nZ2VyLmRlYnVnKFwiU2V0dGluZyBKU09OLVJQQyByZXF1ZXN0IGhpc3RvcnkgcmVjb3JkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJzZXRcIiwgdG9waWM6IHMsIHJlcXVlc3Q6IHIsIGNoYWluSWQ6IG4gfSksIHRoaXMucmVjb3Jkcy5oYXMoci5pZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG8gPSB7IGlkOiByLmlkLCB0b3BpYzogcywgcmVxdWVzdDogeyBtZXRob2Q6IHIubWV0aG9kLCBwYXJhbXM6IHIucGFyYW1zIHx8IG51bGwgfSwgY2hhaW5JZDogbiwgZXhwaXJ5OiBNdChWLlRISVJUWV9EQVlTKSB9O1xuICAgICAgdGhpcy5yZWNvcmRzLnNldChvLmlkLCBvKSwgdGhpcy5ldmVudHMuZW1pdCh6dC5jcmVhdGVkLCBvKTtcbiAgICB9LCB0aGlzLnJlc29sdmUgPSBhc3luYyAocykgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlVwZGF0aW5nIEpTT04tUlBDIHJlc3BvbnNlIGhpc3RvcnkgcmVjb3JkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJ1cGRhdGVcIiwgcmVzcG9uc2U6IHMgfSksICF0aGlzLnJlY29yZHMuaGFzKHMuaWQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5nZXRSZWNvcmQocy5pZCk7XG4gICAgICB0eXBlb2Ygci5yZXNwb25zZSA+IFwidVwiICYmIChyLnJlc3BvbnNlID0gR2UocykgPyB7IGVycm9yOiBzLmVycm9yIH0gOiB7IHJlc3VsdDogcy5yZXN1bHQgfSwgdGhpcy5yZWNvcmRzLnNldChyLmlkLCByKSwgdGhpcy5ldmVudHMuZW1pdCh6dC51cGRhdGVkLCByKSk7XG4gICAgfSwgdGhpcy5nZXQgPSBhc3luYyAocywgcikgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgcmVjb3JkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJnZXRcIiwgdG9waWM6IHMsIGlkOiByIH0pLCBhd2FpdCB0aGlzLmdldFJlY29yZChyKSksIHRoaXMuZGVsZXRlID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkRlbGV0aW5nIHJlY29yZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwiZGVsZXRlXCIsIGlkOiByIH0pLCB0aGlzLnZhbHVlcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGlmIChuLnRvcGljID09PSBzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByIDwgXCJ1XCIgJiYgbi5pZCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB0aGlzLnJlY29yZHMuZGVsZXRlKG4uaWQpLCB0aGlzLmV2ZW50cy5lbWl0KHp0LmRlbGV0ZWQsIG4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB0aGlzLmV4aXN0cyA9IGFzeW5jIChzLCByKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMucmVjb3Jkcy5oYXMocikgPyAoYXdhaXQgdGhpcy5nZXRSZWNvcmQocikpLnRvcGljID09PSBzIDogITEpLCB0aGlzLm9uID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uKHMsIHIpO1xuICAgIH0sIHRoaXMub25jZSA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbmNlKHMsIHIpO1xuICAgIH0sIHRoaXMub2ZmID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9mZihzLCByKTtcbiAgICB9LCB0aGlzLnJlbW92ZUxpc3RlbmVyID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHMsIHIpO1xuICAgIH0sIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgXCIvL1wiICsgdGhpcy5uYW1lO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJlY29yZHMuc2l6ZTtcbiAgfVxuICBnZXQga2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlY29yZHMua2V5cygpKTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVjb3Jkcy52YWx1ZXMoKSk7XG4gIH1cbiAgZ2V0IHBlbmRpbmcoKSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHJldHVybiB0aGlzLnZhbHVlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHQucmVzcG9uc2UgPCBcInVcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcyA9IHsgdG9waWM6IHQudG9waWMsIHJlcXVlc3Q6IHRpKHQucmVxdWVzdC5tZXRob2QsIHQucmVxdWVzdC5wYXJhbXMsIHQuaWQpLCBjaGFpbklkOiB0LmNoYWluSWQgfTtcbiAgICAgIHJldHVybiBlLnB1c2gocyk7XG4gICAgfSksIGU7XG4gIH1cbiAgYXN5bmMgc2V0SnNvblJwY1JlY29yZHMoZSkge1xuICAgIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBlKTtcbiAgfVxuICBhc3luYyBnZXRKc29uUnBjUmVjb3JkcygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG4gIGdldFJlY29yZChlKSB7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgY29uc3QgdCA9IHRoaXMucmVjb3Jkcy5nZXQoZSk7XG4gICAgaWYgKCF0KSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHMgfSA9IFkoXCJOT19NQVRDSElOR19LRVlcIiwgYCR7dGhpcy5uYW1lfTogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHMpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBhc3luYyBwZXJzaXN0KCkge1xuICAgIGF3YWl0IHRoaXMuc2V0SnNvblJwY1JlY29yZHModGhpcy52YWx1ZXMpLCB0aGlzLmV2ZW50cy5lbWl0KHp0LnN5bmMpO1xuICB9XG4gIGFzeW5jIHJlc3RvcmUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmdldEpzb25ScGNSZWNvcmRzKCk7XG4gICAgICBpZiAodHlwZW9mIGUgPiBcInVcIiB8fCAhZS5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnJlY29yZHMuc2l6ZSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJSRVNUT1JFX1dJTExfT1ZFUlJJREVcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3IodCksIG5ldyBFcnJvcih0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGVkID0gZSwgdGhpcy5sb2dnZXIuZGVidWcoYFN1Y2Nlc3NmdWxseSBSZXN0b3JlZCByZWNvcmRzIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicmVzdG9yZVwiLCByZWNvcmRzOiB0aGlzLnZhbHVlcyB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmFpbGVkIHRvIFJlc3RvcmUgcmVjb3JkcyBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKHp0LmNyZWF0ZWQsIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0genQuY3JlYXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCByZWNvcmQ6IGUgfSksIHRoaXMucGVyc2lzdCgpO1xuICAgIH0pLCB0aGlzLmV2ZW50cy5vbih6dC51cGRhdGVkLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IHp0LnVwZGF0ZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgcmVjb3JkOiBlIH0pLCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KSwgdGhpcy5ldmVudHMub24oenQuZGVsZXRlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB6dC5kZWxldGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIHJlY29yZDogZSB9KSwgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSksIHRoaXMuY29yZS5oZWFydGJlYXQub24oV3QuSEVBUlRCRUFUX0VWRU5UUy5wdWxzZSwgKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfSk7XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5yZWNvcmRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgVi50b01pbGlzZWNvbmRzKGUuZXhwaXJ5IHx8IDApIC0gRGF0ZS5ub3coKSA8PSAwICYmICh0aGlzLmxvZ2dlci5pbmZvKGBEZWxldGluZyBleHBpcmVkIGhpc3RvcnkgbG9nOiAke2UuaWR9YCksIHRoaXMuZGVsZXRlKGUudG9waWMsIGUuaWQpKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oZSk7XG4gICAgfVxuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IFkoXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn0sIHRtID0gY2xhc3MgZXh0ZW5kcyB2bCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLmV4cGlyYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMubmFtZSA9IEExLCB0aGlzLnZlcnNpb24gPSBUMSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSBoaSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAodGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSwgYXdhaXQgdGhpcy5yZXN0b3JlKCksIHRoaXMuY2FjaGVkLmZvckVhY2goKHMpID0+IHRoaXMuZXhwaXJhdGlvbnMuc2V0KHMudGFyZ2V0LCBzKSksIHRoaXMuY2FjaGVkID0gW10sIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLmluaXRpYWxpemVkID0gITApO1xuICAgIH0sIHRoaXMuaGFzID0gKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLmZvcm1hdFRhcmdldChzKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmdldEV4cGlyYXRpb24ocikgPCBcInVcIjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgfSwgdGhpcy5zZXQgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBuID0gdGhpcy5mb3JtYXRUYXJnZXQocyksIG8gPSB7IHRhcmdldDogbiwgZXhwaXJ5OiByIH07XG4gICAgICB0aGlzLmV4cGlyYXRpb25zLnNldChuLCBvKSwgdGhpcy5jaGVja0V4cGlyeShuLCBvKSwgdGhpcy5ldmVudHMuZW1pdChUdC5jcmVhdGVkLCB7IHRhcmdldDogbiwgZXhwaXJhdGlvbjogbyB9KTtcbiAgICB9LCB0aGlzLmdldCA9IChzKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmZvcm1hdFRhcmdldChzKTtcbiAgICAgIHJldHVybiB0aGlzLmdldEV4cGlyYXRpb24ocik7XG4gICAgfSwgdGhpcy5kZWwgPSAocykgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmhhcyhzKSkge1xuICAgICAgICBjb25zdCByID0gdGhpcy5mb3JtYXRUYXJnZXQocyksIG4gPSB0aGlzLmdldEV4cGlyYXRpb24ocik7XG4gICAgICAgIHRoaXMuZXhwaXJhdGlvbnMuZGVsZXRlKHIpLCB0aGlzLmV2ZW50cy5lbWl0KFR0LmRlbGV0ZWQsIHsgdGFyZ2V0OiByLCBleHBpcmF0aW9uOiBuIH0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub24gPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub24ocywgcik7XG4gICAgfSwgdGhpcy5vbmNlID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uY2Uocywgcik7XG4gICAgfSwgdGhpcy5vZmYgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub2ZmKHMsIHIpO1xuICAgIH0sIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIocywgcik7XG4gICAgfSwgdGhpcy5sb2dnZXIgPSBlZS5nZW5lcmF0ZUNoaWxkTG9nZ2VyKHQsIHRoaXMubmFtZSk7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBzdG9yYWdlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcmVmaXggKyB0aGlzLnZlcnNpb24gKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHBpcmF0aW9ucy5zaXplO1xuICB9XG4gIGdldCBrZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZXhwaXJhdGlvbnMua2V5cygpKTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZXhwaXJhdGlvbnMudmFsdWVzKCkpO1xuICB9XG4gIGZvcm1hdFRhcmdldChlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdnAoZSk7XG4gICAgaWYgKHR5cGVvZiBlID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gX3AoZSk7XG4gICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiVU5LTk9XTl9UWVBFXCIsIGBUYXJnZXQgdHlwZTogJHt0eXBlb2YgZX1gKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gIH1cbiAgYXN5bmMgc2V0RXhwaXJhdGlvbnMoZSkge1xuICAgIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBlKTtcbiAgfVxuICBhc3luYyBnZXRFeHBpcmF0aW9ucygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG4gIGFzeW5jIHBlcnNpc3QoKSB7XG4gICAgYXdhaXQgdGhpcy5zZXRFeHBpcmF0aW9ucyh0aGlzLnZhbHVlcyksIHRoaXMuZXZlbnRzLmVtaXQoVHQuc3luYyk7XG4gIH1cbiAgYXN5bmMgcmVzdG9yZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuZ2V0RXhwaXJhdGlvbnMoKTtcbiAgICAgIGlmICh0eXBlb2YgZSA+IFwidVwiIHx8ICFlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuZXhwaXJhdGlvbnMuc2l6ZSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJSRVNUT1JFX1dJTExfT1ZFUlJJREVcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3IodCksIG5ldyBFcnJvcih0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGVkID0gZSwgdGhpcy5sb2dnZXIuZGVidWcoYFN1Y2Nlc3NmdWxseSBSZXN0b3JlZCBleHBpcmF0aW9ucyBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInJlc3RvcmVcIiwgZXhwaXJhdGlvbnM6IHRoaXMudmFsdWVzIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gUmVzdG9yZSBleHBpcmF0aW9ucyBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBnZXRFeHBpcmF0aW9uKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5leHBpcmF0aW9ucy5nZXQoZSk7XG4gICAgaWYgKCF0KSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHMgfSA9IFkoXCJOT19NQVRDSElOR19LRVlcIiwgYCR7dGhpcy5uYW1lfTogJHtlfWApO1xuICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3IocyksIG5ldyBFcnJvcihzKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgY2hlY2tFeHBpcnkoZSwgdCkge1xuICAgIGNvbnN0IHsgZXhwaXJ5OiBzIH0gPSB0O1xuICAgIFYudG9NaWxpc2Vjb25kcyhzKSAtIERhdGUubm93KCkgPD0gMCAmJiB0aGlzLmV4cGlyZShlLCB0KTtcbiAgfVxuICBleHBpcmUoZSwgdCkge1xuICAgIHRoaXMuZXhwaXJhdGlvbnMuZGVsZXRlKGUpLCB0aGlzLmV2ZW50cy5lbWl0KFR0LmV4cGlyZWQsIHsgdGFyZ2V0OiBlLCBleHBpcmF0aW9uOiB0IH0pO1xuICB9XG4gIGNoZWNrRXhwaXJhdGlvbnMoKSB7XG4gICAgdGhpcy5jb3JlLnJlbGF5ZXIuY29ubmVjdGVkICYmIHRoaXMuZXhwaXJhdGlvbnMuZm9yRWFjaCgoZSwgdCkgPT4gdGhpcy5jaGVja0V4cGlyeSh0LCBlKSk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmNvcmUuaGVhcnRiZWF0Lm9uKFd0LkhFQVJUQkVBVF9FVkVOVFMucHVsc2UsICgpID0+IHRoaXMuY2hlY2tFeHBpcmF0aW9ucygpKSwgdGhpcy5ldmVudHMub24oVHQuY3JlYXRlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBUdC5jcmVhdGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIGRhdGE6IGUgfSksIHRoaXMucGVyc2lzdCgpO1xuICAgIH0pLCB0aGlzLmV2ZW50cy5vbihUdC5leHBpcmVkLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IFR0LmV4cGlyZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgZGF0YTogZSB9KSwgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSksIHRoaXMuZXZlbnRzLm9uKFR0LmRlbGV0ZWQsIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gVHQuZGVsZXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCBkYXRhOiBlIH0pLCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBZKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG59LCBpbSA9IGNsYXNzIGV4dGVuZHMgX2wge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCksIHRoaXMucHJvamVjdElkID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLm5hbWUgPSBOciwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnF1ZXVlID0gW10sIHRoaXMudmVyaWZ5RGlzYWJsZWQgPSAhMSwgdGhpcy5pbml0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIGlmICh0aGlzLnZlcmlmeURpc2FibGVkIHx8IHVyKCkgfHwgIXZzKCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBzPy52ZXJpZnlVcmwgfHwgS3M7XG4gICAgICB0aGlzLnZlcmlmeVVybCAhPT0gciAmJiB0aGlzLnJlbW92ZUlmcmFtZSgpLCB0aGlzLnZlcmlmeVVybCA9IHI7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUlmcmFtZSgpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBWZXJpZnkgaWZyYW1lIGZhaWxlZCB0byBsb2FkOiAke3RoaXMudmVyaWZ5VXJsfWApLCB0aGlzLmxvZ2dlci5pbmZvKG4pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSWZyYW1lKCksIHRoaXMudmVyaWZ5VXJsID0gdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVJZnJhbWUoKTtcbiAgICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFZlcmlmeSBpZnJhbWUgZmFpbGVkIHRvIGxvYWQ6ICR7dGhpcy52ZXJpZnlVcmx9YCksIHRoaXMubG9nZ2VyLmluZm8obiksIHRoaXMudmVyaWZ5RGlzYWJsZWQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMucmVnaXN0ZXIgPSBhc3luYyAocykgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA/IHRoaXMuc2VuZFBvc3Qocy5hdHRlc3RhdGlvbklkKSA6ICh0aGlzLmFkZFRvUXVldWUocy5hdHRlc3RhdGlvbklkKSwgYXdhaXQgdGhpcy5pbml0KCkpO1xuICAgIH0sIHRoaXMucmVzb2x2ZSA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0RldkVudilcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBjb25zdCByID0gcz8udmVyaWZ5VXJsIHx8IEtzO1xuICAgICAgbGV0IG47XG4gICAgICB0cnkge1xuICAgICAgICBuID0gYXdhaXQgdGhpcy5mZXRjaEF0dGVzdGF0aW9uKHMuYXR0ZXN0YXRpb25JZCwgcik7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYGZhaWxlZCB0byByZXNvbHZlIGF0dGVzdGF0aW9uOiAke3MuYXR0ZXN0YXRpb25JZH0gZnJvbSB1cmw6ICR7cn1gKSwgdGhpcy5sb2dnZXIuaW5mbyhvKSwgbiA9IGF3YWl0IHRoaXMuZmV0Y2hBdHRlc3RhdGlvbihzLmF0dGVzdGF0aW9uSWQsIHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH0sIHRoaXMuZmV0Y2hBdHRlc3RhdGlvbiA9IGFzeW5jIChzLCByKSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGByZXNvbHZpbmcgYXR0ZXN0YXRpb246ICR7c30gZnJvbSB1cmw6ICR7cn1gKTtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLnN0YXJ0QWJvcnRUaW1lcihWLk9ORV9TRUNPTkQgKiAyKSwgbyA9IGF3YWl0IGZldGNoKGAke3J9L2F0dGVzdGF0aW9uLyR7c31gLCB7IHNpZ25hbDogdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChuKSwgby5zdGF0dXMgPT09IDIwMCA/IGF3YWl0IG8uanNvbigpIDogdm9pZCAwO1xuICAgIH0sIHRoaXMuYWRkVG9RdWV1ZSA9IChzKSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2gocyk7XG4gICAgfSwgdGhpcy5wcm9jZXNzUXVldWUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLmxlbmd0aCAhPT0gMCAmJiAodGhpcy5xdWV1ZS5mb3JFYWNoKChzKSA9PiB0aGlzLnNlbmRQb3N0KHMpKSwgdGhpcy5xdWV1ZSA9IFtdKTtcbiAgICB9LCB0aGlzLnNlbmRQb3N0ID0gKHMpID0+IHtcbiAgICAgIHZhciByO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF0aGlzLmlmcmFtZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIChyID0gdGhpcy5pZnJhbWUuY29udGVudFdpbmRvdykgPT0gbnVsbCB8fCByLnBvc3RNZXNzYWdlKHMsIFwiKlwiKSwgdGhpcy5sb2dnZXIuaW5mbyhgcG9zdE1lc3NhZ2Ugc2VudDogJHtzfSAke3RoaXMudmVyaWZ5VXJsfWApO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfSwgdGhpcy5jcmVhdGVJZnJhbWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcztcbiAgICAgIGNvbnN0IHIgPSAobikgPT4ge1xuICAgICAgICBuLmRhdGEgPT09IFwidmVyaWZ5X3JlYWR5XCIgJiYgKHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCwgdGhpcy5wcm9jZXNzUXVldWUoKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHIpLCBzKCkpO1xuICAgICAgfTtcbiAgICAgIGF3YWl0IFByb21pc2UucmFjZShbbmV3IFByb21pc2UoKG4pID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKE5yKSlcbiAgICAgICAgICByZXR1cm4gbigpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcik7XG4gICAgICAgIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBvLmlkID0gTnIsIG8uc3JjID0gYCR7dGhpcy52ZXJpZnlVcmx9LyR7dGhpcy5wcm9qZWN0SWR9YCwgby5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIGRvY3VtZW50LmJvZHkuYXBwZW5kKG8pLCB0aGlzLmlmcmFtZSA9IG8sIHMgPSBuO1xuICAgICAgfSksIG5ldyBQcm9taXNlKChuLCBvKSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHIpLCBvKFwidmVyaWZ5IGlmcmFtZSBsb2FkIHRpbWVvdXRcIik7XG4gICAgICB9LCBWLnRvTWlsaXNlY29uZHMoVi5GSVZFX1NFQ09ORFMpKSldKTtcbiAgICB9LCB0aGlzLnJlbW92ZUlmcmFtZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaWZyYW1lICYmICh0aGlzLmlmcmFtZS5yZW1vdmUoKSwgdGhpcy5pZnJhbWUgPSB2b2lkIDAsIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSk7XG4gICAgfSwgdGhpcy5sb2dnZXIgPSBlZS5nZW5lcmF0ZUNoaWxkTG9nZ2VyKHQsIHRoaXMubmFtZSksIHRoaXMudmVyaWZ5VXJsID0gS3MsIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpLCB0aGlzLmlzRGV2RW52ID0geW4oKSAmJiBwcm9jZXNzLmVudi5JU19WSVRFU1Q7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIHN0YXJ0QWJvcnRUaW1lcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpLCBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCksIFYudG9NaWxpc2Vjb25kcyhlKSk7XG4gIH1cbn07XG52YXIgc20gPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGhhID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgcm0gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBubSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIHVhID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IHNtKGksIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW2VdID0gdCwgbGEgPSAoaSwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgcm0uY2FsbChlLCB0KSAmJiB1YShpLCB0LCBlW3RdKTtcbiAgaWYgKGhhKVxuICAgIGZvciAodmFyIHQgb2YgaGEoZSkpXG4gICAgICBubS5jYWxsKGUsIHQpICYmIHVhKGksIHQsIGVbdF0pO1xuICByZXR1cm4gaTtcbn07XG5sZXQgb20gPSBjbGFzcyB1aCBleHRlbmRzIGZsIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLnByb3RvY29sID0gYWgsIHRoaXMudmVyc2lvbiA9IG8xLCB0aGlzLm5hbWUgPSBFbiwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5vbiA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5vbihzLCByKSwgdGhpcy5vbmNlID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLm9uY2UocywgciksIHRoaXMub2ZmID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLm9mZihzLCByKSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihzLCByKSwgdGhpcy5wcm9qZWN0SWQgPSBlPy5wcm9qZWN0SWQsIHRoaXMucmVsYXlVcmwgPSBlPy5yZWxheVVybCB8fCBoaDtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGU/LmxvZ2dlciA8IFwidVwiICYmIHR5cGVvZiBlPy5sb2dnZXIgIT0gXCJzdHJpbmdcIiA/IGUubG9nZ2VyIDogZWUucGlubyhlZS5nZXREZWZhdWx0TG9nZ2VyT3B0aW9ucyh7IGxldmVsOiBlPy5sb2dnZXIgfHwgYTEubG9nZ2VyIH0pKTtcbiAgICB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy5oZWFydGJlYXQgPSBuZXcgV3QuSGVhcnRCZWF0KCksIHRoaXMuY3J5cHRvID0gbmV3IEYxKHRoaXMsIHRoaXMubG9nZ2VyLCBlPy5rZXljaGFpbiksIHRoaXMuaGlzdG9yeSA9IG5ldyBlbSh0aGlzLCB0aGlzLmxvZ2dlciksIHRoaXMuZXhwaXJlciA9IG5ldyB0bSh0aGlzLCB0aGlzLmxvZ2dlciksIHRoaXMuc3RvcmFnZSA9IGUgIT0gbnVsbCAmJiBlLnN0b3JhZ2UgPyBlLnN0b3JhZ2UgOiBuZXcgbmMobGEobGEoe30sIGMxKSwgZT8uc3RvcmFnZU9wdGlvbnMpKSwgdGhpcy5yZWxheWVyID0gbmV3IFkxKHsgY29yZTogdGhpcywgbG9nZ2VyOiB0aGlzLmxvZ2dlciwgcmVsYXlVcmw6IHRoaXMucmVsYXlVcmwsIHByb2plY3RJZDogdGhpcy5wcm9qZWN0SWQgfSksIHRoaXMucGFpcmluZyA9IG5ldyBaMSh0aGlzLCB0aGlzLmxvZ2dlciksIHRoaXMudmVyaWZ5ID0gbmV3IGltKHRoaXMucHJvamVjdElkIHx8IFwiXCIsIHRoaXMubG9nZ2VyKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgaW5pdChlKSB7XG4gICAgY29uc3QgdCA9IG5ldyB1aChlKTtcbiAgICBhd2FpdCB0LmluaXRpYWxpemUoKTtcbiAgICBjb25zdCBzID0gYXdhaXQgdC5jcnlwdG8uZ2V0Q2xpZW50SWQoKTtcbiAgICByZXR1cm4gYXdhaXQgdC5zdG9yYWdlLnNldEl0ZW0oSTEsIHMpLCB0O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBhc3luYyBzdGFydCgpIHtcbiAgICB0aGlzLmluaXRpYWxpemVkIHx8IGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jcnlwdG8uaW5pdCgpLCBhd2FpdCB0aGlzLmhpc3RvcnkuaW5pdCgpLCBhd2FpdCB0aGlzLmV4cGlyZXIuaW5pdCgpLCBhd2FpdCB0aGlzLnJlbGF5ZXIuaW5pdCgpLCBhd2FpdCB0aGlzLmhlYXJ0YmVhdC5pbml0KCksIGF3YWl0IHRoaXMucGFpcmluZy5pbml0KCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCwgdGhpcy5sb2dnZXIuaW5mbyhcIkNvcmUgSW5pdGlhbGl6YXRpb24gU3VjY2Vzc1wiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyB0aGlzLmxvZ2dlci53YXJuKGBDb3JlIEluaXRpYWxpemF0aW9uIEZhaWx1cmUgYXQgZXBvY2ggJHtEYXRlLm5vdygpfWAsIGUpLCB0aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpLCBlO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGFtID0gb20sIGxoID0gXCJ3Y1wiLCBkaCA9IDIsIGZoID0gXCJjbGllbnRcIiwgU24gPSBgJHtsaH1AJHtkaH06JHtmaH06YCwgUnIgPSB7IG5hbWU6IGZoLCBsb2dnZXI6IFwiZXJyb3JcIiwgY29udHJvbGxlcjogITEsIHJlbGF5VXJsOiBcIndzczovL3JlbGF5LndhbGxldGNvbm5lY3QuY29tXCIgfSwgZGEgPSBcIldBTExFVENPTk5FQ1RfREVFUExJTktfQ0hPSUNFXCIsIGNtID0gXCJwcm9wb3NhbFwiLCBobSA9IFwiUHJvcG9zYWwgZXhwaXJlZFwiLCB1bSA9IFwic2Vzc2lvblwiLCBGcyA9IFYuU0VWRU5fREFZUywgbG0gPSBcImVuZ2luZVwiLCBlcyA9IHsgd2Nfc2Vzc2lvblByb3Bvc2U6IHsgcmVxOiB7IHR0bDogVi5GSVZFX01JTlVURVMsIHByb21wdDogITAsIHRhZzogMTEwMCB9LCByZXM6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMSwgdGFnOiAxMTAxIH0gfSwgd2Nfc2Vzc2lvblNldHRsZTogeyByZXE6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMSwgdGFnOiAxMTAyIH0sIHJlczogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICExLCB0YWc6IDExMDMgfSB9LCB3Y19zZXNzaW9uVXBkYXRlOiB7IHJlcTogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTA0IH0sIHJlczogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTA1IH0gfSwgd2Nfc2Vzc2lvbkV4dGVuZDogeyByZXE6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTEwNiB9LCByZXM6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTEwNyB9IH0sIHdjX3Nlc3Npb25SZXF1ZXN0OiB7IHJlcTogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICEwLCB0YWc6IDExMDggfSwgcmVzOiB7IHR0bDogVi5GSVZFX01JTlVURVMsIHByb21wdDogITEsIHRhZzogMTEwOSB9IH0sIHdjX3Nlc3Npb25FdmVudDogeyByZXE6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMCwgdGFnOiAxMTEwIH0sIHJlczogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICExLCB0YWc6IDExMTEgfSB9LCB3Y19zZXNzaW9uRGVsZXRlOiB7IHJlcTogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTEyIH0sIHJlczogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTEzIH0gfSwgd2Nfc2Vzc2lvblBpbmc6IHsgcmVxOiB7IHR0bDogVi5USElSVFlfU0VDT05EUywgcHJvbXB0OiAhMSwgdGFnOiAxMTE0IH0sIHJlczogeyB0dGw6IFYuVEhJUlRZX1NFQ09ORFMsIHByb21wdDogITEsIHRhZzogMTExNSB9IH0gfSwgQ3IgPSB7IG1pbjogVi5GSVZFX01JTlVURVMsIG1heDogVi5TRVZFTl9EQVlTIH0sIGVpID0geyBpZGxlOiBcIklETEVcIiwgYWN0aXZlOiBcIkFDVElWRVwiIH0sIGRtID0gXCJyZXF1ZXN0XCIsIGZtID0gW1wid2Nfc2Vzc2lvblByb3Bvc2VcIiwgXCJ3Y19zZXNzaW9uUmVxdWVzdFwiLCBcIndjX2F1dGhSZXF1ZXN0XCJdO1xudmFyIHBtID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBnbSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCB5bSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBmYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIG1tID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgYm0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBwYSA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBwbShpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQsIEV0ID0gKGksIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIG1tLmNhbGwoZSwgdCkgJiYgcGEoaSwgdCwgZVt0XSk7XG4gIGlmIChmYSlcbiAgICBmb3IgKHZhciB0IG9mIGZhKGUpKVxuICAgICAgYm0uY2FsbChlLCB0KSAmJiBwYShpLCB0LCBlW3RdKTtcbiAgcmV0dXJuIGk7XG59LCB0cyA9IChpLCBlKSA9PiBnbShpLCB5bShlKSk7XG5sZXQgd20gPSBjbGFzcyBleHRlbmRzIFNsIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLm5hbWUgPSBsbSwgdGhpcy5ldmVudHMgPSBuZXcgaXIoKSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLmlnbm9yZWRQYXlsb2FkVHlwZXMgPSBbRGldLCB0aGlzLnJlcXVlc3RRdWV1ZSA9IHsgc3RhdGU6IGVpLmlkbGUsIHF1ZXVlOiBbXSB9LCB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUgPSB7IHN0YXRlOiBlaS5pZGxlLCBxdWV1ZTogW10gfSwgdGhpcy5yZXF1ZXN0UXVldWVEZWxheSA9IFYuT05FX1NFQ09ORCwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAoYXdhaXQgdGhpcy5jbGVhbnVwKCksIHRoaXMucmVnaXN0ZXJSZWxheWVyRXZlbnRzKCksIHRoaXMucmVnaXN0ZXJFeHBpcmVyRXZlbnRzKCksIHRoaXMucmVnaXN0ZXJQYWlyaW5nRXZlbnRzKCksIHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5yZWdpc3Rlcih7IG1ldGhvZHM6IE9iamVjdC5rZXlzKGVzKSB9KSwgdGhpcy5pbml0aWFsaXplZCA9ICEwLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXNzaW9uUmVxdWVzdFF1ZXVlLnF1ZXVlID0gdGhpcy5nZXRQZW5kaW5nU2Vzc2lvblJlcXVlc3RzKCksIHRoaXMucHJvY2Vzc1Nlc3Npb25SZXF1ZXN0UXVldWUoKTtcbiAgICAgIH0sIFYudG9NaWxpc2Vjb25kcyh0aGlzLnJlcXVlc3RRdWV1ZURlbGF5KSkpO1xuICAgIH0sIHRoaXMuY29ubmVjdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHMgPSB0cyhFdCh7fSwgdCksIHsgcmVxdWlyZWROYW1lc3BhY2VzOiB0LnJlcXVpcmVkTmFtZXNwYWNlcyB8fCB7fSwgb3B0aW9uYWxOYW1lc3BhY2VzOiB0Lm9wdGlvbmFsTmFtZXNwYWNlcyB8fCB7fSB9KTtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZENvbm5lY3Qocyk7XG4gICAgICBjb25zdCB7IHBhaXJpbmdUb3BpYzogciwgcmVxdWlyZWROYW1lc3BhY2VzOiBuLCBvcHRpb25hbE5hbWVzcGFjZXM6IG8sIHNlc3Npb25Qcm9wZXJ0aWVzOiBjLCByZWxheXM6IHUgfSA9IHM7XG4gICAgICBsZXQgZCA9IHIsIHAsIGIgPSAhMTtcbiAgICAgIGlmIChkICYmIChiID0gdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmdldChkKS5hY3RpdmUpLCAhZCB8fCAhYikge1xuICAgICAgICBjb25zdCB7IHRvcGljOiBELCB1cmk6IHkgfSA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5jcmVhdGUoKTtcbiAgICAgICAgZCA9IEQsIHAgPSB5O1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmdlbmVyYXRlS2V5UGFpcigpLCBPID0gRXQoeyByZXF1aXJlZE5hbWVzcGFjZXM6IG4sIG9wdGlvbmFsTmFtZXNwYWNlczogbywgcmVsYXlzOiB1ID8/IFt7IHByb3RvY29sOiBjaCB9XSwgcHJvcG9zZXI6IHsgcHVibGljS2V5OiB4LCBtZXRhZGF0YTogdGhpcy5jbGllbnQubWV0YWRhdGEgfSB9LCBjICYmIHsgc2Vzc2lvblByb3BlcnRpZXM6IGMgfSksIHsgcmVqZWN0OiBfLCByZXNvbHZlOiBDLCBkb25lOiBGIH0gPSBBaShWLkZJVkVfTUlOVVRFUywgaG0pO1xuICAgICAgaWYgKHRoaXMuZXZlbnRzLm9uY2UoQmUoXCJzZXNzaW9uX2Nvbm5lY3RcIiksIGFzeW5jICh7IGVycm9yOiBELCBzZXNzaW9uOiB5IH0pID0+IHtcbiAgICAgICAgaWYgKEQpXG4gICAgICAgICAgXyhEKTtcbiAgICAgICAgZWxzZSBpZiAoeSkge1xuICAgICAgICAgIHkuc2VsZi5wdWJsaWNLZXkgPSB4O1xuICAgICAgICAgIGNvbnN0IHcgPSB0cyhFdCh7fSwgeSksIHsgcmVxdWlyZWROYW1lc3BhY2VzOiB5LnJlcXVpcmVkTmFtZXNwYWNlcywgb3B0aW9uYWxOYW1lc3BhY2VzOiB5Lm9wdGlvbmFsTmFtZXNwYWNlcyB9KTtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLnNldCh5LnRvcGljLCB3KSwgYXdhaXQgdGhpcy5zZXRFeHBpcnkoeS50b3BpYywgeS5leHBpcnkpLCBkICYmIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy51cGRhdGVNZXRhZGF0YSh7IHRvcGljOiBkLCBtZXRhZGF0YTogeS5wZWVyLm1ldGFkYXRhIH0pLCBDKHcpO1xuICAgICAgICB9XG4gICAgICB9KSwgIWQpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBEIH0gPSBZKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGBjb25uZWN0KCkgcGFpcmluZyB0b3BpYzogJHtkfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRCk7XG4gICAgICB9XG4gICAgICBjb25zdCBLID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7IHRvcGljOiBkLCBtZXRob2Q6IFwid2Nfc2Vzc2lvblByb3Bvc2VcIiwgcGFyYW1zOiBPIH0pLCBJID0gTXQoVi5GSVZFX01JTlVURVMpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0UHJvcG9zYWwoSywgRXQoeyBpZDogSywgZXhwaXJ5OiBJIH0sIE8pKSwgeyB1cmk6IHAsIGFwcHJvdmFsOiBGIH07XG4gICAgfSwgdGhpcy5wYWlyID0gYXN5bmMgKHQpID0+IChhd2FpdCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXIodCkpLCB0aGlzLmFwcHJvdmUgPSBhc3luYyAodCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZEFwcHJvdmUodCk7XG4gICAgICBjb25zdCB7IGlkOiBzLCByZWxheVByb3RvY29sOiByLCBuYW1lc3BhY2VzOiBuLCBzZXNzaW9uUHJvcGVydGllczogbyB9ID0gdCwgYyA9IHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldChzKTtcbiAgICAgIGxldCB7IHBhaXJpbmdUb3BpYzogdSwgcHJvcG9zZXI6IGQsIHJlcXVpcmVkTmFtZXNwYWNlczogcCwgb3B0aW9uYWxOYW1lc3BhY2VzOiBiIH0gPSBjO1xuICAgICAgdSA9IHUgfHwgXCJcIiwgY3MocCkgfHwgKHAgPSBVcChuLCBcImFwcHJvdmUoKVwiKSk7XG4gICAgICBjb25zdCB4ID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZ2VuZXJhdGVLZXlQYWlyKCksIE8gPSBkLnB1YmxpY0tleSwgXyA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmdlbmVyYXRlU2hhcmVkS2V5KHgsIE8pO1xuICAgICAgdSAmJiBzICYmIChhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcudXBkYXRlTWV0YWRhdGEoeyB0b3BpYzogdSwgbWV0YWRhdGE6IGQubWV0YWRhdGEgfSksIGF3YWl0IHRoaXMuc2VuZFJlc3VsdCh7IGlkOiBzLCB0b3BpYzogdSwgcmVzdWx0OiB7IHJlbGF5OiB7IHByb3RvY29sOiByID8/IFwiaXJuXCIgfSwgcmVzcG9uZGVyUHVibGljS2V5OiB4IH0gfSksIGF3YWl0IHRoaXMuY2xpZW50LnByb3Bvc2FsLmRlbGV0ZShzLCBudChcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLmFjdGl2YXRlKHsgdG9waWM6IHUgfSkpO1xuICAgICAgY29uc3QgQyA9IEV0KHsgcmVsYXk6IHsgcHJvdG9jb2w6IHIgPz8gXCJpcm5cIiB9LCBuYW1lc3BhY2VzOiBuLCByZXF1aXJlZE5hbWVzcGFjZXM6IHAsIG9wdGlvbmFsTmFtZXNwYWNlczogYiwgcGFpcmluZ1RvcGljOiB1LCBjb250cm9sbGVyOiB7IHB1YmxpY0tleTogeCwgbWV0YWRhdGE6IHRoaXMuY2xpZW50Lm1ldGFkYXRhIH0sIGV4cGlyeTogTXQoRnMpIH0sIG8gJiYgeyBzZXNzaW9uUHJvcGVydGllczogbyB9KTtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5zdWJzY3JpYmUoXyksIGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoeyB0b3BpYzogXywgbWV0aG9kOiBcIndjX3Nlc3Npb25TZXR0bGVcIiwgcGFyYW1zOiBDLCB0aHJvd09uRmFpbGVkUHVibGlzaDogITAgfSk7XG4gICAgICBjb25zdCBGID0gdHMoRXQoe30sIEMpLCB7IHRvcGljOiBfLCBwYWlyaW5nVG9waWM6IHUsIGFja25vd2xlZGdlZDogITEsIHNlbGY6IEMuY29udHJvbGxlciwgcGVlcjogeyBwdWJsaWNLZXk6IGQucHVibGljS2V5LCBtZXRhZGF0YTogZC5tZXRhZGF0YSB9LCBjb250cm9sbGVyOiB4IH0pO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24uc2V0KF8sIEYpLCBhd2FpdCB0aGlzLnNldEV4cGlyeShfLCBNdChGcykpLCB7IHRvcGljOiBfLCBhY2tub3dsZWRnZWQ6ICgpID0+IG5ldyBQcm9taXNlKChLKSA9PiBzZXRUaW1lb3V0KCgpID0+IEsodGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQoXykpLCA1MDApKSB9O1xuICAgIH0sIHRoaXMucmVqZWN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRSZWplY3QodCk7XG4gICAgICBjb25zdCB7IGlkOiBzLCByZWFzb246IHIgfSA9IHQsIHsgcGFpcmluZ1RvcGljOiBuIH0gPSB0aGlzLmNsaWVudC5wcm9wb3NhbC5nZXQocyk7XG4gICAgICBuICYmIChhd2FpdCB0aGlzLnNlbmRFcnJvcihzLCBuLCByKSwgYXdhaXQgdGhpcy5jbGllbnQucHJvcG9zYWwuZGVsZXRlKHMsIG50KFwiVVNFUl9ESVNDT05ORUNURURcIikpKTtcbiAgICB9LCB0aGlzLnVwZGF0ZSA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkVXBkYXRlKHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcywgbmFtZXNwYWNlczogciB9ID0gdCwgbiA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoeyB0b3BpYzogcywgbWV0aG9kOiBcIndjX3Nlc3Npb25VcGRhdGVcIiwgcGFyYW1zOiB7IG5hbWVzcGFjZXM6IHIgfSB9KSwgeyBkb25lOiBvLCByZXNvbHZlOiBjLCByZWplY3Q6IHUgfSA9IEFpKCk7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudHMub25jZShCZShcInNlc3Npb25fdXBkYXRlXCIsIG4pLCAoeyBlcnJvcjogZCB9KSA9PiB7XG4gICAgICAgIGQgPyB1KGQpIDogYygpO1xuICAgICAgfSksIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24udXBkYXRlKHMsIHsgbmFtZXNwYWNlczogciB9KSwgeyBhY2tub3dsZWRnZWQ6IG8gfTtcbiAgICB9LCB0aGlzLmV4dGVuZCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkRXh0ZW5kKHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcyB9ID0gdCwgciA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoeyB0b3BpYzogcywgbWV0aG9kOiBcIndjX3Nlc3Npb25FeHRlbmRcIiwgcGFyYW1zOiB7fSB9KSwgeyBkb25lOiBuLCByZXNvbHZlOiBvLCByZWplY3Q6IGMgfSA9IEFpKCk7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudHMub25jZShCZShcInNlc3Npb25fZXh0ZW5kXCIsIHIpLCAoeyBlcnJvcjogdSB9KSA9PiB7XG4gICAgICAgIHUgPyBjKHUpIDogbygpO1xuICAgICAgfSksIGF3YWl0IHRoaXMuc2V0RXhwaXJ5KHMsIE10KEZzKSksIHsgYWNrbm93bGVkZ2VkOiBuIH07XG4gICAgfSwgdGhpcy5yZXF1ZXN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRSZXF1ZXN0KHQpO1xuICAgICAgY29uc3QgeyBjaGFpbklkOiBzLCByZXF1ZXN0OiByLCB0b3BpYzogbiwgZXhwaXJ5OiBvIH0gPSB0LCBjID0gd24oKSwgeyBkb25lOiB1LCByZXNvbHZlOiBkLCByZWplY3Q6IHAgfSA9IEFpKG8pO1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLm9uY2UoQmUoXCJzZXNzaW9uX3JlcXVlc3RcIiwgYyksICh7IGVycm9yOiBiLCByZXN1bHQ6IHggfSkgPT4ge1xuICAgICAgICBiID8gcChiKSA6IGQoeCk7XG4gICAgICB9KSwgYXdhaXQgUHJvbWlzZS5hbGwoW25ldyBQcm9taXNlKGFzeW5jIChiKSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoeyBjbGllbnRScGNJZDogYywgdG9waWM6IG4sIG1ldGhvZDogXCJ3Y19zZXNzaW9uUmVxdWVzdFwiLCBwYXJhbXM6IHsgcmVxdWVzdDogciwgY2hhaW5JZDogcyB9LCBleHBpcnk6IG8sIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KS5jYXRjaCgoeCkgPT4gcCh4KSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9yZXF1ZXN0X3NlbnRcIiwgeyB0b3BpYzogbiwgcmVxdWVzdDogciwgY2hhaW5JZDogcywgaWQ6IGMgfSksIGIoKTtcbiAgICAgIH0pLCBuZXcgUHJvbWlzZShhc3luYyAoYikgPT4ge1xuICAgICAgICBjb25zdCB4ID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5zdG9yYWdlLmdldEl0ZW0oZGEpO1xuICAgICAgICBFcCh7IGlkOiBjLCB0b3BpYzogbiwgd2NEZWVwTGluazogeCB9KSwgYigpO1xuICAgICAgfSksIHUoKV0pLnRoZW4oKGIpID0+IGJbMl0pO1xuICAgIH0sIHRoaXMucmVzcG9uZCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkUmVzcG9uZCh0KTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIHJlc3BvbnNlOiByIH0gPSB0LCB7IGlkOiBuIH0gPSByO1xuICAgICAgaHQocikgPyBhd2FpdCB0aGlzLnNlbmRSZXN1bHQoeyBpZDogbiwgdG9waWM6IHMsIHJlc3VsdDogci5yZXN1bHQsIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KSA6IEdlKHIpICYmIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHMsIHIuZXJyb3IpLCB0aGlzLmNsZWFudXBBZnRlclJlc3BvbnNlKHQpO1xuICAgIH0sIHRoaXMucGluZyA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkUGluZyh0KTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMgfSA9IHQ7XG4gICAgICBpZiAodGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKHMpKSB7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHsgdG9waWM6IHMsIG1ldGhvZDogXCJ3Y19zZXNzaW9uUGluZ1wiLCBwYXJhbXM6IHt9IH0pLCB7IGRvbmU6IG4sIHJlc29sdmU6IG8sIHJlamVjdDogYyB9ID0gQWkoKTtcbiAgICAgICAgdGhpcy5ldmVudHMub25jZShCZShcInNlc3Npb25fcGluZ1wiLCByKSwgKHsgZXJyb3I6IHUgfSkgPT4ge1xuICAgICAgICAgIHUgPyBjKHUpIDogbygpO1xuICAgICAgICB9KSwgYXdhaXQgbigpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHMpICYmIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5waW5nKHsgdG9waWM6IHMgfSk7XG4gICAgfSwgdGhpcy5lbWl0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRFbWl0KHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcywgZXZlbnQ6IHIsIGNoYWluSWQ6IG4gfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHsgdG9waWM6IHMsIG1ldGhvZDogXCJ3Y19zZXNzaW9uRXZlbnRcIiwgcGFyYW1zOiB7IGV2ZW50OiByLCBjaGFpbklkOiBuIH0gfSk7XG4gICAgfSwgdGhpcy5kaXNjb25uZWN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWREaXNjb25uZWN0KHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcyB9ID0gdDtcbiAgICAgIHRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyhzKSA/IChhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHsgdG9waWM6IHMsIG1ldGhvZDogXCJ3Y19zZXNzaW9uRGVsZXRlXCIsIHBhcmFtczogbnQoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSwgdGhyb3dPbkZhaWxlZFB1Ymxpc2g6ICEwIH0pLCBhd2FpdCB0aGlzLmRlbGV0ZVNlc3Npb24ocykpIDogYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLmRpc2Nvbm5lY3QoeyB0b3BpYzogcyB9KTtcbiAgICB9LCB0aGlzLmZpbmQgPSAodCkgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmNsaWVudC5zZXNzaW9uLmdldEFsbCgpLmZpbHRlcigocykgPT4gcXAocywgdCkpKSwgdGhpcy5nZXRQZW5kaW5nU2Vzc2lvblJlcXVlc3RzID0gKCkgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmNsaWVudC5wZW5kaW5nUmVxdWVzdC5nZXRBbGwoKSksIHRoaXMuY2xlYW51cER1cGxpY2F0ZVBhaXJpbmdzID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICh0LnBhaXJpbmdUb3BpYylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzID0gdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmdldCh0LnBhaXJpbmdUb3BpYyksIHIgPSB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3MuZ2V0QWxsKCkuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgICB2YXIgbywgYztcbiAgICAgICAgICAgIHJldHVybiAoKG8gPSBuLnBlZXJNZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8udXJsKSAmJiAoKGMgPSBuLnBlZXJNZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IGMudXJsKSA9PT0gdC5wZWVyLm1ldGFkYXRhLnVybCAmJiBuLnRvcGljICYmIG4udG9waWMgIT09IHMudG9waWM7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHIubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBDbGVhbmluZyB1cCAke3IubGVuZ3RofSBkdXBsaWNhdGUgcGFpcmluZyhzKWApLCBhd2FpdCBQcm9taXNlLmFsbChyLm1hcCgobikgPT4gdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLmRpc2Nvbm5lY3QoeyB0b3BpYzogbi50b3BpYyB9KSkpLCB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhcIkR1cGxpY2F0ZSBwYWlyaW5ncyBjbGVhbiB1cCBmaW5pc2hlZFwiKTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihzKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMuZGVsZXRlU2Vzc2lvbiA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IHNlbGY6IHIgfSA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KHQpO1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnVuc3Vic2NyaWJlKHQpLCB0aGlzLmNsaWVudC5zZXNzaW9uLmRlbGV0ZSh0LCBudChcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8ua2V5Y2hhaW4uaGFzKHIucHVibGljS2V5KSAmJiBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5kZWxldGVLZXlQYWlyKHIucHVibGljS2V5KSwgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8ua2V5Y2hhaW4uaGFzKHQpICYmIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmRlbGV0ZVN5bUtleSh0KSwgcyB8fCB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuZGVsKHQpLCB0aGlzLmNsaWVudC5jb3JlLnN0b3JhZ2UucmVtb3ZlSXRlbShkYSkuY2F0Y2goKG4pID0+IHRoaXMuY2xpZW50LmxvZ2dlci53YXJuKG4pKTtcbiAgICB9LCB0aGlzLmRlbGV0ZVByb3Bvc2FsID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmNsaWVudC5wcm9wb3NhbC5kZWxldGUodCwgbnQoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIHMgPyBQcm9taXNlLnJlc29sdmUoKSA6IHRoaXMuY2xpZW50LmNvcmUuZXhwaXJlci5kZWwodCldKTtcbiAgICB9LCB0aGlzLmRlbGV0ZVBlbmRpbmdTZXNzaW9uUmVxdWVzdCA9IGFzeW5jICh0LCBzLCByID0gITEpID0+IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmNsaWVudC5wZW5kaW5nUmVxdWVzdC5kZWxldGUodCwgcyksIHIgPyBQcm9taXNlLnJlc29sdmUoKSA6IHRoaXMuY2xpZW50LmNvcmUuZXhwaXJlci5kZWwodCldKSwgdGhpcy5zZXNzaW9uUmVxdWVzdFF1ZXVlLnF1ZXVlID0gdGhpcy5zZXNzaW9uUmVxdWVzdFF1ZXVlLnF1ZXVlLmZpbHRlcigobikgPT4gbi5pZCAhPT0gdCksIHIgJiYgKHRoaXMuc2Vzc2lvblJlcXVlc3RRdWV1ZS5zdGF0ZSA9IGVpLmlkbGUpO1xuICAgIH0sIHRoaXMuc2V0RXhwaXJ5ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIHRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyh0KSAmJiBhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLnVwZGF0ZSh0LCB7IGV4cGlyeTogcyB9KSwgdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLnNldCh0LCBzKTtcbiAgICB9LCB0aGlzLnNldFByb3Bvc2FsID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnByb3Bvc2FsLnNldCh0LCBzKSwgdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLnNldCh0LCBzLmV4cGlyeSk7XG4gICAgfSwgdGhpcy5zZXRQZW5kaW5nU2Vzc2lvblJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgY29uc3QgcyA9IGVzLndjX3Nlc3Npb25SZXF1ZXN0LnJlcS50dGwsIHsgaWQ6IHIsIHRvcGljOiBuLCBwYXJhbXM6IG8sIHZlcmlmeUNvbnRleHQ6IGMgfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5wZW5kaW5nUmVxdWVzdC5zZXQociwgeyBpZDogciwgdG9waWM6IG4sIHBhcmFtczogbywgdmVyaWZ5Q29udGV4dDogYyB9KSwgcyAmJiB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuc2V0KHIsIE10KHMpKTtcbiAgICB9LCB0aGlzLnNlbmRSZXF1ZXN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIG1ldGhvZDogciwgcGFyYW1zOiBuLCBleHBpcnk6IG8sIHJlbGF5UnBjSWQ6IGMsIGNsaWVudFJwY0lkOiB1LCB0aHJvd09uRmFpbGVkUHVibGlzaDogZCB9ID0gdCwgcCA9IHRpKHIsIG4sIHUpO1xuICAgICAgaWYgKHZzKCkgJiYgZm0uaW5jbHVkZXMocikpIHtcbiAgICAgICAgY29uc3QgTyA9IEZpKEpTT04uc3RyaW5naWZ5KHApKTtcbiAgICAgICAgdGhpcy5jbGllbnQuY29yZS52ZXJpZnkucmVnaXN0ZXIoeyBhdHRlc3RhdGlvbklkOiBPIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgYiA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmVuY29kZShzLCBwKSwgeCA9IGVzW3JdLnJlcTtcbiAgICAgIHJldHVybiBvICYmICh4LnR0bCA9IG8pLCBjICYmICh4LmlkID0gYyksIHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5zZXQocywgcCksIGQgPyAoeC5pbnRlcm5hbCA9IHRzKEV0KHt9LCB4LmludGVybmFsKSwgeyB0aHJvd09uRmFpbGVkUHVibGlzaDogITAgfSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKHMsIGIsIHgpKSA6IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKHMsIGIsIHgpLmNhdGNoKChPKSA9PiB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoTykpLCBwLmlkO1xuICAgIH0sIHRoaXMuc2VuZFJlc3VsdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBzLCB0b3BpYzogciwgcmVzdWx0OiBuLCB0aHJvd09uRmFpbGVkUHVibGlzaDogbyB9ID0gdCwgYyA9IHhpKHMsIG4pLCB1ID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZW5jb2RlKHIsIGMpLCBkID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LmdldChyLCBzKSwgcCA9IGVzW2QucmVxdWVzdC5tZXRob2RdLnJlcztcbiAgICAgIG8gPyAocC5pbnRlcm5hbCA9IHRzKEV0KHt9LCBwLmludGVybmFsKSwgeyB0aHJvd09uRmFpbGVkUHVibGlzaDogITAgfSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKHIsIHUsIHApKSA6IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKHIsIHUsIHApLmNhdGNoKChiKSA9PiB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoYikpLCBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkucmVzb2x2ZShjKTtcbiAgICB9LCB0aGlzLnNlbmRFcnJvciA9IGFzeW5jICh0LCBzLCByKSA9PiB7XG4gICAgICBjb25zdCBuID0gcWkodCwgciksIG8gPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5lbmNvZGUocywgbiksIGMgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkuZ2V0KHMsIHQpLCB1ID0gZXNbYy5yZXF1ZXN0Lm1ldGhvZF0ucmVzO1xuICAgICAgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnB1Ymxpc2gocywgbywgdSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5yZXNvbHZlKG4pO1xuICAgIH0sIHRoaXMuY2xlYW51cCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBbXSwgcyA9IFtdO1xuICAgICAgdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXRBbGwoKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIGFpKHIuZXhwaXJ5KSAmJiB0LnB1c2goci50b3BpYyk7XG4gICAgICB9KSwgdGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0QWxsKCkuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICBhaShyLmV4cGlyeSkgJiYgcy5wdXNoKHIuaWQpO1xuICAgICAgfSksIGF3YWl0IFByb21pc2UuYWxsKFsuLi50Lm1hcCgocikgPT4gdGhpcy5kZWxldGVTZXNzaW9uKHIpKSwgLi4ucy5tYXAoKHIpID0+IHRoaXMuZGVsZXRlUHJvcG9zYWwocikpXSk7XG4gICAgfSwgdGhpcy5vblJlbGF5RXZlbnRSZXF1ZXN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnF1ZXVlLnB1c2godCksIGF3YWl0IHRoaXMucHJvY2Vzc1JlcXVlc3RzUXVldWUoKTtcbiAgICB9LCB0aGlzLnByb2Nlc3NSZXF1ZXN0c1F1ZXVlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVxdWVzdFF1ZXVlLnN0YXRlID09PSBlaS5hY3RpdmUpIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oXCJSZXF1ZXN0IHF1ZXVlIGFscmVhZHkgYWN0aXZlLCBza2lwcGluZy4uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhgUmVxdWVzdCBxdWV1ZSBzdGFydGluZyB3aXRoICR7dGhpcy5yZXF1ZXN0UXVldWUucXVldWUubGVuZ3RofSByZXF1ZXN0c2ApOyB0aGlzLnJlcXVlc3RRdWV1ZS5xdWV1ZS5sZW5ndGggPiAwOyApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuc3RhdGUgPSBlaS5hY3RpdmU7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnJlcXVlc3RRdWV1ZS5xdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAodClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUmVxdWVzdCh0KSwgYXdhaXQgbmV3IFByb21pc2UoKHMpID0+IHNldFRpbWVvdXQocywgMzAwKSk7XG4gICAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLndhcm4ocyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuc3RhdGUgPSBlaS5pZGxlO1xuICAgIH0sIHRoaXMucHJvY2Vzc1JlcXVlc3QgPSAodCkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogcywgcGF5bG9hZDogciB9ID0gdCwgbiA9IHIubWV0aG9kO1xuICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUHJvcG9zZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblByb3Bvc2VSZXF1ZXN0KHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblNldHRsZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblNldHRsZVJlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uVXBkYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uVXBkYXRlUmVxdWVzdChzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25FeHRlbmRcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25FeHRlbmRSZXF1ZXN0KHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblBpbmdcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25QaW5nUmVxdWVzdChzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25EZWxldGVcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25EZWxldGVSZXF1ZXN0KHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblJlcXVlc3RcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25SZXF1ZXN0KHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvbkV2ZW50XCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uRXZlbnRSZXF1ZXN0KHMsIHIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhgVW5zdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2QgJHtufWApO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25SZWxheUV2ZW50UmVzcG9uc2UgPSBhc3luYyAodCkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogcywgcGF5bG9hZDogciB9ID0gdCwgbiA9IChhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkuZ2V0KHMsIHIuaWQpKS5yZXF1ZXN0Lm1ldGhvZDtcbiAgICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblByb3Bvc2VcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25Qcm9wb3NlUmVzcG9uc2Uocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uU2V0dGxlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uU2V0dGxlUmVzcG9uc2Uocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uVXBkYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uVXBkYXRlUmVzcG9uc2Uocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uRXh0ZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uRXh0ZW5kUmVzcG9uc2Uocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUGluZ1wiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblBpbmdSZXNwb25zZShzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25SZXF1ZXN0XCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uUmVxdWVzdFJlc3BvbnNlKHMsIHIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhgVW5zdXBwb3J0ZWQgcmVzcG9uc2UgbWV0aG9kICR7bn1gKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uUmVsYXlFdmVudFVua25vd25QYXlsb2FkID0gKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMgfSA9IHQsIHsgbWVzc2FnZTogciB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgRGVjb2RlZCBwYXlsb2FkIG9uIHRvcGljICR7c30gaXMgbm90IGlkZW50aWZpYWJsZSBhcyBhIEpTT04tUlBDIHJlcXVlc3Qgb3IgYSByZXNwb25zZS5gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvblByb3Bvc2VSZXF1ZXN0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zOiByLCBpZDogbiB9ID0gcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZENvbm5lY3QoRXQoe30sIHMucGFyYW1zKSk7XG4gICAgICAgIGNvbnN0IG8gPSBNdChWLkZJVkVfTUlOVVRFUyksIGMgPSBFdCh7IGlkOiBuLCBwYWlyaW5nVG9waWM6IHQsIGV4cGlyeTogbyB9LCByKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRQcm9wb3NhbChuLCBjKTtcbiAgICAgICAgY29uc3QgdSA9IEZpKEpTT04uc3RyaW5naWZ5KHMpKSwgZCA9IGF3YWl0IHRoaXMuZ2V0VmVyaWZ5Q29udGV4dCh1LCBjLnByb3Bvc2VyLm1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX3Byb3Bvc2FsXCIsIHsgaWQ6IG4sIHBhcmFtczogYywgdmVyaWZ5Q29udGV4dDogZCB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IobiwgdCwgbyksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZSA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgaWYgKGh0KHMpKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0OiBuIH0gPSBzO1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHJlc3VsdDogbiB9KTtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldChyKTtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcIm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZVwiLCBwcm9wb3NhbDogbyB9KTtcbiAgICAgICAgY29uc3QgYyA9IG8ucHJvcG9zZXIucHVibGljS2V5O1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHNlbGZQdWJsaWNLZXk6IGMgfSk7XG4gICAgICAgIGNvbnN0IHUgPSBuLnJlc3BvbmRlclB1YmxpY0tleTtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcIm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZVwiLCBwZWVyUHVibGljS2V5OiB1IH0pO1xuICAgICAgICBjb25zdCBkID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZ2VuZXJhdGVTaGFyZWRLZXkoYywgdSk7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25Qcm9wb3NlUmVzcG9uc2VcIiwgc2Vzc2lvblRvcGljOiBkIH0pO1xuICAgICAgICBjb25zdCBwID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnN1YnNjcmliZShkKTtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcIm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZVwiLCBzdWJzY3JpcHRpb25JZDogcCB9KSwgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLmFjdGl2YXRlKHsgdG9waWM6IHQgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgR2UocykgJiYgKGF3YWl0IHRoaXMuY2xpZW50LnByb3Bvc2FsLmRlbGV0ZShyLCBudChcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgdGhpcy5ldmVudHMuZW1pdChCZShcInNlc3Npb25fY29ubmVjdFwiKSwgeyBlcnJvcjogcy5lcnJvciB9KSk7XG4gICAgfSwgdGhpcy5vblNlc3Npb25TZXR0bGVSZXF1ZXN0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIsIHBhcmFtczogbiB9ID0gcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZFNlc3Npb25TZXR0bGVSZXF1ZXN0KG4pO1xuICAgICAgICBjb25zdCB7IHJlbGF5OiBvLCBjb250cm9sbGVyOiBjLCBleHBpcnk6IHUsIG5hbWVzcGFjZXM6IGQsIHJlcXVpcmVkTmFtZXNwYWNlczogcCwgb3B0aW9uYWxOYW1lc3BhY2VzOiBiLCBzZXNzaW9uUHJvcGVydGllczogeCwgcGFpcmluZ1RvcGljOiBPIH0gPSBzLnBhcmFtcywgXyA9IEV0KHsgdG9waWM6IHQsIHJlbGF5OiBvLCBleHBpcnk6IHUsIG5hbWVzcGFjZXM6IGQsIGFja25vd2xlZGdlZDogITAsIHBhaXJpbmdUb3BpYzogTywgcmVxdWlyZWROYW1lc3BhY2VzOiBwLCBvcHRpb25hbE5hbWVzcGFjZXM6IGIsIGNvbnRyb2xsZXI6IGMucHVibGljS2V5LCBzZWxmOiB7IHB1YmxpY0tleTogXCJcIiwgbWV0YWRhdGE6IHRoaXMuY2xpZW50Lm1ldGFkYXRhIH0sIHBlZXI6IHsgcHVibGljS2V5OiBjLnB1YmxpY0tleSwgbWV0YWRhdGE6IGMubWV0YWRhdGEgfSB9LCB4ICYmIHsgc2Vzc2lvblByb3BlcnRpZXM6IHggfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFJlc3VsdCh7IGlkOiBzLmlkLCB0b3BpYzogdCwgcmVzdWx0OiAhMCB9KSwgdGhpcy5ldmVudHMuZW1pdChCZShcInNlc3Npb25fY29ubmVjdFwiKSwgeyBzZXNzaW9uOiBfIH0pLCB0aGlzLmNsZWFudXBEdXBsaWNhdGVQYWlyaW5ncyhfKTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IociwgdCwgbyksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblNldHRsZVJlc3BvbnNlID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICBodChzKSA/IChhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLnVwZGF0ZSh0LCB7IGFja25vd2xlZGdlZDogITAgfSksIHRoaXMuZXZlbnRzLmVtaXQoQmUoXCJzZXNzaW9uX2FwcHJvdmVcIiwgciksIHt9KSkgOiBHZShzKSAmJiAoYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi5kZWxldGUodCwgbnQoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIHRoaXMuZXZlbnRzLmVtaXQoQmUoXCJzZXNzaW9uX2FwcHJvdmVcIiwgciksIHsgZXJyb3I6IHMuZXJyb3IgfSkpO1xuICAgIH0sIHRoaXMub25TZXNzaW9uVXBkYXRlUmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IHBhcmFtczogciwgaWQ6IG4gfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvID0gYCR7dH1fc2Vzc2lvbl91cGRhdGVgLCBjID0gJHMuZ2V0KG8pO1xuICAgICAgICBpZiAoYyAmJiB0aGlzLmlzUmVxdWVzdE91dE9mU3luYyhjLCBuKSkge1xuICAgICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBEaXNjYXJkaW5nIG91dCBvZiBzeW5jIHJlcXVlc3QgLSAke259YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNWYWxpZFVwZGF0ZShFdCh7IHRvcGljOiB0IH0sIHIpKSwgYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi51cGRhdGUodCwgeyBuYW1lc3BhY2VzOiByLm5hbWVzcGFjZXMgfSksIGF3YWl0IHRoaXMuc2VuZFJlc3VsdCh7IGlkOiBuLCB0b3BpYzogdCwgcmVzdWx0OiAhMCB9KSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX3VwZGF0ZVwiLCB7IGlkOiBuLCB0b3BpYzogdCwgcGFyYW1zOiByIH0pLCAkcy5zZXQobywgbik7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHQsIG8pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1JlcXVlc3RPdXRPZlN5bmMgPSAodCwgcykgPT4gcGFyc2VJbnQocy50b1N0cmluZygpLnNsaWNlKDAsIC0zKSkgPD0gcGFyc2VJbnQodC50b1N0cmluZygpLnNsaWNlKDAsIC0zKSksIHRoaXMub25TZXNzaW9uVXBkYXRlUmVzcG9uc2UgPSAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIGh0KHMpID8gdGhpcy5ldmVudHMuZW1pdChCZShcInNlc3Npb25fdXBkYXRlXCIsIHIpLCB7fSkgOiBHZShzKSAmJiB0aGlzLmV2ZW50cy5lbWl0KEJlKFwic2Vzc2lvbl91cGRhdGVcIiwgciksIHsgZXJyb3I6IHMuZXJyb3IgfSk7XG4gICAgfSwgdGhpcy5vblNlc3Npb25FeHRlbmRSZXF1ZXN0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRFeHRlbmQoeyB0b3BpYzogdCB9KSwgYXdhaXQgdGhpcy5zZXRFeHBpcnkodCwgTXQoRnMpKSwgYXdhaXQgdGhpcy5zZW5kUmVzdWx0KHsgaWQ6IHIsIHRvcGljOiB0LCByZXN1bHQ6ICEwIH0pLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fZXh0ZW5kXCIsIHsgaWQ6IHIsIHRvcGljOiB0IH0pO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihyLCB0LCBuKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG4pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uRXh0ZW5kUmVzcG9uc2UgPSAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIGh0KHMpID8gdGhpcy5ldmVudHMuZW1pdChCZShcInNlc3Npb25fZXh0ZW5kXCIsIHIpLCB7fSkgOiBHZShzKSAmJiB0aGlzLmV2ZW50cy5lbWl0KEJlKFwic2Vzc2lvbl9leHRlbmRcIiwgciksIHsgZXJyb3I6IHMuZXJyb3IgfSk7XG4gICAgfSwgdGhpcy5vblNlc3Npb25QaW5nUmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkUGluZyh7IHRvcGljOiB0IH0pLCBhd2FpdCB0aGlzLnNlbmRSZXN1bHQoeyBpZDogciwgdG9waWM6IHQsIHJlc3VsdDogITAgfSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9waW5nXCIsIHsgaWQ6IHIsIHRvcGljOiB0IH0pO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihyLCB0LCBuKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG4pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uUGluZ1Jlc3BvbnNlID0gKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaHQocykgPyB0aGlzLmV2ZW50cy5lbWl0KEJlKFwic2Vzc2lvbl9waW5nXCIsIHIpLCB7fSkgOiBHZShzKSAmJiB0aGlzLmV2ZW50cy5lbWl0KEJlKFwic2Vzc2lvbl9waW5nXCIsIHIpLCB7IGVycm9yOiBzLmVycm9yIH0pO1xuICAgICAgfSwgNTAwKTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvbkRlbGV0ZVJlcXVlc3QgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZERpc2Nvbm5lY3QoeyB0b3BpYzogdCwgcmVhc29uOiBzLnBhcmFtcyB9KSwgYXdhaXQgUHJvbWlzZS5hbGwoW25ldyBQcm9taXNlKChuKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLm9uY2UoZ3QucHVibGlzaCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbihhd2FpdCB0aGlzLmRlbGV0ZVNlc3Npb24odCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgdGhpcy5zZW5kUmVzdWx0KHsgaWQ6IHIsIHRvcGljOiB0LCByZXN1bHQ6ICEwIH0pXSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9kZWxldGVcIiwgeyBpZDogciwgdG9waWM6IHQgfSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihuKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblJlcXVlc3QgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciwgcGFyYW1zOiBuIH0gPSBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkUmVxdWVzdChFdCh7IHRvcGljOiB0IH0sIG4pKTtcbiAgICAgICAgY29uc3QgbyA9IEZpKEpTT04uc3RyaW5naWZ5KHRpKFwid2Nfc2Vzc2lvblJlcXVlc3RcIiwgbiwgcikpKSwgYyA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KHQpLCB1ID0gYXdhaXQgdGhpcy5nZXRWZXJpZnlDb250ZXh0KG8sIGMucGVlci5tZXRhZGF0YSksIGQgPSB7IGlkOiByLCB0b3BpYzogdCwgcGFyYW1zOiBuLCB2ZXJpZnlDb250ZXh0OiB1IH07XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0UGVuZGluZ1Nlc3Npb25SZXF1ZXN0KGQpLCB0aGlzLmFkZFNlc3Npb25SZXF1ZXN0VG9TZXNzaW9uUmVxdWVzdFF1ZXVlKGQpLCB0aGlzLnByb2Nlc3NTZXNzaW9uUmVxdWVzdFF1ZXVlKCk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKHIsIHQsIG8pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25SZXF1ZXN0UmVzcG9uc2UgPSAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIGh0KHMpID8gdGhpcy5ldmVudHMuZW1pdChCZShcInNlc3Npb25fcmVxdWVzdFwiLCByKSwgeyByZXN1bHQ6IHMucmVzdWx0IH0pIDogR2UocykgJiYgdGhpcy5ldmVudHMuZW1pdChCZShcInNlc3Npb25fcmVxdWVzdFwiLCByKSwgeyBlcnJvcjogcy5lcnJvciB9KTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvbkV2ZW50UmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByLCBwYXJhbXM6IG4gfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvID0gYCR7dH1fc2Vzc2lvbl9ldmVudF8ke24uZXZlbnQubmFtZX1gLCBjID0gJHMuZ2V0KG8pO1xuICAgICAgICBpZiAoYyAmJiB0aGlzLmlzUmVxdWVzdE91dE9mU3luYyhjLCByKSkge1xuICAgICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBEaXNjYXJkaW5nIG91dCBvZiBzeW5jIHJlcXVlc3QgLSAke3J9YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNWYWxpZEVtaXQoRXQoeyB0b3BpYzogdCB9LCBuKSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9ldmVudFwiLCB7IGlkOiByLCB0b3BpYzogdCwgcGFyYW1zOiBuIH0pLCAkcy5zZXQobywgcik7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKHIsIHQsIG8pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5hZGRTZXNzaW9uUmVxdWVzdFRvU2Vzc2lvblJlcXVlc3RRdWV1ZSA9ICh0KSA9PiB7XG4gICAgICB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUucXVldWUucHVzaCh0KTtcbiAgICB9LCB0aGlzLmNsZWFudXBBZnRlclJlc3BvbnNlID0gKHQpID0+IHtcbiAgICAgIHRoaXMuZGVsZXRlUGVuZGluZ1Nlc3Npb25SZXF1ZXN0KHQucmVzcG9uc2UuaWQsIHsgbWVzc2FnZTogXCJmdWxmaWxsZWRcIiwgY29kZTogMCB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2Vzc2lvblJlcXVlc3RRdWV1ZS5zdGF0ZSA9IGVpLmlkbGUsIHRoaXMucHJvY2Vzc1Nlc3Npb25SZXF1ZXN0UXVldWUoKTtcbiAgICAgIH0sIFYudG9NaWxpc2Vjb25kcyh0aGlzLnJlcXVlc3RRdWV1ZURlbGF5KSk7XG4gICAgfSwgdGhpcy5wcm9jZXNzU2Vzc2lvblJlcXVlc3RRdWV1ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUuc3RhdGUgPT09IGVpLmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhcInNlc3Npb24gcmVxdWVzdCBxdWV1ZSBpcyBhbHJlYWR5IGFjdGl2ZS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUucXVldWVbMF07XG4gICAgICBpZiAoIXQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oXCJzZXNzaW9uIHJlcXVlc3QgcXVldWUgaXMgZW1wdHkuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUuc3RhdGUgPSBlaS5hY3RpdmUsIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9yZXF1ZXN0XCIsIHQpO1xuICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iocyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblBhaXJpbmdDcmVhdGVkID0gKHQpID0+IHtcbiAgICAgIGlmICh0LmFjdGl2ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcyA9IHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldEFsbCgpLmZpbmQoKHIpID0+IHIucGFpcmluZ1RvcGljID09PSB0LnRvcGljKTtcbiAgICAgIHMgJiYgdGhpcy5vblNlc3Npb25Qcm9wb3NlUmVxdWVzdCh0LnRvcGljLCB0aShcIndjX3Nlc3Npb25Qcm9wb3NlXCIsIHsgcmVxdWlyZWROYW1lc3BhY2VzOiBzLnJlcXVpcmVkTmFtZXNwYWNlcywgb3B0aW9uYWxOYW1lc3BhY2VzOiBzLm9wdGlvbmFsTmFtZXNwYWNlcywgcmVsYXlzOiBzLnJlbGF5cywgcHJvcG9zZXI6IHMucHJvcG9zZXIgfSwgcy5pZCkpO1xuICAgIH0sIHRoaXMuaXNWYWxpZENvbm5lY3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFTdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHUgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGNvbm5lY3QoKSBwYXJhbXM6ICR7SlNPTi5zdHJpbmdpZnkodCl9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcGFpcmluZ1RvcGljOiBzLCByZXF1aXJlZE5hbWVzcGFjZXM6IHIsIG9wdGlvbmFsTmFtZXNwYWNlczogbiwgc2Vzc2lvblByb3BlcnRpZXM6IG8sIHJlbGF5czogYyB9ID0gdDtcbiAgICAgIGlmIChidChzKSB8fCBhd2FpdCB0aGlzLmlzVmFsaWRQYWlyaW5nVG9waWMocyksICFRcChjLCAhMCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBjb25uZWN0KCkgcmVsYXlzOiAke2N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgICFidChyKSAmJiBjcyhyKSAhPT0gMCAmJiB0aGlzLnZhbGlkYXRlTmFtZXNwYWNlcyhyLCBcInJlcXVpcmVkTmFtZXNwYWNlc1wiKSwgIWJ0KG4pICYmIGNzKG4pICE9PSAwICYmIHRoaXMudmFsaWRhdGVOYW1lc3BhY2VzKG4sIFwib3B0aW9uYWxOYW1lc3BhY2VzXCIpLCBidChvKSB8fCB0aGlzLnZhbGlkYXRlU2Vzc2lvblByb3BzKG8sIFwic2Vzc2lvblByb3BlcnRpZXNcIik7XG4gICAgfSwgdGhpcy52YWxpZGF0ZU5hbWVzcGFjZXMgPSAodCwgcykgPT4ge1xuICAgICAgY29uc3QgciA9IEpwKHQsIFwiY29ubmVjdCgpXCIsIHMpO1xuICAgICAgaWYgKHIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyLm1lc3NhZ2UpO1xuICAgIH0sIHRoaXMuaXNWYWxpZEFwcHJvdmUgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFTdCh0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGFwcHJvdmUoKSBwYXJhbXM6ICR7dH1gKS5tZXNzYWdlKTtcbiAgICAgIGNvbnN0IHsgaWQ6IHMsIG5hbWVzcGFjZXM6IHIsIHJlbGF5UHJvdG9jb2w6IG4sIHNlc3Npb25Qcm9wZXJ0aWVzOiBvIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkUHJvcG9zYWxJZChzKTtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmNsaWVudC5wcm9wb3NhbC5nZXQocyksIHUgPSB6cyhyLCBcImFwcHJvdmUoKVwiKTtcbiAgICAgIGlmICh1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodS5tZXNzYWdlKTtcbiAgICAgIGNvbnN0IGQgPSBNbyhjLnJlcXVpcmVkTmFtZXNwYWNlcywgciwgXCJhcHByb3ZlKClcIik7XG4gICAgICBpZiAoZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGQubWVzc2FnZSk7XG4gICAgICBpZiAoIW90KG4sICEwKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHAgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGFwcHJvdmUoKSByZWxheVByb3RvY29sOiAke259YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwKTtcbiAgICAgIH1cbiAgICAgIGJ0KG8pIHx8IHRoaXMudmFsaWRhdGVTZXNzaW9uUHJvcHMobywgXCJzZXNzaW9uUHJvcGVydGllc1wiKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRSZWplY3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFTdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlamVjdCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGlkOiBzLCByZWFzb246IHIgfSA9IHQ7XG4gICAgICBpZiAoYXdhaXQgdGhpcy5pc1ZhbGlkUHJvcG9zYWxJZChzKSwgIVpwKHIpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVqZWN0KCkgcmVhc29uOiAke0pTT04uc3RyaW5naWZ5KHIpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkU2Vzc2lvblNldHRsZVJlcXVlc3QgPSAodCkgPT4ge1xuICAgICAgaWYgKCFTdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGQgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYG9uU2Vzc2lvblNldHRsZVJlcXVlc3QoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyByZWxheTogcywgY29udHJvbGxlcjogciwgbmFtZXNwYWNlczogbiwgZXhwaXJ5OiBvIH0gPSB0O1xuICAgICAgaWYgKCFLYyhzKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGQgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgXCJvblNlc3Npb25TZXR0bGVSZXF1ZXN0KCkgcmVsYXkgcHJvdG9jb2wgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjID0gQnAociwgXCJvblNlc3Npb25TZXR0bGVSZXF1ZXN0KClcIik7XG4gICAgICBpZiAoYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMubWVzc2FnZSk7XG4gICAgICBjb25zdCB1ID0genMobiwgXCJvblNlc3Npb25TZXR0bGVSZXF1ZXN0KClcIik7XG4gICAgICBpZiAodSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUubWVzc2FnZSk7XG4gICAgICBpZiAoYWkobykpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBkIH0gPSBZKFwiRVhQSVJFRFwiLCBcIm9uU2Vzc2lvblNldHRsZVJlcXVlc3QoKVwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaXNWYWxpZFVwZGF0ZSA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIVN0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgdXBkYXRlKCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIG5hbWVzcGFjZXM6IHIgfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMocyk7XG4gICAgICBjb25zdCBuID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQocyksIG8gPSB6cyhyLCBcInVwZGF0ZSgpXCIpO1xuICAgICAgaWYgKG8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvLm1lc3NhZ2UpO1xuICAgICAgY29uc3QgYyA9IE1vKG4ucmVxdWlyZWROYW1lc3BhY2VzLCByLCBcInVwZGF0ZSgpXCIpO1xuICAgICAgaWYgKGMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjLm1lc3NhZ2UpO1xuICAgIH0sIHRoaXMuaXNWYWxpZEV4dGVuZCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIVN0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZXh0ZW5kKCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHMgfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMocyk7XG4gICAgfSwgdGhpcy5pc1ZhbGlkUmVxdWVzdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIVN0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVxdWVzdCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodSk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCByZXF1ZXN0OiByLCBjaGFpbklkOiBuLCBleHBpcnk6IG8gfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMocyk7XG4gICAgICBjb25zdCB7IG5hbWVzcGFjZXM6IGMgfSA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KHMpO1xuICAgICAgaWYgKCFMbyhjLCBuKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHUgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlcXVlc3QoKSBjaGFpbklkOiAke259YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgIGlmICghZWcocikpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXF1ZXN0KCkgJHtKU09OLnN0cmluZ2lmeShyKX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgICAgfVxuICAgICAgaWYgKCFzZyhjLCBuLCByLm1ldGhvZCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXF1ZXN0KCkgbWV0aG9kOiAke3IubWV0aG9kfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodSk7XG4gICAgICB9XG4gICAgICBpZiAobyAmJiAhYWcobywgQ3IpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVxdWVzdCgpIGV4cGlyeTogJHtvfS4gRXhwaXJ5IG11c3QgYmUgYSBudW1iZXIgKGluIHNlY29uZHMpIGJldHdlZW4gJHtDci5taW59IGFuZCAke0NyLm1heH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaXNWYWxpZFJlc3BvbmQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFTdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlc3BvbmQoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogcywgcmVzcG9uc2U6IHIgfSA9IHQ7XG4gICAgICBpZiAoYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKHMpLCAhdGcocikpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXNwb25kKCkgcmVzcG9uc2U6ICR7SlNPTi5zdHJpbmdpZnkocil9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWRQaW5nID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghU3QodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwaW5nKCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHMgfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uT3JQYWlyaW5nVG9waWMocyk7XG4gICAgfSwgdGhpcy5pc1ZhbGlkRW1pdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIVN0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogYyB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZW1pdCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCBldmVudDogciwgY2hhaW5JZDogbiB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFNlc3Npb25Ub3BpYyhzKTtcbiAgICAgIGNvbnN0IHsgbmFtZXNwYWNlczogbyB9ID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQocyk7XG4gICAgICBpZiAoIUxvKG8sIG4pKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogYyB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZW1pdCgpIGNoYWluSWQ6ICR7bn1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMpO1xuICAgICAgfVxuICAgICAgaWYgKCFpZyhyKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGMgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGVtaXQoKSBldmVudDogJHtKU09OLnN0cmluZ2lmeShyKX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZyhvLCBuLCByLm5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogYyB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZW1pdCgpIGV2ZW50OiAke0pTT04uc3RyaW5naWZ5KHIpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkRGlzY29ubmVjdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIVN0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZGlzY29ubmVjdCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBzIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvbk9yUGFpcmluZ1RvcGljKHMpO1xuICAgIH0sIHRoaXMuZ2V0VmVyaWZ5Q29udGV4dCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCByID0geyB2ZXJpZmllZDogeyB2ZXJpZnlVcmw6IHMudmVyaWZ5VXJsIHx8IEtzLCB2YWxpZGF0aW9uOiBcIlVOS05PV05cIiwgb3JpZ2luOiBzLnVybCB8fCBcIlwiIH0gfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG4gPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnZlcmlmeS5yZXNvbHZlKHsgYXR0ZXN0YXRpb25JZDogdCwgdmVyaWZ5VXJsOiBzLnZlcmlmeVVybCB9KTtcbiAgICAgICAgbiAmJiAoci52ZXJpZmllZC5vcmlnaW4gPSBuLm9yaWdpbiwgci52ZXJpZmllZC5pc1NjYW0gPSBuLmlzU2NhbSwgci52ZXJpZmllZC52YWxpZGF0aW9uID0gbi5vcmlnaW4gPT09IG5ldyBVUkwocy51cmwpLm9yaWdpbiA/IFwiVkFMSURcIiA6IFwiSU5WQUxJRFwiKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8obik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oYFZlcmlmeSBjb250ZXh0OiAke0pTT04uc3RyaW5naWZ5KHIpfWApLCByO1xuICAgIH0sIHRoaXMudmFsaWRhdGVTZXNzaW9uUHJvcHMgPSAodCwgcykgPT4ge1xuICAgICAgT2JqZWN0LnZhbHVlcyh0KS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIGlmICghb3QociwgITEpKSB7XG4gICAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGAke3N9IG11c3QgYmUgaW4gUmVjb3JkPHN0cmluZywgc3RyaW5nPiBmb3JtYXQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHIpfWApO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBhc3luYyBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBZKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5jb25maXJtT25saW5lU3RhdGVPclRocm93KCk7XG4gIH1cbiAgcmVnaXN0ZXJSZWxheWVyRXZlbnRzKCkge1xuICAgIHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5vbihndC5tZXNzYWdlLCBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogdCwgbWVzc2FnZTogcyB9ID0gZTtcbiAgICAgIGlmICh0aGlzLmlnbm9yZWRQYXlsb2FkVHlwZXMuaW5jbHVkZXModGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZ2V0UGF5bG9hZFR5cGUocykpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZGVjb2RlKHQsIHMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgamkocikgPyAodGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LnNldCh0LCByKSwgdGhpcy5vblJlbGF5RXZlbnRSZXF1ZXN0KHsgdG9waWM6IHQsIHBheWxvYWQ6IHIgfSkpIDogT2kocikgPyAoYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LnJlc29sdmUociksIGF3YWl0IHRoaXMub25SZWxheUV2ZW50UmVzcG9uc2UoeyB0b3BpYzogdCwgcGF5bG9hZDogciB9KSwgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LmRlbGV0ZSh0LCByLmlkKSkgOiB0aGlzLm9uUmVsYXlFdmVudFVua25vd25QYXlsb2FkKHsgdG9waWM6IHQsIHBheWxvYWQ6IHIgfSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZWdpc3RlckV4cGlyZXJFdmVudHMoKSB7XG4gICAgdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLm9uKFR0LmV4cGlyZWQsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiB0LCBpZDogcyB9ID0gamMoZS50YXJnZXQpO1xuICAgICAgaWYgKHMgJiYgdGhpcy5jbGllbnQucGVuZGluZ1JlcXVlc3Qua2V5cy5pbmNsdWRlcyhzKSlcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVsZXRlUGVuZGluZ1Nlc3Npb25SZXF1ZXN0KHMsIFkoXCJFWFBJUkVEXCIpLCAhMCk7XG4gICAgICB0ID8gdGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKHQpICYmIChhd2FpdCB0aGlzLmRlbGV0ZVNlc3Npb24odCwgITApLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fZXhwaXJlXCIsIHsgdG9waWM6IHQgfSkpIDogcyAmJiAoYXdhaXQgdGhpcy5kZWxldGVQcm9wb3NhbChzLCAhMCksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwicHJvcG9zYWxfZXhwaXJlXCIsIHsgaWQ6IHMgfSkpO1xuICAgIH0pO1xuICB9XG4gIHJlZ2lzdGVyUGFpcmluZ0V2ZW50cygpIHtcbiAgICB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuZXZlbnRzLm9uKG9zLmNyZWF0ZSwgKGUpID0+IHRoaXMub25QYWlyaW5nQ3JlYXRlZChlKSk7XG4gIH1cbiAgaXNWYWxpZFBhaXJpbmdUb3BpYyhlKSB7XG4gICAgaWYgKCFvdChlLCAhMSkpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcGFpcmluZyB0b3BpYyBzaG91bGQgYmUgYSBzdHJpbmc6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhlKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGBwYWlyaW5nIHRvcGljIGRvZXNuJ3QgZXhpc3Q6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gICAgaWYgKGFpKHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5nZXQoZSkuZXhwaXJ5KSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiRVhQSVJFRFwiLCBgcGFpcmluZyB0b3BpYzogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBpc1ZhbGlkU2Vzc2lvblRvcGljKGUpIHtcbiAgICBpZiAoIW90KGUsICExKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBzZXNzaW9uIHRvcGljIHNob3VsZCBiZSBhIHN0cmluZzogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyhlKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGBzZXNzaW9uIHRvcGljIGRvZXNuJ3QgZXhpc3Q6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gICAgaWYgKGFpKHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KGUpLmV4cGlyeSkpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVsZXRlU2Vzc2lvbihlKTtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gWShcIkVYUElSRURcIiwgYHNlc3Npb24gdG9waWM6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaXNWYWxpZFNlc3Npb25PclBhaXJpbmdUb3BpYyhlKSB7XG4gICAgaWYgKHRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyhlKSlcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFNlc3Npb25Ub3BpYyhlKTtcbiAgICBlbHNlIGlmICh0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhlKSlcbiAgICAgIHRoaXMuaXNWYWxpZFBhaXJpbmdUb3BpYyhlKTtcbiAgICBlbHNlIGlmIChvdChlLCAhMSkpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gWShcIk5PX01BVENISU5HX0tFWVwiLCBgc2Vzc2lvbiBvciBwYWlyaW5nIHRvcGljIGRvZXNuJ3QgZXhpc3Q6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBzZXNzaW9uIG9yIHBhaXJpbmcgdG9waWMgc2hvdWxkIGJlIGEgc3RyaW5nOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGlzVmFsaWRQcm9wb3NhbElkKGUpIHtcbiAgICBpZiAoIVhwKGUpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHByb3Bvc2FsIGlkIHNob3VsZCBiZSBhIG51bWJlcjogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2xpZW50LnByb3Bvc2FsLmtleXMuaW5jbHVkZXMoZSkpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gWShcIk5PX01BVENISU5HX0tFWVwiLCBgcHJvcG9zYWwgaWQgZG9lc24ndCBleGlzdDogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAoYWkodGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0KGUpLmV4cGlyeSkpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVsZXRlUHJvcG9zYWwoZSk7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJFWFBJUkVEXCIsIGBwcm9wb3NhbCBpZDogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgfVxufSwgdm0gPSBjbGFzcyBleHRlbmRzIGRyIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQsIGNtLCBTbiksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufSwgX20gPSBjbGFzcyBleHRlbmRzIGRyIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQsIHVtLCBTbiksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufSwgRW0gPSBjbGFzcyBleHRlbmRzIGRyIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQsIGRtLCBTbiwgKHMpID0+IHMuaWQpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQ7XG4gIH1cbn0sIFNtID0gY2xhc3MgcGggZXh0ZW5kcyBFbCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKSwgdGhpcy5wcm90b2NvbCA9IGxoLCB0aGlzLnZlcnNpb24gPSBkaCwgdGhpcy5uYW1lID0gUnIubmFtZSwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMub24gPSAocywgcikgPT4gdGhpcy5ldmVudHMub24ocywgciksIHRoaXMub25jZSA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5vbmNlKHMsIHIpLCB0aGlzLm9mZiA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5vZmYocywgciksIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSAocywgcikgPT4gdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIocywgciksIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzID0gKHMpID0+IHRoaXMuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycyhzKSwgdGhpcy5jb25uZWN0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5jb25uZWN0KHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMucGFpciA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUucGFpcihzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmFwcHJvdmUgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmFwcHJvdmUocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5yZWplY3QgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLnJlamVjdChzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnVwZGF0ZSA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUudXBkYXRlKHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMuZXh0ZW5kID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5leHRlbmQocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5yZXF1ZXN0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5yZXF1ZXN0KHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMucmVzcG9uZCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUucmVzcG9uZChzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnBpbmcgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLnBpbmcocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5lbWl0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5lbWl0KHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMuZGlzY29ubmVjdCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUuZGlzY29ubmVjdChzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmZpbmQgPSAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5naW5lLmZpbmQocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5nZXRQZW5kaW5nU2Vzc2lvblJlcXVlc3RzID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5naW5lLmdldFBlbmRpbmdTZXNzaW9uUmVxdWVzdHMoKTtcbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Iocy5tZXNzYWdlKSwgcztcbiAgICAgIH1cbiAgICB9LCB0aGlzLm5hbWUgPSBlPy5uYW1lIHx8IFJyLm5hbWUsIHRoaXMubWV0YWRhdGEgPSBlPy5tZXRhZGF0YSB8fCBncCgpO1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZT8ubG9nZ2VyIDwgXCJ1XCIgJiYgdHlwZW9mIGU/LmxvZ2dlciAhPSBcInN0cmluZ1wiID8gZS5sb2dnZXIgOiBlZS5waW5vKGVlLmdldERlZmF1bHRMb2dnZXJPcHRpb25zKHsgbGV2ZWw6IGU/LmxvZ2dlciB8fCBSci5sb2dnZXIgfSkpO1xuICAgIHRoaXMuY29yZSA9IGU/LmNvcmUgfHwgbmV3IGFtKGUpLCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy5zZXNzaW9uID0gbmV3IF9tKHRoaXMuY29yZSwgdGhpcy5sb2dnZXIpLCB0aGlzLnByb3Bvc2FsID0gbmV3IHZtKHRoaXMuY29yZSwgdGhpcy5sb2dnZXIpLCB0aGlzLnBlbmRpbmdSZXF1ZXN0ID0gbmV3IEVtKHRoaXMuY29yZSwgdGhpcy5sb2dnZXIpLCB0aGlzLmVuZ2luZSA9IG5ldyB3bSh0aGlzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgaW5pdChlKSB7XG4gICAgY29uc3QgdCA9IG5ldyBwaChlKTtcbiAgICByZXR1cm4gYXdhaXQgdC5pbml0aWFsaXplKCksIHQ7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBwYWlyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvcmUucGFpcmluZy5wYWlyaW5ncztcbiAgfVxuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY29yZS5zdGFydCgpLCBhd2FpdCB0aGlzLnNlc3Npb24uaW5pdCgpLCBhd2FpdCB0aGlzLnByb3Bvc2FsLmluaXQoKSwgYXdhaXQgdGhpcy5wZW5kaW5nUmVxdWVzdC5pbml0KCksIGF3YWl0IHRoaXMuZW5naW5lLmluaXQoKSwgdGhpcy5jb3JlLnZlcmlmeS5pbml0KHsgdmVyaWZ5VXJsOiB0aGlzLm1ldGFkYXRhLnZlcmlmeVVybCB9KSwgdGhpcy5sb2dnZXIuaW5mbyhcIlNpZ25DbGllbnQgSW5pdGlhbGl6YXRpb24gU3VjY2Vzc1wiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyB0aGlzLmxvZ2dlci5pbmZvKFwiU2lnbkNsaWVudCBJbml0aWFsaXphdGlvbiBGYWlsdXJlXCIpLCB0aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpLCBlO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IEltID0gKCkgPT4ge1xuICBjb25zdCBlID0gaG4oKT8ub3M/LnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBlPy5pbmNsdWRlcyhcImFuZHJvaWRcIikgPyBcImFuZHJvaWRcIiA6IGU/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJpb3NcIikgfHwgZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcIm1hY1wiKSAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxID8gXCJpb3NcIiA6IFwiZGVza3RvcFwiO1xufSwgVXMgPSBJbSgpLCBEbSA9IHtcbiAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgdG9wOiBcIjBcIixcbiAgbGVmdDogXCIwXCIsXG4gIHJpZ2h0OiBcIjBcIixcbiAgYm90dG9tOiBcIjBcIixcbiAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoMCwwLDAsMC44KVwiLFxuICBiYWNrZHJvcEZpbHRlcjogXCJibHVyKDEwcHgpXCIsXG4gIHpJbmRleDogXCI5OTk5XCIsXG4gIGRpc3BsYXk6IFwiZmxleFwiLFxuICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgY29sb3I6IFwid2hpdGVcIixcbiAgZm9udFdlaWdodDogXCI1MDBcIixcbiAgZm9udEZhbWlseTogXCInQmFybG93Jywgc2Fucy1zZXJpZlwiXG59LCB4bSA9IHtcbiAgd2lkdGg6IFwiODQwcHhcIixcbiAgaGVpZ2h0OiBcIjU0MHB4XCIsXG4gIHpJbmRleDogXCI5OTk5OVwiLFxuICBiYWNrZ3JvdW5kQ29sb3I6IFwid2hpdGVcIixcbiAgYm9yZGVyOiBcIm5vbmVcIixcbiAgb3V0bGluZTogXCJub25lXCIsXG4gIGJvcmRlclJhZGl1czogXCI0MHB4XCIsXG4gIGJveFNoYWRvdzogXCIwcHggNHB4IDQwcHggMHB4IHJnYigwIDAgMCksIDBweCA0cHggOHB4IDBweCByZ2IoMCAwIDAgLyAyNSUpXCIsXG4gIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gIHRvcDogXCI1MCVcIixcbiAgbGVmdDogXCI1MCVcIixcbiAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLC01MCUpXCJcbn0sIE9tID0gYFxuICA8ZGl2IGlkPVwiYXJnZW50LW1vYmlsZS1tb2RhbC1jb250YWluZXJcIiBzdHlsZT1cInBvc2l0aW9uOiByZWxhdGl2ZVwiPlxuICAgIDxpZnJhbWUgY2xhc3M9XCJhcmdlbnQtaWZyYW1lXCIgYWxsb3c9XCJjbGlwYm9hcmQtd3JpdGVcIj48L2lmcmFtZT5cbiAgICA8ZGl2IGNsYXNzPVwiYXJnZW50LWNsb3NlLWJ1dHRvblwiIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IDI0cHg7IHJpZ2h0OiAyNHB4OyBjdXJzb3I6IHBvaW50ZXI7XCI+XG4gICAgICA8c3ZnIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgPGNpcmNsZSBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxNlwiIGZpbGw9XCIjRjVGM0YwXCIvPlxuICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNMjIuMjQ2MiA5Ljc1MzgyQzIyLjcwMTggMTAuMjA5NCAyMi43MDE4IDEwLjk0ODEgMjIuMjQ2MiAxMS40MDM3TDE3LjY0OTkgMTZMMjIuMjQ2MiAyMC41OTYzQzIyLjcwMTggMjEuMDUxOSAyMi43MDE4IDIxLjc5MDYgMjIuMjQ2MiAyMi4yNDYyQzIxLjc5MDUgMjIuNzAxOCAyMS4wNTE5IDIyLjcwMTggMjAuNTk2MiAyMi4yNDYyTDE2IDE3LjY0OTlMMTEuNDAzOSAyMi4yNDZDMTAuOTQ4MiAyMi43MDE3IDEwLjIwOTYgMjIuNzAxNyA5Ljc1Mzk0IDIyLjI0NkM5LjI5ODMzIDIxLjc5MDQgOS4yOTgzMyAyMS4wNTE3IDkuNzUzOTQgMjAuNTk2MUwxNC4zNTAxIDE2TDkuNzUzOTQgMTEuNDAzOUM5LjI5ODMzIDEwLjk0ODMgOS4yOTgzMyAxMC4yMDk2IDkuNzUzOTQgOS43NTM5NkMxMC4yMDk2IDkuMjk4MzUgMTAuOTQ4MiA5LjI5ODM1IDExLjQwMzkgOS43NTM5NkwxNiAxNC4zNTAxTDIwLjU5NjIgOS43NTM4MkMyMS4wNTE5IDkuMjk4MjEgMjEuNzkwNSA5LjI5ODIxIDIyLjI0NjIgOS43NTM4MlpcIiBmaWxsPVwiIzMzMzMzMlwiLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbmA7XG5jbGFzcyBObSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHdlKHRoaXMsIFwiYnJpZGdlVXJsXCIsIFwiaHR0cHM6Ly9sb2dpbi5hcmdlbnQueHl6XCIpO1xuICAgIHdlKHRoaXMsIFwibW9iaWxlVXJsXCIsIFwiYXJnZW50Oi8vXCIpO1xuICAgIHdlKHRoaXMsIFwidHlwZVwiLCBcIm92ZXJsYXlcIik7XG4gICAgd2UodGhpcywgXCJ3Y1VyaVwiKTtcbiAgICB3ZSh0aGlzLCBcIm92ZXJsYXlcIik7XG4gICAgd2UodGhpcywgXCJwb3B1cFdpbmRvd1wiKTtcbiAgICB3ZSh0aGlzLCBcImNsb3NpbmdUaW1lb3V0XCIpO1xuICAgIHdlKHRoaXMsIFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vdmVybGF5Py5yZW1vdmUoKSwgdGhpcy5wb3B1cFdpbmRvdz8uY2xvc2UoKSwgdGhpcy5vdmVybGF5ID0gdm9pZCAwLCB0aGlzLnBvcHVwV2luZG93ID0gdm9pZCAwO1xuICAgIH0pO1xuICB9XG4gIHNob3dDb25uZWN0aW9uTW9kYWwoZSkge1xuICAgIGNvbnN0IHQgPSBlbmNvZGVVUklDb21wb25lbnQoZSksIHMgPSBlbmNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIHRoaXMuc2hvd01vZGFsKHtcbiAgICAgIGRlc2t0b3A6IGAke3RoaXMuYnJpZGdlVXJsfT93Yz0ke3R9JmRldmljZT1kZXNrdG9wYCxcbiAgICAgIGlvczogYCR7dGhpcy5tb2JpbGVVcmx9YXBwL3djP3VyaT0ke3R9JmhyZWY9JHtzfSZkZXZpY2U9bW9iaWxlYCxcbiAgICAgIGFuZHJvaWQ6IGAke3RoaXMubW9iaWxlVXJsfWFwcC93Yz91cmk9JHt0fSZocmVmPSR7c30mZGV2aWNlPW1vYmlsZWBcbiAgICB9KTtcbiAgfVxuICBzaG93QXBwcm92YWxNb2RhbChlKSB7XG4gICAgaWYgKFVzID09PSBcImRlc2t0b3BcIikge1xuICAgICAgdGhpcy5zaG93TW9kYWwoe1xuICAgICAgICBkZXNrdG9wOiBgJHt0aGlzLmJyaWRnZVVybH0/YWN0aW9uPXNpZ25gLFxuICAgICAgICBpb3M6IFwiXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB0aGlzLnNob3dNb2RhbCh7XG4gICAgICBkZXNrdG9wOiBgJHt0aGlzLmJyaWRnZVVybH0/YWN0aW9uPXNpZ24mZGV2aWNlPWRlc2t0b3BgLFxuICAgICAgaW9zOiBgJHt0aGlzLm1vYmlsZVVybH1hcHAvd2MvcmVxdWVzdD9ocmVmPSR7dH0mZGV2aWNlPW1vYmlsZWAsXG4gICAgICBhbmRyb2lkOiBgJHt0aGlzLm1vYmlsZVVybH1hcHAvd2MvcmVxdWVzdD9ocmVmPSR7dH0mZGV2aWNlPW1vYmlsZWBcbiAgICB9KTtcbiAgfVxuICBjbG9zZU1vZGFsKGUpIHtcbiAgICBlID8gKHRoaXMub3ZlcmxheT8ucXVlcnlTZWxlY3RvcihcImlmcmFtZVwiKT8uY29udGVudFdpbmRvdz8ucG9zdE1lc3NhZ2UoXCJhcmdlbnQtbG9naW4uc3VjY2Vzc1wiLCBcIipcIiksIHRoaXMucG9wdXBXaW5kb3c/LnBvc3RNZXNzYWdlKFwiYXJnZW50LWxvZ2luLnN1Y2Nlc3NcIiwgXCIqXCIpLCB0aGlzLmNsb3NpbmdUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNsb3NlLCAzNDAwKSkgOiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgc2hvd01vZGFsKGUpIHtcbiAgICBpZiAoY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2luZ1RpbWVvdXQpLCAodGhpcy5vdmVybGF5IHx8IHRoaXMucG9wdXBXaW5kb3cpICYmIHRoaXMuY2xvc2UoKSwgVXMgPT09IFwiYW5kcm9pZFwiIHx8IFVzID09PSBcImlvc1wiKSB7XG4gICAgICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIG4uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCBuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZVtVc107XG4gICAgICB9KSwgbi5jbGljaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50eXBlID09PSBcIndpbmRvd1wiKSB7XG4gICAgICBjb25zdCBuID0gXCJtZW51YmFyPW5vLGxvY2F0aW9uPW5vLHJlc2l6YWJsZT1ubyxzY3JvbGxiYXJzPW5vLHN0YXR1cz1ubyx3aWR0aD04NDAsaGVpZ2h0PTU0MFwiO1xuICAgICAgdGhpcy5wb3B1cFdpbmRvdyA9IHdpbmRvdy5vcGVuKGUuZGVza3RvcCwgXCJfYmxhbmtcIiwgbikgfHwgdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0LmlubmVySFRNTCA9IE9tLCB0LmlkID0gXCJhcmdlbnQtbW9iaWxlLW1vZGFsLW92ZXJsYXlcIjtcbiAgICBmb3IgKGNvbnN0IFtuLCBvXSBvZiBPYmplY3QuZW50cmllcyhEbSkpXG4gICAgICB0LnN0eWxlW25dID0gbztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLmNsb3NlTW9kYWwoKSksIHRoaXMub3ZlcmxheSA9IHQ7XG4gICAgY29uc3QgcyA9IHQucXVlcnlTZWxlY3RvcihcImlmcmFtZVwiKTtcbiAgICBzLnNldEF0dHJpYnV0ZShcInNyY1wiLCBlLmRlc2t0b3ApO1xuICAgIGZvciAoY29uc3QgW24sIG9dIG9mIE9iamVjdC5lbnRyaWVzKHhtKSlcbiAgICAgIHMuc3R5bGVbbl0gPSBvO1xuICAgIHQucXVlcnlTZWxlY3RvcihcbiAgICAgIFwiLmFyZ2VudC1jbG9zZS1idXR0b25cIlxuICAgICkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuY2xvc2VNb2RhbCgpKTtcbiAgfVxufVxuY29uc3Qga3QgPSBuZXcgTm0oKSwgWHMgPSBNcy5OZXR3b3JrTmFtZSwgUG0gPSBhc3luYyAoe1xuICBwcm9qZWN0SWQ6IGksXG4gIGNoYWluSWQ6IGUsXG4gIG5hbWU6IHQsXG4gIGRlc2NyaXB0aW9uOiBzLFxuICBycGNVcmw6IHIsXG4gIGJyaWRnZVVybDogbiA9IFJtKGUpLFxuICBtb2JpbGVVcmw6IG8gPSBDbShlKSxcbiAgbW9kYWxUeXBlOiBjID0gXCJvdmVybGF5XCIsXG4gIHVybDogdSxcbiAgaWNvbnM6IGQsXG4gIHdhbGxldENvbm5lY3Q6IHAsXG4gIHByb3ZpZGVyOiBiXG59LCB4KSA9PiB7XG4gIGlmICghbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJicmlkZ2VVcmwgaXMgcmVxdWlyZWRcIik7XG4gIGlmICghbylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2JpbGVVcmwgaXMgcmVxdWlyZWRcIik7XG4gIGt0LmJyaWRnZVVybCA9IG4sIGt0Lm1vYmlsZVVybCA9IG8sIGt0LnR5cGUgPSBjO1xuICBjb25zdCBPID0ge1xuICAgIHByb2plY3RJZDogaSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgbmFtZTogdCA/PyBcIlVua25vd24gZGFwcFwiLFxuICAgICAgZGVzY3JpcHRpb246IHMgPz8gXCJVbmtub3duIGRhcHAgZGVzY3JpcHRpb25cIixcbiAgICAgIHVybDogdSA/PyBcIiNcIixcbiAgICAgIGljb25zOiBkID8/IFtdLFxuICAgICAgLi4ucD8ubWV0YWRhdGFcbiAgICB9XG4gIH0sIF8gPSBhd2FpdCBTbS5pbml0KE8pLCBDID0gbmV3IHgoeyBjbGllbnQ6IF8sIGNoYWluSWQ6IGUsIHJwY1VybDogciwgcHJvdmlkZXI6IGIgfSk7XG4gIF8ub24oXCJzZXNzaW9uX2V2ZW50XCIsIChGKSA9PiB7XG4gIH0pLCBfLm9uKFwic2Vzc2lvbl91cGRhdGVcIiwgKHsgdG9waWM6IEYsIHBhcmFtczogSyB9KSA9PiB7XG4gICAgY29uc3QgeyBuYW1lc3BhY2VzOiBJIH0gPSBLLCBEID0gXy5zZXNzaW9uLmdldChGKTtcbiAgICBDLnVwZGF0ZVNlc3Npb24oeyAuLi5ELCBuYW1lc3BhY2VzOiBJIH0pO1xuICB9KSwgXy5vbihcInNlc3Npb25fZGVsZXRlXCIsICgpID0+IHtcbiAgfSk7XG4gIHRyeSB7XG4gICAgY29uc3QgRiA9IF8uc2Vzc2lvbi5nZXRBbGwoKS5maW5kKEMuaXNWYWxpZFNlc3Npb24pO1xuICAgIGlmIChGKVxuICAgICAgcmV0dXJuIEMudXBkYXRlU2Vzc2lvbihGKSwgQztcbiAgICBjb25zdCBLID0geyByZXF1aXJlZE5hbWVzcGFjZXM6IEMuZ2V0UmVxdWlyZWROYW1lc3BhY2VzKCkgfTtcbiAgICBVdSgpLCBhd2FpdCBuZXcgUHJvbWlzZSgoeSkgPT4gc2V0VGltZW91dCh5LCAyMDApKTtcbiAgICBjb25zdCB7IHVyaTogSSwgYXBwcm92YWw6IEQgfSA9IGF3YWl0IF8uY29ubmVjdChLKTtcbiAgICBpZiAoSSkge1xuICAgICAga3Quc2hvd0Nvbm5lY3Rpb25Nb2RhbChJKSwga3Qud2NVcmkgPSBJO1xuICAgICAgY29uc3QgeSA9IGF3YWl0IEQoKTtcbiAgICAgIEMudXBkYXRlU2Vzc2lvbih5KSwga3QuY2xvc2VNb2RhbChcImFuaW1hdGVTdWNjZXNzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gQztcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJAYXJnZW50L2xvZ2luOjplcnJvclwiKSwga3QuY2xvc2VNb2RhbCgpLCBudWxsO1xuICB9XG59LCBSbSA9IChpKSA9PiB7XG4gIGlmICghaSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5rbm93biBvciB1bnN1cHBvcnRlZCBjaGFpbklkICgke2l9KSwgZWl0aGVyIHNwZWNpZnkgYSBzdXBwb3J0ZWQgY2hhaW4gb3Igc2V0IGJyaWRnZVVybC5gXG4gICAgKTtcbiAgY29uc3QgZSA9IHBhcnNlSW50KGAke2l9YCk7XG4gIGlmIChTdHJpbmcoaSkuc3RhcnRzV2l0aChYcy5TTl9TRVBPTElBKSB8fCBlID09PSAxMTE1NTExMSlcbiAgICByZXR1cm4gXCJodHRwczovL2xvZ2luLmh5ZHJvZ2VuLmFyZ2VudDQ3Lm5ldFwiO1xuICBpZiAoU3RyaW5nKGkpLnN0YXJ0c1dpdGgoWHMuU05fTUFJTikgfHwgZSA9PT0gMSlcbiAgICByZXR1cm4gXCJodHRwczovL2xvZ2luLmFyZ2VudC54eXpcIjtcbn0sIENtID0gKGkpID0+IHtcbiAgaWYgKCFpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmtub3duIG9yIHVuc3VwcG9ydGVkIGNoYWluSWQgKCR7aX0pLCBlaXRoZXIgc3BlY2lmeSBhIHN1cHBvcnRlZCBjaGFpbiBvciBzZXQgbW9iaWxlVXJsLmBcbiAgICApO1xuICBjb25zdCBlID0gcGFyc2VJbnQoYCR7aX1gKTtcbiAgaWYgKFN0cmluZyhpKS5zdGFydHNXaXRoKFhzLlNOX1NFUE9MSUEpIHx8IGUgPT09IDExMTU1MTExKVxuICAgIHJldHVybiBcImFyZ2VudC1kZXY6Ly9cIjtcbiAgaWYgKFN0cmluZyhpKS5zdGFydHNXaXRoKFhzLlNOX01BSU4pIHx8IGUgPT09IDEpXG4gICAgcmV0dXJuIFwiYXJnZW50Oi8vXCI7XG59O1xuY2xhc3MgQW0gZXh0ZW5kcyBOdCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLm9wdHMgPSBlLCB0aGlzLnByb3RvY29sID0gXCJ3Y1wiLCB0aGlzLnZlcnNpb24gPSAyO1xuICB9XG59XG5jbGFzcyBUbSBleHRlbmRzIE50IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKCksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5yZWNvcmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxufVxuY2xhc3MgJG0ge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy5sb2dnZXIgPSBlLCB0aGlzLmNvcmUgPSB0O1xuICB9XG59XG5jbGFzcyBGbSBleHRlbmRzIE50IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKCksIHRoaXMucmVsYXllciA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufVxubGV0IFVtID0gY2xhc3MgZXh0ZW5kcyBOdCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG59LCBMbSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcywgcikge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5uYW1lID0gcztcbiAgfVxufTtcbmNsYXNzIE1tIGV4dGVuZHMgTnQge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59XG5jbGFzcyBxbSBleHRlbmRzIE50IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKCksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufVxuY2xhc3Mgam0ge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy5wcm9qZWN0SWQgPSBlLCB0aGlzLmxvZ2dlciA9IHQ7XG4gIH1cbn1cbmxldCB6bSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMub3B0cyA9IGUsIHRoaXMucHJvdG9jb2wgPSBcIndjXCIsIHRoaXMudmVyc2lvbiA9IDI7XG4gIH1cbn0sIEttID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5jbGllbnQgPSBlO1xuICB9XG59O1xuY29uc3QgZ2ggPSBcIjpcIjtcbmZ1bmN0aW9uIFZtKGkpIHtcbiAgY29uc3QgeyBuYW1lc3BhY2U6IGUsIHJlZmVyZW5jZTogdCB9ID0gaTtcbiAgcmV0dXJuIFtlLCB0XS5qb2luKGdoKTtcbn1cbmZ1bmN0aW9uIEJtKGkpIHtcbiAgY29uc3QgW2UsIHQsIHNdID0gaS5zcGxpdChnaCk7XG4gIHJldHVybiB7IG5hbWVzcGFjZTogZSwgcmVmZXJlbmNlOiB0LCBhZGRyZXNzOiBzIH07XG59XG5mdW5jdGlvbiBrbShpLCBlKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIGkuZm9yRWFjaCgocykgPT4ge1xuICAgIGNvbnN0IHIgPSBlKHMpO1xuICAgIHQuaW5jbHVkZXMocikgfHwgdC5wdXNoKHIpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIEhtKGkpIHtcbiAgY29uc3QgeyBuYW1lc3BhY2U6IGUsIHJlZmVyZW5jZTogdCB9ID0gQm0oaSk7XG4gIHJldHVybiBWbSh7IG5hbWVzcGFjZTogZSwgcmVmZXJlbmNlOiB0IH0pO1xufVxuZnVuY3Rpb24gR20oaSkge1xuICByZXR1cm4ga20oaSwgSG0pO1xufVxuZnVuY3Rpb24gV20oaSwgZSA9IFtdKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHMpID0+IHtcbiAgICBpZiAoZS5sZW5ndGggJiYgIWUuaW5jbHVkZXMocykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IGlbc107XG4gICAgdC5wdXNoKC4uLnIuYWNjb3VudHMpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIFltKGksIGUgPSBbXSkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgaWYgKGUubGVuZ3RoICYmICFlLmluY2x1ZGVzKHMpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSBpW3NdO1xuICAgIHQucHVzaCguLi5HbShyLmFjY291bnRzKSk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gSm0oaSwgZSA9IFtdKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHMpID0+IHtcbiAgICBpZiAoZS5sZW5ndGggJiYgIWUuaW5jbHVkZXMocykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IGlbc107XG4gICAgdC5wdXNoKC4uLkluKHMsIHIpKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBJbihpLCBlKSB7XG4gIHJldHVybiBpLmluY2x1ZGVzKFwiOlwiKSA/IFtpXSA6IGUuY2hhaW5zIHx8IFtdO1xufVxuY29uc3QgeWggPSBcImJhc2UxMFwiLCBfdCA9IFwiYmFzZTE2XCIsIEpyID0gXCJiYXNlNjRwYWRcIiwgRG4gPSBcInV0ZjhcIiwgbWggPSAwLCBOaSA9IDEsIFFtID0gMCwgZ2EgPSAxLCBRciA9IDEyLCB4biA9IDMyO1xuZnVuY3Rpb24gWG0oKSB7XG4gIGNvbnN0IGkgPSBtcy5nZW5lcmF0ZUtleVBhaXIoKTtcbiAgcmV0dXJuIHsgcHJpdmF0ZUtleTogTmUoaS5zZWNyZXRLZXksIF90KSwgcHVibGljS2V5OiBOZShpLnB1YmxpY0tleSwgX3QpIH07XG59XG5mdW5jdGlvbiBYcigpIHtcbiAgY29uc3QgaSA9IGxpLnJhbmRvbUJ5dGVzKHhuKTtcbiAgcmV0dXJuIE5lKGksIF90KTtcbn1cbmZ1bmN0aW9uIFptKGksIGUpIHtcbiAgY29uc3QgdCA9IG1zLnNoYXJlZEtleShDZShpLCBfdCksIENlKGUsIF90KSksIHMgPSBuZXcgUmMoU2kuU0hBMjU2LCB0KS5leHBhbmQoeG4pO1xuICByZXR1cm4gTmUocywgX3QpO1xufVxuZnVuY3Rpb24gZWIoaSkge1xuICBjb25zdCBlID0gU2kuaGFzaChDZShpLCBfdCkpO1xuICByZXR1cm4gTmUoZSwgX3QpO1xufVxuZnVuY3Rpb24gVWkoaSkge1xuICBjb25zdCBlID0gU2kuaGFzaChDZShpLCBEbikpO1xuICByZXR1cm4gTmUoZSwgX3QpO1xufVxuZnVuY3Rpb24gdGIoaSkge1xuICByZXR1cm4gQ2UoYCR7aX1gLCB5aCk7XG59XG5mdW5jdGlvbiBJcyhpKSB7XG4gIHJldHVybiBOdW1iZXIoTmUoaSwgeWgpKTtcbn1cbmZ1bmN0aW9uIGliKGkpIHtcbiAgY29uc3QgZSA9IHRiKHR5cGVvZiBpLnR5cGUgPCBcInVcIiA/IGkudHlwZSA6IG1oKTtcbiAgaWYgKElzKGUpID09PSBOaSAmJiB0eXBlb2YgaS5zZW5kZXJQdWJsaWNLZXkgPiBcInVcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNlbmRlciBwdWJsaWMga2V5IGZvciB0eXBlIDEgZW52ZWxvcGVcIik7XG4gIGNvbnN0IHQgPSB0eXBlb2YgaS5zZW5kZXJQdWJsaWNLZXkgPCBcInVcIiA/IENlKGkuc2VuZGVyUHVibGljS2V5LCBfdCkgOiB2b2lkIDAsIHMgPSB0eXBlb2YgaS5pdiA8IFwidVwiID8gQ2UoaS5pdiwgX3QpIDogbGkucmFuZG9tQnl0ZXMoUXIpLCByID0gbmV3IGdzLkNoYUNoYTIwUG9seTEzMDUoQ2UoaS5zeW1LZXksIF90KSkuc2VhbChzLCBDZShpLm1lc3NhZ2UsIERuKSk7XG4gIHJldHVybiByYih7IHR5cGU6IGUsIHNlYWxlZDogciwgaXY6IHMsIHNlbmRlclB1YmxpY0tleTogdCB9KTtcbn1cbmZ1bmN0aW9uIHNiKGkpIHtcbiAgY29uc3QgZSA9IG5ldyBncy5DaGFDaGEyMFBvbHkxMzA1KENlKGkuc3ltS2V5LCBfdCkpLCB7IHNlYWxlZDogdCwgaXY6IHMgfSA9IFpzKGkuZW5jb2RlZCksIHIgPSBlLm9wZW4ocywgdCk7XG4gIGlmIChyID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0XCIpO1xuICByZXR1cm4gTmUociwgRG4pO1xufVxuZnVuY3Rpb24gcmIoaSkge1xuICBpZiAoSXMoaS50eXBlKSA9PT0gTmkpIHtcbiAgICBpZiAodHlwZW9mIGkuc2VuZGVyUHVibGljS2V5ID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNlbmRlciBwdWJsaWMga2V5IGZvciB0eXBlIDEgZW52ZWxvcGVcIik7XG4gICAgcmV0dXJuIE5lKGxzKFtpLnR5cGUsIGkuc2VuZGVyUHVibGljS2V5LCBpLml2LCBpLnNlYWxlZF0pLCBKcik7XG4gIH1cbiAgcmV0dXJuIE5lKGxzKFtpLnR5cGUsIGkuaXYsIGkuc2VhbGVkXSksIEpyKTtcbn1cbmZ1bmN0aW9uIFpzKGkpIHtcbiAgY29uc3QgZSA9IENlKGksIEpyKSwgdCA9IGUuc2xpY2UoUW0sIGdhKSwgcyA9IGdhO1xuICBpZiAoSXModCkgPT09IE5pKSB7XG4gICAgY29uc3QgYyA9IHMgKyB4biwgdSA9IGMgKyBRciwgZCA9IGUuc2xpY2UocywgYyksIHAgPSBlLnNsaWNlKGMsIHUpLCBiID0gZS5zbGljZSh1KTtcbiAgICByZXR1cm4geyB0eXBlOiB0LCBzZWFsZWQ6IGIsIGl2OiBwLCBzZW5kZXJQdWJsaWNLZXk6IGQgfTtcbiAgfVxuICBjb25zdCByID0gcyArIFFyLCBuID0gZS5zbGljZShzLCByKSwgbyA9IGUuc2xpY2Uocik7XG4gIHJldHVybiB7IHR5cGU6IHQsIHNlYWxlZDogbywgaXY6IG4gfTtcbn1cbmZ1bmN0aW9uIG5iKGksIGUpIHtcbiAgY29uc3QgdCA9IFpzKGkpO1xuICByZXR1cm4gYmgoeyB0eXBlOiBJcyh0LnR5cGUpLCBzZW5kZXJQdWJsaWNLZXk6IHR5cGVvZiB0LnNlbmRlclB1YmxpY0tleSA8IFwidVwiID8gTmUodC5zZW5kZXJQdWJsaWNLZXksIF90KSA6IHZvaWQgMCwgcmVjZWl2ZXJQdWJsaWNLZXk6IGU/LnJlY2VpdmVyUHVibGljS2V5IH0pO1xufVxuZnVuY3Rpb24gYmgoaSkge1xuICBjb25zdCBlID0gaT8udHlwZSB8fCBtaDtcbiAgaWYgKGUgPT09IE5pKSB7XG4gICAgaWYgKHR5cGVvZiBpPy5zZW5kZXJQdWJsaWNLZXkgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgc2VuZGVyIHB1YmxpYyBrZXlcIik7XG4gICAgaWYgKHR5cGVvZiBpPy5yZWNlaXZlclB1YmxpY0tleSA+IFwidVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyByZWNlaXZlciBwdWJsaWMga2V5XCIpO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IGUsIHNlbmRlclB1YmxpY0tleTogaT8uc2VuZGVyUHVibGljS2V5LCByZWNlaXZlclB1YmxpY0tleTogaT8ucmVjZWl2ZXJQdWJsaWNLZXkgfTtcbn1cbmZ1bmN0aW9uIHlhKGkpIHtcbiAgcmV0dXJuIGkudHlwZSA9PT0gTmkgJiYgdHlwZW9mIGkuc2VuZGVyUHVibGljS2V5ID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGkucmVjZWl2ZXJQdWJsaWNLZXkgPT0gXCJzdHJpbmdcIjtcbn1cbnZhciBvYiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgbWEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBhYiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGNiID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgYmEgPSAoaSwgZSwgdCkgPT4gZSBpbiBpID8gb2IoaSwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGlbZV0gPSB0LCB3YSA9IChpLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICBhYi5jYWxsKGUsIHQpICYmIGJhKGksIHQsIGVbdF0pO1xuICBpZiAobWEpXG4gICAgZm9yICh2YXIgdCBvZiBtYShlKSlcbiAgICAgIGNiLmNhbGwoZSwgdCkgJiYgYmEoaSwgdCwgZVt0XSk7XG4gIHJldHVybiBpO1xufTtcbmNvbnN0IGhiID0gXCJSZWFjdE5hdGl2ZVwiLCBhcyA9IHsgcmVhY3ROYXRpdmU6IFwicmVhY3QtbmF0aXZlXCIsIG5vZGU6IFwibm9kZVwiLCBicm93c2VyOiBcImJyb3dzZXJcIiwgdW5rbm93bjogXCJ1bmtub3duXCIgfSwgdWIgPSBcImpzXCI7XG5mdW5jdGlvbiBPbigpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzIDwgXCJ1XCIgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgPCBcInVcIiAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlIDwgXCJ1XCI7XG59XG5mdW5jdGlvbiB3aCgpIHtcbiAgcmV0dXJuICF1bigpICYmICEhYnMoKSAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gaGI7XG59XG5mdW5jdGlvbiBObigpIHtcbiAgcmV0dXJuICFPbigpICYmICEhYnMoKTtcbn1cbmZ1bmN0aW9uIGxiKCkge1xuICByZXR1cm4gd2goKSA/IGFzLnJlYWN0TmF0aXZlIDogT24oKSA/IGFzLm5vZGUgOiBObigpID8gYXMuYnJvd3NlciA6IGFzLnVua25vd247XG59XG5mdW5jdGlvbiBkYihpLCBlKSB7XG4gIGxldCB0ID0gaWkucGFyc2UoaSk7XG4gIHJldHVybiB0ID0gd2Eod2Eoe30sIHQpLCBlKSwgaSA9IGlpLnN0cmluZ2lmeSh0KSwgaTtcbn1cbmZ1bmN0aW9uIGZiKCkge1xuICByZXR1cm4gZm4oKSB8fCB7IG5hbWU6IFwiXCIsIGRlc2NyaXB0aW9uOiBcIlwiLCB1cmw6IFwiXCIsIGljb25zOiBbXCJcIl0gfTtcbn1cbmZ1bmN0aW9uIHBiKCkge1xuICBjb25zdCBpID0gaG4oKTtcbiAgaWYgKGkgPT09IG51bGwpXG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xuICBjb25zdCBlID0gaS5vcyA/IGkub3MucmVwbGFjZShcIiBcIiwgXCJcIikudG9Mb3dlckNhc2UoKSA6IFwidW5rbm93blwiO1xuICByZXR1cm4gaS50eXBlID09PSBcImJyb3dzZXJcIiA/IFtlLCBpLm5hbWUsIGkudmVyc2lvbl0uam9pbihcIi1cIikgOiBbZSwgaS52ZXJzaW9uXS5qb2luKFwiLVwiKTtcbn1cbmZ1bmN0aW9uIGdiKCkge1xuICB2YXIgaTtcbiAgY29uc3QgZSA9IGxiKCk7XG4gIHJldHVybiBlID09PSBhcy5icm93c2VyID8gW2UsICgoaSA9IGxuKCkpID09IG51bGwgPyB2b2lkIDAgOiBpLmhvc3QpIHx8IFwidW5rbm93blwiXS5qb2luKFwiOlwiKSA6IGU7XG59XG5mdW5jdGlvbiB5YihpLCBlLCB0KSB7XG4gIGNvbnN0IHMgPSBwYigpLCByID0gZ2IoKTtcbiAgcmV0dXJuIFtbaSwgZV0uam9pbihcIi1cIiksIFt1YiwgdF0uam9pbihcIi1cIiksIHMsIHJdLmpvaW4oXCIvXCIpO1xufVxuZnVuY3Rpb24gbWIoeyBwcm90b2NvbDogaSwgdmVyc2lvbjogZSwgcmVsYXlVcmw6IHQsIHNka1ZlcnNpb246IHMsIGF1dGg6IHIsIHByb2plY3RJZDogbiwgdXNlT25DbG9zZUV2ZW50OiBvIH0pIHtcbiAgY29uc3QgYyA9IHQuc3BsaXQoXCI/XCIpLCB1ID0geWIoaSwgZSwgcyksIGQgPSB7IGF1dGg6IHIsIHVhOiB1LCBwcm9qZWN0SWQ6IG4sIHVzZU9uQ2xvc2VFdmVudDogbyB8fCB2b2lkIDAgfSwgcCA9IGRiKGNbMV0gfHwgXCJcIiwgZCk7XG4gIHJldHVybiBjWzBdICsgXCI/XCIgKyBwO1xufVxuZnVuY3Rpb24gRWkoaSwgZSkge1xuICByZXR1cm4gaS5maWx0ZXIoKHQpID0+IGUuaW5jbHVkZXModCkpLmxlbmd0aCA9PT0gaS5sZW5ndGg7XG59XG5mdW5jdGlvbiB2aChpKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoaS5lbnRyaWVzKCkpO1xufVxuZnVuY3Rpb24gX2goaSkge1xuICByZXR1cm4gbmV3IE1hcChPYmplY3QuZW50cmllcyhpKSk7XG59XG5mdW5jdGlvbiBUaShpID0gVi5GSVZFX01JTlVURVMsIGUpIHtcbiAgY29uc3QgdCA9IFYudG9NaWxpc2Vjb25kcyhpIHx8IFYuRklWRV9NSU5VVEVTKTtcbiAgbGV0IHMsIHIsIG47XG4gIHJldHVybiB7IHJlc29sdmU6IChvKSA9PiB7XG4gICAgbiAmJiBzICYmIChjbGVhclRpbWVvdXQobiksIHMobykpO1xuICB9LCByZWplY3Q6IChvKSA9PiB7XG4gICAgbiAmJiByICYmIChjbGVhclRpbWVvdXQobiksIHIobykpO1xuICB9LCBkb25lOiAoKSA9PiBuZXcgUHJvbWlzZSgobywgYykgPT4ge1xuICAgIG4gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMobmV3IEVycm9yKGUpKTtcbiAgICB9LCB0KSwgcyA9IG8sIHIgPSBjO1xuICB9KSB9O1xufVxuZnVuY3Rpb24gZXIoaSwgZSwgdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHMsIHIpID0+IHtcbiAgICBjb25zdCBuID0gc2V0VGltZW91dCgoKSA9PiByKG5ldyBFcnJvcih0KSksIGUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvID0gYXdhaXQgaTtcbiAgICAgIHMobyk7XG4gICAgfSBjYXRjaCAobykge1xuICAgICAgcihvKTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KG4pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIEVoKGksIGUpIHtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIgJiYgZS5zdGFydHNXaXRoKGAke2l9OmApKVxuICAgIHJldHVybiBlO1xuICBpZiAoaS50b0xvd2VyQ2FzZSgpID09PSBcInRvcGljXCIpIHtcbiAgICBpZiAodHlwZW9mIGUgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgbXVzdCBiZSBcInN0cmluZ1wiIGZvciBleHBpcmVyIHRhcmdldCB0eXBlOiB0b3BpYycpO1xuICAgIHJldHVybiBgdG9waWM6JHtlfWA7XG4gIH0gZWxzZSBpZiAoaS50b0xvd2VyQ2FzZSgpID09PSBcImlkXCIpIHtcbiAgICBpZiAodHlwZW9mIGUgIT0gXCJudW1iZXJcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgbXVzdCBiZSBcIm51bWJlclwiIGZvciBleHBpcmVyIHRhcmdldCB0eXBlOiBpZCcpO1xuICAgIHJldHVybiBgaWQ6JHtlfWA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGV4cGlyZXIgdGFyZ2V0IHR5cGU6ICR7aX1gKTtcbn1cbmZ1bmN0aW9uIGJiKGkpIHtcbiAgcmV0dXJuIEVoKFwidG9waWNcIiwgaSk7XG59XG5mdW5jdGlvbiB3YihpKSB7XG4gIHJldHVybiBFaChcImlkXCIsIGkpO1xufVxuZnVuY3Rpb24gU2goaSkge1xuICBjb25zdCBbZSwgdF0gPSBpLnNwbGl0KFwiOlwiKSwgcyA9IHsgaWQ6IHZvaWQgMCwgdG9waWM6IHZvaWQgMCB9O1xuICBpZiAoZSA9PT0gXCJ0b3BpY1wiICYmIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgcy50b3BpYyA9IHQ7XG4gIGVsc2UgaWYgKGUgPT09IFwiaWRcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcih0KSkpXG4gICAgcy5pZCA9IE51bWJlcih0KTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0YXJnZXQsIGV4cGVjdGVkIGlkOm51bWJlciBvciB0b3BpYzpzdHJpbmcsIGdvdCAke2V9OiR7dH1gKTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBIdChpLCBlKSB7XG4gIHJldHVybiBWLmZyb21NaWxpc2Vjb25kcygoZSB8fCBEYXRlLm5vdygpKSArIFYudG9NaWxpc2Vjb25kcyhpKSk7XG59XG5mdW5jdGlvbiBjaShpKSB7XG4gIHJldHVybiBEYXRlLm5vdygpID49IFYudG9NaWxpc2Vjb25kcyhpKTtcbn1cbmZ1bmN0aW9uIGtlKGksIGUpIHtcbiAgcmV0dXJuIGAke2l9JHtlID8gYDoke2V9YCA6IFwiXCJ9YDtcbn1cbmNvbnN0IHZiID0gXCJpcm5cIjtcbmZ1bmN0aW9uIFpyKGkpIHtcbiAgcmV0dXJuIGk/LnJlbGF5IHx8IHsgcHJvdG9jb2w6IHZiIH07XG59XG5mdW5jdGlvbiBWcyhpKSB7XG4gIGNvbnN0IGUgPSBBY1tpXTtcbiAgaWYgKHR5cGVvZiBlID4gXCJ1XCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBSZWxheSBQcm90b2NvbCBub3Qgc3VwcG9ydGVkOiAke2l9YCk7XG4gIHJldHVybiBlO1xufVxudmFyIF9iID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCB2YSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIEViID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgU2IgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBfYSA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBfYihpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQsIEliID0gKGksIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIEViLmNhbGwoZSwgdCkgJiYgX2EoaSwgdCwgZVt0XSk7XG4gIGlmICh2YSlcbiAgICBmb3IgKHZhciB0IG9mIHZhKGUpKVxuICAgICAgU2IuY2FsbChlLCB0KSAmJiBfYShpLCB0LCBlW3RdKTtcbiAgcmV0dXJuIGk7XG59O1xuZnVuY3Rpb24gRGIoaSwgZSA9IFwiLVwiKSB7XG4gIGNvbnN0IHQgPSB7fSwgcyA9IFwicmVsYXlcIiArIGU7XG4gIHJldHVybiBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgaWYgKHIuc3RhcnRzV2l0aChzKSkge1xuICAgICAgY29uc3QgbiA9IHIucmVwbGFjZShzLCBcIlwiKSwgbyA9IGlbcl07XG4gICAgICB0W25dID0gbztcbiAgICB9XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24geGIoaSkge1xuICBjb25zdCBlID0gaS5pbmRleE9mKFwiOlwiKSwgdCA9IGkuaW5kZXhPZihcIj9cIikgIT09IC0xID8gaS5pbmRleE9mKFwiP1wiKSA6IHZvaWQgMCwgcyA9IGkuc3Vic3RyaW5nKDAsIGUpLCByID0gaS5zdWJzdHJpbmcoZSArIDEsIHQpLnNwbGl0KFwiQFwiKSwgbiA9IHR5cGVvZiB0IDwgXCJ1XCIgPyBpLnN1YnN0cmluZyh0KSA6IFwiXCIsIG8gPSBpaS5wYXJzZShuKTtcbiAgcmV0dXJuIHsgcHJvdG9jb2w6IHMsIHRvcGljOiBPYihyWzBdKSwgdmVyc2lvbjogcGFyc2VJbnQoclsxXSwgMTApLCBzeW1LZXk6IG8uc3ltS2V5LCByZWxheTogRGIobykgfTtcbn1cbmZ1bmN0aW9uIE9iKGkpIHtcbiAgcmV0dXJuIGkuc3RhcnRzV2l0aChcIi8vXCIpID8gaS5zdWJzdHJpbmcoMikgOiBpO1xufVxuZnVuY3Rpb24gTmIoaSwgZSA9IFwiLVwiKSB7XG4gIGNvbnN0IHQgPSBcInJlbGF5XCIsIHMgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHIpID0+IHtcbiAgICBjb25zdCBuID0gdCArIGUgKyByO1xuICAgIGlbcl0gJiYgKHNbbl0gPSBpW3JdKTtcbiAgfSksIHM7XG59XG5mdW5jdGlvbiBQYihpKSB7XG4gIHJldHVybiBgJHtpLnByb3RvY29sfToke2kudG9waWN9QCR7aS52ZXJzaW9ufT9gICsgaWkuc3RyaW5naWZ5KEliKHsgc3ltS2V5OiBpLnN5bUtleSB9LCBOYihpLnJlbGF5KSkpO1xufVxuZnVuY3Rpb24gemkoaSkge1xuICBjb25zdCBlID0gW107XG4gIHJldHVybiBpLmZvckVhY2goKHQpID0+IHtcbiAgICBjb25zdCBbcywgcl0gPSB0LnNwbGl0KFwiOlwiKTtcbiAgICBlLnB1c2goYCR7c306JHtyfWApO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIFJiKGkpIHtcbiAgY29uc3QgZSA9IFtdO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgZS5wdXNoKC4uLnppKHQuYWNjb3VudHMpKTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBDYihpLCBlKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaSkuZm9yRWFjaCgocykgPT4ge1xuICAgIHppKHMuYWNjb3VudHMpLmluY2x1ZGVzKGUpICYmIHQucHVzaCguLi5zLm1ldGhvZHMpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIEFiKGksIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgemkocy5hY2NvdW50cykuaW5jbHVkZXMoZSkgJiYgdC5wdXNoKC4uLnMuZXZlbnRzKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBUYihpLCBlKSB7XG4gIGNvbnN0IHQgPSBCcyhpLCBlKTtcbiAgaWYgKHQpXG4gICAgdGhyb3cgbmV3IEVycm9yKHQubWVzc2FnZSk7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChjb25zdCBbciwgbl0gb2YgT2JqZWN0LmVudHJpZXMoaSkpXG4gICAgc1tyXSA9IHsgbWV0aG9kczogbi5tZXRob2RzLCBldmVudHM6IG4uZXZlbnRzLCBjaGFpbnM6IG4uYWNjb3VudHMubWFwKChvKSA9PiBgJHtvLnNwbGl0KFwiOlwiKVswXX06JHtvLnNwbGl0KFwiOlwiKVsxXX1gKSB9O1xuICByZXR1cm4gcztcbn1cbmNvbnN0ICRiID0geyBJTlZBTElEX01FVEhPRDogeyBtZXNzYWdlOiBcIkludmFsaWQgbWV0aG9kLlwiLCBjb2RlOiAxMDAxIH0sIElOVkFMSURfRVZFTlQ6IHsgbWVzc2FnZTogXCJJbnZhbGlkIGV2ZW50LlwiLCBjb2RlOiAxMDAyIH0sIElOVkFMSURfVVBEQVRFX1JFUVVFU1Q6IHsgbWVzc2FnZTogXCJJbnZhbGlkIHVwZGF0ZSByZXF1ZXN0LlwiLCBjb2RlOiAxMDAzIH0sIElOVkFMSURfRVhURU5EX1JFUVVFU1Q6IHsgbWVzc2FnZTogXCJJbnZhbGlkIGV4dGVuZCByZXF1ZXN0LlwiLCBjb2RlOiAxMDA0IH0sIElOVkFMSURfU0VTU0lPTl9TRVRUTEVfUkVRVUVTVDogeyBtZXNzYWdlOiBcIkludmFsaWQgc2Vzc2lvbiBzZXR0bGUgcmVxdWVzdC5cIiwgY29kZTogMTAwNSB9LCBVTkFVVEhPUklaRURfTUVUSE9EOiB7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkIG1ldGhvZC5cIiwgY29kZTogMzAwMSB9LCBVTkFVVEhPUklaRURfRVZFTlQ6IHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWQgZXZlbnQuXCIsIGNvZGU6IDMwMDIgfSwgVU5BVVRIT1JJWkVEX1VQREFURV9SRVFVRVNUOiB7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkIHVwZGF0ZSByZXF1ZXN0LlwiLCBjb2RlOiAzMDAzIH0sIFVOQVVUSE9SSVpFRF9FWFRFTkRfUkVRVUVTVDogeyBtZXNzYWdlOiBcIlVuYXV0aG9yaXplZCBleHRlbmQgcmVxdWVzdC5cIiwgY29kZTogMzAwNCB9LCBVU0VSX1JFSkVDVEVEOiB7IG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZC5cIiwgY29kZTogNWUzIH0sIFVTRVJfUkVKRUNURURfQ0hBSU5TOiB7IG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZCBjaGFpbnMuXCIsIGNvZGU6IDUwMDEgfSwgVVNFUl9SRUpFQ1RFRF9NRVRIT0RTOiB7IG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZCBtZXRob2RzLlwiLCBjb2RlOiA1MDAyIH0sIFVTRVJfUkVKRUNURURfRVZFTlRTOiB7IG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZCBldmVudHMuXCIsIGNvZGU6IDUwMDMgfSwgVU5TVVBQT1JURURfQ0hBSU5TOiB7IG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgY2hhaW5zLlwiLCBjb2RlOiA1MTAwIH0sIFVOU1VQUE9SVEVEX01FVEhPRFM6IHsgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBtZXRob2RzLlwiLCBjb2RlOiA1MTAxIH0sIFVOU1VQUE9SVEVEX0VWRU5UUzogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIGV2ZW50cy5cIiwgY29kZTogNTEwMiB9LCBVTlNVUFBPUlRFRF9BQ0NPVU5UUzogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIGFjY291bnRzLlwiLCBjb2RlOiA1MTAzIH0sIFVOU1VQUE9SVEVEX05BTUVTUEFDRV9LRVk6IHsgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBuYW1lc3BhY2Uga2V5LlwiLCBjb2RlOiA1MTA0IH0sIFVTRVJfRElTQ09OTkVDVEVEOiB7IG1lc3NhZ2U6IFwiVXNlciBkaXNjb25uZWN0ZWQuXCIsIGNvZGU6IDZlMyB9LCBTRVNTSU9OX1NFVFRMRU1FTlRfRkFJTEVEOiB7IG1lc3NhZ2U6IFwiU2Vzc2lvbiBzZXR0bGVtZW50IGZhaWxlZC5cIiwgY29kZTogN2UzIH0sIFdDX01FVEhPRF9VTlNVUFBPUlRFRDogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIHdjXyBtZXRob2QuXCIsIGNvZGU6IDEwMDAxIH0gfSwgRmIgPSB7IE5PVF9JTklUSUFMSVpFRDogeyBtZXNzYWdlOiBcIk5vdCBpbml0aWFsaXplZC5cIiwgY29kZTogMSB9LCBOT19NQVRDSElOR19LRVk6IHsgbWVzc2FnZTogXCJObyBtYXRjaGluZyBrZXkuXCIsIGNvZGU6IDIgfSwgUkVTVE9SRV9XSUxMX09WRVJSSURFOiB7IG1lc3NhZ2U6IFwiUmVzdG9yZSB3aWxsIG92ZXJyaWRlLlwiLCBjb2RlOiAzIH0sIFJFU1VCU0NSSUJFRDogeyBtZXNzYWdlOiBcIlJlc3Vic2NyaWJlZC5cIiwgY29kZTogNCB9LCBNSVNTSU5HX09SX0lOVkFMSUQ6IHsgbWVzc2FnZTogXCJNaXNzaW5nIG9yIGludmFsaWQuXCIsIGNvZGU6IDUgfSwgRVhQSVJFRDogeyBtZXNzYWdlOiBcIkV4cGlyZWQuXCIsIGNvZGU6IDYgfSwgVU5LTk9XTl9UWVBFOiB7IG1lc3NhZ2U6IFwiVW5rbm93biB0eXBlLlwiLCBjb2RlOiA3IH0sIE1JU01BVENIRURfVE9QSUM6IHsgbWVzc2FnZTogXCJNaXNtYXRjaGVkIHRvcGljLlwiLCBjb2RlOiA4IH0sIE5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVM6IHsgbWVzc2FnZTogXCJOb24gY29uZm9ybWluZyBuYW1lc3BhY2VzLlwiLCBjb2RlOiA5IH0gfTtcbmZ1bmN0aW9uIEooaSwgZSkge1xuICBjb25zdCB7IG1lc3NhZ2U6IHQsIGNvZGU6IHMgfSA9IEZiW2ldO1xuICByZXR1cm4geyBtZXNzYWdlOiBlID8gYCR7dH0gJHtlfWAgOiB0LCBjb2RlOiBzIH07XG59XG5mdW5jdGlvbiBKZShpLCBlKSB7XG4gIGNvbnN0IHsgbWVzc2FnZTogdCwgY29kZTogcyB9ID0gJGJbaV07XG4gIHJldHVybiB7IG1lc3NhZ2U6IGUgPyBgJHt0fSAke2V9YCA6IHQsIGNvZGU6IHMgfTtcbn1cbmZ1bmN0aW9uIERzKGksIGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaSkgPyB0eXBlb2YgZSA8IFwidVwiICYmIGkubGVuZ3RoID8gaS5ldmVyeShlKSA6ICEwIDogITE7XG59XG5mdW5jdGlvbiB1cyhpKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaSkgPT09IE9iamVjdC5wcm90b3R5cGUgJiYgT2JqZWN0LmtleXMoaSkubGVuZ3RoO1xufVxuZnVuY3Rpb24gd3QoaSkge1xuICByZXR1cm4gdHlwZW9mIGkgPiBcInVcIjtcbn1cbmZ1bmN0aW9uIGF0KGksIGUpIHtcbiAgcmV0dXJuIGUgJiYgd3QoaSkgPyAhMCA6IHR5cGVvZiBpID09IFwic3RyaW5nXCIgJiYgISFpLnRyaW0oKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBQbihpLCBlKSB7XG4gIHJldHVybiBlICYmIHd0KGkpID8gITAgOiB0eXBlb2YgaSA9PSBcIm51bWJlclwiICYmICFpc05hTihpKTtcbn1cbmZ1bmN0aW9uIFViKGksIGUpIHtcbiAgY29uc3QgeyByZXF1aXJlZE5hbWVzcGFjZXM6IHQgfSA9IGUsIHMgPSBPYmplY3Qua2V5cyhpLm5hbWVzcGFjZXMpLCByID0gT2JqZWN0LmtleXModCk7XG4gIGxldCBuID0gITA7XG4gIHJldHVybiBFaShyLCBzKSA/IChzLmZvckVhY2goKG8pID0+IHtcbiAgICBjb25zdCB7IGFjY291bnRzOiBjLCBtZXRob2RzOiB1LCBldmVudHM6IGQgfSA9IGkubmFtZXNwYWNlc1tvXSwgcCA9IHppKGMpLCBiID0gdFtvXTtcbiAgICAoIUVpKEluKG8sIGIpLCBwKSB8fCAhRWkoYi5tZXRob2RzLCB1KSB8fCAhRWkoYi5ldmVudHMsIGQpKSAmJiAobiA9ICExKTtcbiAgfSksIG4pIDogITE7XG59XG5mdW5jdGlvbiBSbihpKSB7XG4gIHJldHVybiBhdChpLCAhMSkgJiYgaS5pbmNsdWRlcyhcIjpcIikgPyBpLnNwbGl0KFwiOlwiKS5sZW5ndGggPT09IDIgOiAhMTtcbn1cbmZ1bmN0aW9uIExiKGkpIHtcbiAgaWYgKGF0KGksICExKSAmJiBpLmluY2x1ZGVzKFwiOlwiKSkge1xuICAgIGNvbnN0IGUgPSBpLnNwbGl0KFwiOlwiKTtcbiAgICBpZiAoZS5sZW5ndGggPT09IDMpIHtcbiAgICAgIGNvbnN0IHQgPSBlWzBdICsgXCI6XCIgKyBlWzFdO1xuICAgICAgcmV0dXJuICEhZVsyXSAmJiBSbih0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gTWIoaSkge1xuICBpZiAoYXQoaSwgITEpKVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG5ldyBVUkwoaSkgPCBcInVcIjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIHFiKGkpIHtcbiAgdmFyIGU7XG4gIHJldHVybiAoZSA9IGk/LnByb3Bvc2VyKSA9PSBudWxsID8gdm9pZCAwIDogZS5wdWJsaWNLZXk7XG59XG5mdW5jdGlvbiBqYihpKSB7XG4gIHJldHVybiBpPy50b3BpYztcbn1cbmZ1bmN0aW9uIHpiKGksIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICByZXR1cm4gYXQoaT8ucHVibGljS2V5LCAhMSkgfHwgKHQgPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGAke2V9IGNvbnRyb2xsZXIgcHVibGljIGtleSBzaG91bGQgYmUgYSBzdHJpbmdgKSksIHQ7XG59XG5mdW5jdGlvbiBFYShpKSB7XG4gIGxldCBlID0gITA7XG4gIHJldHVybiBEcyhpKSA/IGkubGVuZ3RoICYmIChlID0gaS5ldmVyeSgodCkgPT4gYXQodCwgITEpKSkgOiBlID0gITEsIGU7XG59XG5mdW5jdGlvbiBLYihpLCBlLCB0KSB7XG4gIGxldCBzID0gbnVsbDtcbiAgcmV0dXJuIERzKGUpID8gZS5mb3JFYWNoKChyKSA9PiB7XG4gICAgcyB8fCAoIVJuKHIpIHx8ICFyLmluY2x1ZGVzKGkpKSAmJiAocyA9IEplKFwiVU5TVVBQT1JURURfQ0hBSU5TXCIsIGAke3R9LCBjaGFpbiAke3J9IHNob3VsZCBiZSBhIHN0cmluZyBhbmQgY29uZm9ybSB0byBcIm5hbWVzcGFjZTpjaGFpbklkXCIgZm9ybWF0YCkpO1xuICB9KSA6IHMgPSBKZShcIlVOU1VQUE9SVEVEX0NIQUlOU1wiLCBgJHt0fSwgY2hhaW5zICR7ZX0gc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgY29uZm9ybWluZyB0byBcIm5hbWVzcGFjZTpjaGFpbklkXCIgZm9ybWF0YCksIHM7XG59XG5mdW5jdGlvbiBWYihpLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGkpLmZvckVhY2goKFtzLCByXSkgPT4ge1xuICAgIGlmICh0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSBLYihzLCBJbihzLCByKSwgYCR7ZX0gcmVxdWlyZWROYW1lc3BhY2VgKTtcbiAgICBuICYmICh0ID0gbik7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gQmIoaSwgZSkge1xuICBsZXQgdCA9IG51bGw7XG4gIHJldHVybiBEcyhpKSA/IGkuZm9yRWFjaCgocykgPT4ge1xuICAgIHQgfHwgTGIocykgfHwgKHQgPSBKZShcIlVOU1VQUE9SVEVEX0FDQ09VTlRTXCIsIGAke2V9LCBhY2NvdW50ICR7c30gc2hvdWxkIGJlIGEgc3RyaW5nIGFuZCBjb25mb3JtIHRvIFwibmFtZXNwYWNlOmNoYWluSWQ6YWRkcmVzc1wiIGZvcm1hdGApKTtcbiAgfSkgOiB0ID0gSmUoXCJVTlNVUFBPUlRFRF9BQ0NPVU5UU1wiLCBgJHtlfSwgYWNjb3VudHMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgY29uZm9ybWluZyB0byBcIm5hbWVzcGFjZTpjaGFpbklkOmFkZHJlc3NcIiBmb3JtYXRgKSwgdDtcbn1cbmZ1bmN0aW9uIGtiKGksIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgaWYgKHQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IEJiKHM/LmFjY291bnRzLCBgJHtlfSBuYW1lc3BhY2VgKTtcbiAgICByICYmICh0ID0gcik7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gSGIoaSwgZSkge1xuICBsZXQgdCA9IG51bGw7XG4gIHJldHVybiBFYShpPy5tZXRob2RzKSA/IEVhKGk/LmV2ZW50cykgfHwgKHQgPSBKZShcIlVOU1VQUE9SVEVEX0VWRU5UU1wiLCBgJHtlfSwgZXZlbnRzIHNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIGVtcHR5IGFycmF5IGZvciBubyBldmVudHNgKSkgOiB0ID0gSmUoXCJVTlNVUFBPUlRFRF9NRVRIT0RTXCIsIGAke2V9LCBtZXRob2RzIHNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIGVtcHR5IGFycmF5IGZvciBubyBtZXRob2RzYCksIHQ7XG59XG5mdW5jdGlvbiBJaChpLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaSkuZm9yRWFjaCgocykgPT4ge1xuICAgIGlmICh0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSBIYihzLCBgJHtlfSwgbmFtZXNwYWNlYCk7XG4gICAgciAmJiAodCA9IHIpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIEdiKGksIGUsIHQpIHtcbiAgbGV0IHMgPSBudWxsO1xuICBpZiAoaSAmJiB1cyhpKSkge1xuICAgIGNvbnN0IHIgPSBJaChpLCBlKTtcbiAgICByICYmIChzID0gcik7XG4gICAgY29uc3QgbiA9IFZiKGksIGUpO1xuICAgIG4gJiYgKHMgPSBuKTtcbiAgfSBlbHNlXG4gICAgcyA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYCR7ZX0sICR7dH0gc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGRhdGFgKTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBCcyhpLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgaWYgKGkgJiYgdXMoaSkpIHtcbiAgICBjb25zdCBzID0gSWgoaSwgZSk7XG4gICAgcyAmJiAodCA9IHMpO1xuICAgIGNvbnN0IHIgPSBrYihpLCBlKTtcbiAgICByICYmICh0ID0gcik7XG4gIH0gZWxzZVxuICAgIHQgPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGAke2V9LCBuYW1lc3BhY2VzIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBkYXRhYCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gRGgoaSkge1xuICByZXR1cm4gYXQoaS5wcm90b2NvbCwgITApO1xufVxuZnVuY3Rpb24gV2IoaSwgZSkge1xuICBsZXQgdCA9ICExO1xuICByZXR1cm4gZSAmJiAhaSA/IHQgPSAhMCA6IGkgJiYgRHMoaSkgJiYgaS5sZW5ndGggJiYgaS5mb3JFYWNoKChzKSA9PiB7XG4gICAgdCA9IERoKHMpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIFliKGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpID09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBJdChpKSB7XG4gIHJldHVybiB0eXBlb2YgaSA8IFwidVwiICYmIHR5cGVvZiBpICE9PSBudWxsO1xufVxuZnVuY3Rpb24gSmIoaSkge1xuICByZXR1cm4gISghaSB8fCB0eXBlb2YgaSAhPSBcIm9iamVjdFwiIHx8ICFpLmNvZGUgfHwgIVBuKGkuY29kZSwgITEpIHx8ICFpLm1lc3NhZ2UgfHwgIWF0KGkubWVzc2FnZSwgITEpKTtcbn1cbmZ1bmN0aW9uIFFiKGkpIHtcbiAgcmV0dXJuICEod3QoaSkgfHwgIWF0KGkubWV0aG9kLCAhMSkpO1xufVxuZnVuY3Rpb24gWGIoaSkge1xuICByZXR1cm4gISh3dChpKSB8fCB3dChpLnJlc3VsdCkgJiYgd3QoaS5lcnJvcikgfHwgIVBuKGkuaWQsICExKSB8fCAhYXQoaS5qc29ucnBjLCAhMSkpO1xufVxuZnVuY3Rpb24gWmIoaSkge1xuICByZXR1cm4gISh3dChpKSB8fCAhYXQoaS5uYW1lLCAhMSkpO1xufVxuZnVuY3Rpb24gU2EoaSwgZSkge1xuICByZXR1cm4gISghUm4oZSkgfHwgIVJiKGkpLmluY2x1ZGVzKGUpKTtcbn1cbmZ1bmN0aW9uIGV3KGksIGUsIHQpIHtcbiAgcmV0dXJuIGF0KHQsICExKSA/IENiKGksIGUpLmluY2x1ZGVzKHQpIDogITE7XG59XG5mdW5jdGlvbiB0dyhpLCBlLCB0KSB7XG4gIHJldHVybiBhdCh0LCAhMSkgPyBBYihpLCBlKS5pbmNsdWRlcyh0KSA6ICExO1xufVxuZnVuY3Rpb24gSWEoaSwgZSwgdCkge1xuICBsZXQgcyA9IG51bGw7XG4gIGNvbnN0IHIgPSBpdyhpKSwgbiA9IHN3KGUpLCBvID0gT2JqZWN0LmtleXMociksIGMgPSBPYmplY3Qua2V5cyhuKSwgdSA9IERhKE9iamVjdC5rZXlzKGkpKSwgZCA9IERhKE9iamVjdC5rZXlzKGUpKSwgcCA9IHUuZmlsdGVyKChiKSA9PiAhZC5pbmNsdWRlcyhiKSk7XG4gIHJldHVybiBwLmxlbmd0aCAmJiAocyA9IEooXCJOT05fQ09ORk9STUlOR19OQU1FU1BBQ0VTXCIsIGAke3R9IG5hbWVzcGFjZXMga2V5cyBkb24ndCBzYXRpc2Z5IHJlcXVpcmVkTmFtZXNwYWNlcy5cbiAgICAgIFJlcXVpcmVkOiAke3AudG9TdHJpbmcoKX1cbiAgICAgIFJlY2VpdmVkOiAke09iamVjdC5rZXlzKGUpLnRvU3RyaW5nKCl9YCkpLCBFaShvLCBjKSB8fCAocyA9IEooXCJOT05fQ09ORk9STUlOR19OQU1FU1BBQ0VTXCIsIGAke3R9IG5hbWVzcGFjZXMgY2hhaW5zIGRvbid0IHNhdGlzZnkgcmVxdWlyZWQgbmFtZXNwYWNlcy5cbiAgICAgIFJlcXVpcmVkOiAke28udG9TdHJpbmcoKX1cbiAgICAgIEFwcHJvdmVkOiAke2MudG9TdHJpbmcoKX1gKSksIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGIpID0+IHtcbiAgICBpZiAoIWIuaW5jbHVkZXMoXCI6XCIpIHx8IHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeCA9IHppKGVbYl0uYWNjb3VudHMpO1xuICAgIHguaW5jbHVkZXMoYikgfHwgKHMgPSBKKFwiTk9OX0NPTkZPUk1JTkdfTkFNRVNQQUNFU1wiLCBgJHt0fSBuYW1lc3BhY2VzIGFjY291bnRzIGRvbid0IHNhdGlzZnkgbmFtZXNwYWNlIGFjY291bnRzIGZvciAke2J9XG4gICAgICAgIFJlcXVpcmVkOiAke2J9XG4gICAgICAgIEFwcHJvdmVkOiAke3gudG9TdHJpbmcoKX1gKSk7XG4gIH0pLCBvLmZvckVhY2goKGIpID0+IHtcbiAgICBzIHx8IChFaShyW2JdLm1ldGhvZHMsIG5bYl0ubWV0aG9kcykgPyBFaShyW2JdLmV2ZW50cywgbltiXS5ldmVudHMpIHx8IChzID0gSihcIk5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVNcIiwgYCR7dH0gbmFtZXNwYWNlcyBldmVudHMgZG9uJ3Qgc2F0aXNmeSBuYW1lc3BhY2UgZXZlbnRzIGZvciAke2J9YCkpIDogcyA9IEooXCJOT05fQ09ORk9STUlOR19OQU1FU1BBQ0VTXCIsIGAke3R9IG5hbWVzcGFjZXMgbWV0aG9kcyBkb24ndCBzYXRpc2Z5IG5hbWVzcGFjZSBtZXRob2RzIGZvciAke2J9YCkpO1xuICB9KSwgcztcbn1cbmZ1bmN0aW9uIGl3KGkpIHtcbiAgY29uc3QgZSA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgodCkgPT4ge1xuICAgIHZhciBzO1xuICAgIHQuaW5jbHVkZXMoXCI6XCIpID8gZVt0XSA9IGlbdF0gOiAocyA9IGlbdF0uY2hhaW5zKSA9PSBudWxsIHx8IHMuZm9yRWFjaCgocikgPT4ge1xuICAgICAgZVtyXSA9IHsgbWV0aG9kczogaVt0XS5tZXRob2RzLCBldmVudHM6IGlbdF0uZXZlbnRzIH07XG4gICAgfSk7XG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gRGEoaSkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoaS5tYXAoKGUpID0+IGUuaW5jbHVkZXMoXCI6XCIpID8gZS5zcGxpdChcIjpcIilbMF0gOiBlKSldO1xufVxuZnVuY3Rpb24gc3coaSkge1xuICBjb25zdCBlID0ge307XG4gIHJldHVybiBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgdC5pbmNsdWRlcyhcIjpcIikgPyBlW3RdID0gaVt0XSA6IHppKGlbdF0uYWNjb3VudHMpPy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBlW3JdID0geyBhY2NvdW50czogaVt0XS5hY2NvdW50cy5maWx0ZXIoKG4pID0+IG4uaW5jbHVkZXMoYCR7cn06YCkpLCBtZXRob2RzOiBpW3RdLm1ldGhvZHMsIGV2ZW50czogaVt0XS5ldmVudHMgfTtcbiAgICB9KTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBydyhpLCBlKSB7XG4gIHJldHVybiBQbihpLCAhMSkgJiYgaSA8PSBlLm1heCAmJiBpID49IGUubWluO1xufVxuZnVuY3Rpb24gbncoaSwgZSkge1xuICBpZiAoaS5sZW5ndGggPj0gMjU1KVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBbHBoYWJldCB0b28gbG9uZ1wiKTtcbiAgZm9yICh2YXIgdCA9IG5ldyBVaW50OEFycmF5KDI1NiksIHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMrKylcbiAgICB0W3NdID0gMjU1O1xuICBmb3IgKHZhciByID0gMDsgciA8IGkubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgbiA9IGkuY2hhckF0KHIpLCBvID0gbi5jaGFyQ29kZUF0KDApO1xuICAgIGlmICh0W29dICE9PSAyNTUpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG4gKyBcIiBpcyBhbWJpZ3VvdXNcIik7XG4gICAgdFtvXSA9IHI7XG4gIH1cbiAgdmFyIGMgPSBpLmxlbmd0aCwgdSA9IGkuY2hhckF0KDApLCBkID0gTWF0aC5sb2coYykgLyBNYXRoLmxvZygyNTYpLCBwID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKGMpO1xuICBmdW5jdGlvbiBiKF8pIHtcbiAgICBpZiAoXyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhfKSA/IF8gPSBuZXcgVWludDhBcnJheShfLmJ1ZmZlciwgXy5ieXRlT2Zmc2V0LCBfLmJ5dGVMZW5ndGgpIDogQXJyYXkuaXNBcnJheShfKSAmJiAoXyA9IFVpbnQ4QXJyYXkuZnJvbShfKSkpLCAhKF8gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5XCIpO1xuICAgIGlmIChfLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGZvciAodmFyIEMgPSAwLCBGID0gMCwgSyA9IDAsIEkgPSBfLmxlbmd0aDsgSyAhPT0gSSAmJiBfW0tdID09PSAwOyApXG4gICAgICBLKyssIEMrKztcbiAgICBmb3IgKHZhciBEID0gKEkgLSBLKSAqIHAgKyAxID4+PiAwLCB5ID0gbmV3IFVpbnQ4QXJyYXkoRCk7IEsgIT09IEk7ICkge1xuICAgICAgZm9yICh2YXIgdyA9IF9bS10sIGYgPSAwLCBhID0gRCAtIDE7ICh3ICE9PSAwIHx8IGYgPCBGKSAmJiBhICE9PSAtMTsgYS0tLCBmKyspXG4gICAgICAgIHcgKz0gMjU2ICogeVthXSA+Pj4gMCwgeVthXSA9IHcgJSBjID4+PiAwLCB3ID0gdyAvIGMgPj4+IDA7XG4gICAgICBpZiAodyAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLXplcm8gY2FycnlcIik7XG4gICAgICBGID0gZiwgSysrO1xuICAgIH1cbiAgICBmb3IgKHZhciBsID0gRCAtIEY7IGwgIT09IEQgJiYgeVtsXSA9PT0gMDsgKVxuICAgICAgbCsrO1xuICAgIGZvciAodmFyIEwgPSB1LnJlcGVhdChDKTsgbCA8IEQ7ICsrbClcbiAgICAgIEwgKz0gaS5jaGFyQXQoeVtsXSk7XG4gICAgcmV0dXJuIEw7XG4gIH1cbiAgZnVuY3Rpb24geChfKSB7XG4gICAgaWYgKHR5cGVvZiBfICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgU3RyaW5nXCIpO1xuICAgIGlmIChfLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIHZhciBDID0gMDtcbiAgICBpZiAoX1tDXSAhPT0gXCIgXCIpIHtcbiAgICAgIGZvciAodmFyIEYgPSAwLCBLID0gMDsgX1tDXSA9PT0gdTsgKVxuICAgICAgICBGKyssIEMrKztcbiAgICAgIGZvciAodmFyIEkgPSAoXy5sZW5ndGggLSBDKSAqIGQgKyAxID4+PiAwLCBEID0gbmV3IFVpbnQ4QXJyYXkoSSk7IF9bQ107ICkge1xuICAgICAgICB2YXIgeSA9IHRbXy5jaGFyQ29kZUF0KEMpXTtcbiAgICAgICAgaWYgKHkgPT09IDI1NSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAodmFyIHcgPSAwLCBmID0gSSAtIDE7ICh5ICE9PSAwIHx8IHcgPCBLKSAmJiBmICE9PSAtMTsgZi0tLCB3KyspXG4gICAgICAgICAgeSArPSBjICogRFtmXSA+Pj4gMCwgRFtmXSA9IHkgJSAyNTYgPj4+IDAsIHkgPSB5IC8gMjU2ID4+PiAwO1xuICAgICAgICBpZiAoeSAhPT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24temVybyBjYXJyeVwiKTtcbiAgICAgICAgSyA9IHcsIEMrKztcbiAgICAgIH1cbiAgICAgIGlmIChfW0NdICE9PSBcIiBcIikge1xuICAgICAgICBmb3IgKHZhciBhID0gSSAtIEs7IGEgIT09IEkgJiYgRFthXSA9PT0gMDsgKVxuICAgICAgICAgIGErKztcbiAgICAgICAgZm9yICh2YXIgbCA9IG5ldyBVaW50OEFycmF5KEYgKyAoSSAtIGEpKSwgTCA9IEY7IGEgIT09IEk7IClcbiAgICAgICAgICBsW0wrK10gPSBEW2ErK107XG4gICAgICAgIHJldHVybiBsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBPKF8pIHtcbiAgICB2YXIgQyA9IHgoXyk7XG4gICAgaWYgKEMpXG4gICAgICByZXR1cm4gQztcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi0ke2V9IGNoYXJhY3RlcmApO1xuICB9XG4gIHJldHVybiB7IGVuY29kZTogYiwgZGVjb2RlVW5zYWZlOiB4LCBkZWNvZGU6IE8gfTtcbn1cbnZhciBvdyA9IG53LCBhdyA9IG93O1xuY29uc3QgeGggPSAoaSkgPT4ge1xuICBpZiAoaSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgaS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlVpbnQ4QXJyYXlcIilcbiAgICByZXR1cm4gaTtcbiAgaWYgKGkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaSk7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaSkpXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGkuYnVmZmVyLCBpLmJ5dGVPZmZzZXQsIGkuYnl0ZUxlbmd0aCk7XG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZVwiKTtcbn0sIGN3ID0gKGkpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpKSwgaHcgPSAoaSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGkpO1xuY2xhc3MgdXcge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzKSB7XG4gICAgdGhpcy5uYW1lID0gZSwgdGhpcy5wcmVmaXggPSB0LCB0aGlzLmJhc2VFbmNvZGUgPSBzO1xuICB9XG4gIGVuY29kZShlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fSR7dGhpcy5iYXNlRW5jb2RlKGUpfWA7XG4gICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGVcIik7XG4gIH1cbn1cbmNsYXNzIGx3IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcykge1xuICAgIGlmICh0aGlzLm5hbWUgPSBlLCB0aGlzLnByZWZpeCA9IHQsIHQuY29kZVBvaW50QXQoMCkgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJlZml4IGNoYXJhY3RlclwiKTtcbiAgICB0aGlzLnByZWZpeENvZGVQb2ludCA9IHQuY29kZVBvaW50QXQoMCksIHRoaXMuYmFzZURlY29kZSA9IHM7XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGUuY29kZVBvaW50QXQoMCkgIT09IHRoaXMucHJlZml4Q29kZVBvaW50KVxuICAgICAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkoZSl9LCAke3RoaXMubmFtZX0gZGVjb2RlciBvbmx5IHN1cHBvcnRzIGlucHV0cyBwcmVmaXhlZCB3aXRoICR7dGhpcy5wcmVmaXh9YCk7XG4gICAgICByZXR1cm4gdGhpcy5iYXNlRGVjb2RlKGUuc2xpY2UodGhpcy5wcmVmaXgubGVuZ3RoKSk7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBFcnJvcihcIkNhbiBvbmx5IG11bHRpYmFzZSBkZWNvZGUgc3RyaW5nc1wiKTtcbiAgfVxuICBvcihlKSB7XG4gICAgcmV0dXJuIE9oKHRoaXMsIGUpO1xuICB9XG59XG5jbGFzcyBkdyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmRlY29kZXJzID0gZTtcbiAgfVxuICBvcihlKSB7XG4gICAgcmV0dXJuIE9oKHRoaXMsIGUpO1xuICB9XG4gIGRlY29kZShlKSB7XG4gICAgY29uc3QgdCA9IGVbMF0sIHMgPSB0aGlzLmRlY29kZXJzW3RdO1xuICAgIGlmIChzKVxuICAgICAgcmV0dXJuIHMuZGVjb2RlKGUpO1xuICAgIHRocm93IFJhbmdlRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgbXVsdGliYXNlIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KGUpfSwgb25seSBpbnB1dHMgcHJlZml4ZWQgd2l0aCAke09iamVjdC5rZXlzKHRoaXMuZGVjb2RlcnMpfSBhcmUgc3VwcG9ydGVkYCk7XG4gIH1cbn1cbmNvbnN0IE9oID0gKGksIGUpID0+IG5ldyBkdyh7IC4uLmkuZGVjb2RlcnMgfHwgeyBbaS5wcmVmaXhdOiBpIH0sIC4uLmUuZGVjb2RlcnMgfHwgeyBbZS5wcmVmaXhdOiBlIH0gfSk7XG5jbGFzcyBmdyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMsIHIpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnByZWZpeCA9IHQsIHRoaXMuYmFzZUVuY29kZSA9IHMsIHRoaXMuYmFzZURlY29kZSA9IHIsIHRoaXMuZW5jb2RlciA9IG5ldyB1dyhlLCB0LCBzKSwgdGhpcy5kZWNvZGVyID0gbmV3IGx3KGUsIHQsIHIpO1xuICB9XG4gIGVuY29kZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoZSk7XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyLmRlY29kZShlKTtcbiAgfVxufVxuY29uc3QgZnIgPSAoeyBuYW1lOiBpLCBwcmVmaXg6IGUsIGVuY29kZTogdCwgZGVjb2RlOiBzIH0pID0+IG5ldyBmdyhpLCBlLCB0LCBzKSwgeHMgPSAoeyBwcmVmaXg6IGksIG5hbWU6IGUsIGFscGhhYmV0OiB0IH0pID0+IHtcbiAgY29uc3QgeyBlbmNvZGU6IHMsIGRlY29kZTogciB9ID0gYXcodCwgZSk7XG4gIHJldHVybiBmcih7IHByZWZpeDogaSwgbmFtZTogZSwgZW5jb2RlOiBzLCBkZWNvZGU6IChuKSA9PiB4aChyKG4pKSB9KTtcbn0sIHB3ID0gKGksIGUsIHQsIHMpID0+IHtcbiAgY29uc3QgciA9IHt9O1xuICBmb3IgKGxldCBwID0gMDsgcCA8IGUubGVuZ3RoOyArK3ApXG4gICAgcltlW3BdXSA9IHA7XG4gIGxldCBuID0gaS5sZW5ndGg7XG4gIGZvciAoOyBpW24gLSAxXSA9PT0gXCI9XCI7IClcbiAgICAtLW47XG4gIGNvbnN0IG8gPSBuZXcgVWludDhBcnJheShuICogdCAvIDggfCAwKTtcbiAgbGV0IGMgPSAwLCB1ID0gMCwgZCA9IDA7XG4gIGZvciAobGV0IHAgPSAwOyBwIDwgbjsgKytwKSB7XG4gICAgY29uc3QgYiA9IHJbaVtwXV07XG4gICAgaWYgKGIgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTm9uLSR7c30gY2hhcmFjdGVyYCk7XG4gICAgdSA9IHUgPDwgdCB8IGIsIGMgKz0gdCwgYyA+PSA4ICYmIChjIC09IDgsIG9bZCsrXSA9IDI1NSAmIHUgPj4gYyk7XG4gIH1cbiAgaWYgKGMgPj0gdCB8fCAyNTUgJiB1IDw8IDggLSBjKVxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGRhdGFcIik7XG4gIHJldHVybiBvO1xufSwgZ3cgPSAoaSwgZSwgdCkgPT4ge1xuICBjb25zdCBzID0gZVtlLmxlbmd0aCAtIDFdID09PSBcIj1cIiwgciA9ICgxIDw8IHQpIC0gMTtcbiAgbGV0IG4gPSBcIlwiLCBvID0gMCwgYyA9IDA7XG4gIGZvciAobGV0IHUgPSAwOyB1IDwgaS5sZW5ndGg7ICsrdSlcbiAgICBmb3IgKGMgPSBjIDw8IDggfCBpW3VdLCBvICs9IDg7IG8gPiB0OyApXG4gICAgICBvIC09IHQsIG4gKz0gZVtyICYgYyA+PiBvXTtcbiAgaWYgKG8gJiYgKG4gKz0gZVtyICYgYyA8PCB0IC0gb10pLCBzKVxuICAgIGZvciAoOyBuLmxlbmd0aCAqIHQgJiA3OyApXG4gICAgICBuICs9IFwiPVwiO1xuICByZXR1cm4gbjtcbn0sIGR0ID0gKHsgbmFtZTogaSwgcHJlZml4OiBlLCBiaXRzUGVyQ2hhcjogdCwgYWxwaGFiZXQ6IHMgfSkgPT4gZnIoeyBwcmVmaXg6IGUsIG5hbWU6IGksIGVuY29kZShyKSB7XG4gIHJldHVybiBndyhyLCBzLCB0KTtcbn0sIGRlY29kZShyKSB7XG4gIHJldHVybiBwdyhyLCBzLCB0LCBpKTtcbn0gfSksIHl3ID0gZnIoeyBwcmVmaXg6IFwiXFwwXCIsIG5hbWU6IFwiaWRlbnRpdHlcIiwgZW5jb2RlOiAoaSkgPT4gaHcoaSksIGRlY29kZTogKGkpID0+IGN3KGkpIH0pO1xudmFyIG13ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgaWRlbnRpdHk6IHl3IH0pO1xuY29uc3QgYncgPSBkdCh7IHByZWZpeDogXCIwXCIsIG5hbWU6IFwiYmFzZTJcIiwgYWxwaGFiZXQ6IFwiMDFcIiwgYml0c1BlckNoYXI6IDEgfSk7XG52YXIgd3cgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMjogYncgfSk7XG5jb25zdCB2dyA9IGR0KHsgcHJlZml4OiBcIjdcIiwgbmFtZTogXCJiYXNlOFwiLCBhbHBoYWJldDogXCIwMTIzNDU2N1wiLCBiaXRzUGVyQ2hhcjogMyB9KTtcbnZhciBfdyA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2U4OiB2dyB9KTtcbmNvbnN0IEV3ID0geHMoeyBwcmVmaXg6IFwiOVwiLCBuYW1lOiBcImJhc2UxMFwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5XCIgfSk7XG52YXIgU3cgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMTA6IEV3IH0pO1xuY29uc3QgSXcgPSBkdCh7IHByZWZpeDogXCJmXCIsIG5hbWU6IFwiYmFzZTE2XCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZcIiwgYml0c1BlckNoYXI6IDQgfSksIER3ID0gZHQoeyBwcmVmaXg6IFwiRlwiLCBuYW1lOiBcImJhc2UxNnVwcGVyXCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZcIiwgYml0c1BlckNoYXI6IDQgfSk7XG52YXIgeHcgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMTY6IEl3LCBiYXNlMTZ1cHBlcjogRHcgfSk7XG5jb25zdCBPdyA9IGR0KHsgcHJlZml4OiBcImJcIiwgbmFtZTogXCJiYXNlMzJcIiwgYWxwaGFiZXQ6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjdcIiwgYml0c1BlckNoYXI6IDUgfSksIE53ID0gZHQoeyBwcmVmaXg6IFwiQlwiLCBuYW1lOiBcImJhc2UzMnVwcGVyXCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBQdyA9IGR0KHsgcHJlZml4OiBcImNcIiwgbmFtZTogXCJiYXNlMzJwYWRcIiwgYWxwaGFiZXQ6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBSdyA9IGR0KHsgcHJlZml4OiBcIkNcIiwgbmFtZTogXCJiYXNlMzJwYWR1cHBlclwiLCBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz1cIiwgYml0c1BlckNoYXI6IDUgfSksIEN3ID0gZHQoeyBwcmVmaXg6IFwidlwiLCBuYW1lOiBcImJhc2UzMmhleFwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dlwiLCBiaXRzUGVyQ2hhcjogNSB9KSwgQXcgPSBkdCh7IHByZWZpeDogXCJWXCIsIG5hbWU6IFwiYmFzZTMyaGV4dXBwZXJcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZcIiwgYml0c1BlckNoYXI6IDUgfSksIFR3ID0gZHQoeyBwcmVmaXg6IFwidFwiLCBuYW1lOiBcImJhc2UzMmhleHBhZFwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj1cIiwgYml0c1BlckNoYXI6IDUgfSksICR3ID0gZHQoeyBwcmVmaXg6IFwiVFwiLCBuYW1lOiBcImJhc2UzMmhleHBhZHVwcGVyXCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPVwiLCBiaXRzUGVyQ2hhcjogNSB9KSwgRncgPSBkdCh7IHByZWZpeDogXCJoXCIsIG5hbWU6IFwiYmFzZTMyelwiLCBhbHBoYWJldDogXCJ5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OVwiLCBiaXRzUGVyQ2hhcjogNSB9KTtcbnZhciBVdyA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2UzMjogT3csIGJhc2UzMnVwcGVyOiBOdywgYmFzZTMycGFkOiBQdywgYmFzZTMycGFkdXBwZXI6IFJ3LCBiYXNlMzJoZXg6IEN3LCBiYXNlMzJoZXh1cHBlcjogQXcsIGJhc2UzMmhleHBhZDogVHcsIGJhc2UzMmhleHBhZHVwcGVyOiAkdywgYmFzZTMyejogRncgfSk7XG5jb25zdCBMdyA9IHhzKHsgcHJlZml4OiBcImtcIiwgbmFtZTogXCJiYXNlMzZcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIgfSksIE13ID0geHMoeyBwcmVmaXg6IFwiS1wiLCBuYW1lOiBcImJhc2UzNnVwcGVyXCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiIH0pO1xudmFyIHF3ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTM2OiBMdywgYmFzZTM2dXBwZXI6IE13IH0pO1xuY29uc3QgancgPSB4cyh7IG5hbWU6IFwiYmFzZTU4YnRjXCIsIHByZWZpeDogXCJ6XCIsIGFscGhhYmV0OiBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIiB9KSwgencgPSB4cyh7IG5hbWU6IFwiYmFzZTU4ZmxpY2tyXCIsIHByZWZpeDogXCJaXCIsIGFscGhhYmV0OiBcIjEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVpcIiB9KTtcbnZhciBLdyA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2U1OGJ0YzogancsIGJhc2U1OGZsaWNrcjogencgfSk7XG5jb25zdCBWdyA9IGR0KHsgcHJlZml4OiBcIm1cIiwgbmFtZTogXCJiYXNlNjRcIiwgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLCBiaXRzUGVyQ2hhcjogNiB9KSwgQncgPSBkdCh7IHByZWZpeDogXCJNXCIsIG5hbWU6IFwiYmFzZTY0cGFkXCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIsIGJpdHNQZXJDaGFyOiA2IH0pLCBrdyA9IGR0KHsgcHJlZml4OiBcInVcIiwgbmFtZTogXCJiYXNlNjR1cmxcIiwgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX1wiLCBiaXRzUGVyQ2hhcjogNiB9KSwgSHcgPSBkdCh7IHByZWZpeDogXCJVXCIsIG5hbWU6IFwiYmFzZTY0dXJscGFkXCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89XCIsIGJpdHNQZXJDaGFyOiA2IH0pO1xudmFyIEd3ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTY0OiBWdywgYmFzZTY0cGFkOiBCdywgYmFzZTY0dXJsOiBrdywgYmFzZTY0dXJscGFkOiBIdyB9KTtcbmNvbnN0IE5oID0gQXJyYXkuZnJvbShcIvCfmoDwn6qQ4piE8J+bsPCfjIzwn4yR8J+MkvCfjJPwn4yU8J+MlfCfjJbwn4yX8J+MmPCfjI3wn4yP8J+MjvCfkInimIDwn5K78J+WpfCfkr7wn5K/8J+YguKdpPCfmI3wn6Sj8J+YivCfmY/wn5KV8J+YrfCfmJjwn5GN8J+YhfCfkY/wn5iB8J+UpfCfpbDwn5KU8J+SlvCfkpnwn5ii8J+klPCfmIbwn5mE8J+SqvCfmInimLrwn5GM8J+kl/Cfkpzwn5iU8J+YjvCfmIfwn4y58J+kpvCfjonwn5Ke4pyM4pyo8J+kt/CfmLHwn5iM8J+MuPCfmYzwn5iL8J+Sl/Cfkprwn5iP8J+Sm/CfmYLwn5KT8J+kqfCfmITwn5iA8J+WpPCfmIPwn5Kv8J+ZiPCfkYfwn4628J+YkvCfpK3inaPwn5ic8J+Si/CfkYDwn5iq8J+YkfCfkqXwn5mL8J+YnvCfmKnwn5ih8J+kqvCfkYrwn6Wz8J+YpfCfpKTwn5GJ8J+Sg/CfmLPinIvwn5ia8J+YnfCfmLTwn4yf8J+YrPCfmYPwn42A8J+Mt/CfmLvwn5iT4q2Q4pyF8J+luvCfjIjwn5iI8J+kmPCfkqbinJTwn5ij8J+Pg/CfkpDimLnwn46K8J+SmPCfmKDimJ3wn5iV8J+MuvCfjoLwn4y78J+YkPCflpXwn5Kd8J+ZivCfmLnwn5ej8J+Sq/CfkoDwn5GR8J+OtfCfpJ7wn5ib8J+UtPCfmKTwn4y88J+Yq+KavfCfpJnimJXwn4+G8J+kq/CfkYjwn5iu8J+ZhvCfjbvwn42D8J+QtvCfkoHwn5iy8J+Mv/Cfp6Hwn46B4pqh8J+MnvCfjojinYzinIrwn5GL8J+YsPCfpKjwn5i28J+knfCfmrbwn5Kw8J+Nk/CfkqLwn6Sf8J+ZgfCfmqjwn5Ko8J+krOKciPCfjoDwn4268J+kk/CfmJnwn5Kf8J+MsfCfmJbwn5G28J+ltOKWtuKeoeKdk/Cfko7wn5K44qyH8J+YqPCfjJrwn6aL8J+Yt/CflbrimqDwn5mF8J+Yn/CfmLXwn5GO8J+ksvCfpKDwn6Sn8J+TjPCflLXwn5KF8J+nkPCfkL7wn42S8J+Yl/CfpJHwn4yK8J+kr/CfkLfimI7wn5Kn8J+Yr/Cfkobwn5GG8J+OpPCfmYfwn42R4p2E8J+MtPCfkqPwn5C48J+SjPCfk43wn6WA8J+kovCfkYXwn5Kh8J+SqfCfkZDwn5O48J+Ru/CfpJDwn6Su8J+OvPCfpbXwn5qp8J+NjvCfjYrwn5G88J+SjfCfk6Pwn6WCXCIpLCBXdyA9IE5oLnJlZHVjZSgoaSwgZSwgdCkgPT4gKGlbdF0gPSBlLCBpKSwgW10pLCBZdyA9IE5oLnJlZHVjZSgoaSwgZSwgdCkgPT4gKGlbZS5jb2RlUG9pbnRBdCgwKV0gPSB0LCBpKSwgW10pO1xuZnVuY3Rpb24gSncoaSkge1xuICByZXR1cm4gaS5yZWR1Y2UoKGUsIHQpID0+IChlICs9IFd3W3RdLCBlKSwgXCJcIik7XG59XG5mdW5jdGlvbiBRdyhpKSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgZm9yIChjb25zdCB0IG9mIGkpIHtcbiAgICBjb25zdCBzID0gWXdbdC5jb2RlUG9pbnRBdCgwKV07XG4gICAgaWYgKHMgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLWJhc2UyNTZlbW9qaSBjaGFyYWN0ZXI6ICR7dH1gKTtcbiAgICBlLnB1c2gocyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGUpO1xufVxuY29uc3QgWHcgPSBmcih7IHByZWZpeDogXCLwn5qAXCIsIG5hbWU6IFwiYmFzZTI1NmVtb2ppXCIsIGVuY29kZTogSncsIGRlY29kZTogUXcgfSk7XG52YXIgWncgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMjU2ZW1vamk6IFh3IH0pLCBlMCA9IFBoLCB4YSA9IDEyOCwgdDAgPSAxMjcsIGkwID0gfnQwLCBzMCA9IE1hdGgucG93KDIsIDMxKTtcbmZ1bmN0aW9uIFBoKGksIGUsIHQpIHtcbiAgZSA9IGUgfHwgW10sIHQgPSB0IHx8IDA7XG4gIGZvciAodmFyIHMgPSB0OyBpID49IHMwOyApXG4gICAgZVt0KytdID0gaSAmIDI1NSB8IHhhLCBpIC89IDEyODtcbiAgZm9yICg7IGkgJiBpMDsgKVxuICAgIGVbdCsrXSA9IGkgJiAyNTUgfCB4YSwgaSA+Pj49IDc7XG4gIHJldHVybiBlW3RdID0gaSB8IDAsIFBoLmJ5dGVzID0gdCAtIHMgKyAxLCBlO1xufVxudmFyIHIwID0gZW4sIG4wID0gMTI4LCBPYSA9IDEyNztcbmZ1bmN0aW9uIGVuKGksIHMpIHtcbiAgdmFyIHQgPSAwLCBzID0gcyB8fCAwLCByID0gMCwgbiA9IHMsIG8sIGMgPSBpLmxlbmd0aDtcbiAgZG8ge1xuICAgIGlmIChuID49IGMpXG4gICAgICB0aHJvdyBlbi5ieXRlcyA9IDAsIG5ldyBSYW5nZUVycm9yKFwiQ291bGQgbm90IGRlY29kZSB2YXJpbnRcIik7XG4gICAgbyA9IGlbbisrXSwgdCArPSByIDwgMjggPyAobyAmIE9hKSA8PCByIDogKG8gJiBPYSkgKiBNYXRoLnBvdygyLCByKSwgciArPSA3O1xuICB9IHdoaWxlIChvID49IG4wKTtcbiAgcmV0dXJuIGVuLmJ5dGVzID0gbiAtIHMsIHQ7XG59XG52YXIgbzAgPSBNYXRoLnBvdygyLCA3KSwgYTAgPSBNYXRoLnBvdygyLCAxNCksIGMwID0gTWF0aC5wb3coMiwgMjEpLCBoMCA9IE1hdGgucG93KDIsIDI4KSwgdTAgPSBNYXRoLnBvdygyLCAzNSksIGwwID0gTWF0aC5wb3coMiwgNDIpLCBkMCA9IE1hdGgucG93KDIsIDQ5KSwgZjAgPSBNYXRoLnBvdygyLCA1NiksIHAwID0gTWF0aC5wb3coMiwgNjMpLCBnMCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIGkgPCBvMCA/IDEgOiBpIDwgYTAgPyAyIDogaSA8IGMwID8gMyA6IGkgPCBoMCA/IDQgOiBpIDwgdTAgPyA1IDogaSA8IGwwID8gNiA6IGkgPCBkMCA/IDcgOiBpIDwgZjAgPyA4IDogaSA8IHAwID8gOSA6IDEwO1xufSwgeTAgPSB7IGVuY29kZTogZTAsIGRlY29kZTogcjAsIGVuY29kaW5nTGVuZ3RoOiBnMCB9LCBSaCA9IHkwO1xuY29uc3QgTmEgPSAoaSwgZSwgdCA9IDApID0+IChSaC5lbmNvZGUoaSwgZSwgdCksIGUpLCBQYSA9IChpKSA9PiBSaC5lbmNvZGluZ0xlbmd0aChpKSwgdG4gPSAoaSwgZSkgPT4ge1xuICBjb25zdCB0ID0gZS5ieXRlTGVuZ3RoLCBzID0gUGEoaSksIHIgPSBzICsgUGEodCksIG4gPSBuZXcgVWludDhBcnJheShyICsgdCk7XG4gIHJldHVybiBOYShpLCBuLCAwKSwgTmEodCwgbiwgcyksIG4uc2V0KGUsIHIpLCBuZXcgbTAoaSwgdCwgZSwgbik7XG59O1xuY2xhc3MgbTAge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzLCByKSB7XG4gICAgdGhpcy5jb2RlID0gZSwgdGhpcy5zaXplID0gdCwgdGhpcy5kaWdlc3QgPSBzLCB0aGlzLmJ5dGVzID0gcjtcbiAgfVxufVxuY29uc3QgQ2ggPSAoeyBuYW1lOiBpLCBjb2RlOiBlLCBlbmNvZGU6IHQgfSkgPT4gbmV3IGIwKGksIGUsIHQpO1xuY2xhc3MgYjAge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzKSB7XG4gICAgdGhpcy5uYW1lID0gZSwgdGhpcy5jb2RlID0gdCwgdGhpcy5lbmNvZGUgPSBzO1xuICB9XG4gIGRpZ2VzdChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5lbmNvZGUoZSk7XG4gICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyB0bih0aGlzLmNvZGUsIHQpIDogdC50aGVuKChzKSA9PiB0bih0aGlzLmNvZGUsIHMpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlXCIpO1xuICB9XG59XG5jb25zdCBBaCA9IChpKSA9PiBhc3luYyAoZSkgPT4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoaSwgZSkpLCB3MCA9IENoKHsgbmFtZTogXCJzaGEyLTI1NlwiLCBjb2RlOiAxOCwgZW5jb2RlOiBBaChcIlNIQS0yNTZcIikgfSksIHYwID0gQ2goeyBuYW1lOiBcInNoYTItNTEyXCIsIGNvZGU6IDE5LCBlbmNvZGU6IEFoKFwiU0hBLTUxMlwiKSB9KTtcbnZhciBfMCA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIHNoYTI1NjogdzAsIHNoYTUxMjogdjAgfSk7XG5jb25zdCBUaCA9IDAsIEUwID0gXCJpZGVudGl0eVwiLCAkaCA9IHhoLCBTMCA9IChpKSA9PiB0bihUaCwgJGgoaSkpLCBJMCA9IHsgY29kZTogVGgsIG5hbWU6IEUwLCBlbmNvZGU6ICRoLCBkaWdlc3Q6IFMwIH07XG52YXIgRDAgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBpZGVudGl0eTogSTAgfSk7XG5uZXcgVGV4dEVuY29kZXIoKSwgbmV3IFRleHREZWNvZGVyKCk7XG5jb25zdCBSYSA9IHsgLi4ubXcsIC4uLnd3LCAuLi5fdywgLi4uU3csIC4uLnh3LCAuLi5VdywgLi4ucXcsIC4uLkt3LCAuLi5HdywgLi4uWncgfTtcbih7IC4uLl8wLCAuLi5EMCB9KTtcbmZ1bmN0aW9uIEZoKGkpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgPyBuZXcgVWludDhBcnJheShpLmJ1ZmZlciwgaS5ieXRlT2Zmc2V0LCBpLmJ5dGVMZW5ndGgpIDogaTtcbn1cbmZ1bmN0aW9uIHgwKGkgPSAwKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jVW5zYWZlICE9IG51bGwgPyBGaChnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZShpKSkgOiBuZXcgVWludDhBcnJheShpKTtcbn1cbmZ1bmN0aW9uIFVoKGksIGUsIHQsIHMpIHtcbiAgcmV0dXJuIHsgbmFtZTogaSwgcHJlZml4OiBlLCBlbmNvZGVyOiB7IG5hbWU6IGksIHByZWZpeDogZSwgZW5jb2RlOiB0IH0sIGRlY29kZXI6IHsgZGVjb2RlOiBzIH0gfTtcbn1cbmNvbnN0IENhID0gVWgoXCJ1dGY4XCIsIFwidVwiLCAoaSkgPT4gXCJ1XCIgKyBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpLmRlY29kZShpKSwgKGkpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpLnN1YnN0cmluZygxKSkpLCBBciA9IFVoKFwiYXNjaWlcIiwgXCJhXCIsIChpKSA9PiB7XG4gIGxldCBlID0gXCJhXCI7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgaS5sZW5ndGg7IHQrKylcbiAgICBlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoaVt0XSk7XG4gIHJldHVybiBlO1xufSwgKGkpID0+IHtcbiAgaSA9IGkuc3Vic3RyaW5nKDEpO1xuICBjb25zdCBlID0geDAoaS5sZW5ndGgpO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IGkubGVuZ3RoOyB0KyspXG4gICAgZVt0XSA9IGkuY2hhckNvZGVBdCh0KTtcbiAgcmV0dXJuIGU7XG59KSwgTzAgPSB7IHV0Zjg6IENhLCBcInV0Zi04XCI6IENhLCBoZXg6IFJhLmJhc2UxNiwgbGF0aW4xOiBBciwgYXNjaWk6IEFyLCBiaW5hcnk6IEFyLCAuLi5SYSB9O1xuZnVuY3Rpb24gTjAoaSwgZSA9IFwidXRmOFwiKSB7XG4gIGNvbnN0IHQgPSBPMFtlXTtcbiAgaWYgKCF0KVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZW5jb2RpbmcgXCIke2V9XCJgKTtcbiAgcmV0dXJuIChlID09PSBcInV0ZjhcIiB8fCBlID09PSBcInV0Zi04XCIpICYmIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbSAhPSBudWxsID8gRmgoZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShpLCBcInV0Zi04XCIpKSA6IHQuZGVjb2Rlci5kZWNvZGUoYCR7dC5wcmVmaXh9JHtpfWApO1xufVxuY29uc3QgTGggPSBcIndjXCIsIFAwID0gMiwgQ24gPSBcImNvcmVcIiwgdWkgPSBgJHtMaH1AMjoke0NufTpgLCBSMCA9IHsgbmFtZTogQ24sIGxvZ2dlcjogXCJlcnJvclwiIH0sIEMwID0geyBkYXRhYmFzZTogXCI6bWVtb3J5OlwiIH0sIEEwID0gXCJjcnlwdG9cIiwgQWEgPSBcImNsaWVudF9lZDI1NTE5X3NlZWRcIiwgVDAgPSBWLk9ORV9EQVksICQwID0gXCJrZXljaGFpblwiLCBGMCA9IFwiMC4zXCIsIFUwID0gXCJtZXNzYWdlc1wiLCBMMCA9IFwiMC4zXCIsIE0wID0gVi5TSVhfSE9VUlMsIHEwID0gXCJwdWJsaXNoZXJcIiwgTWggPSBcImlyblwiLCBqMCA9IFwiZXJyb3JcIiwgcWggPSBcIndzczovL3JlbGF5LndhbGxldGNvbm5lY3QuY29tXCIsIHowID0gXCJyZWxheWVyXCIsIEhlID0geyBtZXNzYWdlOiBcInJlbGF5ZXJfbWVzc2FnZVwiLCBtZXNzYWdlX2FjazogXCJyZWxheWVyX21lc3NhZ2VfYWNrXCIsIGNvbm5lY3Q6IFwicmVsYXllcl9jb25uZWN0XCIsIGRpc2Nvbm5lY3Q6IFwicmVsYXllcl9kaXNjb25uZWN0XCIsIGVycm9yOiBcInJlbGF5ZXJfZXJyb3JcIiwgY29ubmVjdGlvbl9zdGFsbGVkOiBcInJlbGF5ZXJfY29ubmVjdGlvbl9zdGFsbGVkXCIsIHRyYW5zcG9ydF9jbG9zZWQ6IFwicmVsYXllcl90cmFuc3BvcnRfY2xvc2VkXCIsIHB1Ymxpc2g6IFwicmVsYXllcl9wdWJsaXNoXCIgfSwgSzAgPSBcIl9zdWJzY3JpcHRpb25cIiwgaXMgPSB7IHBheWxvYWQ6IFwicGF5bG9hZFwiLCBjb25uZWN0OiBcImNvbm5lY3RcIiwgZGlzY29ubmVjdDogXCJkaXNjb25uZWN0XCIsIGVycm9yOiBcImVycm9yXCIgfSwgVjAgPSBWLk9ORV9TRUNPTkQgLyAyLCBCMCA9IFwieVwiLCBrMCA9IDFlNCwgSDAgPSBcIjAuM1wiLCBCdCA9IHsgY3JlYXRlZDogXCJzdWJzY3JpcHRpb25fY3JlYXRlZFwiLCBkZWxldGVkOiBcInN1YnNjcmlwdGlvbl9kZWxldGVkXCIsIGV4cGlyZWQ6IFwic3Vic2NyaXB0aW9uX2V4cGlyZWRcIiwgZGlzYWJsZWQ6IFwic3Vic2NyaXB0aW9uX2Rpc2FibGVkXCIsIHN5bmM6IFwic3Vic2NyaXB0aW9uX3N5bmNcIiwgcmVzdWJzY3JpYmVkOiBcInN1YnNjcmlwdGlvbl9yZXN1YnNjcmliZWRcIiB9LCBHMCA9IFwic3Vic2NyaXB0aW9uXCIsIFcwID0gXCIwLjNcIiwgWTAgPSBWLkZJVkVfU0VDT05EUyAqIDFlMywgSjAgPSBcInBhaXJpbmdcIiwgUTAgPSBcIjAuM1wiLCBzcyA9IHsgd2NfcGFpcmluZ0RlbGV0ZTogeyByZXE6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMWUzIH0sIHJlczogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMDAxIH0gfSwgd2NfcGFpcmluZ1Bpbmc6IHsgcmVxOiB7IHR0bDogVi5USElSVFlfU0VDT05EUywgcHJvbXB0OiAhMSwgdGFnOiAxMDAyIH0sIHJlczogeyB0dGw6IFYuVEhJUlRZX1NFQ09ORFMsIHByb21wdDogITEsIHRhZzogMTAwMyB9IH0sIHVucmVnaXN0ZXJlZF9tZXRob2Q6IHsgcmVxOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDAgfSwgcmVzOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDAgfSB9IH0sIEt0ID0geyBjcmVhdGVkOiBcImhpc3RvcnlfY3JlYXRlZFwiLCB1cGRhdGVkOiBcImhpc3RvcnlfdXBkYXRlZFwiLCBkZWxldGVkOiBcImhpc3RvcnlfZGVsZXRlZFwiLCBzeW5jOiBcImhpc3Rvcnlfc3luY1wiIH0sIFgwID0gXCJoaXN0b3J5XCIsIFowID0gXCIwLjNcIiwgZXYgPSBcImV4cGlyZXJcIiwgJHQgPSB7IGNyZWF0ZWQ6IFwiZXhwaXJlcl9jcmVhdGVkXCIsIGRlbGV0ZWQ6IFwiZXhwaXJlcl9kZWxldGVkXCIsIGV4cGlyZWQ6IFwiZXhwaXJlcl9leHBpcmVkXCIsIHN5bmM6IFwiZXhwaXJlcl9zeW5jXCIgfSwgdHYgPSBcIjAuM1wiLCBUciA9IFwidmVyaWZ5LWFwaVwiLCBUYSA9IFwiaHR0cHM6Ly92ZXJpZnkud2FsbGV0Y29ubmVjdC5jb21cIjtcbmNsYXNzIGl2IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5rZXljaGFpbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMubmFtZSA9ICQwLCB0aGlzLnZlcnNpb24gPSBGMCwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSB1aSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IHMgPSBhd2FpdCB0aGlzLmdldEtleUNoYWluKCk7XG4gICAgICAgIHR5cGVvZiBzIDwgXCJ1XCIgJiYgKHRoaXMua2V5Y2hhaW4gPSBzKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaGFzID0gKHMpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5rZXljaGFpbi5oYXMocykpLCB0aGlzLnNldCA9IGFzeW5jIChzLCByKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5rZXljaGFpbi5zZXQocywgciksIGF3YWl0IHRoaXMucGVyc2lzdCgpO1xuICAgIH0sIHRoaXMuZ2V0ID0gKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgciA9IHRoaXMua2V5Y2hhaW4uZ2V0KHMpO1xuICAgICAgaWYgKHR5cGVvZiByID4gXCJ1XCIpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBKKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGAke3RoaXMubmFtZX06ICR7c31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgdGhpcy5kZWwgPSBhc3luYyAocykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMua2V5Y2hhaW4uZGVsZXRlKHMpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9LCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIFwiLy9cIiArIHRoaXMubmFtZTtcbiAgfVxuICBhc3luYyBzZXRLZXlDaGFpbihlKSB7XG4gICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIHZoKGUpKTtcbiAgfVxuICBhc3luYyBnZXRLZXlDaGFpbigpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgIHJldHVybiB0eXBlb2YgZSA8IFwidVwiID8gX2goZSkgOiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldEtleUNoYWluKHRoaXMua2V5Y2hhaW4pO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IEooXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIHN2IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcykge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5uYW1lID0gQTAsIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAoYXdhaXQgdGhpcy5rZXljaGFpbi5pbml0KCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCk7XG4gICAgfSwgdGhpcy5oYXNLZXlzID0gKHIpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5rZXljaGFpbi5oYXMocikpLCB0aGlzLmdldENsaWVudElkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5nZXRDbGllbnRTZWVkKCksIG4gPSBXcyhyKTtcbiAgICAgIHJldHVybiBhbihuLnB1YmxpY0tleSk7XG4gICAgfSwgdGhpcy5nZW5lcmF0ZUtleVBhaXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHIgPSBYbSgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0UHJpdmF0ZUtleShyLnB1YmxpY0tleSwgci5wcml2YXRlS2V5KTtcbiAgICB9LCB0aGlzLnNpZ25KV1QgPSBhc3luYyAocikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5nZXRDbGllbnRTZWVkKCksIG8gPSBXcyhuKSwgYyA9IFhyKCk7XG4gICAgICByZXR1cm4gYXdhaXQgSWMoYywgciwgVDAsIG8pO1xuICAgIH0sIHRoaXMuZ2VuZXJhdGVTaGFyZWRLZXkgPSAociwgbiwgbykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBjID0gdGhpcy5nZXRQcml2YXRlS2V5KHIpLCB1ID0gWm0oYywgbik7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTeW1LZXkodSwgbyk7XG4gICAgfSwgdGhpcy5zZXRTeW1LZXkgPSBhc3luYyAociwgbikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBvID0gbiB8fCBlYihyKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmtleWNoYWluLnNldChvLCByKSwgbztcbiAgICB9LCB0aGlzLmRlbGV0ZUtleVBhaXIgPSBhc3luYyAocikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMua2V5Y2hhaW4uZGVsKHIpO1xuICAgIH0sIHRoaXMuZGVsZXRlU3ltS2V5ID0gYXN5bmMgKHIpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmtleWNoYWluLmRlbChyKTtcbiAgICB9LCB0aGlzLmVuY29kZSA9IGFzeW5jIChyLCBuLCBvKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IGMgPSBiaChvKSwgdSA9IHJyKG4pO1xuICAgICAgaWYgKHlhKGMpKSB7XG4gICAgICAgIGNvbnN0IHggPSBjLnNlbmRlclB1YmxpY0tleSwgTyA9IGMucmVjZWl2ZXJQdWJsaWNLZXk7XG4gICAgICAgIHIgPSBhd2FpdCB0aGlzLmdlbmVyYXRlU2hhcmVkS2V5KHgsIE8pO1xuICAgICAgfVxuICAgICAgY29uc3QgZCA9IHRoaXMuZ2V0U3ltS2V5KHIpLCB7IHR5cGU6IHAsIHNlbmRlclB1YmxpY0tleTogYiB9ID0gYztcbiAgICAgIHJldHVybiBpYih7IHR5cGU6IHAsIHN5bUtleTogZCwgbWVzc2FnZTogdSwgc2VuZGVyUHVibGljS2V5OiBiIH0pO1xuICAgIH0sIHRoaXMuZGVjb2RlID0gYXN5bmMgKHIsIG4sIG8pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgYyA9IG5iKG4sIG8pO1xuICAgICAgaWYgKHlhKGMpKSB7XG4gICAgICAgIGNvbnN0IHAgPSBjLnJlY2VpdmVyUHVibGljS2V5LCBiID0gYy5zZW5kZXJQdWJsaWNLZXk7XG4gICAgICAgIHIgPSBhd2FpdCB0aGlzLmdlbmVyYXRlU2hhcmVkS2V5KHAsIGIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdSA9IHRoaXMuZ2V0U3ltS2V5KHIpLCBkID0gc2IoeyBzeW1LZXk6IHUsIGVuY29kZWQ6IG4gfSk7XG4gICAgICByZXR1cm4gcm4oZCk7XG4gICAgfSwgdGhpcy5nZXRQYXlsb2FkVHlwZSA9IChyKSA9PiB7XG4gICAgICBjb25zdCBuID0gWnMocik7XG4gICAgICByZXR1cm4gSXMobi50eXBlKTtcbiAgICB9LCB0aGlzLmdldFBheWxvYWRTZW5kZXJQdWJsaWNLZXkgPSAocikgPT4ge1xuICAgICAgY29uc3QgbiA9IFpzKHIpO1xuICAgICAgcmV0dXJuIG4uc2VuZGVyUHVibGljS2V5ID8gTmUobi5zZW5kZXJQdWJsaWNLZXksIF90KSA6IHZvaWQgMDtcbiAgICB9LCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy5rZXljaGFpbiA9IHMgfHwgbmV3IGl2KHRoaXMuY29yZSwgdGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBhc3luYyBzZXRQcml2YXRlS2V5KGUsIHQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5rZXljaGFpbi5zZXQoZSwgdCksIGU7XG4gIH1cbiAgZ2V0UHJpdmF0ZUtleShlKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5Y2hhaW4uZ2V0KGUpO1xuICB9XG4gIGFzeW5jIGdldENsaWVudFNlZWQoKSB7XG4gICAgbGV0IGUgPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICBlID0gdGhpcy5rZXljaGFpbi5nZXQoQWEpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgZSA9IFhyKCksIGF3YWl0IHRoaXMua2V5Y2hhaW4uc2V0KEFhLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIE4wKGUsIFwiYmFzZTE2XCIpO1xuICB9XG4gIGdldFN5bUtleShlKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5Y2hhaW4uZ2V0KGUpO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IEooXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIHJ2IGV4dGVuZHMgJG0ge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCksIHRoaXMubG9nZ2VyID0gZSwgdGhpcy5jb3JlID0gdCwgdGhpcy5tZXNzYWdlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMubmFtZSA9IFUwLCB0aGlzLnZlcnNpb24gPSBMMCwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSB1aSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcyA9IGF3YWl0IHRoaXMuZ2V0UmVsYXllck1lc3NhZ2VzKCk7XG4gICAgICAgICAgdHlwZW9mIHMgPCBcInVcIiAmJiAodGhpcy5tZXNzYWdlcyA9IHMpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIHJlY29yZHMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJyZXN0b3JlXCIsIHNpemU6IHRoaXMubWVzc2FnZXMuc2l6ZSB9KTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gUmVzdG9yZSByZWNvcmRzIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3Iocyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9ICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcy5zZXQgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBuID0gVWkocik7XG4gICAgICBsZXQgbyA9IHRoaXMubWVzc2FnZXMuZ2V0KHMpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBvID4gXCJ1XCIgJiYgKG8gPSB7fSksIHR5cGVvZiBvW25dIDwgXCJ1XCIgfHwgKG9bbl0gPSByLCB0aGlzLm1lc3NhZ2VzLnNldChzLCBvKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCkpLCBuO1xuICAgIH0sIHRoaXMuZ2V0ID0gKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgbGV0IHIgPSB0aGlzLm1lc3NhZ2VzLmdldChzKTtcbiAgICAgIHJldHVybiB0eXBlb2YgciA+IFwidVwiICYmIChyID0ge30pLCByO1xuICAgIH0sIHRoaXMuaGFzID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0KHMpLCBvID0gVWkocik7XG4gICAgICByZXR1cm4gdHlwZW9mIG5bb10gPCBcInVcIjtcbiAgICB9LCB0aGlzLmRlbCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5tZXNzYWdlcy5kZWxldGUocyksIGF3YWl0IHRoaXMucGVyc2lzdCgpO1xuICAgIH0sIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcihlLCB0aGlzLm5hbWUpLCB0aGlzLmNvcmUgPSB0O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgXCIvL1wiICsgdGhpcy5uYW1lO1xuICB9XG4gIGFzeW5jIHNldFJlbGF5ZXJNZXNzYWdlcyhlKSB7XG4gICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIHZoKGUpKTtcbiAgfVxuICBhc3luYyBnZXRSZWxheWVyTWVzc2FnZXMoKSB7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICByZXR1cm4gdHlwZW9mIGUgPCBcInVcIiA/IF9oKGUpIDogdm9pZCAwO1xuICB9XG4gIGFzeW5jIHBlcnNpc3QoKSB7XG4gICAgYXdhaXQgdGhpcy5zZXRSZWxheWVyTWVzc2FnZXModGhpcy5tZXNzYWdlcyk7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gSihcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgbnYgZXh0ZW5kcyBGbSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5uYW1lID0gcTAsIHRoaXMucXVldWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnB1Ymxpc2hUaW1lb3V0ID0gMWU0LCB0aGlzLnB1Ymxpc2ggPSBhc3luYyAocywgciwgbikgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJQdWJsaXNoaW5nIFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInB1Ymxpc2hcIiwgcGFyYW1zOiB7IHRvcGljOiBzLCBtZXNzYWdlOiByLCBvcHRzOiBuIH0gfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvID0gbj8udHRsIHx8IE0wLCBjID0gWnIobiksIHUgPSBuPy5wcm9tcHQgfHwgITEsIGQgPSBuPy50YWcgfHwgMCwgcCA9IG4/LmlkIHx8IHZuKCkudG9TdHJpbmcoKSwgYiA9IHsgdG9waWM6IHMsIG1lc3NhZ2U6IHIsIG9wdHM6IHsgdHRsOiBvLCByZWxheTogYywgcHJvbXB0OiB1LCB0YWc6IGQsIGlkOiBwIH0gfTtcbiAgICAgICAgdGhpcy5xdWV1ZS5zZXQocCwgYik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgYXdhaXQgZXIodGhpcy5ycGNQdWJsaXNoKHMsIHIsIG8sIGMsIHUsIGQsIHApLCB0aGlzLnB1Ymxpc2hUaW1lb3V0KSwgdGhpcy5yZWxheWVyLmV2ZW50cy5lbWl0KEhlLnB1Ymxpc2gsIGIpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlB1Ymxpc2hpbmcgUGF5bG9hZCBzdGFsbGVkXCIpLCB0aGlzLnJlbGF5ZXIuZXZlbnRzLmVtaXQoSGUuY29ubmVjdGlvbl9zdGFsbGVkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJTdWNjZXNzZnVsbHkgUHVibGlzaGVkIFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInB1Ymxpc2hcIiwgcGFyYW1zOiB7IHRvcGljOiBzLCBtZXNzYWdlOiByLCBvcHRzOiBuIH0gfSk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmRlYnVnKFwiRmFpbGVkIHRvIFB1Ymxpc2ggUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIuZXJyb3IobyksIG87XG4gICAgICB9XG4gICAgfSwgdGhpcy5vbiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbihzLCByKTtcbiAgICB9LCB0aGlzLm9uY2UgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub25jZShzLCByKTtcbiAgICB9LCB0aGlzLm9mZiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vZmYocywgcik7XG4gICAgfSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihzLCByKTtcbiAgICB9LCB0aGlzLnJlbGF5ZXIgPSBlLCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIHJwY1B1Ymxpc2goZSwgdCwgcywgciwgbiwgbywgYykge1xuICAgIHZhciB1LCBkLCBwLCBiO1xuICAgIGNvbnN0IHggPSB7IG1ldGhvZDogVnMoci5wcm90b2NvbCkucHVibGlzaCwgcGFyYW1zOiB7IHRvcGljOiBlLCBtZXNzYWdlOiB0LCB0dGw6IHMsIHByb21wdDogbiwgdGFnOiBvIH0sIGlkOiBjIH07XG4gICAgcmV0dXJuIHd0KCh1ID0geC5wYXJhbXMpID09IG51bGwgPyB2b2lkIDAgOiB1LnByb21wdCkgJiYgKChkID0geC5wYXJhbXMpID09IG51bGwgfHwgZGVsZXRlIGQucHJvbXB0KSwgd3QoKHAgPSB4LnBhcmFtcykgPT0gbnVsbCA/IHZvaWQgMCA6IHAudGFnKSAmJiAoKGIgPSB4LnBhcmFtcykgPT0gbnVsbCB8fCBkZWxldGUgYi50YWcpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIk91dGdvaW5nIFJlbGF5IFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXNzYWdlXCIsIGRpcmVjdGlvbjogXCJvdXRnb2luZ1wiLCByZXF1ZXN0OiB4IH0pLCB0aGlzLnJlbGF5ZXIucmVxdWVzdCh4KTtcbiAgfVxuICBvblB1Ymxpc2goZSkge1xuICAgIHRoaXMucXVldWUuZGVsZXRlKGUpO1xuICB9XG4gIGNoZWNrUXVldWUoKSB7XG4gICAgdGhpcy5xdWV1ZS5mb3JFYWNoKGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiB0LCBtZXNzYWdlOiBzLCBvcHRzOiByIH0gPSBlO1xuICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoKHQsIHMsIHIpO1xuICAgIH0pO1xuICB9XG4gIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5yZWxheWVyLmNvcmUuaGVhcnRiZWF0Lm9uKFd0LkhFQVJUQkVBVF9FVkVOVFMucHVsc2UsICgpID0+IHtcbiAgICAgIHRoaXMuY2hlY2tRdWV1ZSgpO1xuICAgIH0pLCB0aGlzLnJlbGF5ZXIub24oSGUubWVzc2FnZV9hY2ssIChlKSA9PiB7XG4gICAgICB0aGlzLm9uUHVibGlzaChlLmlkLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBvdiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5zZXQgPSAoZSwgdCkgPT4ge1xuICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0KGUpO1xuICAgICAgdGhpcy5leGlzdHMoZSwgdCkgfHwgdGhpcy5tYXAuc2V0KGUsIFsuLi5zLCB0XSk7XG4gICAgfSwgdGhpcy5nZXQgPSAoZSkgPT4gdGhpcy5tYXAuZ2V0KGUpIHx8IFtdLCB0aGlzLmV4aXN0cyA9IChlLCB0KSA9PiB0aGlzLmdldChlKS5pbmNsdWRlcyh0KSwgdGhpcy5kZWxldGUgPSAoZSwgdCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0ID4gXCJ1XCIpIHtcbiAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubWFwLmhhcyhlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0KGUpO1xuICAgICAgaWYgKCF0aGlzLmV4aXN0cyhlLCB0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IHMuZmlsdGVyKChuKSA9PiBuICE9PSB0KTtcbiAgICAgIGlmICghci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1hcC5zZXQoZSwgcik7XG4gICAgfSwgdGhpcy5jbGVhciA9ICgpID0+IHtcbiAgICAgIHRoaXMubWFwLmNsZWFyKCk7XG4gICAgfTtcbiAgfVxuICBnZXQgdG9waWNzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWFwLmtleXMoKSk7XG4gIH1cbn1cbnZhciBhdiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgY3YgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgaHYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgJGEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCB1diA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGx2ID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgRmEgPSAoaSwgZSwgdCkgPT4gZSBpbiBpID8gYXYoaSwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGlbZV0gPSB0LCBycyA9IChpLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICB1di5jYWxsKGUsIHQpICYmIEZhKGksIHQsIGVbdF0pO1xuICBpZiAoJGEpXG4gICAgZm9yICh2YXIgdCBvZiAkYShlKSlcbiAgICAgIGx2LmNhbGwoZSwgdCkgJiYgRmEoaSwgdCwgZVt0XSk7XG4gIHJldHVybiBpO1xufSwgJHIgPSAoaSwgZSkgPT4gY3YoaSwgaHYoZSkpO1xuY2xhc3MgZHYgZXh0ZW5kcyBNbSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnRvcGljTWFwID0gbmV3IG92KCksIHRoaXMuZXZlbnRzID0gbmV3IFdlLkV2ZW50RW1pdHRlcigpLCB0aGlzLm5hbWUgPSBHMCwgdGhpcy52ZXJzaW9uID0gVzAsIHRoaXMucGVuZGluZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9uV2F0Y2hMYWJlbCA9IFwicGVuZGluZ19zdWJfd2F0Y2hfbGFiZWxcIiwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwgPSAyMCwgdGhpcy5zdG9yYWdlUHJlZml4ID0gdWksIHRoaXMuc3Vic2NyaWJlVGltZW91dCA9IDFlNCwgdGhpcy5yZXN0YXJ0SW5Qcm9ncmVzcyA9ICExLCB0aGlzLmJhdGNoU3Vic2NyaWJlVG9waWNzTGltaXQgPSA1MDAsIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIiksIGF3YWl0IHRoaXMucmVzdGFydCgpLCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5vbkVuYWJsZSgpLCB0aGlzLmNsaWVudElkID0gYXdhaXQgdGhpcy5yZWxheWVyLmNvcmUuY3J5cHRvLmdldENsaWVudElkKCkpO1xuICAgIH0sIHRoaXMuc3Vic2NyaWJlID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRvQ29tcGxldGUoKSwgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3Vic2NyaWJpbmcgVG9waWNcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInN1YnNjcmliZVwiLCBwYXJhbXM6IHsgdG9waWM6IHMsIG9wdHM6IHIgfSB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG4gPSBacihyKSwgbyA9IHsgdG9waWM6IHMsIHJlbGF5OiBuIH07XG4gICAgICAgIHRoaXMucGVuZGluZy5zZXQocywgbyk7XG4gICAgICAgIGNvbnN0IGMgPSBhd2FpdCB0aGlzLnJwY1N1YnNjcmliZShzLCBuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25TdWJzY3JpYmUoYywgbyksIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3VjY2Vzc2Z1bGx5IFN1YnNjcmliZWQgVG9waWNcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInN1YnNjcmliZVwiLCBwYXJhbXM6IHsgdG9waWM6IHMsIG9wdHM6IHIgfSB9KSwgYztcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZGVidWcoXCJGYWlsZWQgdG8gU3Vic2NyaWJlIFRvcGljXCIpLCB0aGlzLmxvZ2dlci5lcnJvcihuKSwgbjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnVuc3Vic2NyaWJlID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRvQ29tcGxldGUoKSwgdGhpcy5pc0luaXRpYWxpemVkKCksIHR5cGVvZiByPy5pZCA8IFwidVwiID8gYXdhaXQgdGhpcy51bnN1YnNjcmliZUJ5SWQocywgci5pZCwgcikgOiBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlQnlUb3BpYyhzLCByKTtcbiAgICB9LCB0aGlzLmlzU3Vic2NyaWJlZCA9IGFzeW5jIChzKSA9PiB0aGlzLnRvcGljcy5pbmNsdWRlcyhzKSA/ICEwIDogYXdhaXQgbmV3IFByb21pc2UoKHIsIG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSBuZXcgVi5XYXRjaCgpO1xuICAgICAgby5zdGFydCh0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25XYXRjaExhYmVsKTtcbiAgICAgIGNvbnN0IGMgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICF0aGlzLnBlbmRpbmcuaGFzKHMpICYmIHRoaXMudG9waWNzLmluY2x1ZGVzKHMpICYmIChjbGVhckludGVydmFsKGMpLCBvLnN0b3AodGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9uV2F0Y2hMYWJlbCksIHIoITApKSwgby5lbGFwc2VkKHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbldhdGNoTGFiZWwpID49IFkwICYmIChjbGVhckludGVydmFsKGMpLCBvLnN0b3AodGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9uV2F0Y2hMYWJlbCksIG4obmV3IEVycm9yKFwiU3Vic2NyaXB0aW9uIHJlc29sdXRpb24gdGltZW91dFwiKSkpO1xuICAgICAgfSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgIH0pLmNhdGNoKCgpID0+ICExKSwgdGhpcy5vbiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbihzLCByKTtcbiAgICB9LCB0aGlzLm9uY2UgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub25jZShzLCByKTtcbiAgICB9LCB0aGlzLm9mZiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vZmYocywgcik7XG4gICAgfSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihzLCByKTtcbiAgICB9LCB0aGlzLnJlc3RhcnQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLnJlc3RhcnRJblByb2dyZXNzID0gITAsIGF3YWl0IHRoaXMucmVzdG9yZSgpLCBhd2FpdCB0aGlzLnJlc2V0KCksIHRoaXMucmVzdGFydEluUHJvZ3Jlc3MgPSAhMTtcbiAgICB9LCB0aGlzLnJlbGF5ZXIgPSBlLCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy5jbGllbnRJZCA9IFwiXCI7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBzdG9yYWdlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcmVmaXggKyB0aGlzLnZlcnNpb24gKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zLnNpemU7XG4gIH1cbiAgZ2V0IGlkcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN1YnNjcmlwdGlvbnMua2V5cygpKTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKSk7XG4gIH1cbiAgZ2V0IHRvcGljcygpIHtcbiAgICByZXR1cm4gdGhpcy50b3BpY01hcC50b3BpY3M7XG4gIH1cbiAgaGFzU3Vic2NyaXB0aW9uKGUsIHQpIHtcbiAgICBsZXQgcyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBzID0gdGhpcy5nZXRTdWJzY3JpcHRpb24oZSkudG9waWMgPT09IHQ7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG4gIG9uRW5hYmxlKCkge1xuICAgIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMDtcbiAgfVxuICBvbkRpc2FibGUoKSB7XG4gICAgdGhpcy5jYWNoZWQgPSB0aGlzLnZhbHVlcywgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCksIHRoaXMudG9waWNNYXAuY2xlYXIoKTtcbiAgfVxuICBhc3luYyB1bnN1YnNjcmliZUJ5VG9waWMoZSwgdCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnRvcGljTWFwLmdldChlKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChzLm1hcChhc3luYyAocikgPT4gYXdhaXQgdGhpcy51bnN1YnNjcmliZUJ5SWQoZSwgciwgdCkpKTtcbiAgfVxuICBhc3luYyB1bnN1YnNjcmliZUJ5SWQoZSwgdCwgcykge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiVW5zdWJzY3JpYmluZyBUb3BpY1wiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwidW5zdWJzY3JpYmVcIiwgcGFyYW1zOiB7IHRvcGljOiBlLCBpZDogdCwgb3B0czogcyB9IH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByID0gWnIocyk7XG4gICAgICBhd2FpdCB0aGlzLnJwY1Vuc3Vic2NyaWJlKGUsIHQsIHIpO1xuICAgICAgY29uc3QgbiA9IEplKFwiVVNFUl9ESVNDT05ORUNURURcIiwgYCR7dGhpcy5uYW1lfSwgJHtlfWApO1xuICAgICAgYXdhaXQgdGhpcy5vblVuc3Vic2NyaWJlKGUsIHQsIG4pLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN1Y2Nlc3NmdWxseSBVbnN1YnNjcmliZWQgVG9waWNcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInVuc3Vic2NyaWJlXCIsIHBhcmFtczogeyB0b3BpYzogZSwgaWQ6IHQsIG9wdHM6IHMgfSB9KTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICB0aHJvdyB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkZhaWxlZCB0byBVbnN1YnNjcmliZSBUb3BpY1wiKSwgdGhpcy5sb2dnZXIuZXJyb3IociksIHI7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJwY1N1YnNjcmliZShlLCB0KSB7XG4gICAgY29uc3QgcyA9IHsgbWV0aG9kOiBWcyh0LnByb3RvY29sKS5zdWJzY3JpYmUsIHBhcmFtczogeyB0b3BpYzogZSB9IH07XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJPdXRnb2luZyBSZWxheSBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwicGF5bG9hZFwiLCBkaXJlY3Rpb246IFwib3V0Z29pbmdcIiwgcmVxdWVzdDogcyB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYXdhaXQgZXIodGhpcy5yZWxheWVyLnJlcXVlc3QocyksIHRoaXMuc3Vic2NyaWJlVGltZW91dCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIk91dGdvaW5nIFJlbGF5IFN1YnNjcmliZSBQYXlsb2FkIHN0YWxsZWRcIiksIHRoaXMucmVsYXllci5ldmVudHMuZW1pdChIZS5jb25uZWN0aW9uX3N0YWxsZWQpO1xuICAgIH1cbiAgICByZXR1cm4gVWkoZSArIHRoaXMuY2xpZW50SWQpO1xuICB9XG4gIGFzeW5jIHJwY0JhdGNoU3Vic2NyaWJlKGUpIHtcbiAgICBpZiAoIWUubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBlWzBdLnJlbGF5LCBzID0geyBtZXRob2Q6IFZzKHQucHJvdG9jb2wpLmJhdGNoU3Vic2NyaWJlLCBwYXJhbXM6IHsgdG9waWNzOiBlLm1hcCgocikgPT4gci50b3BpYykgfSB9O1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcInBheWxvYWRcIiwgZGlyZWN0aW9uOiBcIm91dGdvaW5nXCIsIHJlcXVlc3Q6IHMgfSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhd2FpdCBlcih0aGlzLnJlbGF5ZXIucmVxdWVzdChzKSwgdGhpcy5zdWJzY3JpYmVUaW1lb3V0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgUGF5bG9hZCBzdGFsbGVkXCIpLCB0aGlzLnJlbGF5ZXIuZXZlbnRzLmVtaXQoSGUuY29ubmVjdGlvbl9zdGFsbGVkKTtcbiAgICB9XG4gIH1cbiAgcnBjVW5zdWJzY3JpYmUoZSwgdCwgcykge1xuICAgIGNvbnN0IHIgPSB7IG1ldGhvZDogVnMocy5wcm90b2NvbCkudW5zdWJzY3JpYmUsIHBhcmFtczogeyB0b3BpYzogZSwgaWQ6IHQgfSB9O1xuICAgIHJldHVybiB0aGlzLmxvZ2dlci5kZWJ1ZyhcIk91dGdvaW5nIFJlbGF5IFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJwYXlsb2FkXCIsIGRpcmVjdGlvbjogXCJvdXRnb2luZ1wiLCByZXF1ZXN0OiByIH0pLCB0aGlzLnJlbGF5ZXIucmVxdWVzdChyKTtcbiAgfVxuICBvblN1YnNjcmliZShlLCB0KSB7XG4gICAgdGhpcy5zZXRTdWJzY3JpcHRpb24oZSwgJHIocnMoe30sIHQpLCB7IGlkOiBlIH0pKSwgdGhpcy5wZW5kaW5nLmRlbGV0ZSh0LnRvcGljKTtcbiAgfVxuICBvbkJhdGNoU3Vic2NyaWJlKGUpIHtcbiAgICBlLmxlbmd0aCAmJiBlLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHRoaXMuc2V0U3Vic2NyaXB0aW9uKHQuaWQsIHJzKHt9LCB0KSksIHRoaXMucGVuZGluZy5kZWxldGUodC50b3BpYyk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgb25VbnN1YnNjcmliZShlLCB0LCBzKSB7XG4gICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKHQpLCB0aGlzLmhhc1N1YnNjcmlwdGlvbih0LCBlKSAmJiB0aGlzLmRlbGV0ZVN1YnNjcmlwdGlvbih0LCBzKSwgYXdhaXQgdGhpcy5yZWxheWVyLm1lc3NhZ2VzLmRlbChlKTtcbiAgfVxuICBhc3luYyBzZXRSZWxheWVyU3Vic2NyaXB0aW9ucyhlKSB7XG4gICAgYXdhaXQgdGhpcy5yZWxheWVyLmNvcmUuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgZSk7XG4gIH1cbiAgYXN5bmMgZ2V0UmVsYXllclN1YnNjcmlwdGlvbnMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVsYXllci5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG4gIHNldFN1YnNjcmlwdGlvbihlLCB0KSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmhhcyhlKSB8fCAodGhpcy5sb2dnZXIuZGVidWcoXCJTZXR0aW5nIHN1YnNjcmlwdGlvblwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic2V0U3Vic2NyaXB0aW9uXCIsIGlkOiBlLCBzdWJzY3JpcHRpb246IHQgfSksIHRoaXMuYWRkU3Vic2NyaXB0aW9uKGUsIHQpKTtcbiAgfVxuICBhZGRTdWJzY3JpcHRpb24oZSwgdCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoZSwgcnMoe30sIHQpKSwgdGhpcy50b3BpY01hcC5zZXQodC50b3BpYywgZSksIHRoaXMuZXZlbnRzLmVtaXQoQnQuY3JlYXRlZCwgdCk7XG4gIH1cbiAgZ2V0U3Vic2NyaXB0aW9uKGUpIHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgc3Vic2NyaXB0aW9uXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJnZXRTdWJzY3JpcHRpb25cIiwgaWQ6IGUgfSk7XG4gICAgY29uc3QgdCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQoZSk7XG4gICAgaWYgKCF0KSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHMgfSA9IEooXCJOT19NQVRDSElOR19LRVlcIiwgYCR7dGhpcy5uYW1lfTogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHMpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBkZWxldGVTdWJzY3JpcHRpb24oZSwgdCkge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiRGVsZXRpbmcgc3Vic2NyaXB0aW9uXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJkZWxldGVTdWJzY3JpcHRpb25cIiwgaWQ6IGUsIHJlYXNvbjogdCB9KTtcbiAgICBjb25zdCBzID0gdGhpcy5nZXRTdWJzY3JpcHRpb24oZSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShlKSwgdGhpcy50b3BpY01hcC5kZWxldGUocy50b3BpYywgZSksIHRoaXMuZXZlbnRzLmVtaXQoQnQuZGVsZXRlZCwgJHIocnMoe30sIHMpLCB7IHJlYXNvbjogdCB9KSk7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldFJlbGF5ZXJTdWJzY3JpcHRpb25zKHRoaXMudmFsdWVzKSwgdGhpcy5ldmVudHMuZW1pdChCdC5zeW5jKTtcbiAgfVxuICBhc3luYyByZXNldCgpIHtcbiAgICBpZiAodGhpcy5jYWNoZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlID0gTWF0aC5jZWlsKHRoaXMuY2FjaGVkLmxlbmd0aCAvIHRoaXMuYmF0Y2hTdWJzY3JpYmVUb3BpY3NMaW1pdCk7XG4gICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGU7IHQrKykge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5jYWNoZWQuc3BsaWNlKDAsIHRoaXMuYmF0Y2hTdWJzY3JpYmVUb3BpY3NMaW1pdCk7XG4gICAgICAgIGF3YWl0IHRoaXMuYmF0Y2hTdWJzY3JpYmUocyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzLmVtaXQoQnQucmVzdWJzY3JpYmVkKTtcbiAgfVxuICBhc3luYyByZXN0b3JlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5nZXRSZWxheWVyU3Vic2NyaXB0aW9ucygpO1xuICAgICAgaWYgKHR5cGVvZiBlID4gXCJ1XCIgfHwgIWUubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zLnNpemUpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBKKFwiUkVTVE9SRV9XSUxMX09WRVJSSURFXCIsIHRoaXMubmFtZSk7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHQpLCB0aGlzLmxvZ2dlci5lcnJvcihgJHt0aGlzLm5hbWV9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMudmFsdWVzKX1gKSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIHN1YnNjcmlwdGlvbnMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJyZXN0b3JlXCIsIHN1YnNjcmlwdGlvbnM6IHRoaXMudmFsdWVzIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gUmVzdG9yZSBzdWJzY3JpcHRpb25zIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGJhdGNoU3Vic2NyaWJlKGUpIHtcbiAgICBpZiAoIWUubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBhd2FpdCB0aGlzLnJwY0JhdGNoU3Vic2NyaWJlKGUpO1xuICAgIERzKHQpICYmIHRoaXMub25CYXRjaFN1YnNjcmliZSh0Lm1hcCgocywgcikgPT4gJHIocnMoe30sIGVbcl0pLCB7IGlkOiBzIH0pKSk7XG4gIH1cbiAgYXN5bmMgb25Db25uZWN0KCkge1xuICAgIHRoaXMucmVzdGFydEluUHJvZ3Jlc3MgfHwgKGF3YWl0IHRoaXMucmVzdGFydCgpLCB0aGlzLm9uRW5hYmxlKCkpO1xuICB9XG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm9uRGlzYWJsZSgpO1xuICB9XG4gIGFzeW5jIGNoZWNrUGVuZGluZygpIHtcbiAgICBpZiAodGhpcy5yZWxheWVyLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHRoaXMucGVuZGluZy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBlLnB1c2godCk7XG4gICAgfSksIGF3YWl0IHRoaXMuYmF0Y2hTdWJzY3JpYmUoZSk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLnJlbGF5ZXIuY29yZS5oZWFydGJlYXQub24oV3QuSEVBUlRCRUFUX0VWRU5UUy5wdWxzZSwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5jaGVja1BlbmRpbmcoKTtcbiAgICB9KSwgdGhpcy5yZWxheWVyLm9uKEhlLmNvbm5lY3QsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMub25Db25uZWN0KCk7XG4gICAgfSksIHRoaXMucmVsYXllci5vbihIZS5kaXNjb25uZWN0LCAoKSA9PiB7XG4gICAgICB0aGlzLm9uRGlzY29ubmVjdCgpO1xuICAgIH0pLCB0aGlzLmV2ZW50cy5vbihCdC5jcmVhdGVkLCBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IEJ0LmNyZWF0ZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgZGF0YTogZSB9KSwgYXdhaXQgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSksIHRoaXMuZXZlbnRzLm9uKEJ0LmRlbGV0ZWQsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gQnQuZGVsZXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCBkYXRhOiBlIH0pLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBKKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlc3RhcnRUb0NvbXBsZXRlKCkge1xuICAgIHRoaXMucmVzdGFydEluUHJvZ3Jlc3MgJiYgYXdhaXQgbmV3IFByb21pc2UoKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHRoaXMucmVzdGFydEluUHJvZ3Jlc3MgfHwgKGNsZWFySW50ZXJ2YWwodCksIGUoKSk7XG4gICAgICB9LCB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBmdiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgVWEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBwdiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGd2ID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgTGEgPSAoaSwgZSwgdCkgPT4gZSBpbiBpID8gZnYoaSwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGlbZV0gPSB0LCB5diA9IChpLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICBwdi5jYWxsKGUsIHQpICYmIExhKGksIHQsIGVbdF0pO1xuICBpZiAoVWEpXG4gICAgZm9yICh2YXIgdCBvZiBVYShlKSlcbiAgICAgIGd2LmNhbGwoZSwgdCkgJiYgTGEoaSwgdCwgZVt0XSk7XG4gIHJldHVybiBpO1xufTtcbmNsYXNzIG12IGV4dGVuZHMgVW0ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSksIHRoaXMucHJvdG9jb2wgPSBcIndjXCIsIHRoaXMudmVyc2lvbiA9IDIsIHRoaXMuZXZlbnRzID0gbmV3IFdlLkV2ZW50RW1pdHRlcigpLCB0aGlzLm5hbWUgPSB6MCwgdGhpcy50cmFuc3BvcnRFeHBsaWNpdGx5Q2xvc2VkID0gITEsIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5yZWNvbm5lY3RpbmcgPSAhMSwgdGhpcy5jb25uZWN0aW9uU3RhdHVzUG9sbGluZ0ludGVydmFsID0gMjAsIHRoaXMuc3RhbGVDb25uZWN0aW9uRXJyb3JzID0gW1wic29ja2V0IGhhbmcgdXBcIiwgXCJzb2NrZXQgc3RhbGxlZFwiXSwgdGhpcy5yZXF1ZXN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiUHVibGlzaGluZyBSZXF1ZXN0IFBheWxvYWRcIik7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50b0VzdGFibGlzaENvbm5lY3Rpb24oKSwgYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHQpO1xuICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkZhaWxlZCB0byBQdWJsaXNoIFJlcXVlc3RcIiksIHRoaXMubG9nZ2VyLmVycm9yKHMpLCBzO1xuICAgICAgfVxuICAgIH0sIHRoaXMuY29yZSA9IGUuY29yZSwgdGhpcy5sb2dnZXIgPSB0eXBlb2YgZS5sb2dnZXIgPCBcInVcIiAmJiB0eXBlb2YgZS5sb2dnZXIgIT0gXCJzdHJpbmdcIiA/IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIoZS5sb2dnZXIsIHRoaXMubmFtZSkgOiBlZS5waW5vKGVlLmdldERlZmF1bHRMb2dnZXJPcHRpb25zKHsgbGV2ZWw6IGUubG9nZ2VyIHx8IGowIH0pKSwgdGhpcy5tZXNzYWdlcyA9IG5ldyBydih0aGlzLmxvZ2dlciwgZS5jb3JlKSwgdGhpcy5zdWJzY3JpYmVyID0gbmV3IGR2KHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy5wdWJsaXNoZXIgPSBuZXcgbnYodGhpcywgdGhpcy5sb2dnZXIpLCB0aGlzLnJlbGF5VXJsID0gZT8ucmVsYXlVcmwgfHwgcWgsIHRoaXMucHJvamVjdElkID0gZS5wcm9qZWN0SWQsIHRoaXMucHJvdmlkZXIgPSB7fTtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIiksIGF3YWl0IHRoaXMuY3JlYXRlUHJvdmlkZXIoKSwgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMubWVzc2FnZXMuaW5pdCgpLCB0aGlzLnRyYW5zcG9ydE9wZW4oKSwgdGhpcy5zdWJzY3JpYmVyLmluaXQoKV0pLCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwLCBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlci50b3BpY3MubGVuZ3RoID09PSAwICYmICh0aGlzLmxvZ2dlci5pbmZvKFwiTm8gdG9waWNzIHN1YnNjcmlidGVkIHRvIGFmdGVyIGluaXQsIGNsb3NpbmcgdHJhbnNwb3J0XCIpLCBhd2FpdCB0aGlzLnRyYW5zcG9ydENsb3NlKCksIHRoaXMudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZCA9ICExKTtcbiAgICB9LCBrMCk7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY29ubmVjdGlvbi5jb25uZWN0ZWQ7XG4gIH1cbiAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY29ubmVjdGlvbi5jb25uZWN0aW5nO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZSwgdCwgcykge1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKGUsIHQsIHMpLCBhd2FpdCB0aGlzLnJlY29yZE1lc3NhZ2VFdmVudCh7IHRvcGljOiBlLCBtZXNzYWdlOiB0LCBwdWJsaXNoZWRBdDogRGF0ZS5ub3coKSB9KTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUoZSwgdCkge1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgIGxldCBzID0gXCJcIjtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoW25ldyBQcm9taXNlKChyKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmliZXIub25jZShCdC5jcmVhdGVkLCAobikgPT4ge1xuICAgICAgICBuLnRvcGljID09PSBlICYmIHIoKTtcbiAgICAgIH0pO1xuICAgIH0pLCBuZXcgUHJvbWlzZShhc3luYyAocikgPT4ge1xuICAgICAgcyA9IGF3YWl0IHRoaXMuc3Vic2NyaWJlci5zdWJzY3JpYmUoZSwgdCksIHIoKTtcbiAgICB9KV0pLCBzO1xuICB9XG4gIGFzeW5jIHVuc3Vic2NyaWJlKGUsIHQpIHtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5zdWJzY3JpYmVyLnVuc3Vic2NyaWJlKGUsIHQpO1xuICB9XG4gIG9uKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vbihlLCB0KTtcbiAgfVxuICBvbmNlKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vbmNlKGUsIHQpO1xuICB9XG4gIG9mZihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMub2ZmKGUsIHQpO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVyKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihlLCB0KTtcbiAgfVxuICBhc3luYyB0cmFuc3BvcnRDbG9zZSgpIHtcbiAgICB0aGlzLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQgPSAhMCwgdGhpcy5jb25uZWN0ZWQgJiYgKGF3YWl0IHRoaXMucHJvdmlkZXIuZGlzY29ubmVjdCgpLCB0aGlzLmV2ZW50cy5lbWl0KEhlLnRyYW5zcG9ydF9jbG9zZWQpKTtcbiAgfVxuICBhc3luYyB0cmFuc3BvcnRPcGVuKGUpIHtcbiAgICBpZiAodGhpcy50cmFuc3BvcnRFeHBsaWNpdGx5Q2xvc2VkID0gITEsICF0aGlzLnJlY29ubmVjdGluZykge1xuICAgICAgdGhpcy5yZWxheVVybCA9IGUgfHwgdGhpcy5yZWxheVVybCwgdGhpcy5yZWNvbm5lY3RpbmcgPSAhMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgdCgpLCB0aGlzLnN1YnNjcmliZXIub25jZShCdC5yZXN1YnNjcmliZWQsICgpID0+IHtcbiAgICAgICAgICAgIHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGF3YWl0IFByb21pc2UucmFjZShbbmV3IFByb21pc2UoYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgICAgICBhd2FpdCBlcih0aGlzLnByb3ZpZGVyLmNvbm5lY3QoKSwgNWUzLCBcInNvY2tldCBzdGFsbGVkXCIpLmNhdGNoKChyKSA9PiBzKHIpKS50aGVuKCgpID0+IHQoKSkuZmluYWxseSgoKSA9PiB0aGlzLnJlbW92ZUxpc3RlbmVyKEhlLnRyYW5zcG9ydF9jbG9zZWQsIHRoaXMucmVqZWN0VHJhbnNwb3J0T3BlbikpO1xuICAgICAgICB9KSwgbmV3IFByb21pc2UoKHQpID0+IHRoaXMub25jZShIZS50cmFuc3BvcnRfY2xvc2VkLCB0aGlzLnJlamVjdFRyYW5zcG9ydE9wZW4pKV0pXSk7XG4gICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKHQpO1xuICAgICAgICBjb25zdCBzID0gdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGlvblN0YWxsZWQocy5tZXNzYWdlKSlcbiAgICAgICAgICB0aHJvdyB0O1xuICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KEhlLnRyYW5zcG9ydF9jbG9zZWQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSAhMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVzdGFydFRyYW5zcG9ydChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRFeHBsaWNpdGx5Q2xvc2VkIHx8ICh0aGlzLnJlbGF5VXJsID0gZSB8fCB0aGlzLnJlbGF5VXJsLCB0aGlzLmNvbm5lY3RlZCAmJiBhd2FpdCBQcm9taXNlLmFsbChbbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICAgIHRoaXMucHJvdmlkZXIub25jZShpcy5kaXNjb25uZWN0LCAoKSA9PiB7XG4gICAgICAgIHQoKTtcbiAgICAgIH0pO1xuICAgIH0pLCB0aGlzLnRyYW5zcG9ydENsb3NlKCldKSwgYXdhaXQgdGhpcy5jcmVhdGVQcm92aWRlcigpLCBhd2FpdCB0aGlzLnRyYW5zcG9ydE9wZW4oKSk7XG4gIH1cbiAgaXNDb25uZWN0aW9uU3RhbGxlZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhbGVDb25uZWN0aW9uRXJyb3JzLnNvbWUoKHQpID0+IGUuaW5jbHVkZXModCkpO1xuICB9XG4gIHJlamVjdFRyYW5zcG9ydE9wZW4oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2xvc2VUcmFuc3BvcnQgY2FsbGVkIGJlZm9yZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZFwiKTtcbiAgfVxuICBhc3luYyBjcmVhdGVQcm92aWRlcigpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5jb3JlLmNyeXB0by5zaWduSldUKHRoaXMucmVsYXlVcmwpO1xuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgX24obmV3IFdjKG1iKHsgc2RrVmVyc2lvbjogQjAsIHByb3RvY29sOiB0aGlzLnByb3RvY29sLCB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sIHJlbGF5VXJsOiB0aGlzLnJlbGF5VXJsLCBwcm9qZWN0SWQ6IHRoaXMucHJvamVjdElkLCBhdXRoOiBlLCB1c2VPbkNsb3NlRXZlbnQ6ICEwIH0pKSksIHRoaXMucmVnaXN0ZXJQcm92aWRlckxpc3RlbmVycygpO1xuICB9XG4gIGFzeW5jIHJlY29yZE1lc3NhZ2VFdmVudChlKSB7XG4gICAgY29uc3QgeyB0b3BpYzogdCwgbWVzc2FnZTogcyB9ID0gZTtcbiAgICBhd2FpdCB0aGlzLm1lc3NhZ2VzLnNldCh0LCBzKTtcbiAgfVxuICBhc3luYyBzaG91bGRJZ25vcmVNZXNzYWdlRXZlbnQoZSkge1xuICAgIGNvbnN0IHsgdG9waWM6IHQsIG1lc3NhZ2U6IHMgfSA9IGU7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc3Vic2NyaWJlci5pc1N1YnNjcmliZWQodCkgPyB0aGlzLm1lc3NhZ2VzLmhhcyh0LCBzKSA6ICEwO1xuICB9XG4gIGFzeW5jIG9uUHJvdmlkZXJQYXlsb2FkKGUpIHtcbiAgICBpZiAodGhpcy5sb2dnZXIuZGVidWcoXCJJbmNvbWluZyBSZWxheSBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwicGF5bG9hZFwiLCBkaXJlY3Rpb246IFwiaW5jb21pbmdcIiwgcGF5bG9hZDogZSB9KSwgamkoZSkpIHtcbiAgICAgIGlmICghZS5tZXRob2QuZW5kc1dpdGgoSzApKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB0ID0gZS5wYXJhbXMsIHsgdG9waWM6IHMsIG1lc3NhZ2U6IHIsIHB1Ymxpc2hlZEF0OiBuIH0gPSB0LmRhdGEsIG8gPSB7IHRvcGljOiBzLCBtZXNzYWdlOiByLCBwdWJsaXNoZWRBdDogbiB9O1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJFbWl0dGluZyBSZWxheWVyIFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHl2KHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdC5pZCB9LCBvKSksIHRoaXMuZXZlbnRzLmVtaXQodC5pZCwgbyksIGF3YWl0IHRoaXMuYWNrbm93bGVkZ2VQYXlsb2FkKGUpLCBhd2FpdCB0aGlzLm9uTWVzc2FnZUV2ZW50KG8pO1xuICAgIH0gZWxzZVxuICAgICAgT2koZSkgJiYgdGhpcy5ldmVudHMuZW1pdChIZS5tZXNzYWdlX2FjaywgZSk7XG4gIH1cbiAgYXN5bmMgb25NZXNzYWdlRXZlbnQoZSkge1xuICAgIGF3YWl0IHRoaXMuc2hvdWxkSWdub3JlTWVzc2FnZUV2ZW50KGUpIHx8ICh0aGlzLmV2ZW50cy5lbWl0KEhlLm1lc3NhZ2UsIGUpLCBhd2FpdCB0aGlzLnJlY29yZE1lc3NhZ2VFdmVudChlKSk7XG4gIH1cbiAgYXN5bmMgYWNrbm93bGVkZ2VQYXlsb2FkKGUpIHtcbiAgICBjb25zdCB0ID0geGkoZS5pZCwgITApO1xuICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuY29ubmVjdGlvbi5zZW5kKHQpO1xuICB9XG4gIHJlZ2lzdGVyUHJvdmlkZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5wcm92aWRlci5vbihpcy5wYXlsb2FkLCAoZSkgPT4gdGhpcy5vblByb3ZpZGVyUGF5bG9hZChlKSksIHRoaXMucHJvdmlkZXIub24oaXMuY29ubmVjdCwgKCkgPT4ge1xuICAgICAgdGhpcy5ldmVudHMuZW1pdChIZS5jb25uZWN0KTtcbiAgICB9KSwgdGhpcy5wcm92aWRlci5vbihpcy5kaXNjb25uZWN0LCAoKSA9PiB7XG4gICAgICB0aGlzLm9uUHJvdmlkZXJEaXNjb25uZWN0KCk7XG4gICAgfSksIHRoaXMucHJvdmlkZXIub24oaXMuZXJyb3IsIChlKSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlKSwgdGhpcy5ldmVudHMuZW1pdChIZS5lcnJvciwgZSk7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmV2ZW50cy5vbihIZS5jb25uZWN0aW9uX3N0YWxsZWQsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRyYW5zcG9ydCgpO1xuICAgIH0pO1xuICB9XG4gIG9uUHJvdmlkZXJEaXNjb25uZWN0KCkge1xuICAgIHRoaXMuZXZlbnRzLmVtaXQoSGUuZGlzY29ubmVjdCksIHRoaXMuYXR0ZW1wdFRvUmVjb25uZWN0KCk7XG4gIH1cbiAgYXR0ZW1wdFRvUmVjb25uZWN0KCkge1xuICAgIHRoaXMudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZCB8fCBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRyYW5zcG9ydCgpO1xuICAgIH0sIFYudG9NaWxpc2Vjb25kcyhWMCkpO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IEooXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdG9Fc3RhYmxpc2hDb25uZWN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3RpbmcpXG4gICAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCAmJiAoY2xlYXJJbnRlcnZhbCh0KSwgZSgpKTtcbiAgICAgICAgICB9LCB0aGlzLmNvbm5lY3Rpb25TdGF0dXNQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxufVxudmFyIGJ2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBNYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIHd2ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgdnYgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBxYSA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBidihpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQsIGphID0gKGksIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIHd2LmNhbGwoZSwgdCkgJiYgcWEoaSwgdCwgZVt0XSk7XG4gIGlmIChNYSlcbiAgICBmb3IgKHZhciB0IG9mIE1hKGUpKVxuICAgICAgdnYuY2FsbChlLCB0KSAmJiBxYShpLCB0LCBlW3RdKTtcbiAgcmV0dXJuIGk7XG59O1xuY2xhc3MgcHIgZXh0ZW5kcyBMbSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMsIHIgPSB1aSwgbiA9IHZvaWQgMCkge1xuICAgIHN1cGVyKGUsIHQsIHMsIHIpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMubmFtZSA9IHMsIHRoaXMubWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy52ZXJzaW9uID0gSDAsIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zdG9yYWdlUHJlZml4ID0gdWksIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIiksIGF3YWl0IHRoaXMucmVzdG9yZSgpLCB0aGlzLmNhY2hlZC5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIHRoaXMuZ2V0S2V5ICYmIG8gIT09IG51bGwgJiYgIXd0KG8pID8gdGhpcy5tYXAuc2V0KHRoaXMuZ2V0S2V5KG8pLCBvKSA6IHFiKG8pID8gdGhpcy5tYXAuc2V0KG8uaWQsIG8pIDogamIobykgJiYgdGhpcy5tYXAuc2V0KG8udG9waWMsIG8pO1xuICAgICAgfSksIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCk7XG4gICAgfSwgdGhpcy5zZXQgPSBhc3luYyAobywgYykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubWFwLmhhcyhvKSA/IGF3YWl0IHRoaXMudXBkYXRlKG8sIGMpIDogKHRoaXMubG9nZ2VyLmRlYnVnKFwiU2V0dGluZyB2YWx1ZVwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic2V0XCIsIGtleTogbywgdmFsdWU6IGMgfSksIHRoaXMubWFwLnNldChvLCBjKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCkpO1xuICAgIH0sIHRoaXMuZ2V0ID0gKG8pID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJHZXR0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJnZXRcIiwga2V5OiBvIH0pLCB0aGlzLmdldERhdGEobykpLCB0aGlzLmdldEFsbCA9IChvKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIG8gPyB0aGlzLnZhbHVlcy5maWx0ZXIoKGMpID0+IE9iamVjdC5rZXlzKG8pLmV2ZXJ5KCh1KSA9PiBZYyhjW3VdLCBvW3VdKSkpIDogdGhpcy52YWx1ZXMpLCB0aGlzLnVwZGF0ZSA9IGFzeW5jIChvLCBjKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJVcGRhdGluZyB2YWx1ZVwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwidXBkYXRlXCIsIGtleTogbywgdXBkYXRlOiBjIH0pO1xuICAgICAgY29uc3QgdSA9IGphKGphKHt9LCB0aGlzLmdldERhdGEobykpLCBjKTtcbiAgICAgIHRoaXMubWFwLnNldChvLCB1KSwgYXdhaXQgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSwgdGhpcy5kZWxldGUgPSBhc3luYyAobywgYykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubWFwLmhhcyhvKSAmJiAodGhpcy5sb2dnZXIuZGVidWcoXCJEZWxldGluZyB2YWx1ZVwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwiZGVsZXRlXCIsIGtleTogbywgcmVhc29uOiBjIH0pLCB0aGlzLm1hcC5kZWxldGUobyksIGF3YWl0IHRoaXMucGVyc2lzdCgpKTtcbiAgICB9LCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy5zdG9yYWdlUHJlZml4ID0gciwgdGhpcy5nZXRLZXkgPSBuO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgXCIvL1wiICsgdGhpcy5uYW1lO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLnNpemU7XG4gIH1cbiAgZ2V0IGtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAua2V5cygpKTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWFwLnZhbHVlcygpKTtcbiAgfVxuICBhc3luYyBzZXREYXRhU3RvcmUoZSkge1xuICAgIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBlKTtcbiAgfVxuICBhc3luYyBnZXREYXRhU3RvcmUoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgfVxuICBnZXREYXRhKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5tYXAuZ2V0KGUpO1xuICAgIGlmICghdCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBzIH0gPSBKKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGAke3RoaXMubmFtZX06ICR7ZX1gKTtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHMpLCBuZXcgRXJyb3Iocyk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIGFzeW5jIHBlcnNpc3QoKSB7XG4gICAgYXdhaXQgdGhpcy5zZXREYXRhU3RvcmUodGhpcy52YWx1ZXMpO1xuICB9XG4gIGFzeW5jIHJlc3RvcmUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmdldERhdGFTdG9yZSgpO1xuICAgICAgaWYgKHR5cGVvZiBlID4gXCJ1XCIgfHwgIWUubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5tYXAuc2l6ZSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJSRVNUT1JFX1dJTExfT1ZFUlJJREVcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3IodCksIG5ldyBFcnJvcih0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGVkID0gZSwgdGhpcy5sb2dnZXIuZGVidWcoYFN1Y2Nlc3NmdWxseSBSZXN0b3JlZCB2YWx1ZSBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInJlc3RvcmVcIiwgdmFsdWU6IHRoaXMudmFsdWVzIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gUmVzdG9yZSB2YWx1ZSBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBKKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBfdiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMubmFtZSA9IEowLCB0aGlzLnZlcnNpb24gPSBRMCwgdGhpcy5ldmVudHMgPSBuZXcgaXIoKSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSB1aSwgdGhpcy5pZ25vcmVkUGF5bG9hZFR5cGVzID0gW05pXSwgdGhpcy5yZWdpc3RlcmVkTWV0aG9kcyA9IFtdLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8IChhd2FpdCB0aGlzLnBhaXJpbmdzLmluaXQoKSwgYXdhaXQgdGhpcy5jbGVhbnVwKCksIHRoaXMucmVnaXN0ZXJSZWxheWVyRXZlbnRzKCksIHRoaXMucmVnaXN0ZXJFeHBpcmVyRXZlbnRzKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCwgdGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSk7XG4gICAgfSwgdGhpcy5yZWdpc3RlciA9ICh7IG1ldGhvZHM6IHMgfSkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMucmVnaXN0ZXJlZE1ldGhvZHMgPSBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRoaXMucmVnaXN0ZXJlZE1ldGhvZHMsIC4uLnNdKV07XG4gICAgfSwgdGhpcy5jcmVhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHMgPSBYcigpLCByID0gYXdhaXQgdGhpcy5jb3JlLmNyeXB0by5zZXRTeW1LZXkocyksIG4gPSBIdChWLkZJVkVfTUlOVVRFUyksIG8gPSB7IHByb3RvY29sOiBNaCB9LCBjID0geyB0b3BpYzogciwgZXhwaXJ5OiBuLCByZWxheTogbywgYWN0aXZlOiAhMSB9LCB1ID0gUGIoeyBwcm90b2NvbDogdGhpcy5jb3JlLnByb3RvY29sLCB2ZXJzaW9uOiB0aGlzLmNvcmUudmVyc2lvbiwgdG9waWM6IHIsIHN5bUtleTogcywgcmVsYXk6IG8gfSk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5wYWlyaW5ncy5zZXQociwgYyksIGF3YWl0IHRoaXMuY29yZS5yZWxheWVyLnN1YnNjcmliZShyKSwgdGhpcy5jb3JlLmV4cGlyZXIuc2V0KHIsIG4pLCB7IHRvcGljOiByLCB1cmk6IHUgfTtcbiAgICB9LCB0aGlzLnBhaXIgPSBhc3luYyAocykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMuaXNWYWxpZFBhaXIocyk7XG4gICAgICBjb25zdCB7IHRvcGljOiByLCBzeW1LZXk6IG4sIHJlbGF5OiBvIH0gPSB4YihzLnVyaSk7XG4gICAgICBpZiAodGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhaXJpbmcgYWxyZWFkeSBleGlzdHM6ICR7cn1gKTtcbiAgICAgIGlmICh0aGlzLmNvcmUuY3J5cHRvLmhhc0tleXMocikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5Y2hhaW4gYWxyZWFkeSBleGlzdHM6ICR7cn1gKTtcbiAgICAgIGNvbnN0IGMgPSBIdChWLkZJVkVfTUlOVVRFUyksIHUgPSB7IHRvcGljOiByLCByZWxheTogbywgZXhwaXJ5OiBjLCBhY3RpdmU6ICExIH07XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5wYWlyaW5ncy5zZXQociwgdSksIGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uc2V0U3ltS2V5KG4sIHIpLCBhd2FpdCB0aGlzLmNvcmUucmVsYXllci5zdWJzY3JpYmUociwgeyByZWxheTogbyB9KSwgdGhpcy5jb3JlLmV4cGlyZXIuc2V0KHIsIGMpLCBzLmFjdGl2YXRlUGFpcmluZyAmJiBhd2FpdCB0aGlzLmFjdGl2YXRlKHsgdG9waWM6IHIgfSksIHU7XG4gICAgfSwgdGhpcy5hY3RpdmF0ZSA9IGFzeW5jICh7IHRvcGljOiBzIH0pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgciA9IEh0KFYuVEhJUlRZX0RBWVMpO1xuICAgICAgYXdhaXQgdGhpcy5wYWlyaW5ncy51cGRhdGUocywgeyBhY3RpdmU6ICEwLCBleHBpcnk6IHIgfSksIHRoaXMuY29yZS5leHBpcmVyLnNldChzLCByKTtcbiAgICB9LCB0aGlzLnBpbmcgPSBhc3luYyAocykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZFBpbmcocyk7XG4gICAgICBjb25zdCB7IHRvcGljOiByIH0gPSBzO1xuICAgICAgaWYgKHRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhyKSkge1xuICAgICAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChyLCBcIndjX3BhaXJpbmdQaW5nXCIsIHt9KSwgeyBkb25lOiBvLCByZXNvbHZlOiBjLCByZWplY3Q6IHUgfSA9IFRpKCk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uY2Uoa2UoXCJwYWlyaW5nX3BpbmdcIiwgbiksICh7IGVycm9yOiBkIH0pID0+IHtcbiAgICAgICAgICBkID8gdShkKSA6IGMoKTtcbiAgICAgICAgfSksIGF3YWl0IG8oKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnVwZGF0ZUV4cGlyeSA9IGFzeW5jICh7IHRvcGljOiBzLCBleHBpcnk6IHIgfSkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMucGFpcmluZ3MudXBkYXRlKHMsIHsgZXhwaXJ5OiByIH0pO1xuICAgIH0sIHRoaXMudXBkYXRlTWV0YWRhdGEgPSBhc3luYyAoeyB0b3BpYzogcywgbWV0YWRhdGE6IHIgfSkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMucGFpcmluZ3MudXBkYXRlKHMsIHsgcGVlck1ldGFkYXRhOiByIH0pO1xuICAgIH0sIHRoaXMuZ2V0UGFpcmluZ3MgPSAoKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMucGFpcmluZ3MudmFsdWVzKSwgdGhpcy5kaXNjb25uZWN0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWREaXNjb25uZWN0KHMpO1xuICAgICAgY29uc3QgeyB0b3BpYzogciB9ID0gcztcbiAgICAgIHRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhyKSAmJiAoYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChyLCBcIndjX3BhaXJpbmdEZWxldGVcIiwgSmUoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIGF3YWl0IHRoaXMuZGVsZXRlUGFpcmluZyhyKSk7XG4gICAgfSwgdGhpcy5zZW5kUmVxdWVzdCA9IGFzeW5jIChzLCByLCBuKSA9PiB7XG4gICAgICBjb25zdCBvID0gdGkociwgbiksIGMgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLmVuY29kZShzLCBvKSwgdSA9IHNzW3JdLnJlcTtcbiAgICAgIHJldHVybiB0aGlzLmNvcmUuaGlzdG9yeS5zZXQocywgbyksIHRoaXMuY29yZS5yZWxheWVyLnB1Ymxpc2gocywgYywgdSksIG8uaWQ7XG4gICAgfSwgdGhpcy5zZW5kUmVzdWx0ID0gYXN5bmMgKHMsIHIsIG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSB4aShzLCBuKSwgYyA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uZW5jb2RlKHIsIG8pLCB1ID0gYXdhaXQgdGhpcy5jb3JlLmhpc3RvcnkuZ2V0KHIsIHMpLCBkID0gc3NbdS5yZXF1ZXN0Lm1ldGhvZF0ucmVzO1xuICAgICAgYXdhaXQgdGhpcy5jb3JlLnJlbGF5ZXIucHVibGlzaChyLCBjLCBkKSwgYXdhaXQgdGhpcy5jb3JlLmhpc3RvcnkucmVzb2x2ZShvKTtcbiAgICB9LCB0aGlzLnNlbmRFcnJvciA9IGFzeW5jIChzLCByLCBuKSA9PiB7XG4gICAgICBjb25zdCBvID0gcWkocywgbiksIGMgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLmVuY29kZShyLCBvKSwgdSA9IGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LmdldChyLCBzKSwgZCA9IHNzW3UucmVxdWVzdC5tZXRob2RdID8gc3NbdS5yZXF1ZXN0Lm1ldGhvZF0ucmVzIDogc3MudW5yZWdpc3RlcmVkX21ldGhvZC5yZXM7XG4gICAgICBhd2FpdCB0aGlzLmNvcmUucmVsYXllci5wdWJsaXNoKHIsIGMsIGQpLCBhd2FpdCB0aGlzLmNvcmUuaGlzdG9yeS5yZXNvbHZlKG8pO1xuICAgIH0sIHRoaXMuZGVsZXRlUGFpcmluZyA9IGFzeW5jIChzLCByKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmNvcmUucmVsYXllci51bnN1YnNjcmliZShzKSwgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGFpcmluZ3MuZGVsZXRlKHMsIEplKFwiVVNFUl9ESVNDT05ORUNURURcIikpLCB0aGlzLmNvcmUuY3J5cHRvLmRlbGV0ZVN5bUtleShzKSwgciA/IFByb21pc2UucmVzb2x2ZSgpIDogdGhpcy5jb3JlLmV4cGlyZXIuZGVsKHMpXSk7XG4gICAgfSwgdGhpcy5jbGVhbnVwID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcyA9IHRoaXMucGFpcmluZ3MuZ2V0QWxsKCkuZmlsdGVyKChyKSA9PiBjaShyLmV4cGlyeSkpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocy5tYXAoKHIpID0+IHRoaXMuZGVsZXRlUGFpcmluZyhyLnRvcGljKSkpO1xuICAgIH0sIHRoaXMub25SZWxheUV2ZW50UmVxdWVzdCA9IChzKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiByLCBwYXlsb2FkOiBuIH0gPSBzLCBvID0gbi5tZXRob2Q7XG4gICAgICBpZiAodGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHIpKVxuICAgICAgICBzd2l0Y2ggKG8pIHtcbiAgICAgICAgICBjYXNlIFwid2NfcGFpcmluZ1BpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uUGFpcmluZ1BpbmdSZXF1ZXN0KHIsIG4pO1xuICAgICAgICAgIGNhc2UgXCJ3Y19wYWlyaW5nRGVsZXRlXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vblBhaXJpbmdEZWxldGVSZXF1ZXN0KHIsIG4pO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vblVua25vd25ScGNNZXRob2RSZXF1ZXN0KHIsIG4pO1xuICAgICAgICB9XG4gICAgfSwgdGhpcy5vblJlbGF5RXZlbnRSZXNwb25zZSA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiByLCBwYXlsb2FkOiBuIH0gPSBzLCBvID0gKGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LmdldChyLCBuLmlkKSkucmVxdWVzdC5tZXRob2Q7XG4gICAgICBpZiAodGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHIpKVxuICAgICAgICBzd2l0Y2ggKG8pIHtcbiAgICAgICAgICBjYXNlIFwid2NfcGFpcmluZ1BpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uUGFpcmluZ1BpbmdSZXNwb25zZShyLCBuKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25Vbmtub3duUnBjTWV0aG9kUmVzcG9uc2Uobyk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzLm9uUGFpcmluZ1BpbmdSZXF1ZXN0ID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IG4gfSA9IHI7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRQaW5nKHsgdG9waWM6IHMgfSksIGF3YWl0IHRoaXMuc2VuZFJlc3VsdChuLCBzLCAhMCksIHRoaXMuZXZlbnRzLmVtaXQoXCJwYWlyaW5nX3BpbmdcIiwgeyBpZDogbiwgdG9waWM6IHMgfSk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHMsIG8pLCB0aGlzLmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uUGFpcmluZ1BpbmdSZXNwb25zZSA9IChzLCByKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBuIH0gPSByO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGh0KHIpID8gdGhpcy5ldmVudHMuZW1pdChrZShcInBhaXJpbmdfcGluZ1wiLCBuKSwge30pIDogR2UocikgJiYgdGhpcy5ldmVudHMuZW1pdChrZShcInBhaXJpbmdfcGluZ1wiLCBuKSwgeyBlcnJvcjogci5lcnJvciB9KTtcbiAgICAgIH0sIDUwMCk7XG4gICAgfSwgdGhpcy5vblBhaXJpbmdEZWxldGVSZXF1ZXN0ID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IG4gfSA9IHI7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWREaXNjb25uZWN0KHsgdG9waWM6IHMgfSksIGF3YWl0IHRoaXMuZGVsZXRlUGFpcmluZyhzKSwgdGhpcy5ldmVudHMuZW1pdChcInBhaXJpbmdfZGVsZXRlXCIsIHsgaWQ6IG4sIHRvcGljOiBzIH0pO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihuLCBzLCBvKSwgdGhpcy5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblVua25vd25ScGNNZXRob2RSZXF1ZXN0ID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IG4sIG1ldGhvZDogbyB9ID0gcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRNZXRob2RzLmluY2x1ZGVzKG8pKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYyA9IEplKFwiV0NfTUVUSE9EX1VOU1VQUE9SVEVEXCIsIG8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihuLCBzLCBjKSwgdGhpcy5sb2dnZXIuZXJyb3IoYyk7XG4gICAgICB9IGNhdGNoIChjKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHMsIGMpLCB0aGlzLmxvZ2dlci5lcnJvcihjKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uVW5rbm93blJwY01ldGhvZFJlc3BvbnNlID0gKHMpID0+IHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZE1ldGhvZHMuaW5jbHVkZXMocykgfHwgdGhpcy5sb2dnZXIuZXJyb3IoSmUoXCJXQ19NRVRIT0RfVU5TVVBQT1JURURcIiwgcykpO1xuICAgIH0sIHRoaXMuaXNWYWxpZFBhaXIgPSAocykgPT4ge1xuICAgICAgaWYgKCFJdChzKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHBhaXIoKSBwYXJhbXM6ICR7c31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHIpO1xuICAgICAgfVxuICAgICAgaWYgKCFNYihzLnVyaSkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwYWlyKCkgdXJpOiAke3MudXJpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkUGluZyA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBpZiAoIUl0KHMpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcGluZygpIHBhcmFtczogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiByIH0gPSBzO1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkUGFpcmluZ1RvcGljKHIpO1xuICAgIH0sIHRoaXMuaXNWYWxpZERpc2Nvbm5lY3QgPSBhc3luYyAocykgPT4ge1xuICAgICAgaWYgKCFJdChzKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGRpc2Nvbm5lY3QoKSBwYXJhbXM6ICR7c31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogciB9ID0gcztcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFBhaXJpbmdUb3BpYyhyKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRQYWlyaW5nVG9waWMgPSBhc3luYyAocykgPT4ge1xuICAgICAgaWYgKCFhdChzLCAhMSkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwYWlyaW5nIHRvcGljIHNob3VsZCBiZSBhIHN0cmluZzogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhzKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IEooXCJOT19NQVRDSElOR19LRVlcIiwgYHBhaXJpbmcgdG9waWMgZG9lc24ndCBleGlzdDogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgICBpZiAoY2kodGhpcy5wYWlyaW5ncy5nZXQocykuZXhwaXJ5KSkge1xuICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZVBhaXJpbmcocyk7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gSihcIkVYUElSRURcIiwgYHBhaXJpbmcgdG9waWM6ICR7c31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHIpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLnBhaXJpbmdzID0gbmV3IHByKHRoaXMuY29yZSwgdGhpcy5sb2dnZXIsIHRoaXMubmFtZSwgdGhpcy5zdG9yYWdlUHJlZml4KTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gSihcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlclJlbGF5ZXJFdmVudHMoKSB7XG4gICAgdGhpcy5jb3JlLnJlbGF5ZXIub24oSGUubWVzc2FnZSwgYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHQsIG1lc3NhZ2U6IHMgfSA9IGU7XG4gICAgICBpZiAodGhpcy5pZ25vcmVkUGF5bG9hZFR5cGVzLmluY2x1ZGVzKHRoaXMuY29yZS5jcnlwdG8uZ2V0UGF5bG9hZFR5cGUocykpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5jb3JlLmNyeXB0by5kZWNvZGUodCwgcyk7XG4gICAgICBqaShyKSA/ICh0aGlzLmNvcmUuaGlzdG9yeS5zZXQodCwgciksIHRoaXMub25SZWxheUV2ZW50UmVxdWVzdCh7IHRvcGljOiB0LCBwYXlsb2FkOiByIH0pKSA6IE9pKHIpICYmIChhd2FpdCB0aGlzLmNvcmUuaGlzdG9yeS5yZXNvbHZlKHIpLCB0aGlzLm9uUmVsYXlFdmVudFJlc3BvbnNlKHsgdG9waWM6IHQsIHBheWxvYWQ6IHIgfSkpO1xuICAgIH0pO1xuICB9XG4gIHJlZ2lzdGVyRXhwaXJlckV2ZW50cygpIHtcbiAgICB0aGlzLmNvcmUuZXhwaXJlci5vbigkdC5leHBpcmVkLCBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogdCB9ID0gU2goZS50YXJnZXQpO1xuICAgICAgdCAmJiB0aGlzLnBhaXJpbmdzLmtleXMuaW5jbHVkZXModCkgJiYgKGF3YWl0IHRoaXMuZGVsZXRlUGFpcmluZyh0LCAhMCksIHRoaXMuZXZlbnRzLmVtaXQoXCJwYWlyaW5nX2V4cGlyZVwiLCB7IHRvcGljOiB0IH0pKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRXYgZXh0ZW5kcyBUbSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLnJlY29yZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5uYW1lID0gWDAsIHRoaXMudmVyc2lvbiA9IFowLCB0aGlzLmNhY2hlZCA9IFtdLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuc3RvcmFnZVByZWZpeCA9IHVpLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8ICh0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpLCBhd2FpdCB0aGlzLnJlc3RvcmUoKSwgdGhpcy5jYWNoZWQuZm9yRWFjaCgocykgPT4gdGhpcy5yZWNvcmRzLnNldChzLmlkLCBzKSksIHRoaXMuY2FjaGVkID0gW10sIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLmluaXRpYWxpemVkID0gITApO1xuICAgIH0sIHRoaXMuc2V0ID0gKHMsIHIsIG4pID0+IHtcbiAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJTZXR0aW5nIEpTT04tUlBDIHJlcXVlc3QgaGlzdG9yeSByZWNvcmRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInNldFwiLCB0b3BpYzogcywgcmVxdWVzdDogciwgY2hhaW5JZDogbiB9KSwgdGhpcy5yZWNvcmRzLmhhcyhyLmlkKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbyA9IHsgaWQ6IHIuaWQsIHRvcGljOiBzLCByZXF1ZXN0OiB7IG1ldGhvZDogci5tZXRob2QsIHBhcmFtczogci5wYXJhbXMgfHwgbnVsbCB9LCBjaGFpbklkOiBuIH07XG4gICAgICB0aGlzLnJlY29yZHMuc2V0KG8uaWQsIG8pLCB0aGlzLmV2ZW50cy5lbWl0KEt0LmNyZWF0ZWQsIG8pO1xuICAgIH0sIHRoaXMucmVzb2x2ZSA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubG9nZ2VyLmRlYnVnKFwiVXBkYXRpbmcgSlNPTi1SUEMgcmVzcG9uc2UgaGlzdG9yeSByZWNvcmRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInVwZGF0ZVwiLCByZXNwb25zZTogcyB9KSwgIXRoaXMucmVjb3Jkcy5oYXMocy5pZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmdldFJlY29yZChzLmlkKTtcbiAgICAgIHR5cGVvZiByLnJlc3BvbnNlID4gXCJ1XCIgJiYgKHIucmVzcG9uc2UgPSBHZShzKSA/IHsgZXJyb3I6IHMuZXJyb3IgfSA6IHsgcmVzdWx0OiBzLnJlc3VsdCB9LCB0aGlzLnJlY29yZHMuc2V0KHIuaWQsIHIpLCB0aGlzLmV2ZW50cy5lbWl0KEt0LnVwZGF0ZWQsIHIpKTtcbiAgICB9LCB0aGlzLmdldCA9IGFzeW5jIChzLCByKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubG9nZ2VyLmRlYnVnKFwiR2V0dGluZyByZWNvcmRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImdldFwiLCB0b3BpYzogcywgaWQ6IHIgfSksIGF3YWl0IHRoaXMuZ2V0UmVjb3JkKHIpKSwgdGhpcy5kZWxldGUgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubG9nZ2VyLmRlYnVnKFwiRGVsZXRpbmcgcmVjb3JkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJkZWxldGVcIiwgaWQ6IHIgfSksIHRoaXMudmFsdWVzLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgaWYgKG4udG9waWMgPT09IHMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHIgPCBcInVcIiAmJiBuLmlkICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHRoaXMucmVjb3Jkcy5kZWxldGUobi5pZCksIHRoaXMuZXZlbnRzLmVtaXQoS3QuZGVsZXRlZCwgbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHRoaXMuZXhpc3RzID0gYXN5bmMgKHMsIHIpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5yZWNvcmRzLmhhcyhyKSA/IChhd2FpdCB0aGlzLmdldFJlY29yZChyKSkudG9waWMgPT09IHMgOiAhMSksIHRoaXMub24gPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub24ocywgcik7XG4gICAgfSwgdGhpcy5vbmNlID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uY2Uocywgcik7XG4gICAgfSwgdGhpcy5vZmYgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub2ZmKHMsIHIpO1xuICAgIH0sIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIocywgcik7XG4gICAgfSwgdGhpcy5sb2dnZXIgPSBlZS5nZW5lcmF0ZUNoaWxkTG9nZ2VyKHQsIHRoaXMubmFtZSk7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBzdG9yYWdlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcmVmaXggKyB0aGlzLnZlcnNpb24gKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb3Jkcy5zaXplO1xuICB9XG4gIGdldCBrZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVjb3Jkcy5rZXlzKCkpO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWNvcmRzLnZhbHVlcygpKTtcbiAgfVxuICBnZXQgcGVuZGluZygpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdC5yZXNwb25zZSA8IFwidVwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBzID0geyB0b3BpYzogdC50b3BpYywgcmVxdWVzdDogdGkodC5yZXF1ZXN0Lm1ldGhvZCwgdC5yZXF1ZXN0LnBhcmFtcywgdC5pZCksIGNoYWluSWQ6IHQuY2hhaW5JZCB9O1xuICAgICAgcmV0dXJuIGUucHVzaChzKTtcbiAgICB9KSwgZTtcbiAgfVxuICBhc3luYyBzZXRKc29uUnBjUmVjb3JkcyhlKSB7XG4gICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIGUpO1xuICB9XG4gIGFzeW5jIGdldEpzb25ScGNSZWNvcmRzKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gIH1cbiAgZ2V0UmVjb3JkKGUpIHtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5yZWNvcmRzLmdldChlKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogcyB9ID0gSihcIk5PX01BVENISU5HX0tFWVwiLCBgJHt0aGlzLm5hbWV9OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iocyk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIGFzeW5jIHBlcnNpc3QoKSB7XG4gICAgYXdhaXQgdGhpcy5zZXRKc29uUnBjUmVjb3Jkcyh0aGlzLnZhbHVlcyksIHRoaXMuZXZlbnRzLmVtaXQoS3Quc3luYyk7XG4gIH1cbiAgYXN5bmMgcmVzdG9yZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuZ2V0SnNvblJwY1JlY29yZHMoKTtcbiAgICAgIGlmICh0eXBlb2YgZSA+IFwidVwiIHx8ICFlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMucmVjb3Jkcy5zaXplKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIlJFU1RPUkVfV0lMTF9PVkVSUklERVwiLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcih0KSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIHJlY29yZHMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJyZXN0b3JlXCIsIHJlY29yZHM6IHRoaXMudmFsdWVzIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gUmVzdG9yZSByZWNvcmRzIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5ldmVudHMub24oS3QuY3JlYXRlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBLdC5jcmVhdGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIHJlY29yZDogZSB9KSwgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSksIHRoaXMuZXZlbnRzLm9uKEt0LnVwZGF0ZWQsIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gS3QudXBkYXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCByZWNvcmQ6IGUgfSksIHRoaXMucGVyc2lzdCgpO1xuICAgIH0pLCB0aGlzLmV2ZW50cy5vbihLdC5kZWxldGVkLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IEt0LmRlbGV0ZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgcmVjb3JkOiBlIH0pLCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBKKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBTdiBleHRlbmRzIHFtIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMuZXhwaXJhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5uYW1lID0gZXYsIHRoaXMudmVyc2lvbiA9IHR2LCB0aGlzLmNhY2hlZCA9IFtdLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuc3RvcmFnZVByZWZpeCA9IHVpLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8ICh0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpLCBhd2FpdCB0aGlzLnJlc3RvcmUoKSwgdGhpcy5jYWNoZWQuZm9yRWFjaCgocykgPT4gdGhpcy5leHBpcmF0aW9ucy5zZXQocy50YXJnZXQsIHMpKSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCk7XG4gICAgfSwgdGhpcy5oYXMgPSAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuZm9ybWF0VGFyZ2V0KHMpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuZ2V0RXhwaXJhdGlvbihyKSA8IFwidVwiO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnNldCA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmZvcm1hdFRhcmdldChzKSwgbyA9IHsgdGFyZ2V0OiBuLCBleHBpcnk6IHIgfTtcbiAgICAgIHRoaXMuZXhwaXJhdGlvbnMuc2V0KG4sIG8pLCB0aGlzLmNoZWNrRXhwaXJ5KG4sIG8pLCB0aGlzLmV2ZW50cy5lbWl0KCR0LmNyZWF0ZWQsIHsgdGFyZ2V0OiBuLCBleHBpcmF0aW9uOiBvIH0pO1xuICAgIH0sIHRoaXMuZ2V0ID0gKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgciA9IHRoaXMuZm9ybWF0VGFyZ2V0KHMpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhwaXJhdGlvbihyKTtcbiAgICB9LCB0aGlzLmRlbCA9IChzKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMuaGFzKHMpKSB7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLmZvcm1hdFRhcmdldChzKSwgbiA9IHRoaXMuZ2V0RXhwaXJhdGlvbihyKTtcbiAgICAgICAgdGhpcy5leHBpcmF0aW9ucy5kZWxldGUociksIHRoaXMuZXZlbnRzLmVtaXQoJHQuZGVsZXRlZCwgeyB0YXJnZXQ6IHIsIGV4cGlyYXRpb246IG4gfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vbiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbihzLCByKTtcbiAgICB9LCB0aGlzLm9uY2UgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub25jZShzLCByKTtcbiAgICB9LCB0aGlzLm9mZiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vZmYocywgcik7XG4gICAgfSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihzLCByKTtcbiAgICB9LCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIFwiLy9cIiArIHRoaXMubmFtZTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGlyYXRpb25zLnNpemU7XG4gIH1cbiAgZ2V0IGtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5leHBpcmF0aW9ucy5rZXlzKCkpO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5leHBpcmF0aW9ucy52YWx1ZXMoKSk7XG4gIH1cbiAgZm9ybWF0VGFyZ2V0KGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBiYihlKTtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiB3YihlKTtcbiAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJVTktOT1dOX1RZUEVcIiwgYFRhcmdldCB0eXBlOiAke3R5cGVvZiBlfWApO1xuICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgfVxuICBhc3luYyBzZXRFeHBpcmF0aW9ucyhlKSB7XG4gICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIGUpO1xuICB9XG4gIGFzeW5jIGdldEV4cGlyYXRpb25zKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldEV4cGlyYXRpb25zKHRoaXMudmFsdWVzKSwgdGhpcy5ldmVudHMuZW1pdCgkdC5zeW5jKTtcbiAgfVxuICBhc3luYyByZXN0b3JlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5nZXRFeHBpcmF0aW9ucygpO1xuICAgICAgaWYgKHR5cGVvZiBlID4gXCJ1XCIgfHwgIWUubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5leHBpcmF0aW9ucy5zaXplKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIlJFU1RPUkVfV0lMTF9PVkVSUklERVwiLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcih0KSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIGV4cGlyYXRpb25zIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicmVzdG9yZVwiLCBleHBpcmF0aW9uczogdGhpcy52YWx1ZXMgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIGV4cGlyYXRpb25zIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGdldEV4cGlyYXRpb24oZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmV4cGlyYXRpb25zLmdldChlKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogcyB9ID0gSihcIk5PX01BVENISU5HX0tFWVwiLCBgJHt0aGlzLm5hbWV9OiAke2V9YCk7XG4gICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihzKSwgbmV3IEVycm9yKHMpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBjaGVja0V4cGlyeShlLCB0KSB7XG4gICAgY29uc3QgeyBleHBpcnk6IHMgfSA9IHQ7XG4gICAgVi50b01pbGlzZWNvbmRzKHMpIC0gRGF0ZS5ub3coKSA8PSAwICYmIHRoaXMuZXhwaXJlKGUsIHQpO1xuICB9XG4gIGV4cGlyZShlLCB0KSB7XG4gICAgdGhpcy5leHBpcmF0aW9ucy5kZWxldGUoZSksIHRoaXMuZXZlbnRzLmVtaXQoJHQuZXhwaXJlZCwgeyB0YXJnZXQ6IGUsIGV4cGlyYXRpb246IHQgfSk7XG4gIH1cbiAgY2hlY2tFeHBpcmF0aW9ucygpIHtcbiAgICB0aGlzLmNvcmUucmVsYXllci5jb25uZWN0ZWQgJiYgdGhpcy5leHBpcmF0aW9ucy5mb3JFYWNoKChlLCB0KSA9PiB0aGlzLmNoZWNrRXhwaXJ5KHQsIGUpKTtcbiAgfVxuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuY29yZS5oZWFydGJlYXQub24oV3QuSEVBUlRCRUFUX0VWRU5UUy5wdWxzZSwgKCkgPT4gdGhpcy5jaGVja0V4cGlyYXRpb25zKCkpLCB0aGlzLmV2ZW50cy5vbigkdC5jcmVhdGVkLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9ICR0LmNyZWF0ZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgZGF0YTogZSB9KSwgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSksIHRoaXMuZXZlbnRzLm9uKCR0LmV4cGlyZWQsIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gJHQuZXhwaXJlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCBkYXRhOiBlIH0pLCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KSwgdGhpcy5ldmVudHMub24oJHQuZGVsZXRlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSAkdC5kZWxldGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIGRhdGE6IGUgfSksIHRoaXMucGVyc2lzdCgpO1xuICAgIH0pO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IEooXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEl2IGV4dGVuZHMgam0ge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCksIHRoaXMucHJvamVjdElkID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLm5hbWUgPSBUciwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLmluaXQgPSBhc3luYyAocykgPT4ge1xuICAgICAgd2goKSB8fCAhTm4oKSB8fCAodGhpcy52ZXJpZnlVcmwgPSBzPy52ZXJpZnlVcmwgfHwgVGEsIGF3YWl0IHRoaXMuY3JlYXRlSWZyYW1lKCkpO1xuICAgIH0sIHRoaXMucmVnaXN0ZXIgPSBhc3luYyAocykgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8IGF3YWl0IHRoaXMuaW5pdCgpLCB0aGlzLmlmcmFtZSAmJiAoKHIgPSB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93KSA9PSBudWxsIHx8IHIucG9zdE1lc3NhZ2Uocy5hdHRlc3RhdGlvbklkLCB0aGlzLnZlcmlmeVVybCksIHRoaXMubG9nZ2VyLmluZm8oYHBvc3RNZXNzYWdlIHNlbnQ6ICR7cy5hdHRlc3RhdGlvbklkfSAke3RoaXMudmVyaWZ5VXJsfWApKTtcbiAgICB9LCB0aGlzLnJlc29sdmUgPSBhc3luYyAocykgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICBpZiAodGhpcy5pc0RldkVudilcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGByZXNvbHZpbmcgYXR0ZXN0YXRpb246ICR7cy5hdHRlc3RhdGlvbklkfWApO1xuICAgICAgY29uc3QgbiA9IHRoaXMuc3RhcnRBYm9ydFRpbWVyKFYuRklWRV9TRUNPTkRTKSwgbyA9IGF3YWl0IGZldGNoKGAke3RoaXMudmVyaWZ5VXJsfS9hdHRlc3RhdGlvbi8ke3MuYXR0ZXN0YXRpb25JZH1gLCB7IHNpZ25hbDogdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChuKSwgby5zdGF0dXMgPT09IDIwMCA/IChyID0gYXdhaXQgby5qc29uKCkpID09IG51bGwgPyB2b2lkIDAgOiByLm9yaWdpbiA6IFwiXCI7XG4gICAgfSwgdGhpcy5jcmVhdGVJZnJhbWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW25ldyBQcm9taXNlKChzLCByKSA9PiB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFRyKSlcbiAgICAgICAgICAgIHJldHVybiBzKCk7XG4gICAgICAgICAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgICAgbi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBUciksIG4uc2V0QXR0cmlidXRlKFwic3JjXCIsIGAke3RoaXMudmVyaWZ5VXJsfS8ke3RoaXMucHJvamVjdElkfWApLCBuLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgbi5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gITAsIHMoKTtcbiAgICAgICAgICB9KSwgbi5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKG8pID0+IHtcbiAgICAgICAgICAgIHIobyk7XG4gICAgICAgICAgfSksIGRvY3VtZW50LmJvZHkuYXBwZW5kKG4pLCB0aGlzLmlmcmFtZSA9IG47XG4gICAgICAgIH0pLCBuZXcgUHJvbWlzZSgocykgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcyhcImlmcmFtZSBsb2FkIHRpbWVvdXRcIiksIFYudG9NaWxpc2Vjb25kcyhWLk9ORV9TRUNPTkQgLyAyKSk7XG4gICAgICAgIH0pXSk7XG4gICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBWZXJpZnkgaWZyYW1lIGZhaWxlZCB0byBsb2FkOiAke3RoaXMudmVyaWZ5VXJsfWApLCB0aGlzLmxvZ2dlci5lcnJvcihzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy52ZXJpZnlVcmwgPSBUYSwgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCksIHRoaXMuaXNEZXZFbnYgPSBPbigpICYmIHByb2Nlc3MuZW52LklTX1ZJVEVTVDtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgc3RhcnRBYm9ydFRpbWVyKGUpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpLCBWLnRvTWlsaXNlY29uZHMoZSkpO1xuICB9XG59XG52YXIgRHYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHphID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgeHYgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBPdiA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIEthID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IER2KGksIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW2VdID0gdCwgVmEgPSAoaSwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgeHYuY2FsbChlLCB0KSAmJiBLYShpLCB0LCBlW3RdKTtcbiAgaWYgKHphKVxuICAgIGZvciAodmFyIHQgb2YgemEoZSkpXG4gICAgICBPdi5jYWxsKGUsIHQpICYmIEthKGksIHQsIGVbdF0pO1xuICByZXR1cm4gaTtcbn07XG5sZXQgTnYgPSBjbGFzcyBqaCBleHRlbmRzIEFtIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLnByb3RvY29sID0gTGgsIHRoaXMudmVyc2lvbiA9IFAwLCB0aGlzLm5hbWUgPSBDbiwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5vbiA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5vbihzLCByKSwgdGhpcy5vbmNlID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLm9uY2UocywgciksIHRoaXMub2ZmID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLm9mZihzLCByKSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihzLCByKSwgdGhpcy5wcm9qZWN0SWQgPSBlPy5wcm9qZWN0SWQsIHRoaXMucmVsYXlVcmwgPSBlPy5yZWxheVVybCB8fCBxaDtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGU/LmxvZ2dlciA8IFwidVwiICYmIHR5cGVvZiBlPy5sb2dnZXIgIT0gXCJzdHJpbmdcIiA/IGUubG9nZ2VyIDogZWUucGlubyhlZS5nZXREZWZhdWx0TG9nZ2VyT3B0aW9ucyh7IGxldmVsOiBlPy5sb2dnZXIgfHwgUjAubG9nZ2VyIH0pKTtcbiAgICB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy5oZWFydGJlYXQgPSBuZXcgV3QuSGVhcnRCZWF0KCksIHRoaXMuY3J5cHRvID0gbmV3IHN2KHRoaXMsIHRoaXMubG9nZ2VyLCBlPy5rZXljaGFpbiksIHRoaXMuaGlzdG9yeSA9IG5ldyBFdih0aGlzLCB0aGlzLmxvZ2dlciksIHRoaXMuZXhwaXJlciA9IG5ldyBTdih0aGlzLCB0aGlzLmxvZ2dlciksIHRoaXMuc3RvcmFnZSA9IGUgIT0gbnVsbCAmJiBlLnN0b3JhZ2UgPyBlLnN0b3JhZ2UgOiBuZXcgbmMoVmEoVmEoe30sIEMwKSwgZT8uc3RvcmFnZU9wdGlvbnMpKSwgdGhpcy5yZWxheWVyID0gbmV3IG12KHsgY29yZTogdGhpcywgbG9nZ2VyOiB0aGlzLmxvZ2dlciwgcmVsYXlVcmw6IHRoaXMucmVsYXlVcmwsIHByb2plY3RJZDogdGhpcy5wcm9qZWN0SWQgfSksIHRoaXMucGFpcmluZyA9IG5ldyBfdih0aGlzLCB0aGlzLmxvZ2dlciksIHRoaXMudmVyaWZ5ID0gbmV3IEl2KHRoaXMucHJvamVjdElkIHx8IFwiXCIsIHRoaXMubG9nZ2VyKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgaW5pdChlKSB7XG4gICAgY29uc3QgdCA9IG5ldyBqaChlKTtcbiAgICByZXR1cm4gYXdhaXQgdC5pbml0aWFsaXplKCksIHQ7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNyeXB0by5pbml0KCksIGF3YWl0IHRoaXMuaGlzdG9yeS5pbml0KCksIGF3YWl0IHRoaXMuZXhwaXJlci5pbml0KCksIGF3YWl0IHRoaXMucmVsYXllci5pbml0KCksIGF3YWl0IHRoaXMuaGVhcnRiZWF0LmluaXQoKSwgYXdhaXQgdGhpcy5wYWlyaW5nLmluaXQoKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwLCB0aGlzLmxvZ2dlci5pbmZvKFwiQ29yZSBJbml0aWFsaXphdGlvbiBTdWNjZXNzXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLndhcm4oYENvcmUgSW5pdGlhbGl6YXRpb24gRmFpbHVyZSBhdCBlcG9jaCAke0RhdGUubm93KCl9YCwgZSksIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSksIGU7XG4gICAgfVxuICB9XG59O1xuY29uc3QgUHYgPSBOdiwgemggPSBcIndjXCIsIEtoID0gMiwgVmggPSBcImNsaWVudFwiLCBBbiA9IGAke3pofUAke0tofToke1ZofTpgLCBGciA9IHsgbmFtZTogVmgsIGxvZ2dlcjogXCJlcnJvclwiLCBjb250cm9sbGVyOiAhMSwgcmVsYXlVcmw6IFwid3NzOi8vcmVsYXkud2FsbGV0Y29ubmVjdC5jb21cIiB9LCBSdiA9IFwicHJvcG9zYWxcIiwgQ3YgPSBcIlByb3Bvc2FsIGV4cGlyZWRcIiwgQXYgPSBcInNlc3Npb25cIiwgTHMgPSBWLlNFVkVOX0RBWVMsIFR2ID0gXCJlbmdpbmVcIiwgbnMgPSB7IHdjX3Nlc3Npb25Qcm9wb3NlOiB7IHJlcTogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICEwLCB0YWc6IDExMDAgfSwgcmVzOiB7IHR0bDogVi5GSVZFX01JTlVURVMsIHByb21wdDogITEsIHRhZzogMTEwMSB9IH0sIHdjX3Nlc3Npb25TZXR0bGU6IHsgcmVxOiB7IHR0bDogVi5GSVZFX01JTlVURVMsIHByb21wdDogITEsIHRhZzogMTEwMiB9LCByZXM6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMSwgdGFnOiAxMTAzIH0gfSwgd2Nfc2Vzc2lvblVwZGF0ZTogeyByZXE6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTEwNCB9LCByZXM6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTEwNSB9IH0sIHdjX3Nlc3Npb25FeHRlbmQ6IHsgcmVxOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDExMDYgfSwgcmVzOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDExMDcgfSB9LCB3Y19zZXNzaW9uUmVxdWVzdDogeyByZXE6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMCwgdGFnOiAxMTA4IH0sIHJlczogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICExLCB0YWc6IDExMDkgfSB9LCB3Y19zZXNzaW9uRXZlbnQ6IHsgcmVxOiB7IHR0bDogVi5GSVZFX01JTlVURVMsIHByb21wdDogITAsIHRhZzogMTExMCB9LCByZXM6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMSwgdGFnOiAxMTExIH0gfSwgd2Nfc2Vzc2lvbkRlbGV0ZTogeyByZXE6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTExMiB9LCByZXM6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTExMyB9IH0sIHdjX3Nlc3Npb25QaW5nOiB7IHJlcTogeyB0dGw6IFYuVEhJUlRZX1NFQ09ORFMsIHByb21wdDogITEsIHRhZzogMTExNCB9LCByZXM6IHsgdHRsOiBWLlRISVJUWV9TRUNPTkRTLCBwcm9tcHQ6ICExLCB0YWc6IDExMTUgfSB9IH0sIFVyID0geyBtaW46IFYuRklWRV9NSU5VVEVTLCBtYXg6IFYuU0VWRU5fREFZUyB9LCAkdiA9IFwicmVxdWVzdFwiLCBGdiA9IFtcIndjX3Nlc3Npb25Qcm9wb3NlXCIsIFwid2Nfc2Vzc2lvblJlcXVlc3RcIiwgXCJ3Y19hdXRoUmVxdWVzdFwiXTtcbnZhciBVdiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgTHYgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgTXYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgQmEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBxdiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGp2ID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwga2EgPSAoaSwgZSwgdCkgPT4gZSBpbiBpID8gVXYoaSwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGlbZV0gPSB0LCBBdCA9IChpLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICBxdi5jYWxsKGUsIHQpICYmIGthKGksIHQsIGVbdF0pO1xuICBpZiAoQmEpXG4gICAgZm9yICh2YXIgdCBvZiBCYShlKSlcbiAgICAgIGp2LmNhbGwoZSwgdCkgJiYga2EoaSwgdCwgZVt0XSk7XG4gIHJldHVybiBpO1xufSwgTHIgPSAoaSwgZSkgPT4gTHYoaSwgTXYoZSkpO1xuY2xhc3MgenYgZXh0ZW5kcyBLbSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKSwgdGhpcy5uYW1lID0gVHYsIHRoaXMuZXZlbnRzID0gbmV3IGlyKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5pZ25vcmVkUGF5bG9hZFR5cGVzID0gW05pXSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAoYXdhaXQgdGhpcy5jbGVhbnVwKCksIHRoaXMucmVnaXN0ZXJSZWxheWVyRXZlbnRzKCksIHRoaXMucmVnaXN0ZXJFeHBpcmVyRXZlbnRzKCksIHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5yZWdpc3Rlcih7IG1ldGhvZHM6IE9iamVjdC5rZXlzKG5zKSB9KSwgdGhpcy5pbml0aWFsaXplZCA9ICEwKTtcbiAgICB9LCB0aGlzLmNvbm5lY3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBzID0gTHIoQXQoe30sIHQpLCB7IHJlcXVpcmVkTmFtZXNwYWNlczogdC5yZXF1aXJlZE5hbWVzcGFjZXMgfHwge30sIG9wdGlvbmFsTmFtZXNwYWNlczogdC5vcHRpb25hbE5hbWVzcGFjZXMgfHwge30gfSk7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRDb25uZWN0KHMpO1xuICAgICAgY29uc3QgeyBwYWlyaW5nVG9waWM6IHIsIHJlcXVpcmVkTmFtZXNwYWNlczogbiwgb3B0aW9uYWxOYW1lc3BhY2VzOiBvLCBzZXNzaW9uUHJvcGVydGllczogYywgcmVsYXlzOiB1IH0gPSBzO1xuICAgICAgbGV0IGQgPSByLCBwLCBiID0gITE7XG4gICAgICBpZiAoZCAmJiAoYiA9IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5nZXQoZCkuYWN0aXZlKSwgIWQgfHwgIWIpIHtcbiAgICAgICAgY29uc3QgeyB0b3BpYzogRCwgdXJpOiB5IH0gPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuY3JlYXRlKCk7XG4gICAgICAgIGQgPSBELCBwID0geTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZW5lcmF0ZUtleVBhaXIoKSwgTyA9IEF0KHsgcmVxdWlyZWROYW1lc3BhY2VzOiBuLCBvcHRpb25hbE5hbWVzcGFjZXM6IG8sIHJlbGF5czogdSA/PyBbeyBwcm90b2NvbDogTWggfV0sIHByb3Bvc2VyOiB7IHB1YmxpY0tleTogeCwgbWV0YWRhdGE6IHRoaXMuY2xpZW50Lm1ldGFkYXRhIH0gfSwgYyAmJiB7IHNlc3Npb25Qcm9wZXJ0aWVzOiBjIH0pLCB7IHJlamVjdDogXywgcmVzb2x2ZTogQywgZG9uZTogRiB9ID0gVGkoVi5GSVZFX01JTlVURVMsIEN2KTtcbiAgICAgIGlmICh0aGlzLmV2ZW50cy5vbmNlKGtlKFwic2Vzc2lvbl9jb25uZWN0XCIpLCBhc3luYyAoeyBlcnJvcjogRCwgc2Vzc2lvbjogeSB9KSA9PiB7XG4gICAgICAgIGlmIChEKVxuICAgICAgICAgIF8oRCk7XG4gICAgICAgIGVsc2UgaWYgKHkpIHtcbiAgICAgICAgICB5LnNlbGYucHVibGljS2V5ID0geDtcbiAgICAgICAgICBjb25zdCB3ID0gTHIoQXQoe30sIHkpLCB7IHJlcXVpcmVkTmFtZXNwYWNlczogeS5yZXF1aXJlZE5hbWVzcGFjZXMsIG9wdGlvbmFsTmFtZXNwYWNlczogeS5vcHRpb25hbE5hbWVzcGFjZXMgfSk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi5zZXQoeS50b3BpYywgdyksIGF3YWl0IHRoaXMuc2V0RXhwaXJ5KHkudG9waWMsIHkuZXhwaXJ5KSwgZCAmJiBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcudXBkYXRlTWV0YWRhdGEoeyB0b3BpYzogZCwgbWV0YWRhdGE6IHkucGVlci5tZXRhZGF0YSB9KSwgQyh3KTtcbiAgICAgICAgfVxuICAgICAgfSksICFkKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogRCB9ID0gSihcIk5PX01BVENISU5HX0tFWVwiLCBgY29ubmVjdCgpIHBhaXJpbmcgdG9waWM6ICR7ZH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEQpO1xuICAgICAgfVxuICAgICAgY29uc3QgSyA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoZCwgXCJ3Y19zZXNzaW9uUHJvcG9zZVwiLCBPKSwgSSA9IEh0KFYuRklWRV9NSU5VVEVTKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldFByb3Bvc2FsKEssIEF0KHsgaWQ6IEssIGV4cGlyeTogSSB9LCBPKSksIHsgdXJpOiBwLCBhcHByb3ZhbDogRiB9O1xuICAgIH0sIHRoaXMucGFpciA9IGFzeW5jICh0KSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyKHQpKSwgdGhpcy5hcHByb3ZlID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRBcHByb3ZlKHQpO1xuICAgICAgY29uc3QgeyBpZDogcywgcmVsYXlQcm90b2NvbDogciwgbmFtZXNwYWNlczogbiwgc2Vzc2lvblByb3BlcnRpZXM6IG8gfSA9IHQsIGMgPSB0aGlzLmNsaWVudC5wcm9wb3NhbC5nZXQocyk7XG4gICAgICBsZXQgeyBwYWlyaW5nVG9waWM6IHUsIHByb3Bvc2VyOiBkLCByZXF1aXJlZE5hbWVzcGFjZXM6IHAsIG9wdGlvbmFsTmFtZXNwYWNlczogYiB9ID0gYztcbiAgICAgIHUgPSB1IHx8IFwiXCIsIHVzKHApIHx8IChwID0gVGIobiwgXCJhcHByb3ZlKClcIikpO1xuICAgICAgY29uc3QgeCA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmdlbmVyYXRlS2V5UGFpcigpLCBPID0gZC5wdWJsaWNLZXksIF8gPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZW5lcmF0ZVNoYXJlZEtleSh4LCBPKTtcbiAgICAgIHUgJiYgcyAmJiAoYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnVwZGF0ZU1ldGFkYXRhKHsgdG9waWM6IHUsIG1ldGFkYXRhOiBkLm1ldGFkYXRhIH0pLCBhd2FpdCB0aGlzLnNlbmRSZXN1bHQocywgdSwgeyByZWxheTogeyBwcm90b2NvbDogciA/PyBcImlyblwiIH0sIHJlc3BvbmRlclB1YmxpY0tleTogeCB9KSwgYXdhaXQgdGhpcy5jbGllbnQucHJvcG9zYWwuZGVsZXRlKHMsIEplKFwiVVNFUl9ESVNDT05ORUNURURcIikpLCBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuYWN0aXZhdGUoeyB0b3BpYzogdSB9KSk7XG4gICAgICBjb25zdCBDID0gQXQoeyByZWxheTogeyBwcm90b2NvbDogciA/PyBcImlyblwiIH0sIG5hbWVzcGFjZXM6IG4sIHJlcXVpcmVkTmFtZXNwYWNlczogcCwgb3B0aW9uYWxOYW1lc3BhY2VzOiBiLCBwYWlyaW5nVG9waWM6IHUsIGNvbnRyb2xsZXI6IHsgcHVibGljS2V5OiB4LCBtZXRhZGF0YTogdGhpcy5jbGllbnQubWV0YWRhdGEgfSwgZXhwaXJ5OiBIdChMcykgfSwgbyAmJiB7IHNlc3Npb25Qcm9wZXJ0aWVzOiBvIH0pO1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnN1YnNjcmliZShfKSwgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChfLCBcIndjX3Nlc3Npb25TZXR0bGVcIiwgQyk7XG4gICAgICBjb25zdCBGID0gTHIoQXQoe30sIEMpLCB7IHRvcGljOiBfLCBwYWlyaW5nVG9waWM6IHUsIGFja25vd2xlZGdlZDogITEsIHNlbGY6IEMuY29udHJvbGxlciwgcGVlcjogeyBwdWJsaWNLZXk6IGQucHVibGljS2V5LCBtZXRhZGF0YTogZC5tZXRhZGF0YSB9LCBjb250cm9sbGVyOiB4IH0pO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24uc2V0KF8sIEYpLCBhd2FpdCB0aGlzLnNldEV4cGlyeShfLCBIdChMcykpLCB7IHRvcGljOiBfLCBhY2tub3dsZWRnZWQ6ICgpID0+IG5ldyBQcm9taXNlKChLKSA9PiBzZXRUaW1lb3V0KCgpID0+IEsodGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQoXykpLCA1MDApKSB9O1xuICAgIH0sIHRoaXMucmVqZWN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRSZWplY3QodCk7XG4gICAgICBjb25zdCB7IGlkOiBzLCByZWFzb246IHIgfSA9IHQsIHsgcGFpcmluZ1RvcGljOiBuIH0gPSB0aGlzLmNsaWVudC5wcm9wb3NhbC5nZXQocyk7XG4gICAgICBuICYmIChhd2FpdCB0aGlzLnNlbmRFcnJvcihzLCBuLCByKSwgYXdhaXQgdGhpcy5jbGllbnQucHJvcG9zYWwuZGVsZXRlKHMsIEplKFwiVVNFUl9ESVNDT05ORUNURURcIikpKTtcbiAgICB9LCB0aGlzLnVwZGF0ZSA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkVXBkYXRlKHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcywgbmFtZXNwYWNlczogciB9ID0gdCwgbiA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QocywgXCJ3Y19zZXNzaW9uVXBkYXRlXCIsIHsgbmFtZXNwYWNlczogciB9KSwgeyBkb25lOiBvLCByZXNvbHZlOiBjLCByZWplY3Q6IHUgfSA9IFRpKCk7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudHMub25jZShrZShcInNlc3Npb25fdXBkYXRlXCIsIG4pLCAoeyBlcnJvcjogZCB9KSA9PiB7XG4gICAgICAgIGQgPyB1KGQpIDogYygpO1xuICAgICAgfSksIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24udXBkYXRlKHMsIHsgbmFtZXNwYWNlczogciB9KSwgeyBhY2tub3dsZWRnZWQ6IG8gfTtcbiAgICB9LCB0aGlzLmV4dGVuZCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkRXh0ZW5kKHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcyB9ID0gdCwgciA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QocywgXCJ3Y19zZXNzaW9uRXh0ZW5kXCIsIHt9KSwgeyBkb25lOiBuLCByZXNvbHZlOiBvLCByZWplY3Q6IGMgfSA9IFRpKCk7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudHMub25jZShrZShcInNlc3Npb25fZXh0ZW5kXCIsIHIpLCAoeyBlcnJvcjogdSB9KSA9PiB7XG4gICAgICAgIHUgPyBjKHUpIDogbygpO1xuICAgICAgfSksIGF3YWl0IHRoaXMuc2V0RXhwaXJ5KHMsIEh0KExzKSksIHsgYWNrbm93bGVkZ2VkOiBuIH07XG4gICAgfSwgdGhpcy5yZXF1ZXN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRSZXF1ZXN0KHQpO1xuICAgICAgY29uc3QgeyBjaGFpbklkOiBzLCByZXF1ZXN0OiByLCB0b3BpYzogbiwgZXhwaXJ5OiBvIH0gPSB0LCBjID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChuLCBcIndjX3Nlc3Npb25SZXF1ZXN0XCIsIHsgcmVxdWVzdDogciwgY2hhaW5JZDogcyB9LCBvKSwgeyBkb25lOiB1LCByZXNvbHZlOiBkLCByZWplY3Q6IHAgfSA9IFRpKG8pO1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLm9uY2Uoa2UoXCJzZXNzaW9uX3JlcXVlc3RcIiwgYyksICh7IGVycm9yOiBiLCByZXN1bHQ6IHggfSkgPT4ge1xuICAgICAgICBiID8gcChiKSA6IGQoeCk7XG4gICAgICB9KSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX3JlcXVlc3Rfc2VudFwiLCB7IHRvcGljOiBuLCByZXF1ZXN0OiByLCBjaGFpbklkOiBzLCBpZDogYyB9KSwgYXdhaXQgdSgpO1xuICAgIH0sIHRoaXMucmVzcG9uZCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkUmVzcG9uZCh0KTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIHJlc3BvbnNlOiByIH0gPSB0LCB7IGlkOiBuIH0gPSByO1xuICAgICAgaHQocikgPyBhd2FpdCB0aGlzLnNlbmRSZXN1bHQobiwgcywgci5yZXN1bHQpIDogR2UocikgJiYgYXdhaXQgdGhpcy5zZW5kRXJyb3Iobiwgcywgci5lcnJvciksIHRoaXMuZGVsZXRlUGVuZGluZ1Nlc3Npb25SZXF1ZXN0KHQucmVzcG9uc2UuaWQsIHsgbWVzc2FnZTogXCJmdWxmaWxsZWRcIiwgY29kZTogMCB9KTtcbiAgICB9LCB0aGlzLnBpbmcgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZFBpbmcodCk7XG4gICAgICBjb25zdCB7IHRvcGljOiBzIH0gPSB0O1xuICAgICAgaWYgKHRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyhzKSkge1xuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChzLCBcIndjX3Nlc3Npb25QaW5nXCIsIHt9KSwgeyBkb25lOiBuLCByZXNvbHZlOiBvLCByZWplY3Q6IGMgfSA9IFRpKCk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uY2Uoa2UoXCJzZXNzaW9uX3BpbmdcIiwgciksICh7IGVycm9yOiB1IH0pID0+IHtcbiAgICAgICAgICB1ID8gYyh1KSA6IG8oKTtcbiAgICAgICAgfSksIGF3YWl0IG4oKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhzKSAmJiBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGluZyh7IHRvcGljOiBzIH0pO1xuICAgIH0sIHRoaXMuZW1pdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkRW1pdCh0KTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIGV2ZW50OiByLCBjaGFpbklkOiBuIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChzLCBcIndjX3Nlc3Npb25FdmVudFwiLCB7IGV2ZW50OiByLCBjaGFpbklkOiBuIH0pO1xuICAgIH0sIHRoaXMuZGlzY29ubmVjdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkRGlzY29ubmVjdCh0KTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMgfSA9IHQ7XG4gICAgICB0aGlzLmNsaWVudC5zZXNzaW9uLmtleXMuaW5jbHVkZXMocykgPyAoYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChzLCBcIndjX3Nlc3Npb25EZWxldGVcIiwgSmUoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIGF3YWl0IHRoaXMuZGVsZXRlU2Vzc2lvbihzKSkgOiBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuZGlzY29ubmVjdCh7IHRvcGljOiBzIH0pO1xuICAgIH0sIHRoaXMuZmluZCA9ICh0KSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0QWxsKCkuZmlsdGVyKChzKSA9PiBVYihzLCB0KSkpLCB0aGlzLmdldFBlbmRpbmdTZXNzaW9uUmVxdWVzdHMgPSAoKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMuY2xpZW50LnBlbmRpbmdSZXF1ZXN0LmdldEFsbCgpKSwgdGhpcy5jbGVhbnVwRHVwbGljYXRlUGFpcmluZ3MgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5nZXQodC5wYWlyaW5nVG9waWMpLCByID0gdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmdldEFsbCgpLmZpbHRlcigobikgPT4ge1xuICAgICAgICAgIHZhciBvLCBjO1xuICAgICAgICAgIHJldHVybiAoKG8gPSBuLnBlZXJNZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8udXJsKSAmJiAoKGMgPSBuLnBlZXJNZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IGMudXJsKSA9PT0gdC5zZWxmLm1ldGFkYXRhLnVybCAmJiBuLnRvcGljICE9PSBzLnRvcGljO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHIubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oYENsZWFuaW5nIHVwICR7ci5sZW5ndGh9IGR1cGxpY2F0ZSBwYWlyaW5nKHMpYCksIGF3YWl0IFByb21pc2UuYWxsKHIubWFwKChuKSA9PiB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuZGlzY29ubmVjdCh7IHRvcGljOiBuLnRvcGljIH0pKSksIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKFwiRHVwbGljYXRlIHBhaXJpbmdzIGNsZWFuIHVwIGZpbmlzaGVkXCIpO1xuICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iocyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5kZWxldGVTZXNzaW9uID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgc2VsZjogciB9ID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQodCk7XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIudW5zdWJzY3JpYmUodCksIGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmNsaWVudC5zZXNzaW9uLmRlbGV0ZSh0LCBKZShcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZGVsZXRlS2V5UGFpcihyLnB1YmxpY0tleSksIHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmRlbGV0ZVN5bUtleSh0KSwgcyA/IFByb21pc2UucmVzb2x2ZSgpIDogdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLmRlbCh0KV0pO1xuICAgIH0sIHRoaXMuZGVsZXRlUHJvcG9zYWwgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuY2xpZW50LnByb3Bvc2FsLmRlbGV0ZSh0LCBKZShcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgcyA/IFByb21pc2UucmVzb2x2ZSgpIDogdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLmRlbCh0KV0pO1xuICAgIH0sIHRoaXMuZGVsZXRlUGVuZGluZ1Nlc3Npb25SZXF1ZXN0ID0gYXN5bmMgKHQsIHMsIHIgPSAhMSkgPT4ge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuY2xpZW50LnBlbmRpbmdSZXF1ZXN0LmRlbGV0ZSh0LCBzKSwgciA/IFByb21pc2UucmVzb2x2ZSgpIDogdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLmRlbCh0KV0pO1xuICAgIH0sIHRoaXMuc2V0RXhwaXJ5ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIHRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyh0KSAmJiBhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLnVwZGF0ZSh0LCB7IGV4cGlyeTogcyB9KSwgdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLnNldCh0LCBzKTtcbiAgICB9LCB0aGlzLnNldFByb3Bvc2FsID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnByb3Bvc2FsLnNldCh0LCBzKSwgdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLnNldCh0LCBzLmV4cGlyeSk7XG4gICAgfSwgdGhpcy5zZXRQZW5kaW5nU2Vzc2lvblJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgY29uc3QgcyA9IG5zLndjX3Nlc3Npb25SZXF1ZXN0LnJlcS50dGwsIHsgaWQ6IHIsIHRvcGljOiBuLCBwYXJhbXM6IG8gfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5wZW5kaW5nUmVxdWVzdC5zZXQociwgeyBpZDogciwgdG9waWM6IG4sIHBhcmFtczogbyB9KSwgcyAmJiB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuc2V0KHIsIEh0KHMpKTtcbiAgICB9LCB0aGlzLnNlbmRSZXF1ZXN0ID0gYXN5bmMgKHQsIHMsIHIsIG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0aShzLCByKTtcbiAgICAgIGlmIChObigpICYmIEZ2LmluY2x1ZGVzKHMpKSB7XG4gICAgICAgIGNvbnN0IGQgPSBVaShKU09OLnN0cmluZ2lmeShvKSk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUudmVyaWZ5LnJlZ2lzdGVyKHsgYXR0ZXN0YXRpb25JZDogZCB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGMgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5lbmNvZGUodCwgbyksIHUgPSBuc1tzXS5yZXE7XG4gICAgICByZXR1cm4gbiAmJiAodS50dGwgPSBuKSwgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LnNldCh0LCBvKSwgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnB1Ymxpc2godCwgYywgdSksIG8uaWQ7XG4gICAgfSwgdGhpcy5zZW5kUmVzdWx0ID0gYXN5bmMgKHQsIHMsIHIpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB4aSh0LCByKSwgbyA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmVuY29kZShzLCBuKSwgYyA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5nZXQocywgdCksIHUgPSBuc1tjLnJlcXVlc3QubWV0aG9kXS5yZXM7XG4gICAgICB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIucHVibGlzaChzLCBvLCB1KSwgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LnJlc29sdmUobik7XG4gICAgfSwgdGhpcy5zZW5kRXJyb3IgPSBhc3luYyAodCwgcywgcikgPT4ge1xuICAgICAgY29uc3QgbiA9IHFpKHQsIHIpLCBvID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZW5jb2RlKHMsIG4pLCBjID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LmdldChzLCB0KSwgdSA9IG5zW2MucmVxdWVzdC5tZXRob2RdLnJlcztcbiAgICAgIHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKHMsIG8sIHUpLCBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkucmVzb2x2ZShuKTtcbiAgICB9LCB0aGlzLmNsZWFudXAgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gW10sIHMgPSBbXTtcbiAgICAgIHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0QWxsKCkuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICBjaShyLmV4cGlyeSkgJiYgdC5wdXNoKHIudG9waWMpO1xuICAgICAgfSksIHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldEFsbCgpLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgY2koci5leHBpcnkpICYmIHMucHVzaChyLmlkKTtcbiAgICAgIH0pLCBhd2FpdCBQcm9taXNlLmFsbChbLi4udC5tYXAoKHIpID0+IHRoaXMuZGVsZXRlU2Vzc2lvbihyKSksIC4uLnMubWFwKChyKSA9PiB0aGlzLmRlbGV0ZVByb3Bvc2FsKHIpKV0pO1xuICAgIH0sIHRoaXMub25SZWxheUV2ZW50UmVxdWVzdCA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCBwYXlsb2FkOiByIH0gPSB0LCBuID0gci5tZXRob2Q7XG4gICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25Qcm9wb3NlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uUHJvcG9zZVJlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uU2V0dGxlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uU2V0dGxlUmVxdWVzdChzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25VcGRhdGVcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25VcGRhdGVSZXF1ZXN0KHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvbkV4dGVuZFwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvbkV4dGVuZFJlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUGluZ1wiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblBpbmdSZXF1ZXN0KHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvbkRlbGV0ZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvbkRlbGV0ZVJlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUmVxdWVzdFwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblJlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uRXZlbnRcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25FdmVudFJlcXVlc3Qocywgcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBVbnN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZCAke259YCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblJlbGF5RXZlbnRSZXNwb25zZSA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCBwYXlsb2FkOiByIH0gPSB0LCBuID0gKGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5nZXQocywgci5pZCkpLnJlcXVlc3QubWV0aG9kO1xuICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUHJvcG9zZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZShzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25TZXR0bGVcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25TZXR0bGVSZXNwb25zZShzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25VcGRhdGVcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25VcGRhdGVSZXNwb25zZShzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25FeHRlbmRcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25FeHRlbmRSZXNwb25zZShzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25QaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uUGluZ1Jlc3BvbnNlKHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblJlcXVlc3RcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25SZXF1ZXN0UmVzcG9uc2Uocywgcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBVbnN1cHBvcnRlZCByZXNwb25zZSBtZXRob2QgJHtufWApO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uUHJvcG9zZVJlcXVlc3QgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBwYXJhbXM6IHIsIGlkOiBuIH0gPSBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkQ29ubmVjdChBdCh7fSwgcy5wYXJhbXMpKTtcbiAgICAgICAgY29uc3QgbyA9IEh0KFYuRklWRV9NSU5VVEVTKSwgYyA9IEF0KHsgaWQ6IG4sIHBhaXJpbmdUb3BpYzogdCwgZXhwaXJ5OiBvIH0sIHIpO1xuICAgICAgICBhd2FpdCB0aGlzLnNldFByb3Bvc2FsKG4sIGMpO1xuICAgICAgICBjb25zdCB1ID0gVWkoSlNPTi5zdHJpbmdpZnkocykpLCBkID0gYXdhaXQgdGhpcy5nZXRWZXJpZnlDb250ZXh0KHUsIGMucHJvcG9zZXIubWV0YWRhdGEpO1xuICAgICAgICB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fcHJvcG9zYWxcIiwgeyBpZDogbiwgcGFyYW1zOiBjLCB2ZXJpZnlDb250ZXh0OiBkIH0pO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihuLCB0LCBvKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG8pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICBpZiAoaHQocykpIHtcbiAgICAgICAgY29uc3QgeyByZXN1bHQ6IG4gfSA9IHM7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25Qcm9wb3NlUmVzcG9uc2VcIiwgcmVzdWx0OiBuIH0pO1xuICAgICAgICBjb25zdCBvID0gdGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0KHIpO1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHByb3Bvc2FsOiBvIH0pO1xuICAgICAgICBjb25zdCBjID0gby5wcm9wb3Nlci5wdWJsaWNLZXk7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25Qcm9wb3NlUmVzcG9uc2VcIiwgc2VsZlB1YmxpY0tleTogYyB9KTtcbiAgICAgICAgY29uc3QgdSA9IG4ucmVzcG9uZGVyUHVibGljS2V5O1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHBlZXJQdWJsaWNLZXk6IHUgfSk7XG4gICAgICAgIGNvbnN0IGQgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZW5lcmF0ZVNoYXJlZEtleShjLCB1KTtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcIm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZVwiLCBzZXNzaW9uVG9waWM6IGQgfSk7XG4gICAgICAgIGNvbnN0IHAgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIuc3Vic2NyaWJlKGQpO1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHN1YnNjcmlwdGlvbklkOiBwIH0pLCBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuYWN0aXZhdGUoeyB0b3BpYzogdCB9KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBHZShzKSAmJiAoYXdhaXQgdGhpcy5jbGllbnQucHJvcG9zYWwuZGVsZXRlKHIsIEplKFwiVVNFUl9ESVNDT05ORUNURURcIikpLCB0aGlzLmV2ZW50cy5lbWl0KGtlKFwic2Vzc2lvbl9jb25uZWN0XCIpLCB7IGVycm9yOiBzLmVycm9yIH0pKTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvblNldHRsZVJlcXVlc3QgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciwgcGFyYW1zOiBuIH0gPSBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkU2Vzc2lvblNldHRsZVJlcXVlc3Qobik7XG4gICAgICAgIGNvbnN0IHsgcmVsYXk6IG8sIGNvbnRyb2xsZXI6IGMsIGV4cGlyeTogdSwgbmFtZXNwYWNlczogZCwgcmVxdWlyZWROYW1lc3BhY2VzOiBwLCBvcHRpb25hbE5hbWVzcGFjZXM6IGIsIHNlc3Npb25Qcm9wZXJ0aWVzOiB4LCBwYWlyaW5nVG9waWM6IE8gfSA9IHMucGFyYW1zLCBfID0gQXQoeyB0b3BpYzogdCwgcmVsYXk6IG8sIGV4cGlyeTogdSwgbmFtZXNwYWNlczogZCwgYWNrbm93bGVkZ2VkOiAhMCwgcGFpcmluZ1RvcGljOiBPLCByZXF1aXJlZE5hbWVzcGFjZXM6IHAsIG9wdGlvbmFsTmFtZXNwYWNlczogYiwgY29udHJvbGxlcjogYy5wdWJsaWNLZXksIHNlbGY6IHsgcHVibGljS2V5OiBcIlwiLCBtZXRhZGF0YTogdGhpcy5jbGllbnQubWV0YWRhdGEgfSwgcGVlcjogeyBwdWJsaWNLZXk6IGMucHVibGljS2V5LCBtZXRhZGF0YTogYy5tZXRhZGF0YSB9IH0sIHggJiYgeyBzZXNzaW9uUHJvcGVydGllczogeCB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUmVzdWx0KHMuaWQsIHQsICEwKSwgdGhpcy5ldmVudHMuZW1pdChrZShcInNlc3Npb25fY29ubmVjdFwiKSwgeyBzZXNzaW9uOiBfIH0pLCB0aGlzLmNsZWFudXBEdXBsaWNhdGVQYWlyaW5ncyhfKTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IociwgdCwgbyksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblNldHRsZVJlc3BvbnNlID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICBodChzKSA/IChhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLnVwZGF0ZSh0LCB7IGFja25vd2xlZGdlZDogITAgfSksIHRoaXMuZXZlbnRzLmVtaXQoa2UoXCJzZXNzaW9uX2FwcHJvdmVcIiwgciksIHt9KSkgOiBHZShzKSAmJiAoYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi5kZWxldGUodCwgSmUoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIHRoaXMuZXZlbnRzLmVtaXQoa2UoXCJzZXNzaW9uX2FwcHJvdmVcIiwgciksIHsgZXJyb3I6IHMuZXJyb3IgfSkpO1xuICAgIH0sIHRoaXMub25TZXNzaW9uVXBkYXRlUmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IHBhcmFtczogciwgaWQ6IG4gfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRVcGRhdGUoQXQoeyB0b3BpYzogdCB9LCByKSksIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24udXBkYXRlKHQsIHsgbmFtZXNwYWNlczogci5uYW1lc3BhY2VzIH0pLCBhd2FpdCB0aGlzLnNlbmRSZXN1bHQobiwgdCwgITApLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fdXBkYXRlXCIsIHsgaWQ6IG4sIHRvcGljOiB0LCBwYXJhbXM6IHIgfSk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHQsIG8pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25VcGRhdGVSZXNwb25zZSA9ICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgaHQocykgPyB0aGlzLmV2ZW50cy5lbWl0KGtlKFwic2Vzc2lvbl91cGRhdGVcIiwgciksIHt9KSA6IEdlKHMpICYmIHRoaXMuZXZlbnRzLmVtaXQoa2UoXCJzZXNzaW9uX3VwZGF0ZVwiLCByKSwgeyBlcnJvcjogcy5lcnJvciB9KTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvbkV4dGVuZFJlcXVlc3QgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZEV4dGVuZCh7IHRvcGljOiB0IH0pLCBhd2FpdCB0aGlzLnNldEV4cGlyeSh0LCBIdChMcykpLCBhd2FpdCB0aGlzLnNlbmRSZXN1bHQociwgdCwgITApLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fZXh0ZW5kXCIsIHsgaWQ6IHIsIHRvcGljOiB0IH0pO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihyLCB0LCBuKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG4pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uRXh0ZW5kUmVzcG9uc2UgPSAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIGh0KHMpID8gdGhpcy5ldmVudHMuZW1pdChrZShcInNlc3Npb25fZXh0ZW5kXCIsIHIpLCB7fSkgOiBHZShzKSAmJiB0aGlzLmV2ZW50cy5lbWl0KGtlKFwic2Vzc2lvbl9leHRlbmRcIiwgciksIHsgZXJyb3I6IHMuZXJyb3IgfSk7XG4gICAgfSwgdGhpcy5vblNlc3Npb25QaW5nUmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkUGluZyh7IHRvcGljOiB0IH0pLCBhd2FpdCB0aGlzLnNlbmRSZXN1bHQociwgdCwgITApLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fcGluZ1wiLCB7IGlkOiByLCB0b3BpYzogdCB9KTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IociwgdCwgbiksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihuKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblBpbmdSZXNwb25zZSA9ICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGh0KHMpID8gdGhpcy5ldmVudHMuZW1pdChrZShcInNlc3Npb25fcGluZ1wiLCByKSwge30pIDogR2UocykgJiYgdGhpcy5ldmVudHMuZW1pdChrZShcInNlc3Npb25fcGluZ1wiLCByKSwgeyBlcnJvcjogcy5lcnJvciB9KTtcbiAgICAgIH0sIDUwMCk7XG4gICAgfSwgdGhpcy5vblNlc3Npb25EZWxldGVSZXF1ZXN0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWREaXNjb25uZWN0KHsgdG9waWM6IHQsIHJlYXNvbjogcy5wYXJhbXMgfSksIGF3YWl0IFByb21pc2UuYWxsKFtuZXcgUHJvbWlzZSgobikgPT4ge1xuICAgICAgICAgIHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5vbmNlKEhlLnB1Ymxpc2gsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIG4oYXdhaXQgdGhpcy5kZWxldGVTZXNzaW9uKHQpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIHRoaXMuc2VuZFJlc3VsdChyLCB0LCAhMCldKSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX2RlbGV0ZVwiLCB7IGlkOiByLCB0b3BpYzogdCB9KTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IociwgdCwgbiksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihuKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblJlcXVlc3QgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciwgcGFyYW1zOiBuIH0gPSBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkUmVxdWVzdChBdCh7IHRvcGljOiB0IH0sIG4pKSwgYXdhaXQgdGhpcy5zZXRQZW5kaW5nU2Vzc2lvblJlcXVlc3QoeyBpZDogciwgdG9waWM6IHQsIHBhcmFtczogbiB9KTtcbiAgICAgICAgY29uc3QgbyA9IFVpKEpTT04uc3RyaW5naWZ5KHMpKSwgYyA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KHQpLCB1ID0gYXdhaXQgdGhpcy5nZXRWZXJpZnlDb250ZXh0KG8sIGMucGVlci5tZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9yZXF1ZXN0XCIsIHsgaWQ6IHIsIHRvcGljOiB0LCBwYXJhbXM6IG4sIHZlcmlmeUNvbnRleHQ6IHUgfSk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKHIsIHQsIG8pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25SZXF1ZXN0UmVzcG9uc2UgPSAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIGh0KHMpID8gdGhpcy5ldmVudHMuZW1pdChrZShcInNlc3Npb25fcmVxdWVzdFwiLCByKSwgeyByZXN1bHQ6IHMucmVzdWx0IH0pIDogR2UocykgJiYgdGhpcy5ldmVudHMuZW1pdChrZShcInNlc3Npb25fcmVxdWVzdFwiLCByKSwgeyBlcnJvcjogcy5lcnJvciB9KTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvbkV2ZW50UmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByLCBwYXJhbXM6IG4gfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRFbWl0KEF0KHsgdG9waWM6IHQgfSwgbikpLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fZXZlbnRcIiwgeyBpZDogciwgdG9waWM6IHQsIHBhcmFtczogbiB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IociwgdCwgbyksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWRDb25uZWN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghSXQodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBjb25uZWN0KCkgcGFyYW1zOiAke0pTT04uc3RyaW5naWZ5KHQpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodSk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHBhaXJpbmdUb3BpYzogcywgcmVxdWlyZWROYW1lc3BhY2VzOiByLCBvcHRpb25hbE5hbWVzcGFjZXM6IG4sIHNlc3Npb25Qcm9wZXJ0aWVzOiBvLCByZWxheXM6IGMgfSA9IHQ7XG4gICAgICBpZiAod3QocykgfHwgYXdhaXQgdGhpcy5pc1ZhbGlkUGFpcmluZ1RvcGljKHMpLCAhV2IoYywgITApKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgY29ubmVjdCgpIHJlbGF5czogJHtjfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodSk7XG4gICAgICB9XG4gICAgICAhd3QocikgJiYgdXMocikgIT09IDAgJiYgdGhpcy52YWxpZGF0ZU5hbWVzcGFjZXMociwgXCJyZXF1aXJlZE5hbWVzcGFjZXNcIiksICF3dChuKSAmJiB1cyhuKSAhPT0gMCAmJiB0aGlzLnZhbGlkYXRlTmFtZXNwYWNlcyhuLCBcIm9wdGlvbmFsTmFtZXNwYWNlc1wiKSwgd3QobykgfHwgdGhpcy52YWxpZGF0ZVNlc3Npb25Qcm9wcyhvLCBcInNlc3Npb25Qcm9wZXJ0aWVzXCIpO1xuICAgIH0sIHRoaXMudmFsaWRhdGVOYW1lc3BhY2VzID0gKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBHYih0LCBcImNvbm5lY3QoKVwiLCBzKTtcbiAgICAgIGlmIChyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioci5tZXNzYWdlKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRBcHByb3ZlID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghSXQodCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBhcHByb3ZlKCkgcGFyYW1zOiAke3R9YCkubWVzc2FnZSk7XG4gICAgICBjb25zdCB7IGlkOiBzLCBuYW1lc3BhY2VzOiByLCByZWxheVByb3RvY29sOiBuLCBzZXNzaW9uUHJvcGVydGllczogbyB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFByb3Bvc2FsSWQocyk7XG4gICAgICBjb25zdCBjID0gdGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0KHMpLCB1ID0gQnMociwgXCJhcHByb3ZlKClcIik7XG4gICAgICBpZiAodSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUubWVzc2FnZSk7XG4gICAgICBjb25zdCBkID0gSWEoYy5yZXF1aXJlZE5hbWVzcGFjZXMsIHIsIFwiYXBwcm92ZSgpXCIpO1xuICAgICAgaWYgKGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkLm1lc3NhZ2UpO1xuICAgICAgaWYgKCFhdChuLCAhMCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBwIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBhcHByb3ZlKCkgcmVsYXlQcm90b2NvbDogJHtufWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocCk7XG4gICAgICB9XG4gICAgICB3dChvKSB8fCB0aGlzLnZhbGlkYXRlU2Vzc2lvblByb3BzKG8sIFwic2Vzc2lvblByb3BlcnRpZXNcIik7XG4gICAgfSwgdGhpcy5pc1ZhbGlkUmVqZWN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghSXQodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZWplY3QoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBpZDogcywgcmVhc29uOiByIH0gPSB0O1xuICAgICAgaWYgKGF3YWl0IHRoaXMuaXNWYWxpZFByb3Bvc2FsSWQocyksICFKYihyKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlamVjdCgpIHJlYXNvbjogJHtKU09OLnN0cmluZ2lmeShyKX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaXNWYWxpZFNlc3Npb25TZXR0bGVSZXF1ZXN0ID0gKHQpID0+IHtcbiAgICAgIGlmICghSXQodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBkIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBvblNlc3Npb25TZXR0bGVSZXF1ZXN0KCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcmVsYXk6IHMsIGNvbnRyb2xsZXI6IHIsIG5hbWVzcGFjZXM6IG4sIGV4cGlyeTogbyB9ID0gdDtcbiAgICAgIGlmICghRGgocykpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBkIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIFwib25TZXNzaW9uU2V0dGxlUmVxdWVzdCgpIHJlbGF5IHByb3RvY29sIHNob3VsZCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgYyA9IHpiKHIsIFwib25TZXNzaW9uU2V0dGxlUmVxdWVzdCgpXCIpO1xuICAgICAgaWYgKGMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjLm1lc3NhZ2UpO1xuICAgICAgY29uc3QgdSA9IEJzKG4sIFwib25TZXNzaW9uU2V0dGxlUmVxdWVzdCgpXCIpO1xuICAgICAgaWYgKHUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1Lm1lc3NhZ2UpO1xuICAgICAgaWYgKGNpKG8pKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogZCB9ID0gSihcIkVYUElSRURcIiwgXCJvblNlc3Npb25TZXR0bGVSZXF1ZXN0KClcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWRVcGRhdGUgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFJdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHUgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHVwZGF0ZSgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodSk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCBuYW1lc3BhY2VzOiByIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKHMpO1xuICAgICAgY29uc3QgbiA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KHMpLCBvID0gQnMociwgXCJ1cGRhdGUoKVwiKTtcbiAgICAgIGlmIChvKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioby5tZXNzYWdlKTtcbiAgICAgIGNvbnN0IGMgPSBJYShuLnJlcXVpcmVkTmFtZXNwYWNlcywgciwgXCJ1cGRhdGUoKVwiKTtcbiAgICAgIGlmIChjKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYy5tZXNzYWdlKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRFeHRlbmQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFJdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGV4dGVuZCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBzIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKHMpO1xuICAgIH0sIHRoaXMuaXNWYWxpZFJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFJdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHUgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlcXVlc3QoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogcywgcmVxdWVzdDogciwgY2hhaW5JZDogbiwgZXhwaXJ5OiBvIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKHMpO1xuICAgICAgY29uc3QgeyBuYW1lc3BhY2VzOiBjIH0gPSB0aGlzLmNsaWVudC5zZXNzaW9uLmdldChzKTtcbiAgICAgIGlmICghU2EoYywgbikpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXF1ZXN0KCkgY2hhaW5JZDogJHtufWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodSk7XG4gICAgICB9XG4gICAgICBpZiAoIVFiKHIpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVxdWVzdCgpICR7SlNPTi5zdHJpbmdpZnkocil9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgIGlmICghZXcoYywgbiwgci5tZXRob2QpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVxdWVzdCgpIG1ldGhvZDogJHtyLm1ldGhvZH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgICAgfVxuICAgICAgaWYgKG8gJiYgIXJ3KG8sIFVyKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHUgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlcXVlc3QoKSBleHBpcnk6ICR7b30uIEV4cGlyeSBtdXN0IGJlIGEgbnVtYmVyIChpbiBzZWNvbmRzKSBiZXR3ZWVuICR7VXIubWlufSBhbmQgJHtVci5tYXh9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWRSZXNwb25kID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghSXQodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXNwb25kKCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIHJlc3BvbnNlOiByIH0gPSB0O1xuICAgICAgaWYgKGF3YWl0IHRoaXMuaXNWYWxpZFNlc3Npb25Ub3BpYyhzKSwgIVhiKHIpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVzcG9uZCgpIHJlc3BvbnNlOiAke0pTT04uc3RyaW5naWZ5KHIpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkUGluZyA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIUl0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcGluZygpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBzIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvbk9yUGFpcmluZ1RvcGljKHMpO1xuICAgIH0sIHRoaXMuaXNWYWxpZEVtaXQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFJdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGMgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGVtaXQoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogcywgZXZlbnQ6IHIsIGNoYWluSWQ6IG4gfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMocyk7XG4gICAgICBjb25zdCB7IG5hbWVzcGFjZXM6IG8gfSA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KHMpO1xuICAgICAgaWYgKCFTYShvLCBuKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGMgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGVtaXQoKSBjaGFpbklkOiAke259YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjKTtcbiAgICAgIH1cbiAgICAgIGlmICghWmIocikpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBjIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBlbWl0KCkgZXZlbnQ6ICR7SlNPTi5zdHJpbmdpZnkocil9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjKTtcbiAgICAgIH1cbiAgICAgIGlmICghdHcobywgbiwgci5uYW1lKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGMgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGVtaXQoKSBldmVudDogJHtKU09OLnN0cmluZ2lmeShyKX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaXNWYWxpZERpc2Nvbm5lY3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFJdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGRpc2Nvbm5lY3QoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogcyB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFNlc3Npb25PclBhaXJpbmdUb3BpYyhzKTtcbiAgICB9LCB0aGlzLmdldFZlcmlmeUNvbnRleHQgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgciA9IHsgdmVyaWZpZWQ6IHsgdmVyaWZ5VXJsOiBzLnZlcmlmeVVybCB8fCBcIlwiLCB2YWxpZGF0aW9uOiBcIlVOS05PV05cIiwgb3JpZ2luOiBzLnVybCB8fCBcIlwiIH0gfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG4gPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnZlcmlmeS5yZXNvbHZlKHsgYXR0ZXN0YXRpb25JZDogdCwgdmVyaWZ5VXJsOiBzLnZlcmlmeVVybCB9KTtcbiAgICAgICAgbiAmJiAoci52ZXJpZmllZC5vcmlnaW4gPSBuLCByLnZlcmlmaWVkLnZhbGlkYXRpb24gPSBuID09PSBzLnVybCA/IFwiVkFMSURcIiA6IFwiSU5WQUxJRFwiKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBWZXJpZnkgY29udGV4dDogJHtKU09OLnN0cmluZ2lmeShyKX1gKSwgcjtcbiAgICB9LCB0aGlzLnZhbGlkYXRlU2Vzc2lvblByb3BzID0gKHQsIHMpID0+IHtcbiAgICAgIE9iamVjdC52YWx1ZXModCkuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICBpZiAoIWF0KHIsICExKSkge1xuICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgJHtzfSBtdXN0IGJlIGluIFJlY29yZDxzdHJpbmcsIHN0cmluZz4gZm9ybWF0LiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShyKX1gKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gSihcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlclJlbGF5ZXJFdmVudHMoKSB7XG4gICAgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLm9uKEhlLm1lc3NhZ2UsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiB0LCBtZXNzYWdlOiBzIH0gPSBlO1xuICAgICAgaWYgKHRoaXMuaWdub3JlZFBheWxvYWRUeXBlcy5pbmNsdWRlcyh0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZXRQYXlsb2FkVHlwZShzKSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5kZWNvZGUodCwgcyk7XG4gICAgICBqaShyKSA/ICh0aGlzLmNsaWVudC5jb3JlLmhpc3Rvcnkuc2V0KHQsIHIpLCB0aGlzLm9uUmVsYXlFdmVudFJlcXVlc3QoeyB0b3BpYzogdCwgcGF5bG9hZDogciB9KSkgOiBPaShyKSAmJiAoYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LnJlc29sdmUociksIHRoaXMub25SZWxheUV2ZW50UmVzcG9uc2UoeyB0b3BpYzogdCwgcGF5bG9hZDogciB9KSk7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJFeHBpcmVyRXZlbnRzKCkge1xuICAgIHRoaXMuY2xpZW50LmNvcmUuZXhwaXJlci5vbigkdC5leHBpcmVkLCBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogdCwgaWQ6IHMgfSA9IFNoKGUudGFyZ2V0KTtcbiAgICAgIGlmIChzICYmIHRoaXMuY2xpZW50LnBlbmRpbmdSZXF1ZXN0LmtleXMuaW5jbHVkZXMocykpXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlbGV0ZVBlbmRpbmdTZXNzaW9uUmVxdWVzdChzLCBKKFwiRVhQSVJFRFwiKSwgITApO1xuICAgICAgdCA/IHRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyh0KSAmJiAoYXdhaXQgdGhpcy5kZWxldGVTZXNzaW9uKHQsICEwKSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX2V4cGlyZVwiLCB7IHRvcGljOiB0IH0pKSA6IHMgJiYgKGF3YWl0IHRoaXMuZGVsZXRlUHJvcG9zYWwocywgITApLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInByb3Bvc2FsX2V4cGlyZVwiLCB7IGlkOiBzIH0pKTtcbiAgICB9KTtcbiAgfVxuICBpc1ZhbGlkUGFpcmluZ1RvcGljKGUpIHtcbiAgICBpZiAoIWF0KGUsICExKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwYWlyaW5nIHRvcGljIHNob3VsZCBiZSBhIHN0cmluZzogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKGUpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJOT19NQVRDSElOR19LRVlcIiwgYHBhaXJpbmcgdG9waWMgZG9lc24ndCBleGlzdDogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAoY2kodGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmdldChlKS5leHBpcnkpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJFWFBJUkVEXCIsIGBwYWlyaW5nIHRvcGljOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGlzVmFsaWRTZXNzaW9uVG9waWMoZSkge1xuICAgIGlmICghYXQoZSwgITEpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHNlc3Npb24gdG9waWMgc2hvdWxkIGJlIGEgc3RyaW5nOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKGUpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJOT19NQVRDSElOR19LRVlcIiwgYHNlc3Npb24gdG9waWMgZG9lc24ndCBleGlzdDogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAoY2kodGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQoZSkuZXhwaXJ5KSkge1xuICAgICAgYXdhaXQgdGhpcy5kZWxldGVTZXNzaW9uKGUpO1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBKKFwiRVhQSVJFRFwiLCBgc2Vzc2lvbiB0b3BpYzogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBpc1ZhbGlkU2Vzc2lvbk9yUGFpcmluZ1RvcGljKGUpIHtcbiAgICBpZiAodGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKGUpKVxuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKGUpO1xuICAgIGVsc2UgaWYgKHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKGUpKVxuICAgICAgdGhpcy5pc1ZhbGlkUGFpcmluZ1RvcGljKGUpO1xuICAgIGVsc2UgaWYgKGF0KGUsICExKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBKKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGBzZXNzaW9uIG9yIHBhaXJpbmcgdG9waWMgZG9lc24ndCBleGlzdDogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHNlc3Npb24gb3IgcGFpcmluZyB0b3BpYyBzaG91bGQgYmUgYSBzdHJpbmc6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaXNWYWxpZFByb3Bvc2FsSWQoZSkge1xuICAgIGlmICghWWIoZSkpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcHJvcG9zYWwgaWQgc2hvdWxkIGJlIGEgbnVtYmVyOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jbGllbnQucHJvcG9zYWwua2V5cy5pbmNsdWRlcyhlKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBKKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGBwcm9wb3NhbCBpZCBkb2Vzbid0IGV4aXN0OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmIChjaSh0aGlzLmNsaWVudC5wcm9wb3NhbC5nZXQoZSkuZXhwaXJ5KSkge1xuICAgICAgYXdhaXQgdGhpcy5kZWxldGVQcm9wb3NhbChlKTtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIkVYUElSRURcIiwgYHByb3Bvc2FsIGlkOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBLdiBleHRlbmRzIHByIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQsIFJ2LCBBbiksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufVxuY2xhc3MgVnYgZXh0ZW5kcyBwciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0LCBBdiwgQW4pLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQ7XG4gIH1cbn1cbmNsYXNzIEJ2IGV4dGVuZHMgcHIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCwgJHYsIEFuLCAocykgPT4gcy5pZCksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufVxuY2xhc3MgVG4gZXh0ZW5kcyB6bSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKSwgdGhpcy5wcm90b2NvbCA9IHpoLCB0aGlzLnZlcnNpb24gPSBLaCwgdGhpcy5uYW1lID0gRnIubmFtZSwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMub24gPSAocywgcikgPT4gdGhpcy5ldmVudHMub24ocywgciksIHRoaXMub25jZSA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5vbmNlKHMsIHIpLCB0aGlzLm9mZiA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5vZmYocywgciksIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSAocywgcikgPT4gdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIocywgciksIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzID0gKHMpID0+IHRoaXMuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycyhzKSwgdGhpcy5jb25uZWN0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5jb25uZWN0KHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMucGFpciA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUucGFpcihzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmFwcHJvdmUgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmFwcHJvdmUocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5yZWplY3QgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLnJlamVjdChzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnVwZGF0ZSA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUudXBkYXRlKHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMuZXh0ZW5kID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5leHRlbmQocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5yZXF1ZXN0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5yZXF1ZXN0KHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMucmVzcG9uZCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUucmVzcG9uZChzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnBpbmcgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLnBpbmcocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5lbWl0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5lbWl0KHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMuZGlzY29ubmVjdCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUuZGlzY29ubmVjdChzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmZpbmQgPSAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5naW5lLmZpbmQocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5nZXRQZW5kaW5nU2Vzc2lvblJlcXVlc3RzID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5naW5lLmdldFBlbmRpbmdTZXNzaW9uUmVxdWVzdHMoKTtcbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Iocy5tZXNzYWdlKSwgcztcbiAgICAgIH1cbiAgICB9LCB0aGlzLm5hbWUgPSBlPy5uYW1lIHx8IEZyLm5hbWUsIHRoaXMubWV0YWRhdGEgPSBlPy5tZXRhZGF0YSB8fCBmYigpO1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZT8ubG9nZ2VyIDwgXCJ1XCIgJiYgdHlwZW9mIGU/LmxvZ2dlciAhPSBcInN0cmluZ1wiID8gZS5sb2dnZXIgOiBlZS5waW5vKGVlLmdldERlZmF1bHRMb2dnZXJPcHRpb25zKHsgbGV2ZWw6IGU/LmxvZ2dlciB8fCBGci5sb2dnZXIgfSkpO1xuICAgIHRoaXMuY29yZSA9IGU/LmNvcmUgfHwgbmV3IFB2KGUpLCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy5zZXNzaW9uID0gbmV3IFZ2KHRoaXMuY29yZSwgdGhpcy5sb2dnZXIpLCB0aGlzLnByb3Bvc2FsID0gbmV3IEt2KHRoaXMuY29yZSwgdGhpcy5sb2dnZXIpLCB0aGlzLnBlbmRpbmdSZXF1ZXN0ID0gbmV3IEJ2KHRoaXMuY29yZSwgdGhpcy5sb2dnZXIpLCB0aGlzLmVuZ2luZSA9IG5ldyB6dih0aGlzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgaW5pdChlKSB7XG4gICAgY29uc3QgdCA9IG5ldyBUbihlKTtcbiAgICByZXR1cm4gYXdhaXQgdC5pbml0aWFsaXplKCksIHQ7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBwYWlyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvcmUucGFpcmluZy5wYWlyaW5ncztcbiAgfVxuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY29yZS5zdGFydCgpLCBhd2FpdCB0aGlzLnNlc3Npb24uaW5pdCgpLCBhd2FpdCB0aGlzLnByb3Bvc2FsLmluaXQoKSwgYXdhaXQgdGhpcy5wZW5kaW5nUmVxdWVzdC5pbml0KCksIGF3YWl0IHRoaXMuZW5naW5lLmluaXQoKSwgdGhpcy5jb3JlLnZlcmlmeS5pbml0KHsgdmVyaWZ5VXJsOiB0aGlzLm1ldGFkYXRhLnZlcmlmeVVybCB9KSwgdGhpcy5sb2dnZXIuaW5mbyhcIlNpZ25DbGllbnQgSW5pdGlhbGl6YXRpb24gU3VjY2Vzc1wiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyB0aGlzLmxvZ2dlci5pbmZvKFwiU2lnbkNsaWVudCBJbml0aWFsaXphdGlvbiBGYWlsdXJlXCIpLCB0aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpLCBlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24ga3YoaSkge1xuICByZXR1cm4gdHlwZW9mIGkgPCBcInVcIiAmJiB0eXBlb2YgaS5jb250ZXh0IDwgXCJ1XCI7XG59XG5jb25zdCBHdCA9IHsgaW5pdDogXCJzaWduZXJfaW5pdFwiLCB1cmk6IFwic2lnbmVyX3VyaVwiLCBjcmVhdGVkOiBcInNpZ25lcl9jcmVhdGVkXCIsIHVwZGF0ZWQ6IFwic2lnbmVyX3VwZGF0ZWRcIiwgZGVsZXRlZDogXCJzaWduZXJfZGVsZXRlZFwiLCBldmVudDogXCJzaWduZXJfZXZlbnRcIiB9O1xuY2xhc3MgSHYgZXh0ZW5kcyBEZyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5wZW5kaW5nID0gITEsIHRoaXMuaW5pdGlhbGl6aW5nID0gITEsIHRoaXMucmVxdWlyZWROYW1lc3BhY2VzID0gZT8ucmVxdWlyZWROYW1lc3BhY2VzIHx8IHt9LCB0aGlzLm9wdHMgPSBlPy5jbGllbnQ7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuc2Vzc2lvbiA8IFwidVwiO1xuICB9XG4gIGdldCBjb25uZWN0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmc7XG4gIH1cbiAgZ2V0IGNoYWlucygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXNzaW9uID8gWW0odGhpcy5zZXNzaW9uLm5hbWVzcGFjZXMpIDogSm0odGhpcy5yZXF1aXJlZE5hbWVzcGFjZXMpO1xuICB9XG4gIGdldCBhY2NvdW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXNzaW9uID8gV20odGhpcy5zZXNzaW9uLm5hbWVzcGFjZXMpIDogW107XG4gIH1cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKGUsIHQpO1xuICB9XG4gIG9uY2UoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uY2UoZSwgdCk7XG4gIH1cbiAgb2ZmKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vZmYoZSwgdCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGUsIHQpO1xuICB9XG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZylcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZSwgdCkgPT4ge1xuICAgICAgICB0aGlzLmV2ZW50cy5vbmNlKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLm9uY2UoXCJvcGVuX2Vycm9yXCIsIChzKSA9PiB7XG4gICAgICAgICAgICB0KHMpO1xuICAgICAgICAgIH0pLCB0eXBlb2YgdGhpcy5jbGllbnQgPiBcInVcIilcbiAgICAgICAgICAgIHJldHVybiB0KG5ldyBFcnJvcihcIlNpZ24gQ2xpZW50IG5vdCBpbml0aWFsaXplZFwiKSk7XG4gICAgICAgICAgZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnBlbmRpbmcgPSAhMDtcbiAgICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLnJlZ2lzdGVyKCksIHQgPSBlLmZpbmQoeyByZXF1aXJlZE5hbWVzcGFjZXM6IHRoaXMucmVxdWlyZWROYW1lc3BhY2VzIH0pO1xuICAgICAgaWYgKHQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdGhpcy5vbk9wZW4odFswXSk7XG4gICAgICBjb25zdCB7IHVyaTogcywgYXBwcm92YWw6IHIgfSA9IGF3YWl0IGUuY29ubmVjdCh7IHJlcXVpcmVkTmFtZXNwYWNlczogdGhpcy5yZXF1aXJlZE5hbWVzcGFjZXMgfSk7XG4gICAgICB0aGlzLmV2ZW50cy5lbWl0KEd0LnVyaSwgeyB1cmk6IHMgfSksIHRoaXMuc2Vzc2lvbiA9IGF3YWl0IHIoKSwgdGhpcy5ldmVudHMuZW1pdChHdC5jcmVhdGVkLCB0aGlzLnNlc3Npb24pLCB0aGlzLm9uT3BlbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IHRoaXMuZXZlbnRzLmVtaXQoXCJvcGVuX2Vycm9yXCIsIGUpLCBlO1xuICAgIH1cbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICB0eXBlb2YgdGhpcy5zZXNzaW9uID4gXCJ1XCIgfHwgKGF3YWl0IChhd2FpdCB0aGlzLnJlZ2lzdGVyKCkpLmRpc2Nvbm5lY3QoeyB0b3BpYzogdGhpcy5zZXNzaW9uLnRvcGljLCByZWFzb246IEplKFwiVVNFUl9ESVNDT05ORUNURURcIikgfSksIHRoaXMub25DbG9zZSgpKTtcbiAgfVxuICBhc3luYyBzZW5kKGUsIHQpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuY2xpZW50ID4gXCJ1XCIgJiYgKHRoaXMuY2xpZW50ID0gYXdhaXQgdGhpcy5yZWdpc3RlcigpLCB0aGlzLmNvbm5lY3RlZCB8fCBhd2FpdCB0aGlzLm9wZW4oKSksIHR5cGVvZiB0aGlzLnNlc3Npb24gPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25lciBjb25uZWN0aW9uIGlzIG1pc3Npbmcgc2Vzc2lvblwiKTtcbiAgICB0aGlzLmNsaWVudC5yZXF1ZXN0KHsgdG9waWM6IHRoaXMuc2Vzc2lvbi50b3BpYywgcmVxdWVzdDogZSwgY2hhaW5JZDogdD8uY2hhaW5JZCB9KS50aGVuKChzKSA9PiB0aGlzLmV2ZW50cy5lbWl0KFwicGF5bG9hZFwiLCB4aShlLmlkLCBzKSkpLmNhdGNoKChzKSA9PiB0aGlzLmV2ZW50cy5lbWl0KFwicGF5bG9hZFwiLCBxaShlLmlkLCBzLm1lc3NhZ2UpKSk7XG4gIH1cbiAgYXN5bmMgcmVnaXN0ZXIoZSA9IHRoaXMub3B0cykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5jbGllbnQgPCBcInVcIilcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudDtcbiAgICBpZiAodGhpcy5pbml0aWFsaXppbmcpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHQsIHMpID0+IHtcbiAgICAgICAgdGhpcy5ldmVudHMub25jZShcInJlZ2lzdGVyX2Vycm9yXCIsIChyKSA9PiB7XG4gICAgICAgICAgcyhyKTtcbiAgICAgICAgfSksIHRoaXMuZXZlbnRzLm9uY2UoR3QuaW5pdCwgKCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jbGllbnQgPiBcInVcIilcbiAgICAgICAgICAgIHJldHVybiBzKG5ldyBFcnJvcihcIlNpZ24gQ2xpZW50IG5vdCBpbml0aWFsaXplZFwiKSk7XG4gICAgICAgICAgdCh0aGlzLmNsaWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgaWYgKGt2KGUpKVxuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50ID0gZSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIHRoaXMuY2xpZW50O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXppbmcgPSAhMCwgdGhpcy5jbGllbnQgPSBhd2FpdCBUbi5pbml0KGUpLCB0aGlzLmluaXRpYWxpemluZyA9ICExLCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5ldmVudHMuZW1pdChHdC5pbml0KSwgdGhpcy5jbGllbnQ7XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgdGhyb3cgdGhpcy5ldmVudHMuZW1pdChcInJlZ2lzdGVyX2Vycm9yXCIsIHQpLCB0O1xuICAgIH1cbiAgfVxuICBvbk9wZW4oZSkge1xuICAgIHRoaXMucGVuZGluZyA9ICExLCBlICYmICh0aGlzLnNlc3Npb24gPSBlKSwgdGhpcy5ldmVudHMuZW1pdChcIm9wZW5cIik7XG4gIH1cbiAgb25DbG9zZSgpIHtcbiAgICB0aGlzLnBlbmRpbmcgPSAhMSwgdGhpcy5jbGllbnQgJiYgKHRoaXMuY2xpZW50ID0gdm9pZCAwKSwgdGhpcy5ldmVudHMuZW1pdChcImNsb3NlXCIpO1xuICB9XG4gIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdHlwZW9mIHRoaXMuY2xpZW50IDwgXCJ1XCIgJiYgKHRoaXMuY2xpZW50Lm9uKFwic2Vzc2lvbl9ldmVudFwiLCAoZSkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICB0aGlzLnNlc3Npb24gJiYgKCh0ID0gdGhpcy5zZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogdC50b3BpYykgIT09IGUudG9waWMgfHwgdGhpcy5ldmVudHMuZW1pdChHdC5ldmVudCwgZS5wYXJhbXMpO1xuICAgIH0pLCB0aGlzLmNsaWVudC5vbihcInNlc3Npb25fdXBkYXRlXCIsIChlKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIHR5cGVvZiB0aGlzLmNsaWVudCA8IFwidVwiICYmICh0aGlzLnNlc3Npb24gJiYgKCh0ID0gdGhpcy5zZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogdC50b3BpYykgIT09IGUudG9waWMgfHwgKHRoaXMuc2Vzc2lvbiA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KGUudG9waWMpLCB0aGlzLmV2ZW50cy5lbWl0KEd0LnVwZGF0ZWQsIHRoaXMuc2Vzc2lvbikpKTtcbiAgICB9KSwgdGhpcy5jbGllbnQub24oXCJzZXNzaW9uX2RlbGV0ZVwiLCAoZSkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICB0aGlzLnNlc3Npb24gJiYgKHRoaXMuc2Vzc2lvbiAmJiAoKHQgPSB0aGlzLnNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiB0LnRvcGljKSAhPT0gZS50b3BpYyB8fCAodGhpcy5vbkNsb3NlKCksIHRoaXMuZXZlbnRzLmVtaXQoR3QuZGVsZXRlZCwgdGhpcy5zZXNzaW9uKSwgdGhpcy5zZXNzaW9uID0gdm9pZCAwKSk7XG4gICAgfSkpO1xuICB9XG59XG5jb25zdCBCaCA9IFwiOlwiO1xuZnVuY3Rpb24gR3YoaSkge1xuICBjb25zdCB7IG5hbWVzcGFjZTogZSwgcmVmZXJlbmNlOiB0IH0gPSBpO1xuICByZXR1cm4gW2UsIHRdLmpvaW4oQmgpO1xufVxuZnVuY3Rpb24gV3YoaSkge1xuICBjb25zdCBbZSwgdCwgc10gPSBpLnNwbGl0KEJoKTtcbiAgcmV0dXJuIHsgbmFtZXNwYWNlOiBlLCByZWZlcmVuY2U6IHQsIGFkZHJlc3M6IHMgfTtcbn1cbmZ1bmN0aW9uIFl2KGksIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gaS5mb3JFYWNoKChzKSA9PiB7XG4gICAgY29uc3QgciA9IGUocyk7XG4gICAgdC5pbmNsdWRlcyhyKSB8fCB0LnB1c2gocik7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gSnYoaSkge1xuICBjb25zdCB7IG5hbWVzcGFjZTogZSwgcmVmZXJlbmNlOiB0IH0gPSBXdihpKTtcbiAgcmV0dXJuIEd2KHsgbmFtZXNwYWNlOiBlLCByZWZlcmVuY2U6IHQgfSk7XG59XG5mdW5jdGlvbiBRdihpKSB7XG4gIHJldHVybiBZdihpLCBKdik7XG59XG5mdW5jdGlvbiBYdihpLCBlID0gW10pIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgocykgPT4ge1xuICAgIGlmIChlLmxlbmd0aCAmJiAhZS5pbmNsdWRlcyhzKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gaVtzXTtcbiAgICB0LnB1c2goLi4uci5hY2NvdW50cyk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gWnYoaSwgZSA9IFtdKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHMpID0+IHtcbiAgICBpZiAoZS5sZW5ndGggJiYgIWUuaW5jbHVkZXMocykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IGlbc107XG4gICAgdC5wdXNoKC4uLlF2KHIuYWNjb3VudHMpKTtcbiAgfSksIHQ7XG59XG5jbGFzcyBlXyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHdlKHRoaXMsIFwiYWNjb3VudHNcIiwgW10pO1xuICAgIHdlKHRoaXMsIFwiZXZlbnRFbWl0dGVyXCIsIG5ldyBXZS5FdmVudEVtaXR0ZXIoKSk7XG4gICAgd2UodGhpcywgXCJ1cGRhdGVTZXNzaW9uXCIsIChlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZFNlc3Npb24oZSkpXG4gICAgICAgIHRocm93IGNvbnNvbGUud2FybihcbiAgICAgICAgICBcInVwZGF0ZVNlc3Npb24gaW5jb21wYXRpYmxlIHNlc3Npb25cIixcbiAgICAgICAgICBlLFxuICAgICAgICAgIFwiZm9yIGFkYXB0ZXJcIixcbiAgICAgICAgICB0aGlzLmZvcm1hdENoYWluSWQodGhpcy5jaGFpbklkKVxuICAgICAgICApLCBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlc3Npb25cIik7XG4gICAgICB0aGlzLnNlc3Npb24gPSBlO1xuICAgICAgY29uc3QgdCA9IFp2KGUubmFtZXNwYWNlcywgW3RoaXMubmFtZXNwYWNlXSk7XG4gICAgICB0aGlzLnNldENoYWluSWRzKHQpO1xuICAgICAgY29uc3QgcyA9IFh2KGUubmFtZXNwYWNlcywgW1xuICAgICAgICB0aGlzLm5hbWVzcGFjZVxuICAgICAgXSk7XG4gICAgICB0aGlzLnNldEFjY291bnRzKHMpO1xuICAgIH0pO1xuICAgIHdlKHRoaXMsIFwiaXNWYWxpZFNlc3Npb25cIiwgKHtcbiAgICAgIG5hbWVzcGFjZXM6IGUsXG4gICAgICByZXF1aXJlZE5hbWVzcGFjZXM6IHRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBzID0gdGhpcy5mb3JtYXRDaGFpbklkKHRoaXMuY2hhaW5JZCk7XG4gICAgICByZXR1cm4gdCA/ICEhdFt0aGlzLm5hbWVzcGFjZV0/LmNoYWlucz8uaW5jbHVkZXMocykgOiAhIWU/Llt0aGlzLm5hbWVzcGFjZV0/LmFjY291bnRzLnNvbWUoXG4gICAgICAgIChyKSA9PiByLnN0YXJ0c1dpdGgocylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UmVxdWlyZWROYW1lc3BhY2VzKCkge1xuICAgIGNvbnN0IGUgPSBbdGhpcy5mb3JtYXRDaGFpbklkKHRoaXMuY2hhaW5JZCldO1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5uYW1lc3BhY2VdOiB7IGNoYWluczogZSwgbWV0aG9kczogdGhpcy5tZXRob2RzLCBldmVudHM6IHRoaXMuZXZlbnRzIH1cbiAgICB9O1xuICB9XG4gIGlzQ29tcGF0aWJsZUNoYWluSWQoZSkge1xuICAgIHJldHVybiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZS5zdGFydHNXaXRoKGAke3RoaXMubmFtZXNwYWNlfTpgKSA6ICExO1xuICB9XG4gIHNldENoYWluSWRzKGUpIHtcbiAgICBjb25zdCBzID0gZS5maWx0ZXIoKHIpID0+IHRoaXMuaXNDb21wYXRpYmxlQ2hhaW5JZChyKSkubWFwKChyKSA9PiB0aGlzLnBhcnNlQ2hhaW5JZChyKSkuZmlsdGVyKChyKSA9PiByICE9PSB0aGlzLmNoYWluSWQpO1xuICAgIHMubGVuZ3RoICYmICh0aGlzLmNoYWluSWQgPSBzWzBdLCB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiY2hhaW5DaGFuZ2VkXCIsIHRoaXMuY2hhaW5JZCkpO1xuICB9XG4gIHNldENoYWluSWQoZSkge1xuICAgIGlmICh0aGlzLmlzQ29tcGF0aWJsZUNoYWluSWQoZSkpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnBhcnNlQ2hhaW5JZChlKTtcbiAgICAgIHRoaXMuY2hhaW5JZCA9IHQsIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJjaGFpbkNoYW5nZWRcIiwgdGhpcy5jaGFpbklkKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VBY2NvdW50SWQoZSkge1xuICAgIGNvbnN0IFt0LCBzLCByXSA9IGUuc3BsaXQoXCI6XCIpO1xuICAgIHJldHVybiB7IGNoYWluSWQ6IGAke3R9OiR7c31gLCBhZGRyZXNzOiByIH07XG4gIH1cbiAgZ2V0U2lnbmVyQ29ubmVjdGlvbihlKSB7XG4gICAgcmV0dXJuIG5ldyBIdih7XG4gICAgICByZXF1aXJlZE5hbWVzcGFjZXM6IHtcbiAgICAgICAgW3RoaXMubmFtZXNwYWNlXToge1xuICAgICAgICAgIGNoYWluczogdGhpcy5ycGMuY2hhaW5zLFxuICAgICAgICAgIG1ldGhvZHM6IHRoaXMucnBjLm1ldGhvZHMsXG4gICAgICAgICAgZXZlbnRzOiB0aGlzLnJwYy5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNsaWVudDogZVxuICAgIH0pO1xuICB9XG4gIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5ycGNQcm92aWRlci5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyBjaGFpbnM6IGUsIGFjY291bnRzOiB0IH0gPSB0aGlzLnNpZ25lckNvbm5lY3Rpb247XG4gICAgICBlPy5sZW5ndGggJiYgdGhpcy5zZXRDaGFpbklkcyhlKSwgdD8ubGVuZ3RoICYmIHRoaXMuc2V0QWNjb3VudHModCk7XG4gICAgfSksIHRoaXMuc2lnbmVyQ29ubmVjdGlvbi5vbihHdC5jcmVhdGVkLCB0aGlzLnVwZGF0ZVNlc3Npb24pLCB0aGlzLnNpZ25lckNvbm5lY3Rpb24ub24oR3QudXBkYXRlZCwgdGhpcy51cGRhdGVTZXNzaW9uKSwgdGhpcy5zaWduZXJDb25uZWN0aW9uLm9uKEd0LmV2ZW50LCAoZSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnJwYy5jaGFpbnMuaW5jbHVkZXMoZS5jaGFpbklkKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgeyBldmVudDogdCB9ID0gZTtcbiAgICAgIHQubmFtZSA9PT0gXCJhY2NvdW50c0NoYW5nZWRcIiA/ICh0aGlzLmFjY291bnRzID0gdC5kYXRhLCB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiYWNjb3VudHNDaGFuZ2VkXCIsIHRoaXMuYWNjb3VudHMpKSA6IHQubmFtZSA9PT0gXCJjaGFpbkNoYW5nZWRcIiA/IHRoaXMuc2V0Q2hhaW5JZCh0LmRhdGEpIDogdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCh0Lm5hbWUsIHQuZGF0YSk7XG4gICAgfSksIHRoaXMucnBjUHJvdmlkZXIub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBIYSBleHRlbmRzICR1IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcywgcikge1xuICAgIHN1cGVyKGUsIHQsIHMpLCB0aGlzLndhbGxldCA9IHI7XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZShlLCB0ID0gdm9pZCAwLCBzID0ge30pIHtcbiAgICByZXR1cm4gZSA9IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogW2VdLCBhd2FpdCB0aGlzLndhbGxldC5zdGFya25ldF9yZXF1ZXN0QWRkSW52b2tlVHJhbnNhY3Rpb24oe1xuICAgICAgYWNjb3VudEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGV4ZWN1dGlvblJlcXVlc3Q6IHsgY2FsbHM6IGUsIGFiaXM6IHQsIGludm9jYXRpb25EZXRhaWxzOiBzIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBkZWNsYXJlKGUsIHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIHZpYSBBcmdlbnQgTG9naW5cIik7XG4gIH1cbiAgYXN5bmMgZGVwbG95QWNjb3VudChlLCB0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCB2aWEgQXJnZW50IExvZ2luXCIpO1xuICB9XG59XG5jbGFzcyB0XyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLndhbGxldCA9IGU7XG4gIH1cbiAgYXN5bmMgZ2V0UHViS2V5KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgdmlhIEFyZ2VudCBMb2dpblwiKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZShlLCB0KSB7XG4gICAgY29uc3QgeyBzaWduYXR1cmU6IHMgfSA9IGF3YWl0IHRoaXMud2FsbGV0LnN0YXJrbmV0X3NpZ25UeXBlZERhdGEoe1xuICAgICAgYWNjb3VudEFkZHJlc3M6IHQsXG4gICAgICB0eXBlZERhdGE6IGVcbiAgICB9KTtcbiAgICByZXR1cm4gcztcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24oZSwgdCwgcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgdmlhIEFyZ2VudCBMb2dpblwiKTtcbiAgfVxuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIHZpYSBBcmdlbnQgTG9naW5cIik7XG4gIH1cbiAgYXN5bmMgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbihlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCB2aWEgQXJnZW50IExvZ2luXCIpO1xuICB9XG59XG5jb25zdCBpXyA9IChpKSA9PiBpLnJlcGxhY2UoL15TTl8vLCBcIlNOXCIpLCBzXyA9IChpKSA9PiBpLnJlcGxhY2UoL15TTi8sIFwiU05fXCIpO1xuY2xhc3Mgcl8gZXh0ZW5kcyBlXyB7XG4gIGNvbnN0cnVjdG9yKHsgY2xpZW50OiB0LCBjaGFpbklkOiBzLCBycGNVcmw6IHIsIHByb3ZpZGVyOiBuIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHdlKHRoaXMsIFwiaWRcIiwgXCJhcmdlbnRNb2JpbGVcIik7XG4gICAgd2UodGhpcywgXCJuYW1lXCIsIFwiQXJnZW50IE1vYmlsZVwiKTtcbiAgICB3ZSh0aGlzLCBcInZlcnNpb25cIiwgXCIwLjEuMFwiKTtcbiAgICB3ZSh0aGlzLCBcImljb25cIiwgXCJcIik7XG4gICAgd2UodGhpcywgXCJwcm92aWRlclwiKTtcbiAgICB3ZSh0aGlzLCBcInNpZ25lclwiKTtcbiAgICB3ZSh0aGlzLCBcImFjY291bnRcIik7XG4gICAgd2UodGhpcywgXCJzZWxlY3RlZEFkZHJlc3NcIiwgXCJcIik7XG4gICAgLy8gTmFtZXNwYWNlQWRhcHRlclxuICAgIHdlKHRoaXMsIFwibmFtZXNwYWNlXCIsIFwic3RhcmtuZXRcIik7XG4gICAgd2UodGhpcywgXCJtZXRob2RzXCIsIFtcbiAgICAgIFwic3RhcmtuZXRfc2lnblR5cGVkRGF0YVwiLFxuICAgICAgXCJzdGFya25ldF9yZXF1ZXN0QWRkSW52b2tlVHJhbnNhY3Rpb25cIlxuICAgIF0pO1xuICAgIHdlKHRoaXMsIFwiZXZlbnRzXCIsIFtcImNoYWluQ2hhbmdlZFwiLCBcImFjY291bnRzQ2hhbmdlZFwiXSk7XG4gICAgd2UodGhpcywgXCJyZW1vdGVTaWduZXJcIik7XG4gICAgd2UodGhpcywgXCJzaWduZXJDb25uZWN0aW9uXCIpO1xuICAgIHdlKHRoaXMsIFwicnBjUHJvdmlkZXJcIik7XG4gICAgd2UodGhpcywgXCJjaGFpbklkXCIpO1xuICAgIHdlKHRoaXMsIFwiY2xpZW50XCIpO1xuICAgIHdlKHRoaXMsIFwic2Vzc2lvblwiKTtcbiAgICB3ZSh0aGlzLCBcInJwY1wiKTtcbiAgICB3ZSh0aGlzLCBcIndhbGxldFJwY1wiKTtcbiAgICB3ZSh0aGlzLCBcIm9uXCIsICh0LCBzKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50RW1pdHRlci5vbih0LCBzKTtcbiAgICB9KTtcbiAgICB3ZSh0aGlzLCBcIm9mZlwiLCAodCwgcykgPT4ge1xuICAgICAgdGhpcy5ldmVudEVtaXR0ZXIub2ZmKHQsIHMpO1xuICAgIH0pO1xuICAgIHRoaXMuY2hhaW5JZCA9IFN0cmluZyhzID8/IE1zLk5ldHdvcmtOYW1lLlNOX01BSU4pLCB0aGlzLnJwYyA9IHtcbiAgICAgIGNoYWluczogcyA/IFt0aGlzLmZvcm1hdENoYWluSWQodGhpcy5jaGFpbklkKV0gOiBbXSxcbiAgICAgIG1ldGhvZHM6IHRoaXMubWV0aG9kcyxcbiAgICAgIGV2ZW50czogdGhpcy5ldmVudHNcbiAgICB9LCB0aGlzLnNpZ25lckNvbm5lY3Rpb24gPSB0aGlzLmdldFNpZ25lckNvbm5lY3Rpb24odCksIHRoaXMucnBjUHJvdmlkZXIgPSBuZXcgX24odGhpcy5zaWduZXJDb25uZWN0aW9uKSwgdGhpcy5jbGllbnQgPSB0LCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy53YWxsZXRScGMgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgIGdldDogKG8sIGMpID0+ICh1KSA9PiB0aGlzLnJlcXVlc3RXYWxsZXQoeyBtZXRob2Q6IGMsIHBhcmFtczogdSB9KVxuICAgIH0pLCB0aGlzLnJlbW90ZVNpZ25lciA9IG5ldyB0Xyh0aGlzLndhbGxldFJwYyksIHRoaXMucHJvdmlkZXIgPSBuIHx8IG5ldyBGdSh7IG5vZGVVcmw6IHIgfSksIHRoaXMuYWNjb3VudCA9IG5ldyBIYShcbiAgICAgIHRoaXMucHJvdmlkZXIsXG4gICAgICBcIlwiLFxuICAgICAgdGhpcy5yZW1vdGVTaWduZXIsXG4gICAgICB0aGlzLndhbGxldFJwY1xuICAgICk7XG4gIH1cbiAgZ2V0TmV0d29ya05hbWUodCkge1xuICAgIGlmICh0ID09PSBcIlNOX1NFUE9MSUFcIilcbiAgICAgIHJldHVybiBNcy5OZXR3b3JrTmFtZS5TTl9TRVBPTElBO1xuICAgIGlmICh0ID09PSBcIlNOX01BSU5cIilcbiAgICAgIHJldHVybiBNcy5OZXR3b3JrTmFtZS5TTl9NQUlOO1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdGFya25ldC5qcyBuZXR3b3JrIG5hbWUgZm9yIGNoYWluSWQgJHt0fWApO1xuICB9XG4gIC8vIFN0YXJrbmV0V2luZG93T2JqZWN0XG4gIGFzeW5jIHJlcXVlc3QodCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZDogLnJlcXVlc3QoKVwiKTtcbiAgfVxuICBhc3luYyBlbmFibGUoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucnBjUHJvdmlkZXIuY29ubmVjdCgpLCB0aGlzLmFjY291bnRzO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBnZXQgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGFzeW5jIGlzUHJlYXV0aG9yaXplZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmNsaWVudC5zZXNzaW9uLmdldEFsbCgpLmZpbmQodGhpcy5pc1ZhbGlkU2Vzc2lvbik7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdFdhbGxldCh0KSB7XG4gICAgaWYgKCF0aGlzLnNlc3Npb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzZXNzaW9uXCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHRvcGljOiBzIH0gPSB0aGlzLnNlc3Npb24sIHIgPSB0aGlzLmZvcm1hdENoYWluSWQodGhpcy5jaGFpbklkKTtcbiAgICAgIGt0LnNob3dBcHByb3ZhbE1vZGFsKHQpO1xuICAgICAgY29uc3QgbiA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QoeyB0b3BpYzogcywgY2hhaW5JZDogciwgcmVxdWVzdDogdCB9KTtcbiAgICAgIHJldHVybiBrdC5jbG9zZU1vZGFsKFwiYW5pbWF0ZVN1Y2Nlc3NcIiksIG47XG4gICAgfSBjYXRjaCAocykge1xuICAgICAgdGhyb3cga3QuY2xvc2VNb2RhbCgpLCBzIGluc3RhbmNlb2YgRXJyb3IgPyBuZXcgRXJyb3Iocy5tZXNzYWdlKSA6IG5ldyBFcnJvcihcIlVua25vdyBlcnJvciBvbiByZXF1ZXN0V2FsbGV0XCIpO1xuICAgIH1cbiAgfVxuICAvLyBOYW1lc3BhY2VBZGFwdGVyXG4gIGdldCBpc0Nvbm5lY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmVyQ29ubmVjdGlvbi5jb25uZWN0aW5nO1xuICB9XG4gIGFzeW5jIGRpc2FibGUoKSB7XG4gICAgYXdhaXQgdGhpcy5ycGNQcm92aWRlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgZ2V0IGlzV2FsbGV0Q29ubmVjdCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLy8gTmFtZXNwYWNlQWRhcHRlciBwcml2YXRlIG1ldGhvZHNcbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICBzdXBlci5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIHRoaXMuZXZlbnRFbWl0dGVyLm9uKFwiY2hhaW5DaGFuZ2VkXCIsICh0KSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQ6IGNoYWluQ2hhbmdlZFwiKTtcbiAgICB9KTtcbiAgfVxuICBmb3JtYXRDaGFpbklkKHQpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5uYW1lc3BhY2V9OiR7aV8odCl9YDtcbiAgfVxuICBwYXJzZUNoYWluSWQodCkge1xuICAgIHJldHVybiBzXyh0LnNwbGl0KFwiOlwiKVsxXSk7XG4gIH1cbiAgc2V0QWNjb3VudHModCkge1xuICAgIHRoaXMuYWNjb3VudHMgPSB0LmZpbHRlcihcbiAgICAgIChuKSA9PiB0aGlzLnBhcnNlQ2hhaW5JZCh0aGlzLnBhcnNlQWNjb3VudElkKG4pLmNoYWluSWQpID09PSB0aGlzLmNoYWluSWRcbiAgICApLm1hcCgobikgPT4gdGhpcy5wYXJzZUFjY291bnRJZChuKS5hZGRyZXNzKTtcbiAgICBjb25zdCB7IGFkZHJlc3M6IHMgfSA9IHRoaXMucGFyc2VBY2NvdW50SWQodFswXSksIHIgPSBzLnN0YXJ0c1dpdGgoXCIweFwiKSA/IHMgOiBgMHgke3N9YDtcbiAgICB0aGlzLmFjY291bnQgPSBuZXcgSGEoXG4gICAgICB0aGlzLnByb3ZpZGVyLFxuICAgICAgcixcbiAgICAgIHRoaXMucmVtb3RlU2lnbmVyLFxuICAgICAgdGhpcy53YWxsZXRScGNcbiAgICApLCB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiYWNjb3VudHNDaGFuZ2VkXCIsIHRoaXMuYWNjb3VudHMpLCB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IHI7XG4gIH1cbn1cbmNvbnN0IFlfID0gYXN5bmMgKGkpID0+IFBtKGksIHJfKTtcbmV4cG9ydCB7XG4gIFlfIGFzIGdldFN0YXJrbmV0V2luZG93T2JqZWN0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/starknetkit/dist/index-00451f1a.js\n"));

/***/ })

}]);